@&#MAIN-TITLE@&#
Exact algorithms for the traveling salesman problem with draft limits

@&#HIGHLIGHTS@&#
Three formulations and related exact algorithms for the TSP with draft limits are proposed.The three index formulation dominates theoretically and empirically the two index formulation.The branch-cut-and-price algorithm solves the instances from the literature within one hour.

@&#KEYPHRASES@&#
Draft limits,Traveling salesman,Cutting planes,Column generation,Extended formulation,

@&#ABSTRACT@&#
This paper deals with the Traveling Salesman Problem (TSP) with Draft Limits (TSPDL), which is a variant of the well-known TSP in the context of maritime transportation. In this recently proposed problem, draft limits are imposed due to restrictions on the port infrastructures. Exact algorithms based on three mathematical formulations are proposed and their performance compared through extensive computational experiments. Optimal solutions are reported for open instances of benchmark problems available in the literature.

@&#INTRODUCTION@&#
The Traveling Salesman Problem (TSP) with Draft Limits (TSPDL) is a variant of the well-known TSP, recently introduced by Rakke, Christiansen, Fagerholt, and Laporte (2012), that arises in the context of maritime transportation. The sequence of ports that a cargo ship visits in a tour is dependent on the port infrastructures: the sea-level in a port is sometimes not sufficiently deep to accommodate loaded cargo ships. The port is thus associated to a draft limit, i.e., the maximum vertical distance allowed between the waterline and the bottom of the hull. Note that the draft of a cargo ship depends on the load: the heavier the load, the higher the ship’s draft. Therefore, draft limits can be easily translated into restrictions on the maximum load of the ship.The problem can be formalized as follows: A directed graphG=(V,A)is given, whereV={0,…,n}is the set of ports to be visited andA={(i,j),i,j∈V,i≠j}is the arc set, or set of connections between ports. Each arc(i,j)∈Ais associated to a routing costcij>0. The vertex 0 is the port from which the ship starts and ends its tour, whereas verticesV′={1,…,n}are ports to be visited exactly once. Each port requires the delivery ofdi,i∈V′, units of load and is associated to a draft limitli,i∈V′. The initial load isQ=∑i∈V′diand we denoted̲=mini∈V′{di}. The ship cannot enter port i if its load is heavier thanli, or the hull of the ship could be grounded. Therefore the TSPDL asks for the minimum cost Hamiltonian tour, visiting each port exactly once and not violating draft limit constraints.Despite its simple definition, the TSPDL proves hard to solve to optimality. In fact, the problem isNP-Hard since it includes the TSP as special case when the drafts are sufficiently large.Rakke et al. (2012) proposed two mathematical formulations: the first formulation makes use of the binary variablesxijassuming value 1 if arc(i,j)is in the solution, and continuous variablesyij, representing the load on the ship while traveling arc(i,j). The resulting formulation is compact, but provides poor quality bounds. The second formulation includes two additional sets of variables:ujandtijspecifying the position of port j and of arc(i,j)in the circuit, respectively. These two sets of variables allow for the introduction in the model of the Miller, Tucker, and Zemlin (MTZ) constraints (Miller, Tucker, & Zemlin, 1960). The MTZ constraints, usually employed to avoid subtours, are used to strengthen the formulation and they are included at the root node of the branch-and-bound tree.Both formulations have been further strengthened by dynamically separating subtour elimination constraints (Dantzig, Fulkerson, & Johnson, 1954), as well as their lifted counterpart (Balas & Fischetti, 2004). Moreover, lower bounds on theujvariables and lower bounds on the sum ofyijvariables are imposed.The branch-and-cut algorithms originating from both formulations are capable of solving quite effectively instances with a limited amount of ports with draft limits, but when the percentage of ports with a draft limit increases, the algorithm struggles even for medium-sized instances. The problem seems therefore challenging and, as far as we are aware, no other attempts have been made to solve it exactly. This motivated our interest in the problem and we decided to investigate alternative formulations and solution techniques.Three alternative mathematical formulations are introduced (see Section 2). The first formulation is based on two-index variables, the second formulation is based on three-index variables, whereas the third can be viewed as an improvement over a Dantzig–Wolfe decomposition of the second, including the concept of ng-paths (Baldacci, Mingozzi, & Roberti, 2011), and it is solved through a branch-cut-and-price algorithm.In Section 3, a description of the branch-and-cut and branch-cut-and-price implementations are presented. The results of our computational experience are summarized in Section 4, while Section 5 presents conclusions and future possible research directions.The exact algorithms proposed in this work are based on three integer programming formulations that are described in this section.The first formulation, denoted F1, is based on two sets of two-indexed binary variables. Thexijvariable assumes value 1 if(i,j)∈Ais in the solution, 0 otherwise. The variableyikassumes value 1 when the ship enters porti∈V′carryingk∈{di,…,li}units of load, 0 otherwise. Note that arcs(i,j)|dj>li-dican be removed from the network: in order to simplify the notation we do not explicitly remove these arcs, but it is sufficient to disregard the corresponding variables in our models to take this aspect into account. The formulation F1 can be stated as follows:(1)(F1)min∑(i,j)∈Acijxij(2)s.t.∑i∈V,i≠jxij=1,∀j∈V(3)∑j∈V,j≠ixij=1,∀i∈V(4)∑i∈V′|li⩾kyik⩽1,∀k∈{d̲,…,Q-d̲}(5)∑k=diliyik=1,∀i∈V′(6)yiQ=x0i,∀i∈V′|li=Q(7)yidi=xi0,∀i∈V′(8)xij+yik⩽1+yj,k-di,∀(i,j)∈A,k∈{dj+di,…,min{li,lj+di}}(9)xij∈{0,1},∀(i,j)∈A(10)yik∈{0,1}.∀i∈V′,k∈{di,…,li}The Objective Function (1) aims at minimizing routing costs. Constraints (2) and (3) are the degree constraints. Constraints (4) impose that the ship visits at most a port for each intermediate load value. Constraints (4) are not necessary to define an optimal integer solution, because Constraints (2), (3), (6) and (7) guarantee that the ship performs a Hamiltonian tour in which the load is monotonically decreasing. Preliminary experiments showed that these constraints strengthen the linear relaxation and we included them in the formulation. Constraints (5) state that each port has to be assigned to a load. The first and last position of the tour are imposed to be connected to the initial port 0 (Constraints (6) and (7), respectively). Constraints (8) link variablesxijandyik: if arc(i,j)is traversed,xij=1and i and j are located in consecutive positions of the tour. Therefore summing variablesxijandyikcan result in a value equal to 2 only ifyj,k-di=1. These constraints generalize similar constrains encountered in single-machine scheduling problems (an interested reader can refer to the models based on assignment and positional date variables in Keha, Khowala, & Fowler, 2009). Finally, Constraints (9) and (10) define the binary nature of the variables. Note that Constraints (5)–(8) ensure that the flow is monotonically decreasing along the tour and therefore subtours are avoided.Formulation F1 presents similarities with the MTZ-based formulation for the Asymmetric TSP (ATSP) (see Roberti & Toth, 2012 for a recent overview and comparison of ATSP models), but consists only of binary variables.F1 is strengthened by incorporating the trivial constraints(11)xij+xji≤1,∀(i,j)∈Aand by separating in a cutting plane fashion the subtour elimination constraints:(12)∑i∈S∑j∈S‾xij⩾1.∀S⊆V′For this latter set of inequalities, the exact separation can be done in polynomial time.Formulation F2 considers three-indexed binary variableszijk, assuming value 1 if arc(i,j)∈Ais traversed by the ship carrying k units of load (including the demand of port j). By denotingKij=min{lj,li-di}, formulation F2 is:(13)(F2)min∑(i,j)∈A∑k=djKijcijzijk(14)s.t.∑i∈Vi≠j∑k=djKijzijk=1,∀j∈V(15)∑j∈V|j≠ilj⩾k+djzjik-∑j∈V|j≠ilj⩾k-di,dj⩽k-dizijk-di=0,∀i∈V,k∈{di,…,li}(16)zi0k=0,∀i∈V′,k∈{1,…,Q}(17)z0jk=0,∀j∈V′|lj=Q,k<Q,k∈{dj,…,lj}(18)zijk∈{0,1}.∀(i,j)∈A,k∈{dj,…,Kij}The Objective Function (13) minimizes routing costs. Constraints (14) are the degree constraints. Constraints (15) preserve the load conservation. Constraints (16) and (17) force the ship to return to the depot empty and leave the depot carrying Q units, respectively. Constraints (18) define the nature of the variables. Formulation F2 is similar to the three-index formulations proposed in Fox, Gavish, and Graves (1980), for the Time Dependent TSP.Constraints(19)∑j∈Vj≠i∑k=djKijzijk=1,∀i∈Vare implied by Constraints (14) and Constraints (15), as previously stated in Pessoa, Poggi de Aragão, and Uchoa (2008).F2 can be strengthened by the trivial constraints:(20)∑k=djKijzijk+∑k=diKjizjik⩽1,∀(i,j)∈Athat have been included in the formulation a priori.Flow conservation constraints ensure that subtours are avoided for F2 integer solutions, however we strengthened the formulation by including the subtour elimination constraints as cutting planes (as for F1):(21)∑i∈S∑j∈S‾∑k=djKijzijk⩾1,∀S⊆V′Finally, F2 can be strengthened by adding the 2-cycle inequalities:(22)zijk⩽∑t∈V,t≠{i,j},t|lt⩾k-djzjtk-dj,(i,j)∈A,i,j≠0,∀k={dj,…,Kij}as proposed in Abeledo, Fukasawa, Pessoa, and Uchoa (2013). These constraints have been added to F2 in a cutting-plane fashion, using an exact enumerative separation procedure. Note that the constraints can be avoided for the arcs incident in the depot, because Constraints (16) and (17) ensure that no arcs return to the depot after visiting the first port and no arcs would visit a port after the depot.Proposition 1The linear relaxation of F2 ((13)–(18)) dominates the linear relaxation of F1 ((1)–(10)).See Appendix. □F3 originates from an alternative interpretation of the solution space of F2, in the spirit of Pessoa et al. (2008). The left-side of Fig. 1presents a TSPDL solution and the corresponding non-zerozijkvariables (the draft limits are 3, 3, and 1 for the ports 1, 2, and 3, respectively and each port asks for the delivery of one unit). The right side of the same figure pictures a path interpretation of the same solution. For each port (on the x axis), the loads compatible with the port’s draft limit are depicted with a circle. The y axis reports the load of the ship. The ship tour is depicted as a path, starting from port 0 with load 3 and returning to port 0 with load 0, where each port is visited exactly once.A useful relaxation of the problem is obtained by removing (14) from F2. In this case, a feasible solution to (15)–(18) is also a tour starting at the port 0 with load Q and ending at the same port with load 0, respecting the draft limits. Nevertheless, such tour does not have to visit all ports, while other ports may be visited more than once. Optimizing this relaxation can be done inO(n2Q)time by a dynamic programming procedure, which suggests the following reformulation of F2. Let P be a set of all paths defined above. For eachp∈P, we introduce the binary variableλpindicating if p is used or not in the solution. Defineqijkpas a binary coefficient indicating whether variablezijkis associated to path p.(23)min∑p∈P∑i∈V∑j∈Vj≠i∑k=djKijqijkpcijλp(24)s.t.∑p∈P∑j∈Vj≠i∑k=djKijqijkpλp=1,∀i∈V′(25)λp∈{0,1}∀p∈P.An additional constraint r over thezijkvariables having the format(26)∑i∈V′∑j∈V′j≠i∑k=diliαijkrzijk⩾brcan be included in F3 as:(27)∑p∈P∑i∈V′∑j∈V′j≠i∑k=diliαijkrλp⩾br.The linear relaxation of F3, even with additional cuts, can be solved by column generation. Suppose that, at a given instant, the Master LP has R additional cuts, the r-th cut has dual variableβr. Constraints (24) have dual variablesπ. We define the reduced cost of the variablezi,jkas:(28)c¯ijk=cij-πi-∑r=1Rαijkrβr,whereπ0=0. The reduced cost of a Master LP variableλpis given by:(29)λ¯p=∑i∈V∑j∈Vj≠i∑k=djKijqijkpc¯ijk.Therefore, the pricing subproblem can be solved by a shortest path subproblem over the acyclic graph illustrated in Fig. 1, where the arc costs correspond toc¯ijk. This amounts to a shortest path problem with resource constraints over the original graph G.Significantly stronger linear relaxations can be obtained by forbidding some paths in P that visit some ports more than once. For example, one could avoid tours with s-cycles (Irnich & Villeneuve, 2006), i.e., returning to a port i before visiting at least s ports other than i.Instead, we use the following strategy that already proved being more efficient in practice (Baldacci et al., 2011). For each customeri∈V′, letNi⊆V′be the ng-set of i, defining its neighborhood. This may stand for the|Ni|closest ports and includes i itself. The cardinalities of all ng-sets are the same, denoted by T. An ng-path is a path as defined in P where every cycle that starts and ends at a vertex i must contain at least one vertex j such thati∉Nj. This can be interpreted as if the ship “forgot” the visit to i when passing by the port j. The modified shortest path problem that consider the ng-restrictions has a complexity ofO(n2Q2T). This means that T cannot be very large.In our implementation, we define a different ng-setNikfor each load k of the ship after visiting each port i. The neighbors of port i with load k are then selected as the T closest ports that can be visited immediately before i without violating the draft limits and still preserving the same computational complexity. This modification strengthens the relaxation since original ng-sets spend part of its memory to store visits to ports that would violate the draft limits. The same pricing algorithm can be used to handle these ng-sets. To the best of our knowledge, this is the first time that ng-sets depending on the load are considered.Formulation F3 is then defined as (23)–(27), where P is defined as the set of ng-paths, plus all inequalities described in Abeledo et al. (2013) translated to theλpvariables as shown in (26) and (27). F1 and F2 have a number of variables that is pseudo-polynomial in Q and this may undermine the performance of the resulting algorithms when ports have large demands. These formulations are therefore more suitable when the ports’ demands are not very large. The size of formulation F3 does not depend on Q, but the complexity of the column generation subproblem is linearly dependent on Q. Nevertheless, previous studies showed that reasonably large demands can still be handled in practice (Pessoa et al., 2008; Subramanian, Uchoa, Pessoa, & Ochi, 2013). In particular, Pessoa, Uchoa, Poggi, and Rodrigues (2010) solved a multi-machine scheduling problem using an extended formulation. Each job was associated to a processing time up to 100 units and the resulting subproblem would count up to thousands of units of processing time, without compromising the algorithm’s computing time.The branch-and-cut algorithms for formulations F1 and F2 have been implemented using the Callable Libraries of CPLEX, and, the subtour elimination constraints (12) and (21) have been separated using the CVRPSEP Library (Lysgaard, 2003). The subtour constraints have been separated only up to the seventh level of the branching tree to speed up computation. Moreover, at most 50 subtour cuts have been added per iteration. The 2-cycle inequalities (22) were separated only at the root node. CPLEX strong branching was chosen for branching and all CPLEX cuts have been used for strengthening the formulation.The branch-cut-and-price algorithm for formulation F3 is an adaptation of the one proposed by Abeledo et al. (2013). We enhance it by replacing the 5-cycle elimination in the pricing problem with the ng-sets described above withT=12. Preliminary experiments showed thatT=12provides a good compromise: high quality lower bounds are obtained and the computing times remain relatively small. The method starts by only considering Constraints (24) and iteratively adds the remaining inequalities on demand using the separation procedures described by Abeledo et al. (2013). Furthermore, we branch over thexijvariables translated from thezijkvariables usingxij=∑k=djKijzijk.Given a relaxed solutionx¯, we choose a pair of ports(i,j)such thatx¯ij+x¯jiis strictly between 0 and 1 and add the constraintxij+xji⩽0in one branch andxij+xji⩾1in the other. These cuts are translated back to thezijkvariables and then to theλpvariables. In the selection of the best pair(i,j), we try to maximize the absolute difference betweenx¯ij+x¯jiand a target value 0.6 by choosing the pair that maximizesmin{(x¯ij+x¯ji)/0.6,(1.0-x¯ij-x¯ji)/0.4}.The instances considered in our extensive computational testing belong to the benchmark set proposed by Rakke et al. (2012). The problems are adaptations of instances from the TSPLIB (namely burma14, ulysees16, ulysses22, fri26, bayg29, gr17, gr21, and gr48), with number of vertices ranging between 14 and 48. In the following, the acronym a_b_c refers to thecthinstance, adapted from the TSPLIB problem a with b% of ports with draft limit smaller than Q.For each TSP instance, problems with 10%, 25% and 50% of the ports having a draft limit smaller than Q have been generated and each port has unitary demand. More precisely, given each TSP instance and each percentage of ports with drafts smaller than Q, ten instances were proposed. Drafts smaller than Q were randomly generated between 1 andn-1. The instances are available at http://jgr.no/tspdl.Our tests were performed on an Intel Core i5 with 3.2gigahertz and 4gigabyte of RAM, running Ubuntu Linux 10.04. A two-hours time limit was imposed and a single thread used throughout the computational experience.In the following, we compare the root node lower bounds of F1, F2, and F3 (including or not additional constraints). Detailed results can be found in the Appendix (Tables B.3–B.8). For each Instance and each formulation, the percentage deviation of lower bound z with respect to the optimal solutionzoptis computed as:Dev(%)=100×1-zzopt.A summary of our results is provided in Table 1, where for each set of instances the average percentage deviation from the optimal solutions (Dev(%)) and average computing time in seconds (Time(seconds)) are provided. The average geometric deviation is also reported and computed for each set of instances I as:G.Dev(%)=100×(1-z1zopt1×⋯×z|I|zopt|I||I|).The average computing times in seconds are reported in the columnsTime(seconds).Both F1 and F2 dramatically improve their performance when subtour elimination constraints are adopted. F1 with Constraints (12) reduces the average optimality gap with respect to F1 by almost 5%, whereas F2 with Constraints (21) by 1.5%. The average gap of formulation F1 is high (10.68%, and 14.65% for thegr48instances), whereas F2 produces better quality lower bounds (the average gap is 4.53%). F2 is also roughly five times faster than F1. Constraints (22) reduce substantially the optimality gap and roughly double the average computing time.F3 provides highly competitive bounds: all instances, except some of thegr48instances, have been solved to optimality at the root node, in less than roughly 30seconds on average. The average computing times are almost doubled with respect to F2 with Constraints (21), but the average overall deviation is much smaller (3% for F2 with subtour constraints and 0.11% for F3).In terms of optimal solutions achieved, we compare the best bounds provided by Rakke et al. (2012) with those obtained by F1 with (12), F2 with (21) and (22) and F3. The experiments conducted by Rakke et al. (2012) had been performed on a HP dl160 G3 computer with 2×3.0gigahertz Intel E5472 Xeon CPU and 16gigabyte of RAM. The solver used was Xpress-MP 7.2 and the separation routine for the subtour elimination constraints was coded in C++ using the Mosel 3.2.0 callbacks. Finally, the algorithm was executed using parallel processing on the 8 cores available on the machine and for at most 10,000seconds. Our testing has been performed on a more modest computer, using a single core and a 7200seconds time limit, therefore our results are not directly comparable to those of Rakke et al. (2012).The upper and lower bounds achieved by the best branch-and-cut of Rakke et al. (2012), the branch-and-cuts of F1 with (12) and of F2 with (21) and (22), and the branch-cut-and-price F3 are given in Tables C.9–C.14, as well as the computing times and the number of nodes explored are provided. The bold-faced values are the non-optimal solution values. Note that the implementations of F1 and F2 benefit from the CPLEX cuts, whereas F3 does not make use of these inequalities.A summary of these results can be found in Table 2, where the number of optimal solutions achieved for each benchmark set is given. Table 2 presents also results for F1 and F2 without considering CPLEX cuts: this allows for a more comprehensive comparison with the results of Rakke et al. (2012), where these cuts are not implemented.Even if the number of optimal solutions obtained by Rakke et al. (2012) is higher than that of F1, it is interesting to observe that F1 is not dominated. Example of problems in which F1 outperforms Rakke et al. (2012) algorithms with or without CPLEX cuts are available, even if F1 is executed on a slower computer and for a shorter amount of time. F1 performs remarkably better without CPLEX cuts when small instances are considered, but the CPLEX cuts allow for solving to optimality one of thegr48instances. F2 is capable of solving 214 out of the 240 instances in the set, but only 4 of thegr48instances. CPLEX cuts do not affect the number of optimal solutions obtained by F2. F3 solves to optimality all instances in the set.

@&#CONCLUSIONS@&#
In this paper, we presented three exact algorithms for the TSPDL. The first algorithm is a branch-and-cut and it is based on a compact formulation in which two sets of two-index binary variables and a polynomial number of constraints are employed. This formulation, when strengthened with subtour elimination constraints and trivial constraints is not empirically dominated by the best formulation proposed by Rakke et al. (2012). The second algorithm is also a branch-and-cut, but the underlying formulation considers three index variables. This formulation is proven to dominate the first one, both theoretically and empirically. The third algorithm is a branch-cut-and-price and it is based on a Dantzig–Wolfe decomposition of the second formulation. Columns are generated by dynamically introducing ng-paths to the formulation. The latter algorithm was capable of solving to optimality all the benchmark instances from the literature.