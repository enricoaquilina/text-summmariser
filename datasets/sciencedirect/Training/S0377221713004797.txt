@&#MAIN-TITLE@&#
Combining very large scale and ILP based neighborhoods for a two-level location problem

@&#HIGHLIGHTS@&#
Effective heuristics for the two-level capacitated facility location problem.Design and experiment of very large scale neighborhoods using ILP based formulations and techniques.Reaching optimal solutions for a large set of instances.Tight approximations on instances whose size is out of reach for exact algorithms.

@&#KEYPHRASES@&#
Location,Local search,Variable neighborhood search,Very large scale neighborhood search,Matheuristics,

@&#ABSTRACT@&#
In this paper we tackle a generalization of the Single Source Capacitated Facility Location Problem in which two sets of facilities, called intermediate level and upper level facilities, have to be located; the dimensioning of the intermediate set, the assignment of clients to intermediate level facilities, and of intermediate level facilities to upper level facilities, must be optimized, as well. Such problem arises, for instance, in telecommunication network design: in fact, in hierarchical networks the traffic arising at client nodes often have to be routed through different kinds of facility nodes, which provide different services. We propose a heuristic approach, based on very large scale neighborhood search to tackle the problem, in which both ad hoc algorithms and general purpose solvers are applied to explore the search space. We report on experimental results using datasets from the capacitated location literature. Such results show that the approach is promising and that Integer Linear Programming based neighborhoods are significantly effective.

@&#INTRODUCTION@&#
In this paper we consider a generalization of the classical Single Source Capacitated Facility Location Problem in which a set of clients and two different sets of facilities are considered, intermediate level and upper level facilities. The location of each facility must be chosen among a set of candidate sites, requiring different setup costs. Each client must be assigned to exactly one intermediate level facility, and each intermediate level facility must be assigned to exactly one upper level facility. The network is assumed to have a star–star topology, and therefore the assignment costs are proportional to the distance between clients, intermediate level and upper level facilities. A demand amount to be served for each client, and a capacity for each facility, are given: the amount of demand assigned to each facility cannot exceed its capacity. Moreover, each intermediate level facility must be dimensioned, i.e. it must be equipped with one device, chosen among a set of possible types. Different devices provide different capacities at different costs. We denote this problem as Two Level Capacitated Facility Location Problem (TLCFLP).The TLCFLP belongs to the family of multi-level facility location problems, which may arise in several fields, such as telecommunication or transportation. They may take into account different features and have been widely addressed in the literature. A recent review on multi-level hierarchical facility location problems, covering papers since the mid-80s, can be found in Sahin and Süral (2007). In such survey, hierarchical facility location problems are classified according to features such as flow pattern and service availability; applications, models and approaches are described. In a classical generalization of the facility location problem, the so-called Multi-level Facility Location Problem, a set of clients is given together with k sets of facilities, where each set represents a different facility level. Each client must be assigned to a path of k facilities, and its demand must be routed through a facility of each level following a hierarchical order. Star–star topology which is addressed in this paper is not considered. For the uncapacitated version of the problem, heuristic and exact approaches (Tcha & Lee, 1984) as well as approximation properties (Aardal, Chudak, & Shmoys, 1999) have been investigated. Another similar generalization of the facility location problem is the Two-level Simple Plant Location Problem addressed in Chardaire, Lutton, and Sutter (1999): each client must be assigned to one and only one facility of the intermediate level which, in turns, must be assigned to one and only one facility of the high level. In this case star–star topology is considered, but facilities of both levels are uncapacitated.The problem we considered shares some features also with the Two-echelon Single Source Capacitated Facility Location Problem described in Tragantalerngsak, Holt, and Ronnqvist (2000), where each client must be assigned to exactly one intermediate level facility which, in turns, must be assigned exactly to one depot; indeed, depots act as upper level facilities, which however are not capacitated. In Ignacio, Filho, and Galvao (2008) the problem of locating two different types of facilities, concentrators and routers, in a telecommunication network is considered; concentrators and routers act as different kinds of facilities and are both capacitated. Each terminal in the network, which represents a client, has to be assigned to exactly one concentrator, which must in turn be assigned to one router. The location of both concentrators and routers has to be chosen. The problem is heuristically tackled by computing both lower and upper bounds.Besides being a natural variation of classical hierarchical location problems, the TLCFLP shows to be well suited to model more general networking problems. Indeed, many telecommunication networks have a hierarchical structure, in which different sets of nodes play different roles. In such networks, traffic from nodes representing clients must be sent to nodes representing facilities, which are in charge of providing treatments, such as multiplexing. Different kinds of facilities, corresponding to different hierarchy levels and providing different capabilities, are considered. The set of client nodes is usually given, while facility nodes must be located and dimensioned. Such network structure can be found, for instance, in IP networks, in which access nodes must be connected to edge nodes which, in turn, must be connected to core backbone nodes; or in fiber-to-the-home networks, where clients must be connected to cabinet nodes, which collect traffic and send it to central offices (Gualandi, Malucelli, & Sozzi, 2010; Trampont, Destr, & Faye, 2009). At the same time, as a generalization of the Capacitated Facility Location Problem, the TLCFLP is NP-hard; moreover, its generality comes at the price of computational tractability. An attempt to tackle the TLCFLP exactly is described in Addis, Carello, and Ceselli (2012), where a method is proposed which exploits a hybrid formulation and dynamic column generation within a branch-and-bound framework. Instances with 200 clients and 50 candidate location sites are on the edge between solvable and unsolvable in a time limit of two hours.In this paper we focus on solving large instances, as those that might arise in real life applications, fast and efficiently. We propose a heuristic approach for the TLCFLP which combines local search, variable neighborhood search (Hansen & Mladenovich, 2001), very large scale neighborhood search (Ahuja, Ergun, Orlin, & Punnen, 2002) and ILP based neighborhoods.In Section 2 we discuss an ILP model for TLCFLP, in Section 3 we describe our algorithms and in Section 4 we report some computational results. Conclusions are drawn in Section 5.In the TLCFLP a set of client nodesIis given. Each client nodei∈Ihas a demand aiand it must be assigned to an intermediate level facility, which in turn must be assigned to an upper level one. Both kinds of facilities must be located: candidate sites for intermediate level and upper level facilities are given and represented by setsJandK, respectively. Both installation and assignment costs are considered. Placing an intermediate level facility in sitej∈J(an upper level facility in sitek∈K) implies installation costs cj(gk). Assigning a client i to an intermediate level facility located inj∈J(an intermediate level facility located in j to an upper level facility located ink∈K) implies connection costs dij(ljk).Each intermediate level facility must be dimensioned by equipping it with a device chosen in a setT={1⋯T}. For each devicet∈Tthe capacity btand the setup cost ftare given; the capacity btrepresents also the capacity to be provided by the upper level facility to which an intermediate level facility equipped with device t is assigned. According to economy of scale, device costs are assumed to be sub-linear with respect to the provided capacity. All upper level facilities have the same capacity B.Four kinds of variables are needed to represent the decisions which must be taken: whether to open or not an upper level facility in eachk∈K(binary variables zk), whether to open or not an intermediate level facility equipped with devicet∈Tin each candidate sitej∈J(binary variables yjt), whether to assign or not a clienti∈Ito an intermediate level facility located inj∈J(binary variables xij), whether to assign or not an intermediate level facility opened inj∈Jand equipped with devicet∈Tto an upper level facility opened ink∈K(binary variables wjtk).The TLCFLP can be modelled as follows:(1)minζ(x,y,w,z)=∑i∈I∑j∈Jdijxij+∑j∈J∑t∈T(cj+ft)yjt+∑j∈J∑t∈T∑k∈Kljkwjtk+∑k∈Kgkzk(2)∑j∈Jxij=1,∀i∈I(3)∑k∈Kwjtk=yjt,∀j∈J,∀t∈T(4)∑i∈Iaixij⩽∑t∈Tbtyjt,∀j∈J(5)∑t∈Tyjt⩽1,∀j∈J(6)∑j∈J∑t∈Tbtwjtk⩽Bzk,∀k∈K(7)xij,wjtk,yjt,zk∈{0,1}∀i∈I,∀j∈J,∀k∈K,∀t∈TThe objective function (1) aims at minimizing the sum of location, dimensioning and assignment costs. Constraints (2) force each client to be assigned to one intermediate level facility, while constraints (3) force each open intermediate level facility to be assigned to an upper level one. Inequalities (4) guarantee that each intermediate level facility is equipped with a device such that its capacity is sufficient to serve the demand of all the assigned clients, while inequalities (5) guarantee that each intermediate level facility is equipped with at most one device. Finally, inequalities (6) guarantee that each upper level facility has enough capacity to serve all the assigned intermediate level facilities. Integrality conditions (7) complete the model.The model has a polynomial number of variables and constraints, and is therefore suitable to be tackled by general purpose ILP solvers. As discussed in detail in Addis et al. (2012), this approach does not allow to solve to proven optimality a large number of instances. Ad-hoc exact algorithms perform substantially better, but still allow to solve only instances whose size is far from that of practical applications. Therefore, in the next section we propose fast, efficient and effective heuristic algorithms.Our heuristic algorithms are based on two main phases: a Descent Phase, which provides intensification, performing a variable neighborhood search, and a Kick Phase, which provides diversification in an iterated local search fashion (Glover & Kochenberger, 2003). Approaches based on hybridization of exact resolution in heuristic methods are receiving more and more interest (Talbi, 2013). Indeed, the Descent Phase exploits ad hoc algorithms to explore both classical neighborhoods and very large scale ones, while the Kick Phase explores very large scale neighborhoods using ILP techniques. These two phases are performed in sequence and the whole sequence is repeated until no improving solution is found or a maximum number of iterations is reached.The initial solution is computed through a greedy algorithm. A similar scheme is applied both to open intermediate level facilities and to assign clients, and to open upper level facilities and to assign intermediate level ones. The scheme is based on two steps: opening a facility and assigning clients (or intermediate level facilities):•Opening. Starting with an empty set, facilities (intermediate level or upper level facilities, depending on the level on which the scheme is applied) are added one by one. At each step, the intermediate level (upper level) facility j∗(k∗) is chosen such that the sum of the connection costs∑i∈I¯dij∗(∑j∈Jljk∗)is minimum, whereI¯denotes the set of unassigned clients. After a facility is chosen and added, clients (intermediate level facilities) are assigned to the current facility set, as described in the Assigning step, which is based on the approach proposed in Martello and Toth (1990) for generalized assignment problems.Assigning. The clients (the intermediate level facilities) are then assigned to the open intermediate level (upper level) facilities one by one. At each step the client (intermediate level facility), which would suffer the greatest disadvantage if it was not assigned to its best facility (with lower connection cost), is assigned: for each client (intermediate level facility) the two open facilities providing the smallest values of connection costs, while having enough residual capacity to accept the assignment, are selected; the difference between the two connection costs is computed and the client (intermediate level facility) with the largest difference is chosen and assigned to its closest facility.First, the procedure works on the lower level. When all clients are assigned, the greedy considers open intermediate level facilities as clients and the scheme is applied to the upper layer. This simple greedy procedure was able to find a feasible starting solution in almost all our experiments.We developed five different local search neighborhoods for the Descent Phase. Two are generated applying basic swap moves, while three of them are very large scale neighborhoods, which generalize the neighborhoods proposed in Ahuja, Orlin, Pallottino, Scaparra, and Scutellà (2004) for a Capacitated Single Source Facility Location Problem.Single Client Exchange neighborhood (SCE) considers all the pairs of clients assigned to two different intermediate level facilities. Their assignments are swapped provided that the residual capacity on each of the considered intermediate level facilities is sufficient to receive the new client, once the one currently assigned has been removed. Single Facility Exchange neighborhood (SFE) considers all the pairs of open intermediate level facilities assigned to two different upper level facilities and swaps their assignments, provided that the residual capacity on each of the upper level facilities is sufficient to receive the new intermediate level facility, once the currently assigned one has been removed.Three neighborhoods have been developed, which are based on the improvement graph and on very large scale neighborhoods proposed in Ahuja et al. (2004). In such neighborhoods, a sequence of moves is considered instead of a single swap. The possible moves are represented by arcs of an improvement graph, the arc cost representing the increasing or decreasing in the objective function if the move is applied. Each arc represent a feasible move, i.e. a move which does not violate the facility capacity constraints. An improving sequence of moves is represented by a negative cost cycle on the improvement graph. To guarantee the feasibility of the sequence of moves, at most one move involving each intermediate level or upper level facility can be applied. Such feature is implemented by partitioning the improvement graph node set, according to the facilities involved in the moves associated to each node. As the minimum cost set disjoint cycle is a difficult problem, improving neighbors are heuristically found, using the ad hoc procedure described in Ahuja et al. (2004).The improvement graph is built as follows. The set of nodes is composed by:•a node for each client node,a node for each opened intermediate level facility,a root node.To guarantee the feasibility of the sequence of moves, we define a set for each facility. Such set contains all the clients assigned to the facility and the facility itself. The set of arcs is built as follows:•an arc exists between two nodes related to clients i and j, if i and j are currently assigned to different facilities and the available capacity of the facility to which j is assigned is at least the difference aj−ai. Such arc represents the possibility of assigning i to the facility to which j is currently assigned, provided that j is removed. The cost of the arc represents the advantage or disadvantage of the move. Denoting with hjthe facility to which j is currently assigned, the arc cost is given bydihj-djhj;an arc exists between a client node and a facility node, if the client is not currently assigned to the facility and the available capacity of the facility is greater than or equal to the client demand. The arc represents the possibility of assigning the client i to facility h, and its cost is dih;an arc exists between the root node and each client node. The arc represents the possibility of removing the client i from its current assignment hi. The arc cost depends on the number of clients currently assigned to the facility hi. If i is the only client assigned to hi, the facility can be closed if i is removed, and thus the arc cost is-dihi-chi-fτ-lhik, where τ is the index of the device installed on hiand k is the upper level facility to which hiis assigned. If i is not the only client assigned to hi, the arc cost is given by-dihi-fτ+fτ′, where τ′ is the device needed on hionce i is removed;a zero cost arc exists between each facility node and the root node.In the CCN the possibility of opening an intermediate level facility (and therefore an upper level facility) is not considered. The facility nodes are associated only to already open facilities. However, the possibility of changing the facility device is considered. The feasibility of a sequence of moves is therefore guaranteed if the cycle involves each intermediate level facility at most once. Thus, negative cost set disjoint cycles are sought on the improvement graph.The improvement graph is built as follows. The set of nodes is composed by:•a node for each open intermediate level facility,a node for each candidate upper level facility,a root node.To guarantee the feasibility of the sequence of moves, we define a set for each upper level facility. Such set contains all the intermediate level facilities assigned to the upper level facility and the upper level facility itself. The set of arcs is built as follows:•an arc exists between two nodes related to intermediate level facilities i and j, if i and j are currently assigned to different upper level facilities, and the available capacity of the upper level facility to which j is assigned is greater then or equal to the difference between the capacities of the devices installed on j and i. Such arc represents the possibility of assigning intermediate level facility i to the upper level facility to which j is currently assigned, provided that j is removed. The cost of the arc represents the advantage or disadvantage of the move. Denoting with hjthe upper level facility to which j is currently assigned, the arc cost is given bylihj-ljhj;an arc exists between an intermediate level facility node i and an upper level facility node h, if the intermediate level facility is not currently assigned to the upper level facility, and the available capacity of the upper level facility is greater then or equal to the intermediate level facility device capacity. The arc represents the possibility of assigning intermediate level facility i to upper level facility h, and its cost is lih. The arc exists even if the upper level facility is closed in the current solution;an arc exists between the root node and each intermediate level facility node. The arc represents the possibility of removing the intermediate level facility i from its current assignment hi. The arc cost depends on the number of intermediate level facilities currently assigned to the upper level facility hi. If i is the only intermediate level facility assigned to hi, the upper level facility can be closed if i is removed, and thus the arc cost is-lihi-ghi. If i is not the only intermediate level facility assigned to hi, the arc cost is given by-lihi;an arc exists between each upper level facility node k and the root node. Its cost is equal to zero if the upper level facility k is open in the current solution, while it is equal to gkif upper level facility k is not currently open.In the ICN clients are not considered. The possibility of changing the assignment of intermediate level facilities is represented in the neighborhood as well as the possibility of opening and closing upper level facilities. In ICN intermediate level facilities play the role that clients play in CCN, and upper level facilities play the role that intermediate level facilities play in CCN.The improvement graph is built as follows. The set of nodes is composed by:•a node for each client node,a node for each candidate intermediate level facility,a root node.To guarantee the feasibility of the sequence of moves, we define a set for each upper level facility. Such set contains all the open intermediate level facilities assigned to the upper level facility and the upper level facility itself. Further, it contains all the clients currently assigned to an intermediate level facility assigned to the upper level facility. A close intermediate level facility belongs to the set of its closest upper level facility. The set of arcs is built as follows:•an arc exists between two nodes related to clients i and j, currently assigned to hiand hj, respectively, if hiand hjare different. The device τ′ needed to host i on hj, when j is removed, is computed. The arc exists if such a device exists, and the available capacity of the upper level facility to which hjis assigned is greater then or equal to the difference between the capacity of τ′ and τ, being τ the device currently installed on hj. Such arc represents the possibility of assigning i to hj, provided that j is removed, and the possibility of changing the device installed on hj. The arc cost is given bydihj-djhj+fτ′-fτ;an arc exists between a client node i and an intermediate level facility node h, if the client is not currently assigned to the facility. The arc may exist both if the intermediate level facility is open in the current solution and if it is not. The device τ′ needed to host the client i on h is computed. If h is open in the current solution, the arc exists if such a device exists, and the available capacity of the upper level facility, to which h is assigned, is greater then or equal to the difference between the capacity of τ′ and τ, being τ the device currently installed on h. The arc represents the possibility of assigning the client i to facility h, and its cost isdih+fτ′-fτ. If h is not open in the current solution, the arc exists if τ′ is the smallest capacity device. The arc represents the possibility of assigning i to h, to open h and, thus, to assign it to the best (with the lower connection cost) upper level facility, kh. The arc cost isdih+fτ′+lhkh. The upper level facility opening costgkhis added if khis not already open in the current solution;an arc exists between the root node and each client node. The arc represents the possibility of removing the client i from its current facility hi. The arc cost depends on the number of clients currently assigned to the facility hi. If i is the only client assigned to hi, the facility can be closed if i is removed, and thus the arc cost is-dihi-chi-fτ-lhik, where τ is the index of the device installed on hiand k is the upper level facility to which hiis assigned. If i is not the only client assigned to hi, the arc cost is given by-dihi-fτ+fτ′, where τ′ is the device needed on hiwhen i is removed;an arc exists between each intermediate level facility node and the root node, whose cost is zero if the facility is open, and is equal to the intermediate level facility opening cost otherwise.In the FCN, the considered moves are associated to clients, which change their assignment according to the move. Besides, the neighborhood takes into account the possibility of opening intermediate level and upper level facilities.When no improvement is obtained using the above local search procedures, we try to change the solution applying two very large scale neighborhoods using ILP based techniques.Both are based on the idea of reducing model (1)–(7), so that the remaining problem can be effectively optimized by general purpose ILP solvers. Both neighborhoods are defined from a starting TLCFLP solution(x¯,y¯,w¯,z¯).In the first neighborhood we consider model (1)–(7), randomly fixing some upper level location variables; when one of these variables represents an open facility in site k, we fix also the intermediate level location variables corresponding to intermediate level facilities assigned to k. Formally, we consider in turn each variable zk, and we fixzk=z¯kwith a probability α which is a parameter of the algorithm. Let Jkbe the set of intermediate level facilities assigned to upper level facility k in the starting solution, that isJk={j|∑t∈Tw¯jtk=1}. Whenever a variable zkis fixed, we fix also yjt=1 for each j∈Jk. For instance, a solution for a TLCFLP instance with|I|=10,|J|=8and|K|=4is depicted in Fig. 1. Gray nodes represent sites where facilities are built, and arrows represent assignments of clients to intermediate level facilities and of intermediate level facilities to upper level facilities. Let us assume that z variables corresponding to sites 1 and 2 are fixed by our random procedure (nodes with bold border in the figure): the y variable corresponding to intermediate level site a is fixed as well, since site a contains a facility assigned to 1; any other location or assignment variable is left free, and the remaining problem is optimized.The second neighborhood is inspired by local branching methods (Fischetti & Lodi, 2003). We introduce new constraints in the model, forcing a limit on the distance between the starting and any feasible solution. In particular, we add to model (1)–(7) the following constraints:(8)∑i∈I∑j∈J|xij-x¯ij|⩽β(9)∑j∈J∑t∈T|yjt-y¯jt|⩽γ(10)∑j∈J∑t∈T∑k∈K|wjtk-w¯jtk|⩽δ(11)∑k∈K|zk-z¯k|⩽ϕwhere β, γ, δ and ϕ are parameters of the algorithm. These constraints can be linearized with standard techniques; as reported in Section 4, we experimentally observed that general purpose solvers can effectively exploit the resulting model to produce solutions improving(x¯,y¯,w¯,z¯).The above operators are combined to provide the Descent Phase and the Kick Phase of the heuristic. In Fig. 2we report the overall procedure flow. After obtaining a greedy initial solution, the Descent Phase is applied, which explores the different neighborhoods until no improving solution is found; then the Kick Phase is applied. A limited set of iterations interleaving descent and kick phases is performed.Each of the neighborhoods described in Section 3.2 is explored in a steepest descent fashion until the local minimum is reached. Then, the heuristic procedure starts to investigate another neighborhood. After preliminary computational experiments (Addis, Carello, & Ceselli, 2009), we decided to explore the neighborhoods in the following order: FCN, CCN, ICN, SCE, SFE. When SFE local minimum is reached, the procedure starts again from FCN, if at least one improving solution has been found. If all the neighborhoods are explored and no improvement is found, we proceed applying the kick phase.In a preliminary set of experiments two settings showed to be particularly promising. The first one (Rbi) consists of applying iteratively Descent Phase and RANDOM Kick Phase, setting α=0.5 and solving each ILP subproblem to optimality (that is, searching for the best improving move in the RANDOM neighborhood, see Pseudocode 3.1); the second one (LBfi) consists of applying iteratively Descent Phase and LOCAL BRANCHING Kick Phase, setting α=δ=+∞, β=ϕ=2, and stopping the optimization of each ILP subproblem as soon as an improving solution is found, that is, searching for a feasible solution of the problem LB_feas:(2)–(17)(8)–(11)ζ(x,y,w,z)⩽ζ(x¯,y¯,w¯,z¯)wherex¯,y¯,w¯,z¯represent the current local minimum solution (see Pseudocode 3.2).Pseudocode 3.1RANDOM Kickfunction Rbi(x¯,y¯,w¯,z¯)set(x¯,y¯,w¯,z¯)as incumbentrandomly fix some z (and y) variablessolve reduced problemif improved solution found then return improved solutionelse FAILend ifend functionLOCAL BRANCHING Kickfunction LBfi(x¯,y¯,w¯,z¯)set(x¯,y¯,w¯,z¯)as incumbentsolve problem LB_feasif improved solution found then return improved solutionelse FAILend ifend functionWe implemented our heuristics in C++, using CPLEX 11.00 (ILOG CPLEX 11.0 Users Manual. ILOG Inc, 2007) to solve ILP subproblems. CPLEX relies on a state-of-the-art branch-and-cut method, which includes general purpose cut generation and primal heuristics. After preliminary experimental results, we set a time limit of two hours for each run of CPLEX, the ‘bestbound’ option to true, and the ‘mipgap’ value to ‘10−9’. Further comparison on parameters fine tuning was discussed in Addis et al. (2009). Our experiments ran on a Centrino Core2 3GHz workstation equipped with 2GB of RAM.In order to test our heuristics we considered four sets of instances. Dataset 1 is drawn from Holmberg, Ronnqvist, and Yuan (1999), Datasets 2 and 3 are drawn from Beasley (1990) and Ahuja et al. (2004); all of them were adapted to TLCFLP as described in Addis et al. (2012). Dataset 1 consists of 71 instances, where the number of clients ranges from 50 to 200 and the number of candidate facilities from 10 to 50: it aims at testing our method on instances with a wide range of features, but no particular structure. Dataset 2 includes 24 instances, where the number of clients is 50 and the number of candidate facilities ranges from 16 to 50. These instances have, on the average, a low ratio between the overall client demand and the upper level facility capacities. Dataset 3 consists of 12 harder large size instances involving 1000 customers and 100 candidate facilities. Finally, Dataset 4 is drawn from Ernst and Krishnamoorthy (1996). The original instance includes data of 200 clients and 50 candidate facilities in the Euclidean plane; we created three larger sets, including 400, 600 and 800 clients lying in the same region of the Euclidean plane. Four scenarios are provided in Ernst and Krishnamoorthy (1996): loose capacities and loose fixed costs (LL), loose capacities and tight fixed costs (LT), tight capacities and loose fixed costs (TL) and tight capacities and tight fixed costs (TT). Therefore, we obtained a dataset of 16 instances by combining the four client sets with each scenario, and adapting the resulting data to TLCFLP still as described in Addis et al. (2012).Dual bounds are computed for all these instances using the exact methods described in Addis et al. (2012); for most instances in Dataset 1 and 2 these correspond to the optimal solution value, while obtaining proven optimal solutions for instances in Datasets 3 and 4 is most of the time out of reach for exact methods.First, we evaluated the effectiveness of different heuristics in reaching near-optimal solutions. This experiment was carried out on instances of Dataset 1 and Dataset 2, for which the optimal solution is almost always known. At most 10 Descent–Kick iterations are performed in each test.Tables 1 and 2report the comparison of Rbi and LBfi heuristics respectively on Dataset 1 and Dataset 2. The first four columns of each table report the name of the instance and the number of clients, candidate intermediate level and upper level location sites; when the optimal solution of the corresponding instance is unknown an ‘X’ symbol appears in the subsequent column (U.). The subsequent two columns report the percentage gap with respect to the optimal solution for the initial Greedy algorithm and the first Descent Phase respectively; the corresponding CPU time is not reported, as always negligible. Two blocks of columns follow, one for each heuristic as indicated in the leading row, reporting the percentage gap with respect to the optimal solution, the number of Descent–Kick iterations performed and the CPU time spent in seconds. For instances whose optimal solution is unknown, the optimality gap is computed with respect to the best known dual bound. In the last two columns the results obtained by the branch-and-price algorithm described in Addis et al. (2012) at the root node are included as a reference; when no feasible solution was found, the corresponding entry in the Table is marked with a dash. The last row of each block of instances reports average values.First, we could observe that stopping the branch-and-price at the root node is not a viable option for obtaining accurate solutions. Such a method is in general quick, but in some cases produces solutions which are even worse than those of Greedy. Furthermore, as discussed in the next Section, does not scale well as the size of instances increase.Second, by looking at the average values, it is clear that Greedy and pure Descent Phase are very fast, but inaccurate. We observed that, in terms of accuracy, LBfi outperformed Rbi in both Dataset 1 and Dataset 2. Rbi was faster than LBfi in all blocks of instances of Dataset 1 except the last one (p56–p71), which however contains the most difficult instances; Rbi was also generally faster on Dataset 2.Third, we compared the results of LBfi with that of the exact algorithms described in Addis et al. (2012); for instance, in Dataset 1 we observed that on the easier instances, which can be solved by exact algorithms within a time limit of 2hours, LBfi reaches solutions which are on average 0.24% worse than the optimum, and is about three times faster; at the same time, on the hardest instances, which cannot be solved by any exact algorithm due to excessive CPU time or memory consumption, the solutions of LBfi are on the average 1.31% away from the best known dual bound, and the average CPU time is still less than 20minutes.During the previous experiment we observed that LBfi was able to reach an optimal solution in a large set of instances (about 70% in both Dataset 1 and Dataset 2). We also observed that, when an optimum is not reached, LBfi often hits the limit on the maximum number of Descent–Kick iterations; we therefore performed a set of experiments removing the limit on the number of kicks, and setting a time limit of 1hour to the whole computation. In Tables 3 and 4we report respectively the gap between the value of the solution produced and the best known dual bound, and the CPU time spent at each stage of the optimization process. We present only results for instances in the last block (p56–p71), the only group of instances where LBfi hits the kick limit almost always, furthermore they represent the hardest ones for exact algorithms. Each table has one column for each instance. The first row refers to the Greedy algorithm (G); a sequence of two-rows blocks follows, one for each Descent–Kick iteration of the algorithm: the first row of each block refers to the end of the Local Search Descent Phase (LS), and the second one to the end of the Kick phase (K). Statistics are reported in the last columns of each table. In particular, in Table 3 we report in turn the Average, Minimum and Maximum optimality gap values, the corresponding standard deviation, and the number of instances already finished in the given number of iterations; in Table 4 we report in turn the Average, Minimum and Maximum CPU time spent. Finally, in Fig. 3we report a chart representing the quality of the solution at each iteration of the algorithm: on the x axis the iteration number is reported, while on the y axis the corresponding maximum, average and minimum values of optimality gap are represented respectively with dashed, continuous and dotted lines.A very large portion of the gap is closed by kicks; the Descent Phase proved to be useful for obtaining improvements fast and, most of all, for producing different start points for the kicks. We highlight two phenomena: first LBfi showed a very smooth behavior; second, LBfi additionally found an optimal solution on 5 of the 10 instances that could be solved by exact algorithms, and was able to lower the gap with respect to the best known dual bound from 1.19% to 0.34%.We also tested our heuristics on the large size instances included in Dataset 3 and Dataset 4. We let Rbi and LBfi perform at most ten Descent–Kick iterations, and set a timeout of two hours to the solution of each ILP subproblem. The optimization of these instances is out of reach for exact solution methods, but we could still obtain valid dual bounds for almost all instances by running the algorithms described in Addis et al. (2012) for 2hours. The results we obtained are reported in Table 5. The structure of the table is similar to that of Tables 1 and 2: we report the percentage improvement with respect to the solution found by the Greedy algorithm, the percentage gap between the solution obtained and the best known dual bound and the CPU time needed by the computation; for Rbi and LBfi we also report the number of Descent–Kick iterations performed; for the Greedy algorithm the first column is omitted. We also omit the CPU time taken by Greedy and Local search, being negligible. For instances phub800TL and phub800TT no initial valid solution could be found using the Greedy algorithm and therefore no result is given in the table. Furthermore, the algorithms described in Addis et al. (2012) were unable to produce any valid dual bound for instances capa (10000), capa (12000) and capa (14000), since the execution ran out of memory before the root node computation was over; therefore, no duality gap could be computed for these three instances. The last row of each block of instances reports average values. As before, in the last two columns we include the results obtained by branch-and-price at the root node, and when no feasible solution was found, the corresponding entry in the Table is marked with a dash.The truncated branch-and-price is not competitive in this context: no feasible solution is found on many instances, and on the remaining ones a fine tuning of LBfi performs better in terms of both accuracy and CPU time.The Greedy and Local Search algorithms are still very fast, but the duality gaps remain large. Both Rbi and LBfi are able to substantially improve the quality at the expense of reasonable CPU time; indeed, the amount of improvement at each iteration is similar to that measured during the previous experiments. No clear dominance is observed between Rbi and LBfi, as they provide better improvements on different instances with different CPU time; however, LBfi is more stable, and on the average provides better results with less CPU time. We also observe that while Rbi always converged without hitting the limit on Descent–Kick iterations, LBfi was stopped before convergence in almost all instances of Dataset 4; hence, more accuracy can potentially be obtained by loosening such an iterations limit.

@&#CONCLUSIONS@&#
In this paper we proposed effective heuristics for the Two-level Capacitated Facility Location Problem. We designed and experimentally tested two algorithms; they both model and explore very large scale neighborhoods using ILP based formulations and techniques. In particular, one is able to reach optimal solutions for a large set of instances, providing on average very tight primal bounds in a fraction of the CPU time spent by exact algorithms. Our heuristics are also able to provide tight approximations on instances whose size is out of reach for exact algorithms. Different parameter settings easily allow to trade accuracy for CPU time.