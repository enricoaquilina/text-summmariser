@&#MAIN-TITLE@&#
The data transfer problem in a system of systems

@&#HIGHLIGHTS@&#
We study the problem of transferring a datum from its sources to its recipients.We describe the context of this new problem and we formally define the problem.We show that the problem is polynomially solvable in certain cases.We show that the general problem is stronglyNP-Hard.We show that 2 related problems of the literature are also stronglyNP-Hard.

@&#KEYPHRASES@&#
Combinatorial optimization,Data transfer,Scheduling,Routing,

@&#ABSTRACT@&#
Systems of systems are collections of independent systems which interact and share information to provide services. To communicate, systems can opportunistically make use of contacts that occur when two entities are close enough to each other. In this paper, it is assumed that reliable predictions can be made about the sequence of such contacts for each system. An information item (a datum) is split into several datum units which are to be delivered to recipient systems. During a contact between two systems, a sending system can transfer one stored datum unit to a receiving system. Source systems initially store some of the datum units. The data transfer problem consists in searching for a valid transfer plan, i.e. a transfer plan allowing the datum units to be transmitted from their source systems to the recipient systems. The dissemination problem consists in searching a valid transfer plan which minimizes the dissemination length, i.e. the number of contacts which are necessary to deliver all the datum units to the recipient nodes. To our knowledge, there is no previous work attempting to determine the theoretical complexity of these problems. The aim of this paper is to determine the frontier between easy and hard problems. We show that the problems are stronglyNP-Hard when the number of recipients is equal to 2 or more (while the number of datum units is unbounded) or the number of datum units is equal to 2 or more (while the number of recipients is unbounded). We also show that these problems are polynomially solvable when the number of datum units or the number of recipient nodes is equal to 1, or when these parameters are all upper bounded by given positive numbers. The complexity of two related problems is also studied. It is shown that knowing whether there exist k mutually arc-disjoint branchings in an evolving graph and k arc-disjoint Steiner trees in a directed graph without circuit are stronglyNP-Complete.

@&#INTRODUCTION@&#
Systems of systems (SoSs) are integrated systems that are heterogeneous and independently operable on their own, but are networked together for a common goal (Jamshidi, 2008). Most of the functions carried out by SoSs require the transfer of information through the whole SoS. A SoS is generally composed of mobile interacting systems, e.g. satellites, drones, sensors, etc.From a data transportation point of view, a SoS can be considered as an intermittently connected network of several systems. These systems can make opportunistic use of the possibilities for communication that arise when two entities are close enough to share data. A system is equipped with one or more transmitters, referred to below as nodes. Using heterogeneous technologies, e.g. Bluetooth or IEEE 802.11, nodes are communication devices which allow the systems to interact in order to cooperate and efficiently transmit data from one subset of systems to another.Any opportunity to communicate between several compatible nodes is called a contact. Contacts allow the elements of the SoS to collaborate and to route information from a subset of source systems to a subset of recipient systems. This collaboration becomes necessary, for example, when contact durations are relatively short with respect to the quantity of information to be disseminated, and where consequently the complete data cannot be transferred in a single contact. To tackle this problem, modern protocols subdivide data into several datum units which are sent in any order to recipient systems. A datum unit represents an identified, indivisible and unitary datum fragment (measured in bytes). A datum unit could, for example, be one of a set of identified fixed-sized blocks constituting high-resolution satellite images (the data). It is assumed that these recipient systems are able to rebuild the data from the corresponding datum units. The datum units may be transferred to non-recipient messenger systems whose role is to store and pass on the datum units.A source system is characterized by a set of datum units it initially stores, and a recipient system is characterized by a set of datum units that it wishes to store before a given deadline in order to rebuild some data. The problem we address here is how to use knowledge about possibilities for collaboration when routing information from sources to destinations within a given time horizon. The general question to be answered is this: which datum units should be transferred from which nodes to which other nodes, and when (i.e. during which contacts)?Apart from some works where datum units are not identified (Bhadra and Ferreira, 2002; Bui-Xuan, Ferreira, and Jarry, 2003; Ferreira, 2002), all previous works have, to our knowledge, studied a specific problem without attempting to determine the theoretical complexity of the case in hand. Thereby, we have chosen to study a simple case which allows us to determine the frontier between easy and hard problems.In the context of real applications, a contact could have been characterized by its time interval (during which the transmission of data between these nodes is possible), its transmission delay (i.e. the length of time required by the sending node to process all the bytes that are sent according to the data-rate of the link), and its propagation delay (i.e. the amount of time it takes for the head of the signal to travel from the sender to the receiver over the medium concerned). Moreover, systems are often heterogeneous and each system could have been characterized by its buffer capacity (which quantifies the amount of bytes the system is able to store in its non-volatile memory) and the life expectancy of its battery (which limits the activity of the whole system for a given period). However, several simplifying assumptions have been proposed in the literature to study these kinds of problems from a theoretical point of view. For instance, Handorean, Gill, and Roman (2004) defined atomic contacts. This assumption means that contact durations are ignored, given that inter-contact times are much more significant; both propagation and transmission delays are then disregarded. Thus, in the present paper, we have also chosen to consider contacts as being atomic and without interference, i.e. a node is in contact with only one other node at any given time. Knowing the dates of each contact for each node, the collaboration possibilities can be defined as a sequence representing the successive contacts which will occur between nodes. More particularly, we define a contacts sequence of ordered pairs of nodes. Note that if two contacts occur at the same time, they can be sequenced in any order since they concern different nodes. During a contact, a receiver node can receive from a sender node at most one datum unit that is already present in the sender’s buffer (either from the outset or as a result of previous contacts). Following the contact the datum unit is assumed to be stored in the receiver’s internal memory. Buffers are assumed to have an infinite capacity and network failures are disregarded. We also focus on the problem in which datum units are part of the same piece of information. Indeed it does not change the computational complexity of the problem, while the description of the problem is simpler.The remainder of the paper is organized as follows. Section 2 formally describes the studied problem. Section 3 investigates the computational complexity of the general problem. In Section 4 we show that particular cases of the problem are polynomially solvable. Finally, in Section 5 we also prove the complexity of two related problems which are studied in the same context of opportunistic networks.We consider a set V = {1, …, n} of n nodes (representing the transmitters in the systems). Set D = {1, …, p} represents the p units of a datum (numbered from 1 to p). Each of these units represents an identified, indivisible, unitary datum fragment. Each node i ∈ V has a corresponding subset oi⊆D indicating which datum units in D are initially stored by node i.Collaboration possibilities are defined as a sequence σ = (σ1, …, σm) representing the successive contacts which will occur between nodes. The contacts are assumed to occur at different times and in the order of the sequence. Each contact σcis an ordered pair (i, j) ∈ V × V with i ≠ j. During a contact (i, j) ∈ σ, node j can receive from node i a datum unit k ∈ D that i already has stored in its buffer (initially or after some previous contacts). From this point onwards datum unit k is assumed to be stored in node j’s internal memory. Below, scand rcrefer respectively to the sender and the receiver of contact σc∈ σ, i.e. σc= (sc, rc). Note that if we are interested in a non-directed version of the problem (in which either node of the contact can send a datum unit to the other), it is sufficient to add a contact (j, i) after each contact (i, j). The subset R⊆V defines the recipient nodes which have to retrieve datum D before the end of σ. We denote the number of recipients as r = |R|.A transfer plan describes which datum units are transferred during the contacts comprising the sequence, and can be defined by a function ϕ: {1, …, m} → {∅, {1}, {2}, …, {p}} where ϕ(c) is a singleton containing the datum unit transferred from scto rcduring σc. If no unit is transmitted during contact σc(for example, because rcalready possesses all the datum units that scpossesses), then ϕ(c) = ∅. Considering a transfer plan ϕ, we associate with each node i ∈ V the setoicof datum units which are stored by i after the first c contacts (σ1, …, σc) of σ. Therefore,∀i∈V,oi0=oiand∀c∈{1,⋯,m},orcc=orcc−1∪ϕ(c)andoic=oic−1fori∈V∖{rc}. A transfer plan ϕ is said to be valid if a sender always transfers a datum unit it already possesses, i.e.∀c∈{1,⋯,m},ϕ(c)∈{∅}∪{{k}|k∈oscc−1}.In the following “the data transfer problem” designates the problem of finding a valid transfer plan ϕ such that ∀i ∈ R,oim=D,i.e. all recipient nodes possess every datum unit making up D after the sequence of contacts. This problem is summarized in the following integer linear programming formulation (see for example Nemhauser and Wolsey, 1998, pp. 3–14, for a comprehensive introduction on the modeling of combinatorial problems using binary variables). Binary variable xkc, with k ∈ D and c ∈ {1, …, m}, is equal to 1 if datum unit k is transferred during contact σc(i.e. if ϕ(c) = {k}), and to 0 else. Binary variableoikc,with i ∈ V, k ∈ D and c ∈ {1, …, m}, is equal to 1 if node i stores datum unit k at the end of contact σc(i.e. ifk∈oic), and to 0 else. Constantoik0is set to 1 if node i initially stores datum unit k, and to 0 else.(1)∀c∈{1,⋯,m},∑k∈Dxkc≤1(2)∀i∈V,∀k∈D,∀c∈{1,⋯,m},oikc≤oik0+∑{t∈{1,…,c}|rt=i}xkt(3)∀i∈V,∀k∈D,∀c∈{1,⋯,m},oikc≥oik0+∑{t∈{1,…,c}|rt=i}xktm+1(4)∀k∈D,∀c∈{1,⋯,m},xkc≤osckc−1(5)∀i∈R,∀k∈D,oikm=1Eq. (1) states that at most one datum unit can be transferred during each contact σc. Eqs. (2) and (3) state that node i stores datum unit k after contact σcif i initially stores k (i.e.oik0=1) or if i has retrieved k during a contact σt, t ∈ {1, …, c} (in such a case, we have∑{t∈{1,…,c}|rt=i}xkt≥1). Eq. (4) states that during each contact c, the sender node sccan only transfer a datum unit k ∈ D that it stores (i.e. withosckc−1=1). Finally, Eq. (5) states that, at the end of the sequence of contacts, each recipient node has to store each datum unit.With any valid transfer plan ϕ and with any recipient node i ∈ R, is associated a delivery lengthλi(ϕ)=argminc∈{0,…,m}oic=D. This corresponds to the smallest contact index c following which node i ∈ R possesses all datum units making up D. Below we shall assume that if no such index exists, then λi(ϕ) = ∞. The transfer plan ϕ also has an associated dissemination length λ(ϕ) = maxi ∈ Rλi(ϕ). This corresponds to the smallest index c at which all recipients have been served. If no such index exists, it is assumed that λ(r) = ∞. Note that the data transfer problem is a search problem, i.e. in which we search for a valid solution (a transfer plan ϕ such that ∀i ∈ R,oim=D).“The dissemination problem” is one of the possible optimization version of the data transfer problem which consists in finding a valid transfer plan ϕ that minimizes λ(ϕ). This problem can be seen as the offline version of the problem considered by Belblidia, de Amorim, Costa, and Conan (2011) where the contacts between nodes are not known into advance (that is why the problem is online). To manage this online context, they propose a popularity-based strategy which relies on node-local information. Indeed, nodes keep track of the dissemination level of the datum units throughout the network in order to privilege the least prevalent datum unit. This simple strategy has shown to significantly increase the system performances.The special case where R is reduced to a singleton {ω} is called “the delivery problem” and consists in finding a valid transfer plan ϕ minimizing λω(ϕ). To our knowledge, these problems have never been considered in the literature. The previous integer linear programming formulation can be completed in order to introduce this minimization criterion: we introduce a binary variable gcfor each c ∈ {1, …, m} which is equal to 0 if all recipient nodes store all datum units at the end of contact σc, or to 1 otherwise (if there exists a node i which has still to retrieve at least one datum unit). We have then:(6)∀c∈{1,⋯,m},gc≥1/r∑i∈Rp−∑k∈DoikcpThus, the minimization of λ(ϕ) can be added to the formulation with:(7)Minimize∑c∈{1,⋯,m}gcAny instance of the problem can be easily described with an evolving graph, which is a time-dependent graph model proposed by Ferreira (2004). An evolving graph is “an indexed sequence of subgraphs of a given graph where the subgraph at a given index point corresponds to the network connectivity at the time interval indicated by the index number”(Ferreira, 2004). An evolving graph takes concretely the shape of a directed multigraph where the vertices represent the nodes of the network and the arcs represent the network links. Arcs are besides labeled with the time index at which the corresponding links are efficiently active. Thus, it can be seen as a directed multigraph G(V, A, τ) where τ: A → I and I is the set of intervals which can be built over a given time horizon. Thus, for an arc (i, j) ∈ A, τ((i, j)) represents the interval on which (i, j) can be used. For the problem in hand, the considered evolving graph is simpler since each interval can be reduced to an instant time. It can then be seen as a directed multigraph G(V, A, τ) where τ: A → {1, …, m}. With each contact σc= (i, j) ∈ σ is associated an arc (i, j) ∈ A with τ((i, j)) = c (see Fig. 1for an instance). In such a graph, a path [u0, u1, u2, …, uz] with each uj∈ A is such that ∀j ∈ {0, …, z − 1}, we have τ(uj) ≤ τ(uj + 1). Such a path is then called a journey in Ferreira (2004). A branching B rooted at t in an evolving graph G is a subgraph of G such that for every vertex v ∈ V, there is exactly one journey in B from t to v. A solution of the data transfer problem can be described as a set of arc-disjoint branchings in subgraphs of the evolving graph, each branching being rooted in a node initially storing the datum unit which is transferred across the branching.In Fig. 1, we provide an example of an instance with its set of nodes V, its set of datum units D and its sequence of contacts σ. All nodes are recipient nodes, i.e. V = R and all nodes have to retrieve all datum units before the end of the sequence σ. Initially, node 1 stores datum units 1 and 2 (i.e. o1 = {1, 2}) and node 2 stores datum unit 2 (i.e. o2 = {2}) while the other nodes store no datum unit. The evolving graph associated with this instance is provided. Each arc is labeled with the index of the contact corresponding to this arc. For example, arc (1, 2) is labeled with 8, because σ8 = (1, 2). A solution is also provided for this instance. As it can be seen, with the dissemination of each datum unit from a source node to a recipient node is associated a journey. For example, the dissemination of datum unit 1 from node 1 to node 4 is associated with the journey [(1, 6); (6, 5), (5, 4)] which corresponds to ϕ(1) = ϕ(3) = ϕ(6) = {1}. Finally three arc-disjoint branchings are associated with the dissemination of the datum units: two branchings respectively rooted in nodes 1 and 2 (highlighted with bold arcs on the figure) for datum unit 1, and one branching rooted in node 1 (highlighted with doubled arcs on the figure) for datum unit 2. Note that five arcs do not belong to one of the branchings since they are associated with a contact during which no datum unit is transmitted (ϕ(2) = ϕ(9) = ϕ(12) = ϕ(13) = ϕ(14) = ∅). After the application of the provided transfer plan, the final state of the nodes is such that∀i∈R,oim=D,i.e. all nodes store all datum units.In this section we show that the data transfer problem isNP-Hard, leading also to theNP-Hardness of the dissemination problem.Let us consider the decision version of the data transfer problem, denoted henceforward as Dt :INSTANCE:A set V = {1, …, n} of n nodes. A subset R⊆V of recipient nodes. A sequence σ = (σ1, …, σm) of m ordered pairs (i, j) ∈ V × V with i ≠ j. A set D = {1, …, p} of p datum units. For each node i ∈ V, a subset oi⊆D of units initially stored by i.QUESTION:Is there a valid transfer plan ϕ: {1, …, m} → {∅, {1}, …, {p}} such that ∀i ∈ R,oim=D?The data transfer problem (Dt) is obviously inNP,since it can be decided in polynomial time whether a given transfer plan ϕ is valid and such that ∀i ∈ V,oim=D. We show that the problem isNP-Complete in the strong sense when p = 2 and r is not upper bounded, or when r = 2 and p is not upper bounded.To prove these results, we need to reduce a problem known as being stronglyNP-Complete to the studied cases. Garey and Johnson (1979) give a comprehensive guide to the theory ofNP-Completeness and provide an extensive list ofNP-Complete andNP-Hard problems. In this paper, we will consider the 3-SATISFIABILITY problem described on p. 259 in Garey and Johnson (1979) (referred to below as 3Sat). The 3Sat problem is stronglyNP-Complete and is stated as follows:INSTANCE:A set X = {x1, …, xq} of q variables. A set C = {c1, …, cs} of s clauses over X such that for each c ∈ C, |c| = 3.QUESTION:Is there a truth assignment that satisfies C ?Theorem 3.1The data transfer problem is stronglyNP-Hard for p ≥ 2.We now show that 3Sat is reducible in polynomial time to the special case of Dt for which p = 2 (U2Dt). Consider an instance of 3Sat. From this instance, we build an instance of U2Dt as follows:We have p = 2 and then D = {1, 2}.•With each clause cj∈ C with j ∈ {1, …, s} is associated the node ωj∈ V in U2Dt withoωj={2}. The datum units possessed by these nodes will correspond to the logical value of the clause in such a way that the clause will be considered to be true if the associated node possesses datum unit 1 and to be false otherwise. Thus, initially all clauses are false (the associated nodes possess only unit 2).With each variable xi∈ X with i ∈ {1, …, q} are associated 2 nodes li∈ V andl¯i∈Vin U2Dt  witholi=ol¯i=∅. The datum units possessed by these nodes will respectively correspond to the logical values of literals xiandx¯i. The literal among{li,l¯i}which will store datum unit 1 will be considered to be true, while the other one which will store datum unit 2 will be considered to be false. Initially all literals are considered to be undetermined (the associated nodes possess no datum units).In U2Dt is also created the node α ∈ V with oα= {1, 2}. This node is the only one which initially possesses the two datum units. It will allow the logical value of each literal to be given by providing unit 1 only to the nodes associated with literals which have to be true, and unit 2 to the nodes associated with literals which have to be false.We set R = {ωj|j ∈ {1, …, s}}∪{li|i ∈ {1, …, q}}.Thus, from the instance of 3Sat, exactly n = s + 2q + 1 nodes have been created.The sequence σ = σ1○σ2○σ3 of contacts is built from the concatenation of 3 subsequences where:•subsequence σ1 of size 2q is built such that for each i ∈ {1, …, q}, we haveσi1=(α,li)andσq+i1=(α,l¯i);subsequence σ2 of size 3s is built such that for each j ∈ {1, …, s}, considering that cj= {lj1, lj2, lj3}, we haveσ3(j−1)+k2=(li,ωj)if ljk= xi, orσ3(j−1)+k2=(l¯i,ωj)ifljk=x¯i,for k ∈ {1, 2, 3};subsequence σ3 of size q is built such that for each i ∈ {1, …, q}, we haveσi3=(l¯i,li).Thus, from the instance of 3Sat, a sequence of exactly m = 3q + 3s contacts has been created.For example, consider the following instance of 3Sat with q = 3 and X = {x1, x2, x3}, s = 2 and C = {c1, c2} withc1={x1,x¯2,x¯3},c2={x¯1,x¯2,x3}.Then the associated instance for U2Dt is (see Fig. 2) p = 2, D = {1, 2}, n = 9,V={ω1,ω2,l1,l2,l3,l¯1,l¯2,l¯3,α},R = {ω1, ω2, l1, l2, l3}, m = 15 and σ = σ1○σ2○σ3 with:•oω1=oω2={2};oli=ol¯i=∅for i ∈ {1, 2, 3}; oα= {1, 2};σ1=((α,l1),(α,l2),(α,l3),(α,l¯1),(α,l¯2),(α,l¯3));σ2=((l1,ω1),(l¯2,ω1),(l¯3,ω1),(l¯1,ω2),(l¯2,ω2),(l3,ω2));σ3=((l¯1,l1),(l¯2,l2),(l¯3,l3)).Suppose that there is a valid transfer plan ϕ such that ∀i ∈ R,oim=Dfor the built instance of U2Dt. We show how a valid truth assignment can be obtained for C.The logical values of all literals are set during subsequence σ1. Consider the pair of nodes{li,l¯i}(i ∈ {1, …, q}) associated with the pair of literals{xi,x¯i}. Throughout σ, node lihas an initial contact with node α during which it retrieves at most one unit of D. The situation is identical forl¯i. Finally, during contacts in the subsequence σ3, a contact occurs betweenl¯iand li. Since li∈ R, the transfer plan is such thatolim=D. Consequently, the only way for such a transfer to be obtained is where, during the contacts of σ1, liobtains one unit of D andl¯iobtains the other one. Next, during the contacts of σ3, each nodeli¯gives its datum unit to node li. This process ensures that following the contacts of σ1, eitheroli2q={1}∧ol¯i2q={2},oroli2q={2}∧ol¯i2q={1}. Ifoli2q={1}∧ol¯i2q={2},then xiis set to true. Conversely, ifoli2q={2}∧ol¯i2q={1},xiis set to false. Note also that at the end of the sequence σ1 exactly one of the associated literals in{xi,x¯i}is considered to be true and the other false.It remains to be shown that this assignment satisfies C. During the contacts of σ2, nodes{li,l¯i|i∈{1,…,q}}transfer the only datum unit they possess to the nodes associated with each clause they are related to. Note that during contacts of σ2, each node ωj, j ∈ {1, …, s} related to clause cjis in contact with 3 nodes which correspond to the 3 nodes representing the literals which compose the clause: there are therefore three possible ways for each node ωjto retrieve datum unit 1, meaning that cjis true. After the contacts of σ2, all nodes ωj, j ∈ {1, …, s} are such that1∈oωj2q+3s=oωjm=D,since they are such that ωj∈ R. This means that there is a truth assignment for C.Table 1shows a valid transfer plan solution for the previous example, giving rise to a truth assignment of the clauses of C. Each part of the table represents the transfer plan associated with contacts in the subsequence σk, k ∈ {1, 2, 3}. For each contactσikwith i ∈ {1, …, 6}, the pair of nodes (s, r) involved in contactσikis listed, together with the datum unit set stored by each node before the subsequence σk, the datum unit received by r during contactσik,and the datum unit set stored by r after subsequence σk. In the first part of the table, the logical values of literals associated with nodes are also listed (“literal”). In the second part of the table, the logical value of each clause cjwith j ∈ {1, 2}, which is true only if it obtains datum unit 1, is also reported (“clause”).Suppose that there exists a satisfying truth assignment for C. We can build a corresponding valid transfer plan as follows:For each i ∈ {1, …, q}, if xiis true (x¯iis false) then we set ϕ(i) = {1} and ϕ(i + q) = {2}, else (xiis false andx¯iis true) we set ϕ(i) = {2} and ϕ(i + q) = {1}. Note that the datum unit stored by each node l (representing a literal) is given by setol2q(i.e. its state after the 2q contacts of σ1).For each i ∈ {1, …, s}, considering that {li1, li2, li3} are the 3 nodes associated with the literals of ci, for k ∈ {1, 2, 3}, we set ϕ(|σ1| + 3(i − 1) + k) = {1} if datum unit 1 is stored by likelse ϕ(|σ1| + 3(i − 1) + k) = ∅ (node i already stores datum unit 2). Note that if clause ciis satisfied, there exists at least one node likwhich can transmit unit 1 to node i. Thus, after the contacts of σ2 each node ωi, i ∈ {1, …, s}, possesses all the units comprising the datum.For each i ∈ {1, …, q}, we setϕ(|σ1∘σ2|+i)=ol¯i2q. Recall thatl¯ipossesses the datum unit that lineeds. Thus, after the contacts of σ3, lipossesses all the datum units.Given that all nodes i ∈ R of the instance of U2Dt possess all the datum units, the resulting transfer plan is such that ∀i ∈ R,oim=D.Theorem 3.2The data transfer problem is stronglyNP-Hard for r ≥ 2.We now show that 3Sat is reducible in polynomial time to the special case of Dt for which r = 2 (R2Dt). For this purpose we adapt the proof of Even, Itai, and Shamir (1975) showing that the two-commodity integral flow problem isNP-Complete. The significant difference is that instead of dealing with units of flow, we are now dealing with datum units which can be duplicated (which is not the case for a unit of flow). Consider an instance of 3Sat. Using this instance we build an instance of R2Dt as follows:We recall that s is the number of clauses and that q is the number of variables of the 3Sat instance. We set p = s + 1 and D = {0, 1, …, s} (exceptionally, for the sake of simplicity, datum units are numbered starting with 0).•For i ∈ {1, …, q}, let piand nibe respectively the number of occurrences of xiand ofx¯iin the clauses of C. With variable xi∈ X, i ∈ {1, …, q}, is associated setLi={βi,li1,li2,li3,…,li2pi,l¯i1,…,l¯i2ni,ϵi}⊆Vof 2(1 + pi+ ni) nodes in R2Dt (see Figs. 3and 4). Initially, none of these nodes possesses any datum unit (i.e. ∀x ∈ Li, ox= ∅).With clause cj∈ C, j ∈ {1, …, s}, is associated the node Cj∈ V in R2Dt withoCj=∅(see Fig. 4).Moreover 4 nodes {α1, α2, ω1, ω2} ∈ V are built in R2Dt. We setoα1=oω2={0}andoα2=oω1={1,…,s}(see Figs. 3 and 4).Finally, we set R = {ω1, ω2}.Thus, from the instance of 3Sat, exactlyn=4+s+2∑i=1q(1+pi+ni)=4+2q+7snodes have been created in R2Dt (since there are three literals per clause).We build the sequence σ = σ1○σ2○σ3○σ4 of contacts from the concatenation of several subsequences where:•Subsequence σ1 = σ1, 1, 1○σ1, 2, 1○σ1, 1, 2○σ1, 2, 2○⋅⋅⋅○σ1, 1, i○σ1, 2, i○⋅⋅⋅○σ1, 1, q○σ1, 2, qis built such that for i ∈ {1, …, q}, we haveσj1,1,i=(α2,li2j−1)with j ∈ {1, …, pi} andσj1,2,i=(α2,l¯i2j−1)with j ∈ {1, …, ni} (see Fig. 4). Therefore, subsequence σ1 contains∑i=1q(pi+ni)=3scontacts.Subsequence σ2 is obtained from the concatenation of several subsequences. Letσ2,i=((βi,li1),(li1,li2),(li2,li3),…,(li2pi−1,li2pi),(li2pi,ϵi),(β1,l¯i1),(l¯i1,l¯i2),(l¯i2,¯li3),…,(l¯i2ni−1,l¯i2ni),(l¯i2ni,ϵi))be the subsequence of contacts obtained as follows (see Fig. 3) and which is associated with variable xi. If pi= 0 then contact (βi, εi) occurs, else contact(βi,li1)occurs, followed in succession by the contacts(lij,lij+1),j ∈ {1, …2pi− 1}, and finally by contact(li2pi,ϵi). Next, if ni= 0 then contact (βi, εi) occurs, else contact(β1,l¯i1)occurs, followed in succession by the contacts(l¯ij,l¯ij+1),j ∈ {1, …2ni− 1}, and finally by contact(l¯i2ni,ϵi). Thus, subsequence σ2, icontains 2(pi+ ni+ 1) contacts. Sequence σ2 is then such that (see Fig. 4):σ2=((α1,β1))∘σ2,1∘((ϵ1,β2))∘σ2,2∘((ϵ2,β3))∘⋯∘σ2,q−1∘((ϵq−1,βq))∘σ2,q∘(ϵq,ω1).First a contact occurs from α1 to β1. Next each subsequence σ2, j, j ∈ {1, …, q}, is successively applied with a contact (εi, βi + 1) between each pair of subsequences (σ2, j, σ2, j + 1), j ∈ {1, …, q − 1}. Finally, contact (εq, ω1) occurs.Therefore, subsequence σ2 contains2+q−1+∑i=1q2(pi+ni+1)=2+3q+6s−1contacts.Subsequence σ3 is obtained by adding successively the following contacts (see Fig. 3): for the xth occurrence of xi(x¯i), there is a contact fromli2x(l¯i2x) to the node Cjassociated with the clause cjin which xi(x¯i) occurs. For example, in Fig. 4, there are three contacts(l12,C2),(l¯22,C2)and(l¯q2nq,C2)to represent the fact that clause c2 is such thatc2={x1,x¯2,x¯q}and such that they are the 1st occurrence of x1, the 1st occurrence ofx¯2and the (nq)th occurrence ofx¯qin C. Therefore, subsequence σ3 contains 3s contacts.Subsequence σ4 = ((c1, ω2), (c2, ω2), …, (cs, ω2)). Therefore, subsequence σ4 contains s contacts.Thus, from the instance of 3Sat, a sequence of exactly m = 13s + 3q + 1 contacts has been created.For example, consider the instance described in Section 3.1. Then, the associated instance for R2Dt (see Fig. 5) is p = 3, D = {0, 1, 2}, n = 4 + 2q + 7s = 24, V = {α1, α2, ω1, ω2, C1, C2, β1, β2, β3, ε1, ε2, ε3,l11,l12,l¯11,l¯12,l¯21,l¯22,l¯23,l¯24,l31,l32,l¯31,l¯32},m = 15 and σ = σ1○σ2○σ3○σ4 with:•oα1={0},oα2={1,2};oω1={1,2},oω2={0}; oi= ∅ for all other nodes;σ1=((α2,l11),(α2,l¯11),(α2,l¯21),(α2,l¯23),(α2,l31),(α2,l¯31));σ2=((α1,β1),(β1,l11),(l11,l12),(l12,ϵ1),(β1,l¯11),(l¯11,l¯12),(l¯12,ϵ1),(ϵ1,β2),(β2,ϵ2),(β2,l¯21),(l¯21,l¯22),(l¯22,l¯23),(l¯23,l¯24),(l¯24,ϵ2),(ϵ2,β3),(β3,l31),(l31,l32),(l32,ϵ3),(β3,l¯31),(l¯31,l¯32),(l¯32,ϵ3),(ϵ3,ω1);σ3=((l12,C1),(l¯22,C1),(l¯32,C1),(l¯12,C2),(l¯24,C2),(l32,C2));σ4 = ((C1, ω2), (C2, ω2)).Suppose that there is a valid transfer plan ϕ such that ∀i ∈ R,oim=Dfor the built instance of R2Dt. We show how a truth assignment can be obtained that satisfies C.During the contacts of σ, node ω1 needs to obtain datum unit 0, since initially it possessed only datum units {1, …, s}. This can only occur where datum unit 0 has been transmitted from α1 to β1 during contact (α1, β1) and has been transmitted from β1 to ω1 using some contacts of σ2. Therefore, for i ∈ {1, …q}, datum unit 0 is transmitted using either subsequence((βi,li1),(li1,li2),(li2,li3),…,(li2pi−1,li2pi),(li2pi,ϵi))or subsequence((β1,l¯i1),(l¯i1,l¯i2),(l¯i2,¯li3),…,(l¯i2ni−1,l¯i2ni),(l¯i2ni,ϵi))of σ2, i. This means that at least one of these two subsequences is devoted exclusively to transmitting datum unit 0 (and no other datum unit can transit through these nodes). Datum unit 0 next uses contact (εi, βi + 1) if i < q or contact (εi, ω1) if i = q.During the contacts of σ, node ω2 needs to obtain the subset {1, …, s} of datum units, since initially it possessed only datum unit 0. Each datum unit must therefore have been obtained from a different node Cj, since there are exactly s contacts from nodes of {C1, …, Cs} to ω2. The datum unit k which is transmitted during contact (Cj, ω2) comes initially from node α2. It has transited either through some nodes fromli2x−1toli2y(x, y ∈ {1, …, pi}, y > x) or through some nodes froml¯i2x−1tol¯i2y(x, y ∈ {1, …, ni}, y > x) so as finally to be transmitted to Cj. Note that if datum unit k has been transmitted to Cjthrough nodeli2y(l¯i2y) with i > 1, it cannot have come from a nodelz2x−1(l¯z2x−1) with 1 ≤ z < i. Indeed, as mentioned before, datum unit 0 is transmitted during contact (εi − 1, βi).Actually, the path of contacts used to transmit datum unit k to node Cjmakes it possible to identify the literal that makes clause cjtrue. If k has been transmitted through nodes fromli2x−1toli2y(x, y ∈ {1, …, pi}, y > x), then variable xiis set to true. Conversely, if k has been transmitted through nodes froml¯i2x−1tol¯i2y(x, y ∈ {1, …, pi}, y > x), then variable xiis set to false (x¯iis true).We should remember that datum unit 0 has transited using some of the contacts in σ2i, and that xiobviously cannot be true and false at the same time. It should also be noted that the same literal can cause several clauses to be true : in this case, several datum units (one per true clause) transit through nodes of Liusing one disjoint path of contacts per datum unit. Finally, in certain cases none of the datum units in {1, …, s} transits through nodes of Li: in this case, the associated variable xican be arbitrarily set to true or false, meaning that it is not needed to make C true.Given that for each clause cjwe have found exactly one literal that makes cjtrue, we can therefore conclude that there is a truth assignment for CFor the previous example (see Fig. 5), datum unit 1 can be transmitted through the contacts((α2,l¯21),(l¯21,l¯22),(l¯22,C1),(C1,ω2))while datum unit 2 can be transmitted through contacts((α2,l¯23),(l¯23,l¯24),(l¯24,C2),(C2,ω2))making x2 = false, and then, making both C1 and C2 true (leading to a truth assignment of clauses of C). At the same time datum unit 0 can be transmitted through contacts((α1,β1),(β1,l11),(l11,l12),(l12,ϵ1),(ϵ1,β2),(β2,l¯21),(l¯21,l¯22),(l¯22,l¯23),(l¯23,l¯24),(l¯24,ϵ2),(ϵ2,β3),(β3,l31),(l31,l32),(l32,ω2)).Variables x1 and x3 can then be set arbitrarily.Let us assume that there exists a truth assignment that satisfies C. We can build a corresponding valid transfer plan as follows. First, datum unit 0 is transferred during contact (α1, β1), during all contacts (εi, βi + 1) with i ∈ {1, …, q − 1} and during contact (εq, ω1). For each i ∈ {1, …, q}, datum unit 0 is also transmitted through contacts(βi,li1),(li1,li2),…,li2pi−1,li2pi),(l,2piϵi)if xiis true; or through contacts(βi,l¯i1),(l¯i1,l¯i2),…,l¯i2ni−1,l¯i2ni),(l¯i2ni,ϵi)if xiis false. Note that datum unit 0 is transmitted through contact (βi, εi) if xiis true and pi= 0 or if xiis false and ni= 0. Since datum unit 0 has been transmitted from α1 to ω1, ω1 possesses all datum units at the end of sequence σ.For each clause cj, j ∈ {1, …, s} we choose the first literal of cjwhich is true. Suppose that this literal is xi, i ∈ {1, …, q}, and that it is the yth occurrence of xiin the set C. Datum unit j is transferred during contacts(α2,li2y−1),(li2y−1,li2y),(li2y,Cj),(Cj,ω2). Now, suppose that this literal isx¯i,i ∈ {1, …, q} and that it is the yth occurrence ofx¯iin the set C. Then datum unit j is transferred during contacts(α2,l¯i2y−1),(l¯i2y−1,l¯i2y),(l¯i2y,Cj),(Cj,ω2). In both cases, these contacts cannot have been used to transmit datum unit 0 since the contrary would mean that both literals xiandx¯iare true.All other contacts can be set to ∅. Moreover, since each datum unit j ∈ D has been transmitted from α2 to ω2 during contacts associated with clause cj, ω2 also possesses all datum units at the end of sequence σ.Given that every node i ∈ R of the instance of R2Dt has all the units of the datum, the transfer plan obtained is such that ∀i ∈ R,oim=D.In this problem, D = {1}. If there is at least one transfer plan leading to the dissemination of the whole datum, there is at least one optimal transfer plan where, for each contact σc∈ σ, we have ϕ(c) = {1} iforcc−1=∅andoscc−1={1}. Indeed, there is no advantage to be gained in delaying the transfer of the only datum unit for node rc, if such a transfer is possible. It is therefore sufficient to go through the sequence of contacts in such a way that each recipient node rcof a current contact σcobtains the datum unit if it can, and stops as soon as all recipient nodes have the datum.This process is summarized in Algorithm 1. In this algorithm, o[i] represents the current state of a node i: it is equal to ∅ if it does not possess the datum, and {1} if it does possess it. In the first loop, each element o[i] is set to oiand nbdelivered is set to the number of recipient nodes which initially have the datum. In the second loop, each contact σcis considered in the order of sequence σ. For a contact σc= (sc, rc), node rcgets the datum if needed and if possible, i.e. if o[rc] = ∅ and o[sc] = {1}. The transfer plan is then built and nbdelivered is updated if ϕ(c) = {1} and rc∈ R. The loop terminates once all recipient nodes possess the data (if nbdelivered = r), or if the end of sequence σ has been reached. The third loop sets all the remaining contacts to ∅. Each iteration of the loops being in O(1) time, Algorithm 1 runs in O(max (m, n)) time. This leads to the following theorem.Theorem 4.1The dissemination problem can be solved in O(max (m, n)) time if p = 1.Recall that this problem is similar to the dissemination problem, except that only one specified node ω needs to obtain all the datum units.Obviously, if p = 1 then the delivery problem can be solved in O(max (m, n)) time with Algorithm 1. We will now show that the general case is also polynomial, by reducing the problem to the resolution of a max (p, m) separate maximum flow problems. Let μi= |{σc∈ σ|rc= i}| be the number of contacts whose node i ∈ V is the receiver.A transportation network G = (U, A, c) can be made to correspond to any given instance of the decision version of the delivery problem. This network is composed of the following elements:•a source vertex S ∈ U;with each datum unit z ∈ D = {1, …, p}, we associate a vertex dz∈ U;with each node i ∈ V, we associate the set of vertices{i0,…iμi}⊂U;∀z ∈ {1, …, p}, we add an arc (S, dz) ∈ A of capacity c(S, dz) = 1;∀i ∈ V, if datum unit z ∈ oithen we add an arc (dz, i0) ∈ A of capacity c(dz, i0) = 1;∀i ∈ V, ∀x ∈ {1, …, μi}, we add an arc (ix − 1, ix) ∈ A of capacity c(ix − 1, ix) = p;∀σc= (i, j) ∈ σ such that node i has been the receiver of x contacts before σcand such that σcis the yth contact where node j is the receiver, we add arc (ix, jy) ∈ A of capacity c(ix, jy) = 1;finally, we add an arc(ωμω,S)∈Aof capacityc(ωμω,S)=p.For example, the transportation network corresponding to the following instance of the decision version of the delivery problem is depicted in Fig. 6:•n = 4, p = 2, V = {1, 2, 3, 4} and D = {1, 2}, o1 = {1}, o3 = {1, 2}, o2 = o4 = ∅, ω = 4 (i.e. R = {4}),m = 7, σ = ((1, 2), (2, 4), (3, 2), (1, 3), (3, 4), (2, 1), (1, 4), (4, 2)).Note that the maximum flow on arc(ωμω,S)cannot exceed its capacity p. Note also that the resulting transportation network contains |U| = 1 + p + n + m vertices and |A| = p + ∑i ∈ V|oi| + 2m + 1 ≤ (n + 1)p + 2m + 1 arcs.We now show that solving the decision version of the delivery problem is equivalent to searching for a flow of magnitude p in the associated transportation network.Proposition 4.1For any instance of the delivery problem, there exists a transfer plan ϕ such that node ω obtains the whole datum if and only if, in the associated transportation network, the maximum amount of flow through vertex S is equal to p.To prove this proposition, we consider a flow f: A → D in the associated transportation network satisfying the capacity constraints and the conservation of flow such that the flow entering S is equal to p. A valid transfer plan ϕ can then be built as follows.First, we consider the amount of flow from each vertex dz(z ∈ {1, …, p}) to each vertex i0 (i ∈ V). If f(dz, i0) = 1 then i0 is the node that is considered to be the owner of datum unit z. Note that each datum unit is considered to be owned by at most one vertex, since the flow entering vertex dzcannot exceed 1. From now on, each unit of flow from one vertex to another in the transportation network has to be considered as a change of owner for a datum unit.Next, we consider each contact in the order of the sequence. For a contact σc= (i, j), let isand jtbe the nodes in U such that i has already been the receiver of s contacts before contact σcand such that σcis the tth contact in which j is the receiver. Note that we have t > 0. In the associated transportation network, if f(jt − 1, jt) = q, then jtbecomes the owner of q datum units that jt − 1 previously owned. Note that since there is conservation of the flow at each vertex of the transportation network, jt − 1 was the owner of at least q datum units. If jt − 1 was the owner of more than q datum units, the q datum units whose owner is changing can be chosen indifferently (for example the q datum units with the smallest indices). Now, if f(is, jt) = 1, then jtbecomes the owner of one datum unit z that was previously owned by is, and we set Φ(c) = {z}. If f(is, jt) = 0 then we set Φ(c) = ∅. At the end of this step, note that each datum unit is still considered to be owned by only one vertex. The same process is iteratively applied to each contact in the sequence σ.Having considered each contact of the sequence, we look at the amount of flow fromωμωto S. Iff(ωμω,S)=pwe can conclude that vertexωμωis the owner of all units of the datum and that transfer plan that has been constructed is such that node ω has obtained the whole datum at the end of the sequence of contacts.Conversely, consider a valid transfer plan ϕ such that node ω gets the whole datum at the end of the sequence of contacts. From the sequence of contacts and from this transfer plan we can construct the statesoicof each node i after the different contacts σc∈ σ. We can then build the flow function f as follows. First we initialize the flow function such that ∀(i, j) ∈ A, f(i, j) = 0. We consider vertexωμωin the transportation network. Initially we consider that this vertex is the owner of every datum unit. The procedure consists of finding iteratively the different owners of each datum unit z until a vertex i0 (i ∈ V) has become its owner.For this purpose we consider a datum unit z initially owned by vertexis=ωμω. We will assume that s > 0 (if this were not the case, then the process would terminate immediately, because node ω would never be the receiver in a contact and must therefore own the whole datum at the start). Let σxbe the sth contact whose i is the receiver and thus letoixbe the set of datum units stored by node i after contact σx. Ifz∈oix−1,then vertex is − 1 is considered to be the new owner of datum unit z and f(is − 1, is) is incremented of one unit. Ifz∉oix−1,then node i has received datum unit z during the sth contact in which i is the receiver. Then, let σc= (j, i) be the sth contact of i in which i is the receiver, and let t be the number of contacts in which j was the receiver before contact σc(0 ∈ {1, …, μj}). Vertex jtconsequently becomes the new owner of datum unit z and we set f(jt, is) = 1. Note that the flow magnitudes obtained respect the capacity constraints of the transportation network. By resetting is= is − 1 or is= jt − 1 according to the case, the process is repeated until that datum unit z is owned by a vertex i0.Note that at the end of each iteration there is only one owner of datum unit z and that the change of owner results in an increase in the flow on the arc linking the new owner to the previous owner. This ensures the conservation of the flow. This operation is repeated for all of the datum units. At the end of the process we therefore know which vertex i0 is the owner of each datum unit z. For each vertex i0 and for each datum unit z, if i0 is the owner of datum unit z then we set f(dz, i0) = 1. Finally for each dz(z ∈ {1, …, p}), we set f(S, dz) = 1. QEDIn practice the transportation network can be simplified by iteratively removing the vertices that have no successor or no predecessor and through which the flow can only be null. Moreover, the vertices representing the different states of node ω can be merged into a single node (the resulting vertex is the destination of all in-arcs to a vertex ωx, and all the out-arcs are removed, apart from the one to S). The simplified transportation network from the previous example is shown in Fig. 7.Node ω needs at least p − |oω| contacts to obtain all the data. One way of finding a transfer plan ϕ that minimizes λω(ϕ) is to build the transportation network associated with the shortest subsequence of σ involving p − |oω| contacts with node ω. Iff(ωμω,S)=p,then the transfer plan ϕ associated with f is optimal. Otherwise, we complete the current subsequence of σ in such a way that it involvesp−f(ωμω,S)more contacts with node ω. A new maximum flow can be computed. Note that in practice the previously computed flow can be easily transformed to obtain a new starting flow. The procedure is repeated untilf(ωμω,S)=por until the current sequence equals σ. Note that if the procedure stops whilef(ωμω,S)<pthen we know that the instance is not feasible, i.e. there is no valid transfer plan that could ensure the delivery of the whole datum to node ω. By using the Ford–Fulkerson algorithm (Ford and Fulkerson, 1956) or the Edmonds and Karp algorithm (Edmonds and Karp, 1972) to compute the maximum flow of the transportation networks that are constructed, the procedure can run in O((np + m)max (p, m)) time, given that the search for an augmenting path is in O(|A|) time and that we need to obtain at most max (p, m) augmenting paths.Finally, note that if several pieces of information (each one composed of different datum units) have to be considered, the method is still valid since it is sufficient to merge these pieces of information to obtain a single set D of datum units.In this section we look at an instance of the problem in which both p and r are assumed to be upper bounded by given positive constant numbers K1 and K2, with K1 ≥ p ≥ 2 and K2 ≥ r ≥ 2. We might be tempted to use the same kind of technique as in the previous section, but since r ≥ 2 this is no longer possible. In the case where r = 1 it was possible, because exactly p units of flow were sent through the transportation network, and a unit of flow was interpreted as the ownership of one datum unit which did not need to be identified. Now, however, the ownership of a datum unit might need to be duplicated (in order to be transmitted to several nodes), and conservation constraints prohibit the duplication of units of flow. Moreover, taking one unit of flow per datum unit per recipient is not possible, because the units of flow are not identified: this can lead to a solution in which a recipient get the same datum unit twice.However, taking one unit of flow per datum unit per recipient, we can build Algorithm 2using the notion of temporary ownership of a datum unit.In this algorithm, a set of states States is managed. Since there are r recipients of the datum, it is considered that there are exactly r copies of each datum unit. Each state S ∈ States is defined by a bidimensional array S.o, where S.o[z][k] designates the node owning the kth copy of datum unit z, and S.ϕ is the transfer plan from which this state has arisen.Initially, the algorithm is started with only one state S in which the imaginary node 0 is the owner of all copies of each datum unit and where S.ϕ(c) = ∅, ∀c ∈ {1, …, m}. The ownership of each copy of each datum unit z is then distributed among nodes i with z ∈ oi. At the end of this phase of the algorithm, a node i can own several copies of the same datum unit (if it needs to transfer datum unit z to several other nodes).Next, the ownership of datum unit copies is transferred through contacts. At the end of each iteration c, States contains one state for each possible situation which can arise from contacts (σ1, …, σc). For this purpose a new set of states States′ is computed from the set States obtained at the end of the previous iteration. Given a state S ∈ States, for each copy k of each datum unit z, if S.o[z][k] = sc, then a new state S′ is created by copying S (with instruction copy(S) which copies both the dimensional array and the transfer plan of S) and by transferring the ownership of datum unit z to rc(instruction S′.o[z][k] ← rc). Since this corresponds to the transfer of unit z during contact σc, we set S′.ϕ(c) to {z}. Instruction add(States′, S′) is used to add the new state S′ to set States′. We assume that S′ is not added if there exists another state in States′ that has exactly the same ownership matrix (although not necessarily the same associated transfer plan, since several transfer plans can give rise to the same ownership matrix). The instruction isCompleted(S′) checks whether all recipient nodes have obtained all the datum units (this can be done in polynomial time). If this is the case the algorithm stops and returns the computed transfer plan. Finally, at the end of iteration c, States′ is added to States with add(States, States′) (also in such a way that each ownership matrix is unique within the obtained set State).Since the ownership of the kth copy (k ∈ {1, …, p}) of datum unit z (z ∈ {1, …, p}) can take n + 1 values, there are at most (n + 1)rppossible states and at each iteration of the algorithm r ≤ (n + 1)rp. The overall algorithm is consequently in O(mnrp) time. Since r and p are upper bounded by given positive constant numbers K1 and K2, the algorithm is polynomial in m and n.Note that two states S1 and S2 are equivalent if ∀z ∈ {1, …, p}, S2.o[z] is a permutation of S1.o[z]. Indeed, the |R| copies of a datum unit z are equivalent. To avoid having several equivalent states, we can slightly improve the process by incorporating a sorting procedure to obtain sequences S.o[z] where S.o[z][1] ≤ S.o[z][2] ≤ ⋅⋅⋅ ≤ S[z][r].Note this algorithm can be practically used only for small values of r and p. However, from a theoretical point of view, we have shown that the problem can be polynomially solved as soon as r and p are upper bounded. Finally, note that if several pieces of information (each one composed of different datum units) have to be considered, the method is easily adaptable. The instruction isCompleted(S′) has to check whether all recipient nodes have respectively obtained all the datum units of the pieces of information they wished to retrieve.Let G = (V, A) be a directed multigraph. For a vertex t ∈ V, a branching B rooted at t is a subgraph of G such that for every vertex v ∈ V, there is exactly one path in B from t to v(Edmonds, 1972). For any X⊂V, let δG(X) denote the set of arcs (i, j) ∈ A such that i ∈ X and j ∈ V/X. Edmonds (1972) established that there exist k mutually arc-disjoint branchings rooted in t if and only if for every X⊂V with X ≠ ∅, we have |δG(X)| ≥ k.Let cG(t) = min {X|t ∈ X, X⊂V, X ≠ ∅}δG(X) be the maximum number of arc-disjoint branchings at t in G. Therefore, cG(Xt) can be seen as the outward connectivity of t, i.e. the minimum number of edges that would need to be removed to make at least one vertex unreachable from t(Shiloach, 1979). cG(S) can also be seen as the minimum number of arc-disjoint paths from t to any other vertex in V. This well-known property is used by a number of polynomial algorithms that have been developed for finding a given number of arc-disjoint branchings in a multigraph, such as Shiloach’s (1979) in O(k2n(m + n)).An evolving graph is a time-dependent graph model, first introduced by Ferreira (2002), which can be used to deal with intermittently connected communication networks (see for example delay tolerant networks (Fall, 2003)). It can be seen as a directed multigraph G(V, A, τ) where τ: A → I and I is the set of intervals which can be built over a given time horizon. Thus, for an arc (i, j) ∈ A, τ((i, j)) represents the interval on which (i, j) can be used. In its simplest version τ is such thatτ:A→N(i.e. the interval of time on which (i, j) can be used) is reduced to a singleton. In this case, a path [u0, u1, u2, …, uz] in an evolving graph with each uj∈ A is such that ∀j ∈ {0, …, z − 1} we have τ(uj) ≤ τ(uj + 1). Such a path is then called a journey.Surprisingly, unlike usual graphs, knowing if there exists a strong connected component of a given size in evolving graphs (i.e. considering journeys instead of usual paths) isNP-Complete (Bhadra and Ferreira, 2002). However, the directed minimum spanning trees for each vertex in a strongly connected evolving graph can be polynomially computed. Some other algorithms in the literature can be polynomially generalized in evolving graphs. These include the search for foremost journeys (the journeys with the smallest dates), shortest journeys (the journeys which minimize the number of arcs) and fastest journeys (the journeys with the smallest difference between departure and arrival times) from a source vertex to all other vertices (Bui-Xuan et al., 2003).We now turn to the problem of knowing whether there exist k mutually arc-disjoint branchings in an evolving graph. It should be remarked that Edmonds’s property no longer holds for evolving graphs. This can be proved with the following counter-example. Let G = (V, A, τ) with V = {t, a, b, c, d, e, f}, A = {a1, …, a12} with a1 = (t, a), a2  =  (t, b), a3  =  (c, d), a4  =  (t, a), a5  =  (t, b), a6 = (a, c), a7 = (b, c), a8 = (c, d), a9 = (a, e), a10 = (b, f), a11 = (d, e), a12 = (d, f) andτ:V→Nwith τ(a1) = τ(a2) = τ(a3) = 10 and τ(ai) = 1 for i > 3.VertexPathsa[a1]and[a4]b[a2]and[a5]c[a4,a6]and[a5,a7]d[a4,a6,a3]and[a5,a7,a8]e[a4,a9]and[a5,a7,a8,a11]f[a5,a10]and[a4,a6,a8,a12]We can see that for each vertex v ∈ V with v ≠ t, there are at least two journeys from t to v. However, there cannot exist two mutually arc-disjoint branchings rooted at t. Let us suppose that there exist two mutually arc-disjoint branchings B1 and B2 rooted at t. Note that each branching has exactly 6 arcs. Thus, {B1, B2} has to be a partition of A. Arcs a1 and a2 cannot be used in the same branching, otherwise the other vertices could not be reached because of the value of τ(a1) and τ(a2). Suppose that a1 ∈ B1 and a2 ∈ B2. This means that a5 has to be in B1 while a4 has to be in B2. The only possible course of action is to add a7 to B1 and to add a6 to B2. Then we have to put a3 in one branching and a8 in the other one. If a3 ∈ B1 and a8 ∈ B2, then a11 has to be in B1 since vertex e cannot be reached from A. However a11 cannot be used after a3. Now if a3 ∈ B2 and a8 ∈ B1, then a12 has to be in B1 since vertex f cannot be reached from A. However a12 cannot be used after a3.Consider the decision version of the search for arc-disjoint branchings in an evolving graph, referred to below as Adbeg.INSTANCE:An evolving graph G = (V, A, τ), a vertex t ∈ V, an integer k (k ≤ |A|/(|V| − 1)).QUESTION:Are there k mutually arc-disjoint branchings rooted at t (considering journeys) in G ?Theorem 5.1The Adbeg problem isNP-Complete.We will now show that Dt  is reducible to Adbeg in polynomial time. Consider an instance of Dt. From this instance, we build an instance of Adbeg as follows:With each node i ∈ {1, …, n} in Dt, we associate a vertex i ∈ V in Adbeg. With each datum unit k ∈ D in Dt, we also associate a vertex dk∈ V in Adbeg. Finally, we add a vertex t ∈ V.For each datum unit k ∈ D of Dt, we add an arc (t, dk) ∈ A with τ((t, dk)) = 0 in Adbeg. For each node i ∈ {1, …, n} and each datum unit k ∈ D in Dt, ifk∈oi0,we add an arc (dk, i) ∈ A with τ((dk, i)) = 0 in Adbeg. Now, with each contact σc∈ σ in Dt, we associate an arc (sc, rc) ∈ A with τ((sc, rc)) = c in Adbeg. LetR¯be the subset of nodes of V which are not associated with a recipient node in Dt, i.e.R¯={v∈V|v∉R}. Finally, for each nodev∈R¯we add p arcs (t, v) with τ((t, v)) = m + 1.Suppose that there exists a set {B1, …, Bp} of p mutually arc-disjoint branchings in G = (V, A). The only way to reach a vertex i ∈ R is to use some arcs ajwith 1 ≤ τ(aj) ≤ m. These arcs can only be reached by first using an arc (t, dk) with τ((t, dk)) = 0. Each branching is then associated with exactly one arc (t, dk). Let Bkbe the branching associated with the arc (t, dk) such that τ((t, dk)) = 0. We can build a transfer plan ϕ for Dt in the following way. We initially set Φ(c) = ∅ for c ∈ {1, …m}. Next, for each branching Bk, k ∈ {1, …, p}, and for each arc a ∈ Bkwith 1 ≤ τ(a) ≤ m, we set ϕ(τ(a)) = k. Note that since the different branchings are mutually arc-disjoint, and since there is exactly one arc a ∈ A associated with a contact in σ, we do not try to set several values to the same Φ(c). For each i ∈ R there is a journey [u0, …, ux] in each branching Bksuch that u0 = (t, dk), u1 = (dk, z) withk∈oz0,and such that ∀j ∈ {1, …, x}, 1 ≤ τ(uj) ≤ m and τ(uj − 1) < τ(uj). Therefore there is a corresponding list of contacts which allows datum unit k to be transmitted from such a node z to node i. Thus, at the end of σ, all i ∈ R are such thatoim=D.Now, suppose there is a valid transfer plan Φ. For each k ∈ {1, …, p} = D, we first setBk=(V,ABk={(t,dk)}). Next, for each node i ∈ V such thatk∈oi0,we add arc (dk, i) inABk. Then, for each c ∈ {x|Φ(x) = k}, we add arc (rc, sc) inABk. Note that for each i ∈ V∖{t, d1, …, dp} for which there is a path from t to i, there is a corresponding list of contacts which means that datum unit k can be transmitted from a node z withk∈oz0to i. This is particularly true for any node i ∈ R. Moreover, each i ∈ V∖R for which there is no path from t to i is such that it is not connected to another node in Bk. For such node i, we add an arc (t, i) inABkwith τ((t, i)) = m + 1. This is always possible, given that there exist p arcs of this kind. The subgraph Bkobtained is consequently a branching. Therefore, there must exist p mutually arc-disjoint branchings in G.The problem of packing arc capacitated directed Steiner trees is a well known problem (Cheriyan and Salavatipour, 2006). Consider a directed graph G = (V, A) with a positive capacity cafor each arc a ∈ A, a set T⊆V of terminals and a specified root vertex t, t ∈ T. A directed Steiner tree rooted at t is a subgraph of G that contains a path from t to each terminal v ∈ T. The problem of packing arc capacitated directed Steiner Trees is to find the maximum number of directed Steiner trees rooted at t such that for every arc a ∈ A the total number of Steiner trees containing a is at most ca.Cheriyan and Salavatipour (2006) used the following reduction of the problem: given two pairs of vertices (x1, y1) and (x2, y2), are there two arc-disjoint paths, one from x1 to y1 and the other from x2 to y2? This reduction enabled them to show that the problem of knowing whether there are two arc-disjoint Steiner trees in a graph with unit capacities and only three terminals isNP-Complete.In fact, it can be shown that this problem isNP-Complete even if there are three terminals and the graph is without circuit. As we saw in Section 3.1, knowing if there exists a valid transfer plan in a graph (i.e.U2Dt) isNP-Complete even if r = 2. Moreover, with an instance of U2Dt, we can associate a graph G = (U, A, c) similar to the one built for the delivery problem in Section 4.2 and which is composed of the following elements:•a source vertex S ∈ U;with each datum unit z ∈ D = {1, …, p}, we associate vertex dz∈ U;with each node i ∈ V, we associate the set of vertices{i0,…iμi}⊂Uwhere μi= |{σc∈ σ|rc= i}| is the number of contacts in which node i ∈ V is the receiver;∀z ∈ {1, …, p}, we add arc (S, dz) ∈ A of capacity c(S, dz) = 1;∀i ∈ V, ∀z ∈ {1, …, p}, if datum unit z ∈ oithen we add arc (dz, i0) ∈ A of capacity c(dz, i0) = 1;∀i ∈ V, ∀x ∈ {1, …, μi}, we add arc (ix − 1, ix) ∈ A of capacity c(ix − 1, ix) = p;∀σc= (i, j) ∈ σ such that node i has been the receiver of x contacts before σcand such that σcis the yth contact of node j, we add arc (ix, jy) ∈ A of capacity c(ix, jy) = 1.Knowing whether there is a valid transfer planomm=Dwith r = 2 thus becomes equivalent to knowing whether there exist two arc-disjoint Steiner trees rooted at S with terminals T = {S}∪R. It should be noted, moreover that the graph is without circuit by construction.

@&#CONCLUSIONS@&#
