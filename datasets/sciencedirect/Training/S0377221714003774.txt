@&#MAIN-TITLE@&#
Fast computation of bounds for two-terminal network reliability

@&#HIGHLIGHTS@&#
An algorithm for the computation of two-terminal network reliability is proposed.The reliability bounds provide an approximate solution for very large networks.Controlling the execution time the gap between the two bounds is controlled.Applied on an airplane electrical network with about 4 trillion minpaths.Used to analyze the Boeing 787 Current Subsystem for the FAA Certification.

@&#KEYPHRASES@&#
Binary Decision Diagram (BDD),Bounds computation,Large network reliability,Reliability graph,Reliability prediction,

@&#ABSTRACT@&#
In this paper, an algorithm for the fast computation of network reliability bounds is proposed. The evaluation of the network reliability is an intractable problem for very large networks, and hence approximate solutions based on reliability bounds have assumed importance. The proposed bounds computation algorithm is based on an efficient BDD representation of the reliability graph model and a novel search technique to find important minpaths/mincuts to quickly reduce the gap between the reliability upper and lower bounds. Furthermore, our algorithm allows the control of the gap between the two bounds by controlling the overall execution time. Therefore, a trade-off between prediction accuracy and computational resources can be easily made in our approach. The numerical results are presented for large real example reliability graphs to show the efficacy of our approach.

@&#INTRODUCTION@&#
Large and complex networks are used in telecommunications, aerospace, transportation, power, banking and many such sectors. In the design of such networks, their reliability (R(t)) is an important attribute. To support reliability prediction of such networks, many algorithms have been developed. Reliability graph (Colbourn, 1987; Sahner, Trivedi, & Puliafito, 2012; Shooman, 2002) is one of the commonly used non-state-space models for network reliability analysis. Network reliability analysis problem is commonly referred to as the reliability graph analysis problem, the s-t connectedness problem or the two-terminal reliability analysis problem (Colbourn, 1987; Shier, 1991). In the two-terminal network problem the interest lies in computing the probability of communication between a fixed pair of nodes. As long as there is a communication path among that pair of nodes the network is considered operative. Many algorithms for the solution of this problem are known but none of them scale up to the real networks that tend to be very large. To deal with the otherwise computationally intractable problem of the reliability computation of large-scale networks, reliability bounds are often sought. This paper contributes with a new bounding algorithm. Note that we provide upper and lower bounds on network unreliability. Clearly by subtracting from 1, these can be converted into lower and upper bounds respectively, of network reliability.Exact solution methods for the network reliability problem can be divided into two classes: the factoring/decomposition methods (Misra, 1970; Page & Perry, 1989; Satyanarayana & Chang, 1983; Wood, 1985) and the minpaths/mincuts enumeration methods. In the factoring/decomposition method, the basic idea is to condition on an edge in the reliability graph and break the model into two disjoint cases. In one disjoint case, it is assumed that the edge is up and a new graph is generated by merging the two nodes of the edge. In the other disjoint case, it is assumed that the edge is down and a new graph is generated by removing the edge. This factoring/decomposition method is recursively applied on each of the two subgraphs until the resulting graphs have a series–parallel structure. In the minpaths/mincuts enumeration method, a Boolean expression is constructed based on all minpaths (or mincuts) and evaluated. In the reliability graph theory (Colbourn, 1987) a path is defined as a set of edges (components) so that if these edges are all up, the system is up; it is minimal if it has no proper subpaths. While a cut is defined as a set of edges so that if these edges are all down, the system is down; it is minimal if it has no proper subcuts. Based on the Boolean expression evaluation technique, the approaches can be further divided into inclusion/exclusion methods (Kim, Case, & Ghare, 1972; Lin, Leon, & Huang, 1976; Satyanarayana & Prabhakar, 1978), Sum of Disjoint Products (SDP) methods (Hariri & Raghavendra, 1987; Heidtmann, 1989; Jane & Yuan, 2001; Luo & Trivedi, 1998; Rai, Veeraraghavan, & Trivedi, 1995; Soh & Rai, 1993; Veeraraghavan & Trivedi, 1990) and Binary Decision Diagram (BDD) methods (Chang, Lin, Chen, & Kuo, 2003; Kuo, Lu, & Yeh, 1999, 2007; Xing, 2004; Zang, Sun, & Trivedi, 2000). The BDD methods are more recent and in most cases are more efficient for Boolean expression manipulation (Bryant, 1986). SDP methods were popular until recently and clearly outperform inclusion/exclusion methods (Locks, 1982).However, for complex networked systems, such as aircraft current return networks, the above approaches are not adequate and the exact solution for reliability is not feasible. As shown in (Provan & Ball, 1983), the exact computation of two-terminal reliability is NP-hard (Ball, 1986). This has led to the use of Monte Carlo methods (Botev, L’Ecuyer, Rubino, Simard, & Tuffin, 2013; Cancela & El Khadiri, 2003; Cancela, LâEcuyer, Lee, Rubino, & Tuffin, 2010, 2012, 2013; Easton & Wong, 1980; Elperin, Gertsbakh, & Lomonosov, 1991; Fishman, 1986; Hui, Bean, Kraetzl, & Kroese, 2003; Kumamoto, Tanaka, Inoue, & Henley, 1980; Manzi, Labbe, Latouche, & Maffioli, 2001; Zenklusen & Laumanns, 2011) and computation of reliability upper and lower bounds. Recently, in order to reduce the number of samples required by Monte Carlo techniques, approximation approaches based on Machine Learning have been proposed (Rocco & Muselli, 2007; Srivaree-ratana & Smith, 1998; Yeh, Lin, Chung, & Chih, 2010). The inclusion–exclusion (IE) method (Hudson & Kapur, 1985) provides bounds on system reliability when minpaths are used and on system unreliability when mincuts are used. Esary-Proschan (EP) method (Esary & Proschan, 1970; Natvig & Eide, 1987) transforms graph to parallel combination of all minpaths to obtain reliability upper bound and a series combination of all mincuts to obtain the reliability lower bound. However, these methods need to enumerate all minpaths and all mincuts to compute the bounds, and these mincuts and minpaths grow exponentially with the size of the network and are hence infeasible for large scale networks. Most of the other reliability bounds computation techniques are based on finding a certain subset of minpaths/mincuts or series–parallel subgraphs (Elmallah & AboElFotoh, 2006; Galtier, Laugier, & Pons, 2005; Shanthikumar, 1988). Specifically, some of the computation techniques are based on the reliability polynomials (Ball & Provan, 1983; Colbourn, 1987), which is also referred to as subgraph counting method. By assuming all arcs in the network have the same probabilities of operation, system reliability will be simplified to be a polynomial expression of the arc operation probabilities; based on this polynomial the reliability bounds are computed. However, such a method is limited to the constraint that all the arcs have the same operation probabilities. Another well-known technique is Edge-Packing method (Aboelfotoh & Colbourn, 1989; Colbourn, 1988), also known as edge-disjoint method. A subset of disjoint minpaths and mincuts are selected to compute the lower bound and upper bound of system reliability respectively. Some techniques are based on Sum of Disjoint Products (SDP) method as in (Beichelt & Spross, 1989; Jane, Shen, & Laih, 2009). A few recent papers have developed decomposition techniques based on Binary Decision Diagram (BDD) (Niu & Shao, 2011) where the quality of the approximation can be improved according to a predetermined accuracy value. Graphs with special structures are also considered in (Cheng & Ibe, 1992; Feo & Johnson, 1990; Soh, Rai, & Trahan, 1994).One problem associated with known bounds computation techniques is that they are not able to improve the reliability upper bound and lower bound by specifying the execution time. For example, for a specific reliability graph, the outputs of some bounds computation algorithms are fixed. If the bounds are not tight enough, they cannot be improved by a longer execution of the bounds computation algorithms. Many bounds computation algorithms can improve the reliability bounds by varying predetermined parameters for higher accuracy. However, this requires users know explicit definitions regarding accuracy parameters. In addition, the execution time can vary significantly for different input network models given the same accuracy, which makes it difficult to anticipate the real execution time by the users. Methods that exploit the Monte Carlo approach do allow the user to control the total computational effort but only in an indirect manner by choice of the sample size. In this paper, we propose an efficient algorithm using BDD representation for the reliability bounds calculations, which allows users to explicitly specify the execution time that is to be used. The advantage of such an approach is that it can not only search for important minpaths/mincuts that reduce the gap between the reliability upper and lower bounds, but also keep improving the bounds given longer execution time. The BDD representation of the bounds makes the minpath/mincut selection and bounds computation very fast and efficient. Heuristics are first used to find important minpaths/mincuts that can greatly increase/decrease the reliability lower/upper bound, then an exhaustive search is utilized to enumerate all minpaths/mincuts and compute their contribution to the current reliability lower/upper bound.The main contribution of this paper is thus twofold: first, a novel bounds computation algorithm for two-terminal network reliability (or unreliability) problem is proposed. Second, this algorithm is designed to yield higher accuracy given more execution time.This paper is organized as follows. Section 2 presents the mathematical background for the unreliability upper and lower bounds computation. Section 3.1 provides detailed procedures for unreliability upper bound computation including heuristic minpath search, exhaustive minpath search and minpath selection. Similarly, Section 3.2 describes detailed procedures for unreliability lower bound computation including heuristic mincut search, exhaustive mincut search and mincut selection. Numerical results of the proposed bounds computation approach are presented for several example graphs in Section 4 including a large real example reliability graph which contains over 4 trillion minpaths. Section 5 concludes this paper.In reliability graph theory (Colbourn, 1987; Shooman, 2002) the two terminal reliability is defined as the probability that two nodes(s,t), respectively the source s and the destination t (also called terminal or sink), are able to communicate. The source node s does not have any incoming edges and the destination t does not have any outgoing edges. The graph modelG=(V,E)consists of a set V of nodes (also called vertices), a set E of directed edges and a relation of incidence that associates with each edge two nodes. Each edge is assigned a failure probability or its complement known as its reliability.The reliability of a system (or a network) represented by a reliability graph can be expressed in terms of paths or cuts. A path is defined as a set of edges (components) so that if these edges are all up, the system is up; it is minimal (minpath) if it has no proper subpaths. While a cut is defined as a set of edges whose removal brings the system down; it is minimal (mincut) if it has no proper subcuts.A system structure functionϕis an indicator function defined on the status of all minpaths or mincuts (or equivalently on the status of the edges), whose output value is 1 if the system is up and 0 if the system is down.The unreliability upper bound is computed by taking a subset of all the minpaths in the reliability graph. Assume the status of edge i is represented by Boolean variableei, whereei=1,edgeiisup0,edgeiisdownand assumeP{ei=1}=ri, that is,riis the reliability of edge i. Note here that due to the assumption of mutual independence, edge reliabilityrican be easily replaced byRi(t)=e-∫0thi(x)dxto compute time-dependent reliability function for a general time to failure distribution with hazard ratehi(t)andRi(t)=e-λitfor a special case with the exponential distribution for the time to failure. From renewal theory,rican also be replaced byAi=MTTFiMTTFi+MTTRito compute steady-state availability given MTTF (mean time to failure) and MTTR (mean time to repair) for generally distributed time to failure and time to repair of the edge. Finally,rican also be replaced byAi(t)=μiλi+μi+λiλi+μie-(λi+μi)tto compute the instantaneous availability for the special case of exponentially distributed time to failure with parameterλiand exponentially distributed time to repair with parameterμi.For a minpath consisting of edgesx1,x2,…,xk, let the Boolean logic expressionM=ex1·ex2·⋯·exkrepresent the status of that minpath, i.e.,M=1,iftheminpathisup0,iftheminpathisdown.Therefore,P(M=1)=rx1rx2…rxkby independence. Suppose the total number of minpaths in the system is n. LetMidenotes the status of the i-th minpath among the set of all minpaths for1⩽i⩽n. Since the system represented by a reliability graph is up if there exists one or more minpaths from source to target, the system structure functionϕcan be written as the following Boolean logic expression:ϕ=M1+M2+⋯+Mn.The system unreliability is then written asQ=1-P(ϕ=1)=1-P(M1+M2+⋯+Mn=1).Letϕirepresent the subsystem structure function consisting of i minpaths described by the following Boolean logic expression:ϕi=M1+M2+⋯+Miand letUirepresent the unreliability of the subsystem consisting of i minpaths:(1)Ui=1-P(ϕi=1)=P(M‾1·M‾2·⋯·M‾i=1).Clearly, thenU1⩾U2⩾⋯⩾Un=Q.To compute the system unreliability, the Binary Decision Diagram (BDD) (Bryant, 1986) is often used as an efficient method for Boolean function manipulation. However for large reliability models, BDD for the system structure functionϕis too large to build and evaluate, thereforeUifor some i is utilized as the upper bound of Q, and an attempt is made to pick minpaths inUithat make it as close to Q as possible. Note that1-Uiis a lower bound on network reliability.The unreliability lower bound is obtained by using the idea in the previous section replacing minpaths by mincuts in the reliability graph. The same notationeiis utilized as above to represent the status of edge i. Therefore, for a mincut with edgesx1,x2,…,xk, let the Boolean logic expressionC=e‾x1·e‾x2·⋯·e‾xkrepresent the status of that mincut, thenC=1,ifalledgesinthemincutaredown0,ifanyedgeinthemincutisupC=1means that the mincut is down and the network is down. Suppose the total number of mincuts in the network is m. LetCidenote the status of the i-th mincut in the set of all mincuts for1⩽i⩽m. Therefore the system structure function has the following Boolean logic expression:ϕ=C1+C2+⋯+Cm‾.The system unreliability is then given byQ=1-P(ϕ=1)=P(C1+C2+⋯+Cm=1).Similar to unreliability upper bound computation, letϕirepresent the subsystem structure function consisting of i mincuts described by the following Boolean logic expression:ϕi=C1+C2+⋯+Ci‾and letLirepresent the unreliability of the subsystem consisting of i mincuts:(2)Li=1-P(ϕi=1)=P(C1+C2+⋯+Ci=1).ThenL1⩽L2⩽⋯⩽Lm=Q.If the reliability graph is too large to evaluate the system structure functionϕ,Lican be used as the lower bound of system unreliability and1-Lias an upper bound on system reliability. As in the last subsection, algorithms are needed to pick good mincuts in order to makeLias close to Q as possible.For large reliability graphs, the time and the storage needed to find all the minpaths and mincuts can be prohibitively large. Even for the minpaths and mincuts that have been found, it is often impossible to build the BDD to include all of them as the BDD size increases rapidly with the number of minpaths/mincuts included (Zang et al., 2000). To narrow the gap between unreliability upper bound and lower bound as much as possible with limited time and storage space, the reliability bounds computation is divided into two steps:1.Minpath/mincut search. Find new minpath/mincut candidates for inclusion in unreliability bounds computation.Minpath/mincut selection. Select from the minpath/mincut candidates identified in Step 1 above those that contribute the most in narrowing the gap between the current upper and lower bounds.The unreliability upper and lower bounds are then computed from the selected minpaths and mincuts. In the first step above, heuristics are first used to find important minpath/mincut candidates. The found minpath/mincut is said to be more important based on its ability to improve the found unreliability bounds. When no such candidates can be found, exhaustive search algorithms are utilized to enumerate all the minpath/mincut candidates. The reason both heuristic and exhaustive search algorithms are used is that exhaustive methods cannot be guaranteed to find important minpaths and mincuts within the specified time and storage limits. By contrast, heuristics can only generate a small number of minpaths and mincuts, hence accuracy of the computed bounds cannot be guaranteed. The need to use an exhaustive search algorithm relies in its completeness (i.e., it always finds a solution if it exists) since it systematically enumerates all possible candidates for the solution and checks whether each candidate satisfies the problem’s statement. The overall flow chart of the bounds computation method is shown in Fig. 1.The novelty of our approach lies in the efficient computation of bounds using heuristic and exhaustive search that at the same time allows the user to choose the maximum execution time allowed. In the implementation for each step we chose algorithms that are widely known and at the same time can provide good performance.The purpose of the heuristic path search is to find those minpaths that greatly reduce the upper bound of system unreliability. From Eq. (1),(3)Ui=P(M‾1·M‾2·⋯·M‾i=1)⩾P(M‾1·M‾2·⋯·M‾i-1=1)·P(M‾i=1).The equality holds whenM1,M2,…,Miare mutually independent– for example, when minpath i has no shared edges with the firsti-1minpaths. To reduceUias much as possible, it is desired to find an independent (so that the equality holds in the equation above) and reliable (so thatP(M‾i=1)is small) minpath. Independence can be easily guaranteed by deleting all edges in the minpath from the graph after it is found. To find the most reliable minpath, assumerito be the reliability of edge i, andx1,x2,…,xkto be the edges in M, thenP(M=1)=rx1·rx2·⋯·rxk.By taking minus logarithms on both sides of the equation, we get-log(P(M=1))=(-logrx1)+(-logrx2)+⋯+(-logrxk).Since0⩽ri⩽1for each edgei,-logri⩾0. If we assign weight(-logri)to each edge i in the reliability graph, then the problem of finding the most reliable minpath is converted to finding the minpath with the minimum sum of non-negative weights, which we compute using Dijkstra’s single-source shortest path algorithm in timeO(|V|2)and memoryO(|V|2)(Cormen, Leiserson, Rivest, & Stein, 2009), where|V|is the number of vertices.When the most reliable minpath M has been found in the current graph, M is deleted from the graph by changing the weights of all edges in M to infinity. Thus for instance, for edgei∈M, we setri=0and-log(ri)=∞. Dijkstra’s algorithm is then applied again on the remaining graph to find the next most reliable minpath. This procedure is repeated until there is no minpath with a finite sum of weights from source to target. Re-running Dijkstra’s algorithm on the graph with the weights of all edges belonging to the found minpath set to infinity ensures independence of the minpaths by construction. If k minpaths denoted by,M1,M2,…,Mk, are found, then the unreliability upper bound computed using these k minpaths is the probability that all k minpaths fail:UB=P(M‾1·M‾2·⋯·M‾k=1)=P(M1=0)·P(M2=0)·⋯·P(Mk=0).Other heuristic algorithms might be worth of investigation, such as Dijkstra improved with the use of min-priority queue, and dynamic algorithms for shortest path search that allow the update of the weights of each edge belonging to the found minpath (Cicerone, D’Angelo, Stefano, Frigioni, & Maurizio, 2010, 2003; Frigioni, Marchetti-Spaccamela, & Nanni, 2000). We leave these extensions to a future paper.The heuristic minpath search algorithm can only find a small fraction of all minpaths. To further reduce the unreliability upper bound, the exhaustive minpath search is utilized after no more minpaths can be found by the heuristics. Breadth First Search (BFS) is used for this purpose as it finds shorter minpaths first that are likely to be more reliable than longer minpaths. In addition, when the same number of minpaths is found, the number of distinct edges covered by BFS is often more than the number covered by Depth First Search (DFS). Therefore the minpaths truncated (not covered by BFS when it is stopped) usually share more edges with the minpaths already found, thus making the truncated minpaths less important in reducing the unreliability upper bound.The BFS is a tree search algorithm for traversing a path that takes as input parameter the source(s)and the target(t)nodes. Its worst case space and time complexity (to find a single path) are bothO(|V|+|E|)(Cormen et al., 2009), where|E|is the number of edges.To obtain the shortest paths, literature proposes the k shortest path routing algorithms (Eppstein, 1999; Lawler, 1972; Martins & Pascoal, 2003; Yen, 1971) but their computational complexity grows with the value for k. Moreover this approach does not allow one to evaluate each path as soon as it is found and thus causes a loss over the granularity with which the entire algorithm execution is controlled. Hence, we have chosen not to use these algorithms.For large reliability graphs, it is not possible to build the BDD for all the minpaths that have been found by the algorithms as described above. In such cases, a subset of the minpaths is selected to construct the BDD for unreliability upper bound. As an example, let B denote the current BDD corresponding to the union of the minpaths that have already been selected for inclusion, and letu=1-P(B=1)be the unreliability upper bound evaluated from B. Then for a new path M, letB^be the BDD that would have resulted by including the minpath M in it and letuˆ=1-P(B^=1)be the new unreliability upper bound evaluated fromB^. The minpath M is selected if the following condition holds:(4)Δu=u-uˆ⩾α·ufor example, if by adding minpath M, the reduction in the current unreliability upper bound is greater than a factorα, a constant chosen between 0 and 1, then M is included in the set of selected minpaths for upper bound computation. In such a case, u and B are updated touˆandB^, respectively. Otherwise, minpath M is put into a heap sorted by theΔuvalue of M. The reason for storing instead of discarding the unqualified minpath M is because it may later become qualified as the value of unreliability upper bound becomes smaller.When using the algorithm, it was observed that most of the newly found minpaths do not qualify for inclusion, as determined by the inequality (4). For these unqualified minpaths, it is clearly wasteful to constructB^(especially when B becomes large), as it is no longer needed afteruˆis calculated. To reduce the time complexity, it is desirable to computeuˆwithout explicitly constructingB^;B^is constructed only if M is chosen for inclusion. Since,uˆ=1-P(B^=1)=u-P(B‾·M=1),we have(5)Δu=u-uˆ=P(B‾·M=1)=P(M=1)-P(B·M=1).NowP(B·M=1)can be written as(6)P(B·M=1)=P(B|M=1=1)·P(M=1).Therefore from Eqs. (5) and (6),Δu=P(M=1)·[1-P(B|M=1=1)].AssumeM=ex1·ex2·⋯·exk, thenP(M=1)=rx1rx2⋯rxk, andP(B|M=1=1)is the probability forB=1given the constraintex1=ex2=⋯=exk=1. This probability can be computed from the pseudo-code in Fig. 2. The idea is to evaluate the change inΔuinserting the evaluation of the reliability for the edges does not yet considered in the BDD previously constructed.In functionEvalDU(B,M)of Fig. 2, M is a product of some Boolean variables representing the edges in the minpath, B is the BDD whose probability needs to be computed under the constraintM=1. The function traverses down B to computeP(B|M=1=1). Assume b is the top variable of B. If the edge denoted by b is not in the minpath denoted by M, the function computesP(B|M=1=1)as follows:B.value=b.r∗EvalDU(bdd_then(B),M)+(1-b.r)∗EvalDU(bdd_else(B),M),whereb.ris the edge’s reliability,bdd_then(B)andbdd_else(B)return the sub-BDDs pointed to by b’s 1-edge and 0-edge, respectively.If the edge denoted by b is in the minpath denoted by M, the function goes down b’s 1-edge with probability 1 and ignores the sub-BDD pointed to by b’s 0-edge.P(B|M=1=1)is computed asB.value=EvalDU(bdd_then(B),M).Using the method above to computeΔu, the construction ofB^is avoided, and only part of BDD B needs to be visited.The unreliability upper bound is computed in two main parts. In the first part new minpaths are searched using the heuristics at first and the exhaustive algorithm afterwards. The found minpath is used to build/update the BDD and the bound if it allows us to improve the upper bound at least byα%with respect to the previous bound, otherwise the minpath is inserted in the heap. Thus new minpaths are generated only when needed. When all the minpaths are found, the first minpath is taken from the heap and evaluated; if it does not allow us to improve the bound by least byα%, this constraint is relaxed (by halvingα). The procedure is repeated until the computation time set by the user is exhausted or all the minpaths are evaluated.Fig. 3shows the pseudo-code for computing the unreliability upper bound. In functionUpperBound(G),Gcontains the reliability graph information, while the functionFindNewPath(G)returns the next new minpath,ExtractMax(heap)removes the minpath with maximumΔufrom the heap and returns it,Insert(heap,M)adds minpath M into the heap,bdd_or(B,M)computes the BDD forB+M.paths_requiredis the total number of minpaths that need to be generated by the minpath search algorithms,runtime_requiredis the maximum number of seconds the UpperBound function will run. If all minpaths that satisfy the inequalityΔu=u-uˆ⩾α·uhave been selected and the function has not yet reached the maximum execution time, we reduceαby half and reselect all of the newly qualified minpaths from the heap.Similar to the heuristic minpath search described above, the purpose of the heuristic mincut search algorithm is to find mincuts that can greatly increase the unreliability lower bound.Given two mincutsC1andC2,(7)P(C1+C2=1)=P(C1=1)+P(C2=1)-P(C1·C2=1).P(Ci=1)(i=1,2)is the product of unreliabilities of edges in mincut i, whileP(C1·C2=1)is the product of unreliabilities of edges in the union of the two mincuts. In most cases, the unreliability for each edge is quite small, as a resultP(C1·C2=1)is orders of magnitude smaller thanP(Ci=1)(i=1,2)so it can be neglected in Eq. (7). Therefore,P(C1+C2=1)can be approximated byP(C1=1)+P(C2=1).From Eq. (2), the unreliability lower boundLican be written as:(8)Li=P(C1+C2+⋯+Ci=1)≈P(C1=1)+P(C2=1)+⋯+P(Ci=1).This approximation can be applied as long asP(Cx·Cy=1)≪min{P(Cx=1),P(Cy=1)}(1⩽x<y⩽i), and this condition holds if each edge’s unreliability is small. From Eq. (8), it is desirable to find the most unreliable mincuts to increase the lower bound as much as possible.For a mincutC=e‾x1·e‾x2·⋯·e‾xk, we haveP(C=1)=(1-rx1)·(1-rx2)·⋯·(1-rxk)or-log[P(C=1)]=[-log(1-rx1)]+[-log(1-rx2)]+⋯+[-log(1-rxk)].To find the mincut C that maximizesP(C=1)is the same as to find a C that minimizes-log[P(C=1)]. If we assign capacity-log(1-rj)⩾0to the edgej(1⩽j⩽i), then finding the mincut C with the largest unreliability is to find C with minimum sum of capacities, which we compute using the Ford-Fulkerson’s flow augmenting path algorithm (Cormen et al., 2009).To guarantee convergence, Breadth First Search is used to find augmenting paths (Edmonds & Karp, 1972). The difference between the BFS used previously and this one is that the latter looks for only one shortest path, therefore a node is visited at most once. The Ford-Fulkerson’s algorithm runs inO(|V||E|2)time if BFS is used for augmenting path search and the storage requirement isO(|V|2).When a mincut C is found, the flow of each edge in the graph is set to 0, and the Ford-Fulkerson’s algorithm is applied again to find the next most unreliable mincut. To avoid returning to the same mincut C, the capacity of the most reliable edge in C, say j, is changed to infinity, by makingrj=1, and Ford-Fulkerson’s algorithm is run with updated capacities. This procedure stops when there is no mincut with a finite sum of capacities left.When no more mincuts can be found by the above described heuristic mincut search, an exhaustive mincut search is utilized to further increase the unreliability lower bound. Some algorithms have been proposed for the mincut enumeration of directed or undirected graphs (Arunkumar & Lee, 1979; Lin, Kuo, & Yeh, 2003; Martelli, 1976; Shier & Whited, 1985; Tsukiyama, Shirakawa, Ozaki, & Ariyoshi, 1980; Yan, Taha, & Landers, 1994). In this paper, we adopt the simple and efficient algorithm in (Lin et al., 2003) for exhaustive mincut search that guarantees that the generated cutsets are minimal. The pseudo-code for the algorithm is shown in Fig. 4.The underlying idea is, starting from the source node(s), to merge all other nodes in the set S and thus obtaining the mincuts from the sub-graphs. In Fig. 4S represents the source set of vertices and can be thought of as being a single node that represents the originals;Gstores the current graph and can thus be the original graph or one reduced by the merging of the node n in S. A node is isolated if it can only reach the target node t by going through one or more nodes in S (i.e., it does not have a direct connection with t). All the nodes that prove to be isolated after the absorption of node n in S are directly absorbed by S. The algorithm is recursively called on all the nodesn_iadjacent to S and belonging to G. At each step of the algorithm, the heap stores the mincut found on the reduced graph (i.e., the set of edges connecting vertices in S to vertices outside S) if not already included. The run time to find one mincut using such exhaustive mincut search algorithm isO(|V|∗|E|). All mincuts that have been found need to be stored.Given the mincuts that have been found, we select some of them for inclusion in the BDD for unreliability lower bound computation. Let D be the current BDD corresponding to the union of the mincuts that have already been selected for inclusion and letl=P(D=1). For a new mincut C, letD^be the BDD that would result from inclusion of C into D (denoted byD+C) and letlˆ=P(D^=1). ThenΔl=lˆ-lis the increment of the current unreliability lower bound by adding C. C is selected for inclusion if(9)Δl⩾β·l,whereβis a constant between 0 and 1. The selection procedure is similar to that described above for minpath selection in Section 3.1.3. One difference is that for a mincut C,Δlcan be approximated byP(C=1), andΔl⩽P(C=1). Therefore we can useP(C=1)to first filter out most of the mincuts that do not satisfy the inequalityΔl⩾β·l. For example, ifP(C=1)<β·l, then surelyΔl<β·l. IfP(C=1)⩾β·l, the following equation is used to compute the exact value ofΔl:(10)Δl=P(D^=1)-P(D=1)=P(D^·C=1)=P(C=1)-P(D·C=1)=P(C=1)·[1-P(D|C=1=1)].GivenC=ex1·ex2·⋯·exk,P(D|C=1=1)is the probability thatD=1with the constraintex1=ex2=⋯=exk=0. A technique similar to the one in Fig. 2 can be applied to evaluate this probability: when traversing down D, sub-BDDs connected by the 1-edges ofex1,ex2,…,exkwill be ignored. The pseudo-code for the evaluation is shown in Fig. 5. For sake of completeness Fig. 6shows the pseudo-code for unreliability lower bound computation. The procedure, including the update of the selection factor(β)and the store of previously not selected mincuts, is similar to the unreliability upper bound computation described in detail in Section 3.1.3 and is not reported here for the sake of brevity.The novelty of our approach can be summarized in the efficient computation of lower and upper bounds to evaluate the network unreliability, first using fast heuristics and then exhaustive minpaths and mincuts searches over an efficient BDD representation of the reliability graph. Moreover our approach gives to the user the possibility to choose the maximum execution time in order to obtain the best possible precision for the reliability bounds.To provide example numerical results, the unreliability upper/lower bounds computation approach is applied on an example reliability graph. The graph shown in Fig. 7is an example of a typical electrical network of an airplane. The graph contains six sections, labeled A, B, C, D, E and F besides the source and the target vertices. There are 82 nodes and 171 edges in the graph. Each edge may fail with a constant failure rate, and the system represented by the reliability graph is up if there is at least one path (with all edges up) from the source to the target. Table 1shows the number of minpaths from various nodes to the target. As seen from the table, there are approximately4×1012minpaths from the source to the target; it is not possible to enumerate and list all of them, let alone construct the BDD to calculate the exact system reliability.The unreliability bounds computation approach was applied to the example reliability graph of Fig. 7. In this experiment, the failure rate of each edge isλ=10-7hour-1, the default system exposure time ist=105hours (so the reliability of each edge isr=e-λt=e-10-7·105≈0.99). For the parameter settings of the bounds computation algorithm, the maximum number of minpaths/mincuts to be found (paths_requiredin Fig. 3 andcuts_requiredin Fig. 6) is set at 10,000, the default execution time (runtime_requiredin Fig. 3 and in Fig. 6) for the bounds computation algorithm is set at 120 seconds.Fig. 8shows the difference between unreliability upper and lower bounds versus the number of selected minpaths/mincuts. In this figure, the execution time for both the upper and the lower bound computation algorithms is 900 seconds. There are 33 minpaths selected for the unreliability upper bound, and 113 mincuts selected for the lower bound. The reason why more mincuts than minpaths are selected is that the time to find a qualified mincut C is much smaller than the time to find a qualified minpath M, becauseΔlinΔl⩾β·lcan be first approximated byP(C=1)before its exact value is computed. Therefore more mincuts will be scanned and selected when the execution time is the same for both the upper and the lower bound computations.In Fig. 8(a), the x-axis is i, the number of minpaths selected; the y-axis islog10(Ui-Lj), wherej=i∗113/33. The number of points in the curve is 33 which is the number of upper bound values. The factor 113/33 is to select 33 out of the 113 lower bound values to correspond to the 33 upper bound values, and we wish these 33 lower bound values to be evenly distributed. The absolute value of y-axis is the number of zeros in the difference between unreliability upper and lower bounds. As seen from the figure, the gap between upper and lower bounds decreases as more minpaths and mincuts are selected. Fig. 8(b) shows the relative difference between the upper bound and lower bounds. Again the x-axis is the number of minpaths selected, the y-axis is(Ui-Lj)/Uiwhere i is the number of selected minpaths,j=i∗113/33is the number of selected mincuts. As the number of selected minpaths/mincuts increases, the relative difference decreases. When 33 minpaths and 113 mincuts are selected(i=33), the relative difference is around 0.005, which means both bounds are close to the exact system unreliability.Table 2shows the unreliability upper/lower bounds versus different execution times for the bounds computation. The first row lists the maximum runtime in seconds for both the upper and lower bound algorithms, the second row lists the computed unreliability upper bound, the third row gives the computed unreliability lower bound, the fourth row gives the relative difference between the bounds and the last row provides the relative gap among the bounds expressed as a percentage. As shown in Table 2, the bounds become closer as more execution time is allowed since then each time more minpaths and mincuts are considered. As can be noted from the last row, the gap between the bounds undergoes a remarkable percentage reduction in the first two minutes, after that the benefit of a longer execution times becomes smaller for the example reliability graph. Comparing to 33 minpaths selected for 900 seconds execution time case, there are 28 minpaths selected for 20 seconds execution time case and 29 minpaths selected for the 120 seconds case. The mincuts selected for these three cases are all 113. The number of mincuts selected not changing with the runtime is not because we did not find more mincuts but because the mincuts we found did not qualify for inclusion (i.e., did not satisfy inequality (9) in the paper).Two parameters affect the edge reliability: the exposure time(t)and the failure rate(λ).Fig. 9shows the change of unreliability upper/lower bounds with the system exposure time(t). In this figure, both upper and lower bound computation algorithms were run for 120 seconds for each exposure time. The x-axis is the system exposure time varied from 10,000 hours to 100,000 hours, whereas the y-axis Fig. 9(a) is the unreliability bound and there are two curves corresponding to upper bound U and lower bound L, respectively. In Fig. 9(b) the y-axis is the relative difference of the two boundsU-LU. As seen from the figure, both unreliability bounds increase, almost in the same way, with the exposure time because the edge reliability decreases. Fig. 9(b) shows that the relative difference between the two bounds for each exposure time is in[0.02,0.1], a rather small interval.Table 3shows that the unreliability upper/lower bounds significantly change while varying the failure rate(λ), where the algorithm is executed for 120 seconds. The first row lists theλvalue assigned to each edge of the network, the other rows have the same meaning as in the previous table. As shown in the last row the relative gap is affected by the edge reliability. Fig. 10shows that the percentage gap varies greatly by changingλby several orders of magnitude.At a fixed execution time, the relative gap expressed as a function of the edge reliability (given either as exposure time, Fig. 9(b), or as failure rate, Fig. 10) does not necessarily have a monotonic behavior. This is due to the fact that, for a given “sectionable” network (like the one in Fig. 7), the execution time needed to obtain a certain accuracy is reached using intermediate edge reliability values. Indeed, the Ford-Fulkersons algorithm, used in the heuristic minpath search, is slower for very low or very high reliability since it slowly reaches the destination in those cases.To further evaluate our approach, we considered two other examples commonly found in reliability literature (Cancela & El Khadiri, 2003; Cancela et al., 2010, Cancela, Robledo, Rubino, & Sartor, 2012, 2013; Elperin et al., 1991; Fishman, 1986; Hui et al., 2003), i.e., the dodecahedron and the 1973 Arpanet networks.In Fig. 11the dodecahedron network is shown where the highlighted nodes correspond to the source and the target. Though for this network the exact solution can be obtained in reasonable time, it is complex enough to be used as a comparison for bounding approaches.Table 4shows the bounds versus different execution times (the columns, ranging from 10 to 60 seconds) and different edge reliability (table blocks, ranging from0.01to0.5). Since for this network it is possible to obtain an exact solution as well (shown in the first column of the max err row), in addition to the bounds evaluation as in the previous tables the maximum error obtained with the bounds approach is also shown. The maximum error is computed as the maximum difference between the exact solution and the bounds, i.e.,max{U-ExactSolution,ExactSolution-L}.Fig. 12(left hand side) shows how the edge reliability affects the error in the bounds solution. The error is higher, the higher is the network unreliability, moreover as the execution time increases the error decreases faster but with a reduced slope with a higher network unreliability. In Fig. 12 (right hand side) the percentual bounds gap versus the link unreliability is shown. The dependence among the bounds quality and edge reliability is to be noted. Also note that with a more unreliable network, the error is less than 3% with only 60 seconds of execution time.The exact solution for the reliability of the Arpanet 1973 network can be easily computed in few seconds, thus this network can no longer be considered a good benchmark for the evaluation of bounding algorithms. To further evaluate the performance of our approach we have built a network composed of three Arpanet replicas in parallel (Fig. 13).The same kind of analysis as for the dodecahedron network was carried out for the Arpanet network. The results are shown in Table 5. Note that the dependence among the bounds quality and edge reliability cannot be expressed by a monotonic function. The errors are higher when the edge reliability has an intermediate value. In all the cases the error refers to number of decimals with only 60 seconds of execution time.

@&#CONCLUSIONS@&#
