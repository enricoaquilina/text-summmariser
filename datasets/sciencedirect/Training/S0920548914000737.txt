@&#MAIN-TITLE@&#
Rapid lossless compression of short text messages

@&#HIGHLIGHTS@&#
We introduce b64pack, an efficient method for compression of short text messages.b64pack is based on standards which facilitate easy deployment and interoperability.We compare b64pack with common UNIX compression programs, compress, gzip and bzip2.b64pack achieves better compression of short messages than compress, gzip and bzip2.b64pack is faster than compress, gzip and bzip2 by orders of magnitudes.

@&#KEYPHRASES@&#
Data compression,Lossless compression,Short text messages,SMS,

@&#ABSTRACT@&#
In this paper we present a new algorithm called b64pack11b64 stands for Base64.for compression of very short text messages. The algorithm executes in two phases: in the first phase, it converts the input text consisting of letters, numbers, spaces and punctuation marks commonly used in English writings to a format which can be compressed in the second phase. The second phase consists of a transformation which reduces the size of the message by a fixed fraction of its original size. We experimentally measured both the compression speed and the compression ratio of b64pack on a large number of short messages and compared them with compress, gzip and bzip2, three most common UNIX compression programs. We show that in case of short text messages up to a certain size b64pack achieves better compression than any of the three programs. With respect to speed, b64pack beats all three algorithms by orders of magnitudes. This rapid compression is one of the key strengths of b64pack.

@&#INTRODUCTION@&#
Until recent years, most algorithms for text compression were primarily concerned with compressing large inputs. Fast adoption of SMS messaging and Internet services based on short messages (e.g. Twitter, chat) has caused an increased interest in compression of very short texts. Interestingly, though, publications concerning compression of short messages are relatively scarce.Why is compression of short messages necessary? Given the high volume of SMS, Twitter and instant messaging traffic, compression of short text messages can bring tremendous savings in network bandwidth. Could not multiple messages be first buffered to form a larger chunk of data and then compressed with a regular compression algorithm to achieve better results? The answer is: For realtime communication, such as instant messaging or chat, buffering of multiple messages is not possible, since each message has to be sent independently and immediately after it is typed. Therefore we need a mechanism to compress each of these short messages individually.In case of SMS messages, a system called concatenated SMS has been developed to extend the inherent limit of an SMS message. It works by breaking a long message into smaller parts and sending each of them as a single SMS message. At the receiving end the short messages are combined back to one long message. One downside of concatenated SMS is that, if the length of an SMS message exceeds 140bytes, the user is usually charged for two SMS messages, even if the excess is only a few characters long.In this paper we introduce a new algorithm called b64pack for efficient compression of very short text messages. In contrast with other major works in short text compression, such as [1–3], which focus on certain limitations of prediction by partial matching (PPM) compression and provide ways to improve it, we follow a different approach.To facilitate an easy deployment and interoperability across billions of computers, mobile and embedded devices, we propose a compression scheme which relies on a straightforward use of standard open source software libraries available on all operating systems. The use of b64pack does not require any proprietary software components or algorithms. We compare b64pack with other standard compression algorithms implemented by programs such as compress, gzip and bzip2 to demonstrate how applications and users could directly benefit from using b64pack for compression of short messages. Our research objective was to prove that b64pack is able to overcome certain major drawbacks of existing SMS services. We did not specifically set out or purport to evaluate against other data compression schemes, and have used them merely as a reference for comparison.The key features of b64pack are:•extremely low memory requirements—a message compressed with b64pack requires no header/metadata, while in the base case lookup tables used by b64pack together occupy less than 256bytes of memory;very efficient compression and decompression—all operations performed by b64pack can be implemented very efficiently using few CPU instructions, allowing b64pack to be used for realtime message compression on low-power devices with energy consumption limitations;precise estimation of the size of the compressed message during the compression process—this feature allows users to know the size of the compressed message while they are composing it;reliance on standard software libraries to facilitate rapid deployment and interoperability on all types of computers, mobile and embedded devices.Other than the benefits mentioned above, b64pack is a fast process-oriented algorithmic scheme which we believe should be considered by developers, users and standards setting bodies as a viable compression technique.The plan for the remainder of the paper is as follows: in Section 2 we describe b64pack algorithm in detail. In Section 3, we provide experimental data of performance and compare it with those of three well known algorithms implemented by compress, gzip and bzip2. Sections 4 and 5 deal with discussion, future work and conclusions.As illustrated in Fig. 1, the b64pack algorithm consists of two phases. The primary purpose of the first phase is to convert the input text to a format which can be processed in the second phase. The input can optionally be precompressed in this first phase to achieve higher gross space savings. We assume that the input is a short text message, consisting of letters, numbers, spaces and punctuation marks commonly used in English writings. Even though there are no inherent limitations imposed on the nature of the input, we demonstrate the workings of b64pack by following the compression of an SMS message. Therefore, we assume that the input text contains only those punctuation marks, which have a definition within the GSM 03.38 character set [4].The output generated by the first phase is processed in the second phase, which consists of a single transformation that reduces the size of the message by a fixed percentage. This step is thus fully deterministic and always results in the same, constant compression ratio.An important characteristic of the whole b64pack compression procedure is the absence of any metadata. This means that the compressed message requires no header, which is highly important when working with SMS messages or similar kinds of short texts which are inherently limited to a small number of characters.The compression, which happens in the second phase of b64pack algorithm, requires the input text to be transformed to a specific format. To achieve this, the input is transcoded using the following simple rules:Rule 1Letters and numbers are left unchanged.Each space character is replaced with a forward slash ‘/’ character.Each punctuation mark is replaced with a sequence of two characters: the plus ‘+’ character followed by a lowercase letter. The correspondence between punctuation marks and their substitute lowercase letters is established throughTable 1.Rule 3 applies to most common punctuation marks, for which there is a single-character code in the GSM 03.38 character set. For less frequently used punctuation marks, GSM 03.38 provides another representation consisting of two characters per punctuation mark (first of these two characters is the escape character 0x1b). For these we use the following rule in place of Rule 3:Each punctuation mark from the set of characters shown in the first row ofTable 2is replaced with a sequence of three characters: two plus ‘+’ characters followed by a corresponding letter from the second row ofTable 2.To show how the transcoding procedure alters the input, we use the example message given in Fig. 2. The length of this message is exactly 160 characters, which is the limit imposed on an SMS message with 7-bit encoding. For clarity, spaces are represented by white boxes.Following the aforementioned rules for transcoding, we transform this message into the form shown in Fig. 3.The use of the ‘+’ escape character for encoding punctuation marks has led to an increase in message length from 160 to 173 characters. To reduce this loss, we make use of a simple typographic rule, which states that it is often appropriate to insert a space after punctuation in order to increase the overall readability of the text. This typographic convention has been used multiple times in our example message (Fig. 2). Based on this observation we can now introduce another simple encoding rule:If a punctuation mark is followed by a space, this punctuation mark is encoded according to Rule 3 or Rule 4, except that instead of a lowercase letter its uppercase equivalent is used. In this case, the encoded space character (i.e., the forward slash character) is left out.For example, according to Rule 3, a question mark followed by a space would be encoded as ‘+w/’. Rule 5 allows both these characters to be merged into a two-byte sequence ‘+W’, thus preventing any loss caused by the use of the ‘+’ escape character.Following the same procedure, the whole message can be transformed into the form shown in Fig. 4. The length of this message is 167 characters.A closer look at the transcoded message in Fig. 4 reveals an important clue. Namely, all the characters which appear in this message are part of the Base64 character set.Base64 encoding maps an arbitrary sequence of 24 bits into a sequence of four printable characters. In a given sequence of 24 bits (i.e., three octets) of dataa1a2a3a4a5a6a7a8b1b2b3b4b5b6b7b8c1c2c3c4c5c6c7c8the individual bits are grouped to form four bit sextetsa1a2a3a4a5a6a7a8b1b2b3b4b5b6b7b8c1c2c3c4c5c6c7c8Each sextet is then replaced with a printable character based on the mapping established through Table 3.Base64 decoding is the reverse operation, which uses Table 3 to convert a block of four characters into an equivalent block of three octets.Base64 encoding was first introduced in Internet Engineering Task Force (IETF) de facto standard RFC989 [5] to allow binary data to be represented in printable form. In the usual case, Base64 is used to convert three octets of data into four 8-bit Extended ASCII characters. This means that each of the characters in even columns of Table 3 is represented with 8bits.There is, however, no specific requirement that these characters be coded using 8bits. We can make use of this fact to compress the text of an SMS message using Base64 decoding, by treating the text in Fig. 4 as Base64-encoded data.If we are dealing with an SMS message encoded using the GSM 03.38 character set, each character in Fig. 4 is represented using 7bits. A group of four characters thus occupies 28bits.Applying Base64 decoding to a four-character block reduces its size to 24bits. The compression ratio is defined as the fraction where the numerator is the size of the compressed message and the denominator is the size of the original message with 7bits/character. Thus we have(1)ratio7bit=2428=67≈85.7%Given the fact that the maximum size of an SMS message is 160 characters, based on (1) we can now calculate the maximum length Ltmaxof a transcoded message (i.e., SMS message after processing in phase 1 of b64pack) which would not exceed 160 characters after Base64 decoding:(2)Ltmax=160×76≈186.67≈186charactersThe maximum length of 186 characters, calculated in (2), applies to an already transcoded SMS message. As we know from Section 2.1, transcoding of punctuation marks may increase the size of the original message, so that the user would have to estimate in advance how much to type in order to stay within the limits of a single SMS message after compression.Although it is not possible to know in advance how much space in a message would be occupied by punctuation, a simple statistical analysis of a standard corpus of English writings [6] shows that punctuation takes around 2.67% of the corpus text. We could thus assume that nearly 3% of the length of user input are punctuation marks.Assuming that every punctuation mark extends the original message by one character, transcoding would extend the user message by 3%. If we denote the length of the original user message by Lu, its length after transcoding would be(3)Lt=Lu×1.03To calculate the maximum length Lumaxof the user message, which after compression with b64pack should fit into a single SMS message, we substitute (2) into (3):(4)Lumax=Ltmax1.03=1861.03≈180.58≈180charactersThis means that in most cases the sender of an SMS message should be able to type 180 characters and stay within the 140-octet limit of a single SMS message after b64pack compression has been performed.The calculation of compression ratio given in (1) is valid for SMS messages using 7-bit character encoding. In case b64pack compression is applied to text messages encoded in 8-bit Extended ASCII (e.g. instant messages, IRC messages, Twitter tweets, RSS feeds), the corresponding ratio is(5)ratio8bit=2432=34=75%Using Base64 decoding in the second phase of b64pack allows the compression to happen while the user is typing the message. An application for message composition can begin transcoding the message as soon as the user begins typing. Each time the transcoding function generates four characters, these four characters can immediately be processed by the Base64 decoder to produce the corresponding sequence of three octets of compressed data.For example, if the user is composing the message shown in Fig. 2, as soon as the user types ‘Hi m’, b64pack transcodes this to ‘Hi/m’ and then proceeds with Base64 decoding which converts these four characters to the three-octet sequence 0x1e, 0x2f, 0xe6.In case of SMS, this allows an SMS composition application to calculate the number of bytes occupied by the compressed message and provide the user with an estimated number of characters left for input before the 140-octet limit for a single SMS message is reached.The two phases of b64pack compression, described in Sections 2.1 and 2.2, guarantee a fixed, deterministic compression ratio. Introducing a simple dictionary, shared between the sender and the receiver, can lead to further space savings.To save additional space, every word in the input text, for which there is an entry in the dictionary, is replaced with the corresponding key. More generally, dictionary substitution can be applied to an arbitrary sequence of letters.For b64pack dictionary substitution, a key is formed by concatenating the plus character ‘+’ and a sequence of numbers which uniquely corresponds to the replaced sequence of letters. If a letter sequence is found in the dictionary, it is replaced with the corresponding key. This happens immediately after the transcoding phase, before Base64-decoding takes place (Fig. 5). Obviously, to achieve space savings, the total length of the key must be at least one character less than the length of the replaced sequence.It is important to notice that this method of forming the key does not allow substitution in case of letter sequences immediately followed by numbers. If, for instance, the key for the word ‘high’ is ‘+71’, then the sequences ‘highfive’, ‘high/five’ and ‘high/5’ can safely be replaced with ‘+71five’, ‘+71/five’ and ‘+71/5’ respectively. On the other hand, using the same key in case of the sequence ‘high5’ would produce ‘+715’, which is ambiguous.To see dictionary substitution in action, let us assume the words (letter sequences) are, know, last, one, that, the, want and you exist in the dictionary. The dictionary maps each of these letter sequences to a unique sequence of numbers, as shown in Table 4.Now we can revisit the transcoding phase and apply dictionary substitution to the transcoded message in Fig. 4. Fig. 6shows the result of this transformation.In this example, dictionary substitution reduced the length of the transcoded message from 167 to 157 characters. This fully compensates for the loss introduced by transcoding and saves three additional characters (recall that the original message size was 160 characters), which is a significant gain given the tiny size of the dictionary.A dictionary is built from a list of most frequent words appearing in a large set of messages. The building of a dictionary can be a one-time process, or can be done periodically to adapt to possible changes in word frequencies. Which of these two dictionary-building approaches is used, largely depends on the type of application for which it is used.If b64pack compression is to be used on a mobile phone for exchange of SMS messages, the simplest approach consists of building the dictionary once and bundling it with the SMS composition application. This way the dictionary would be installed along with this application, which guarantees that all its users share the same dictionary. In a massive deployment of such an application, it is impractical to allow dictionary to be updated, since this may introduce various inconsistencies when multiple users have different versions of the dictionary.More flexibility with regard to updating dictionary contents can be achieved in cases where the dictionary is shared between a small number of devices, especially if these devices operate under common administration. In private communication, it may be feasible to have a dictionary shared between only two parties, if these two parties exchange a relatively high number of messages. In a company, the dictionary may be updated as a part of a policy which affects all users.The situation is even more convenient with messaging applications which work over IP networks. These applications can easily have multiple versions of the dictionary and can perform regular dictionary updates. In case of server-based instant messaging or chat applications, such as Jabber or IRC, the server could easily push new versions of the dictionary to all logged-in clients.To measure the two most important aspects of compression of short text messages with b64pack, namely, compression speed and compression ratio, we ran multiple experiments under the GNU/Linux operating system running on a general-purpose PC with 1 GB of RAM and an Intel Pentium 4 HT CPU running at 3.0GHz.In all the experiments, b64pack was compared with compress, gzip and bzip2, three most common UNIX compression programs. Compress is based on a variant of the LZW compression algorithm, gzip uses the Deflate algorithm, while bzip2 relies on Burrows–Wheeler compression and Huffman coding.We first considered running our experiments on parts of the Canterbury Corpus [7], which is the most commonly used reference corpus for evaluating and comparing compression algorithms. Since, however, we are dealing with compression of short text messages, whose structure and typography greatly differ from those of literary works and long texts, such as those available in the Canterbury Corpus, we had to adopt another set of texts, which resemble true structure of messages we wish to compress.Fortunately, researchers from the Web Information Retrieval/Natural Language Processing Group of the National University of Singapore have compiled a corpus of a huge number of real SMS messages (NUS SMS Corpus) contributed by different people [8]. In all our experiments, we used 50,619 messages from the corpus (including duplicates), which contain exclusively Latin characters.The objective of our first set of experiments was to compare b64pack with the other three compression methods with regard to compression speed. Since we were dealing with very small amounts of data (i.e., short messages), it was difficult to make speed comparisons by measuring times required for compressing each individual message. Instead, we let each algorithm compress the entire set of 50,619 messages and measured the total compression time for each of the four algorithms, then divided these times by the total number of messages to obtain the average compression time for a single message.The results of these measurements are summarized in Fig. 7. They clearly demonstrate superiority of b64pack, which is almost twice as fast as compress, about 5.5 times faster than gzip and about 9 times faster than bzip2.When it comes to compression of short text messages, the obvious advantage of b64pack over compress, gzip and bzip2 lies in the fact that b64pack does not require a header. Otherwise, all the other three compression methods are far superior to what b64pack is able to achieve by the simple transformations it performs.Since we are primarily interested in compression of SMS messages, we have concentrated our experiments around those messages, whose length is greater than 160 characters. There are a total of 1984 such messages in the NUS SMS Corpus. Since the primary goal of compression of these SMS messages is to make them fit into the 160-character limit, in our experiments we compressed each of the messages with each of the four algorithms and counted the successful compressions resulting in the compressed message being less than or equal to 160 characters in length. Even though b64pack can only successfully compress messages with lengths up to 213 characters160×43≈213.33, we haven't imposed any limits on the maximum message length in our experiments, whose results are shown in Table 5.The total number of successful compressions is 1006. It is obvious from Table 5 that gzip is the only true competitor to b64pack when it comes to compressing short messages. Nonetheless, our results show that b64pack is still significantly superior to gzip in the total number of successfully compressed messages. In most cases b64pack achieves minimal compression ratio and is the only successful algorithm out of all four in about 21%of all successful compressions, with gzip being the only successful algorithm in around 4% of all successful compressions.Since the compression ratio of b64pack depends on the structure of the message (e.g. more punctuation means worse compression), it is interesting to know how successful b64pack is in compressing real SMS messages of varying lengths. Fig. 8shows the length distribution of the 947 messages successfully compressed by b64pack.As Fig. 8 shows, b64pack is good at compressing real SMS messages of all lengths from 161 to 213 characters, being slightly more successful in the case of shorter messages with lengths ranging up to about 180 characters.A further experiment shows how the use of a simple and relatively small dictionary affects the compression ratio of all four considered algorithms, in particular b64pack. For this experiment we used a dictionary containing a total of 1110 frequent English words: 10 three-letter words, 100 four-letter words and 1000 five-letter words. The runtime storage requirements for this small dictionary can be accommodated with 6kilobytes of memory. As a reference for building the dictionary we used a list of 10,000 most frequent English words obtained from [9].In case of compress, gzip and bzip2, we first performed dictionary substitution on the original SMS messages, then let each algorithm perform compression and counted successful compressions. In case of b64pack, dictionary substitution was performed after transcoding, as described in Section 2.4.Our results are summarized in Table 6. With dictionary precompression the total number of successful compressions grew from 1006 to 1179. This does not look like a significant gain, yet for the individual algorithms, dictionary precompression has certainly brought some benefits.Even though compress is the winner in the absolute sense in terms of additionally performed successful compressions, b64pack and gzip still retained more significance. We must, however, notice that b64pack gained 20% in additional successful compressions, whereas the relative gain of gzip is 10%. Other evaluation criteria in Table 6 show a loss of gzip over b64pack.Finally, we wanted to see how dictionary precompression affected the maximum message length and the number of messages of different lengths successfully compressed by b64pack. Fig. 9shows the results. On the graph, we have also included the results we got without dictionary precompression as given in Fig. 8.As we can see, in our experiments dictionary precompression helped increase the potential maximum message length to around 230, which corresponds to a gain of approximately 10%.In the average case, message transcoding and Base64-decoding produce a nearly fixed ratio for all message lengths. Therefore, we propose that future research addresses dictionary precompression. We have seen how a relatively small dictionary with 1110 entries, based on a generic list of words, helped increase maximum length of an SMS message by about 10%. Richer dictionaries with longer words would lead to further improvements in the overall compression ratio of b64pack. With access to a large set of real messages, such as those available in the NUS SMS Corpus, the dictionary could be optimized to include most frequent words from true conversations. This should give maximal space savings in the dictionary substitution phase.Besides enhancing dictionary substitution, improvements in compression speed can easily be achieved by parallelizing the two phases of b64pack. The fact that the Base64 decoder operates on groups of four characters allows it to begin decoding as soon as the transcoder generates a sequence of four characters. We saw an example of this in Section 2.3. If transcoding and Base64-decoding functions are executed in parallel, we can expect to see measurable speed improvements on hardware which allows simultaneous execution of two or more threads.The b64pack algorithm is very similar to the class of compression techniques known as transformation algorithms that perform a reversible precompression transformation which increases its compressibility to other compression techniques. The b64pack algorithm is distinguished from these algorithms by the facts that the transform itself provides a fixed compression ratio and there is no need for metadata to be transmitted along with the compressed file.The well known Burrows–Wheeler Transform [10,11] is a reversible sorting algorithm that creates long runs of identical characters in the output text. This is followed by a Move To Front algorithm and by Huffman or arithmetic coding. This yields compression that outperforms most of the classic algorithms. A much simpler recent algorithm proposed by Mukherjee and Franceschini called Star Compression performs a transformation using a dictionary and yields comparable performance with respect to compression [12]. Its implementation is available on-line [13]. Several modifications have been proposed to improve the performance (see [14]). We plan to explore the possibility of applying the Star Compression ideas for SMS messages.Finally, one additional strength of b64pack lies in the fact that it relies on standards and de facto standards, such as SMS code tables and Base64 encoding. Base64 decoding, which forms the basis of the second phase of b64pack compression, is well supported on all operating systems and is available in all major programming languages in form of standard library functions and classes. In the interest of increased interoperability, future research should attempt to find new solutions to advance the process of large-scale deployment of new compression algorithms. To avoid potential legal issues and reduce costs in massive deployments, such as those among mobile phone users worldwide, these advancements should follow the track of standard-compliance and avoid the use of proprietary algorithms.

@&#CONCLUSIONS@&#
