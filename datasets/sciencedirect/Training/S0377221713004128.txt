@&#MAIN-TITLE@&#
An efficient evolutionary algorithm for the ring star problem

@&#HIGHLIGHTS@&#
A fast and efficient evolutionary algorithm for the RSP.A formulation of the ring star problem as a bilevel program with two followers.In 92.74% of benchmark problems, the best known result has been matched.For one problem, a solution better than the best known solution has been obtained.

@&#KEYPHRASES@&#
Ring star problem,Median cycle problem,Evolutionary algorithm,Bilevel programming,

@&#ABSTRACT@&#
This paper addresses the ring star problem (RSP). The goal is to locate a cycle through a subset of nodes of a network aiming to minimize the sum of the cost of installing facilities on the nodes on the cycle, the cost of connecting them and the cost of assigning the nodes not on the cycle to their closest node on the cycle. A fast and efficient evolutionary algorithm is developed which is based on a new formulation of the RSP as a bilevel programming problem with one leader and two independent followers. The leader decides which nodes to include in the ring, one follower decides about the connections of the cycle and the other follower decides about the assignment of the nodes not on the cycle. The bilevel approach leads to a new form of chromosome encoding in which genes are associated to values of the upper level variables. The quality of each chromosome is evaluated by its fitness, by means of the objective function of the RSP. Hence, in order to compute the value of the lower level variables, two optimization problems are solved for each chromosome. The computational results show the efficiency of the algorithm in terms of the quality of the solutions yielded and the computing time. A study to select the best configuration of the algorithm is presented. The algorithm is tested on a set of benchmark problems providing very accurate solutions within short computing times. Moreover, for one of the problems a new best solution is found.

@&#INTRODUCTION@&#
The Ring Star Problem (RSP) arises in telecommunications network design problems where a subset of nodes is selected for installing concentrators. The selected nodes are interconnected by a ring network (this is known as ring topology), whereas the remaining nodes are linked to their closest concentrator (this is known as star topology). The RSP can also model location–allocation problems occurring in logistics where some retailer locations are used as small depots served from a central depot in a single-vehicle route. The remaining retailers are directly served from their nearest small depot.Let G=(V,E∪A) be a mixed graph, where V={0,1,…,n} is the node set, E={[i,j]:i, j∈V} is the edge set and A={(i,j):i, j∈V} is the arc set. Node 0 is a distinguished node which is referred to as the depot or the root. Edges in E refer to undirected links which are used to form the ring structure and arcs in A refer to directed links used in the star structure. We assume that there is a nonnegative facility cost piassociated with each node i. This may represent, for instance, the cost of placing a facility at node i. There is also a nonnegative ring cost cijassociated with each edge [i,j], representing the cost of connecting nodes i and j, and a nonnegative assignment cost dijassociated with each arc (i,j), referring to the cost of node i being connected to node j. The RSP consists of selecting a subset of nodes V′⊆V, including the depot, where facilities are installed and interconnected by a cycle structure. The remaining nodes are each connected to one of the facilities (see Fig. 1). The goal is to minimize the total cost, being the sum of the cost of placing the facilities at the nodes of the cycle plus the cost of the ring connections and the assignment costs. The cycle connection cost is the sum of all edge costs on the cycle. The assignment cost is defined as∑i∈V⧹V′minj∈V′dij.To formulate the RSP, we definezi=1,ifi∈Visonthecycle0,otherwisexij=1,ifedge[i,j]∈Eisonthecycle0,otherwiseyij=1,ifnodei∈Visassignedtonodejonthecycle,(i,j)∈A0,otherwiseIn order to simplify the notation, we denote {zi,i∈V; xij, [i,j]∈E; yij, (i,j)∈A} by {z,x,y}.Then, the RSP can be formulated as the following binary problem:(1a)minz,x,y∑i∈Vpizi+∑[i,j]∈Ecijxij+∑(i,j)∈Adijyij(1b)subjectto∑[i,j]∈Exij=2zi,∀i∈V(1c)∑(i,j)∈Ayij=1-zi,∀i∈V(1d)∑[i,j]∈E(S)xij⩽|S|-1,∀S⊆V⧹{0},S≠∅(1e)z0=1(1f)zi∈{0,1},∀i∈V(1g)xij∈{0,1},∀[i,j]∈E(1h)yij∈{0,1},∀(i,j)∈Awhere E(S)={[i,j]∈E:i, j∈S⊆V}. In this formulation, the objective function (1a) minimizes the total cycle and assignments costs, and the cost of placing the facilities at the nodes. Constraints (1b) enforce that the degree of each node i is 2 if and only if it belongs to the cycle. Constraints (1c) ensure that either each node i is on the cycle or is assigned to a single node j on the cycle. Constraints (1d) are the well-known subtour elimination constraints limiting the number of cycles to one. Constraint (1e) ensures that the depot is on the cycle. Constraints (1f)–(1h) guarantee that all variables are binary.The RSP is also known as the first version of the Median Cycle Problem (MCP1). Under this name, Moreno Pérez et al. [22] use the model to test a heuristic that combines variable neighborhood search and tabu search using a set of benchmark problems based on Traveling Salesman Problem (TSP) instances from TSPLIB [24] involving between 50 and 200 nodes. In order to provide an optimal solution of the RSP, the algorithms developed in the literature mainly consider branch and cut techniques. Labbé et al. [17] formulate the problem as a mixed integer linear program, which uses connectivity constraints instead of constraints (1d), and relaxes some integer requirements of variables {zi}i∈Vand {yij}(i,j)∈Ain formulation (1). After a polyhedral analysis of the problem, they propose a branch-and-cut algorithm and apply it to solve the benchmark problems and some randomly generated instances with a number of nodes between 10 and 300. Kedad-Sidhoum and Nguyen [16] propose a new formulation of the RSP based on chains and use it to develop a new branch-and-cut approach. A branch-and-cut algorithm is also proposed by Simonetti et al. [26], who reformulate the RSP as a minimum Steiner arborescence problem. They provide an optimal solution for some benchmark instances not solved in [17]. In summary, an optimal solution has been achieved for 120 out of the 124 benchmark instances considered in the literature [17,26].Besides the above mentioned heuristic, other heuristic algorithms have been proposed in the literature. Renaud et al. [25] propose a multistart greedy add heuristic and a random keys evolutionary algorithm. Both algorithms are tested using only the benchmark instances which were exactly solved in [17] and proved to be quite efficient compared with [22]. Dias et al. [12] propose a heuristic that uses a general variable neighborhood search to improve the quality of the solution obtained by a greedy randomized adaptive search procedure. They only solve the benchmark instances having between 50 and 100 nodes, obtaining better results than [22] in some cases.Other variants of the RSP have been introduced in the literature. Baldacci et al. [3] introduce the capacitated m-ring-star problem which consists of designing a set of m rings with bounded capacity that passes through the depot and through some transition points and/or customers, and then assigning each non-visited customer to a visited point or customer. A branch-and-cut approach is proposed to solve the problem. For the same problem, Naji-Azimi et al. [23] develop a heuristic algorithm which follows the scheme of the Variable Neighborhood Search and incorporates an Integer Linear Programming based improvement. Baldacci and Dell’Amico [2] generalize the above problem by allowing the existence of multiple depots. Finally, Liefooghe et al. [19] propose to consider individually on the one hand the costs of the ring and on the other hand the assignment costs. Based on this bi-objective formulation they propose different metaheuristics for solving the problem.The goal of this paper is to propose an evolutionary algorithm for the RSP based on a new encoding scheme to handle which nodes are on the ring. This algorithm has been suggested by a new formulation of the RSP as a bilevel problem with three decision makers, a leader and two independent followers. The paper is organized as follows. In Section 2 the formulation of the RSP as a bilevel problem is proposed and the main results of the equivalence between both problems are proved. The algorithm is developed in Section 3. In Section 4 the computational performance of the procedure is evaluated using the benchmark instances dealt with in the literature. Finally, Section 5 concludes the paper with some final remarks.Bilevel programming has been proposed for modeling hierarchical processes characterized by the existence of two decision levels. The decision makers at both levels of the hierarchy seek to optimize their individual objective functions and control their own set of decision variables. Due to the hierarchical structure of the process, the decision maker at the upper level of the hierarchy, also called the leader, aims to optimize his own objective function but anticipating within the optimization scheme the reaction of the decision maker at the lower level, also called the follower. In mathematical terms, the bilevel programming problem involves two optimization problems where the constraint region of the upper level optimization problem is implicitly determined by the lower level optimization problem. Bilevel programming is discussed in Bard [4], Colson et al. [10] and Dempe [11]. Some extensions of bilevel programming consider the existence of several decision makers at the lower decision level [6] or multiple objectives at each decision level [7,8].In the RSP, the decision maker has to locate a simple cycle and assign the remaining nodes to the nodes on the cycle in an optimal way. In the bilevel programming formulation that we propose, the decision maker will share the decision process. This decision maker will act as a leader and delegate some of the decisions to two followers. The idea is that the leader will decide on the nodes of the cycle, but anticipating the reactions of both followers. Each follower, after receiving the leader’s selection, solves his own problem. One follower will find the cycle by solving a traveling salesman problem and the other follower will solve the problem of assigning the nodes not in the cycle to their closest node on the cycle. These followers are independent in the sense that there is no communication between them and they do not share any information. Taking into account the hierarchical structure of the bilevel problem, the leader maintains overall control of the process. Moreover, since the leader is assumed to anticipate the reactions of the followers, he will be able to choose his optimal strategy. Fig. 2displays a scheme of this decision process.In order to reformulate the RSP as a bilevel problem, we assume that variables {zi}i∈Vare controlled by the leader, variables {xij}[i,j]∈Eare controlled by follower 1 and variables {yij}(i,j)∈Aare controlled by follower 2. The bilevel reformulation of the RSP (BRSP) is:(2a)minz,x,y∑i∈Vpizi+∑[i,j]∈Ecijxij+∑(i,j)∈Adijyij(2b)subjecttoz0=1(2c)zi∈{0,1},∀i∈Vwhere, for every {zi}i∈Vfixed, {xij}[i,j]∈Esolves the problem:(2d)L1(z):minx∑[i,j]∈Ecijxij(2e)subjectto∑[i,j]∈Exij=2zi,∀i∈V(2f)∑[i,j]∈E(S)xij⩽|S|-1,∀S⊆{i∈V⧹{0}:zi=1},(2g)xij∈{0,1},∀[i,j]∈Eand {yij}(i,j)∈Asolves the problem:(2h)L2(z):miny∑(i,j)∈Adijyij(2i)subjectto∑(i,j)∈Ayij=1-zi,∀i∈V(2j)yij∈{0,1},∀(i,j)∈AThis is a binary bilevel problem with two independent followers, meaning that the objective function and the set of constraints of each follower only include the leader’s variables and the individual follower’s own variables. Bilevel problems with multiple independent followers have been addressed by Calvete and Galé [6] when all the functions involved are linear and there are no integrality constraints.We now prove the main results concerning the equivalence between the RSP and the BRSP.Lemma 1Let{z¯i}i∈Vverify constraints(2b)and(2c). Let{x¯ij}[i,j]∈Eand{y¯ij}(i,j)∈Abe feasible solutions of problemsL1(z¯)andL2(z¯), respectively. Then,{z¯,x¯,y¯}is a feasible solution of the RSP.It is obvious that constraints (1b), (1c), (1e)–(1h) are verified.On the other hand, given S⊆V⧹{0}, we defineS0={i∈S:z¯i=0}andS1={i∈S:z¯i=1}. Bearing in mind constraints (2e),x¯ij=0for all [i,j]∈E and i∈S0 or j∈S0. Then, by applying (2f)∑[i,j]∈E(S)x¯ij=∑[i,j]∈E(S1)x¯ij⩽|S1|-1⩽|S|-1This completes the proof.□From the above lemma we can also conclude that every feasible solution of the BRSP provides a feasible solution of the RSP.Lemma 2Let{z¯,x¯,y¯}be an optimal solution of the RSP. Then, it is a feasible solution of the BRSP.Since{z¯,x¯,y¯}is a feasible solution of the RSP, it verifies all constraints of problem (2), i.e. (2b), (2c), (2e)–(2g), (2i) and (2j). In order to show that it is a feasible solution of the BRSP, we need to prove that{x¯ij}[i,j]∈Eis an optimal solution of problemL1(z¯)and{y¯ij}(i,j)∈Ais an optimal solution of problemL2(z¯).Let us first consider the problemL1(z¯). Assume that{x¯ij}[i,j]∈Eis not an optimal solution of this problem. Then, there existsxij∗[i,j]∈E, a feasible solution ofL1(z¯)so that(3)∑[i,j]∈Ecijxij∗<∑[i,j]∈Ecijx¯ijBy applying Lemma 1,{z¯,x∗,y¯}is a feasible solution of the RSP and∑i∈Vpiz¯i+∑[i,j]∈Ecijxij∗+∑(i,j)∈Adijy¯ij<∑i∈Vpiz¯i+∑[i,j]∈Ecijx¯ij+∑(i,j)∈Adijy¯ijwhich contradicts that{z¯,x¯,y¯}is optimal for the RSP. The second part of the proof is analogous.□The RSP and the BRSP provide the same optimal solution.Let {z∗,x∗,y∗} be an optimal solution of the RSP. By applying Lemma 2, it is a feasible solution of the BRSP. Assume that it is not an optimal solution of this problem. Then, there exists a feasible solution of the BRSP{z¯,x¯,y¯}so that(4)∑i∈Vpiz¯i+∑[i,j]∈Ecijx¯ij+∑(i,j)∈Adijy¯ij<∑i∈Vpizi∗+∑[i,j]∈Ecijxij∗+∑(i,j)∈Adijyij∗Due to Lemma 1,{z¯,x¯,y¯}is a feasible solution of the RSP. Hence, (4) is in contradiction to the optimality of {z∗,x∗,y∗}.Conversely, let {z∗,x∗,y∗} be an optimal solution of the BRSP. By applying Lemma 1, it is a feasible solution of the RSP. Assume that it is not an optimal solution of the RSP. Then(5)∑i∈Vpiz¯i+∑[i,j]∈Ecijx¯ij+∑(i,j)∈Adijy¯ij<∑i∈Vpizi∗+∑[i,j]∈Ecijxij∗+∑(i,j)∈Adijyij∗where{z¯,x¯,y¯}is an optimal solution of the RSP. From Lemma 2, it follows that{z¯,x¯,y¯}is a feasible solution of problem BRSP. Hence, (5) is in contradiction to the optimality of {z∗,x∗,y∗}.□In the following section we use these ideas about sharing the decision making process to develop an evolutionary algorithm which solves the BRSP and thus the RSP.Evolutionary Algorithms (EAs) are adaptive heuristic search algorithms based on the principles of biological evolution. They use the ideas of reproduction and selection in populations to produce good solutions to complex optimization problems. Candidate solutions to the optimization problem play the role of individuals in biology. EAs were introduced and developed by Holland [14] and have been increasingly applied to solve a variety of problems [1,9,21]. EAs encode each potential solution as a string of symbols called a chromosome. Each position of a symbol in the chromosome is called a gene and its value is called the allele value. Then, crossover and mutation operators are applied to these structures so as to preserve critical information based on their fitness. The fitness gives each chromosome a score based on how well it performs, usually through the evaluation of the objective function of the optimization problem. An implementation of an EA starts with a randomly generated population of chromosomes whose fitness is evaluated. The population evolves to create offspring by combining chromosomes from the current population using a crossover operation and modifying them by using a mutation operation. Having evaluated the fitness of the new chromosomes, a selection operation allows some of the parents and offspring to survive to the next population. This process continues through successive iterations of the algorithm until a number of populations have been produced or a suitable solution has been found depending on the stopping criterion.As far as we know, Renaud et al. [25] are the only researchers to have developed an EA to solve the RSP. In this algorithm, called the RKEA, each chromosome encodes a cycle, i.e. a feasible solution of the RSP, using the random keys encoding mechanism developed by Bean [5]. This encoding easily allows for the recombination of cycles. Moreover, no mutation operator is applied. Following the ideas presented in the above section, in the algorithm developed in this paper the chromosomes encode the upper level variables of the BRSP. From these values, a feasible solution of the BRSP can be obtained by solving both the followers’ problems. Next, the algorithm proceeds by performing crossover, mutation, fitness evaluation and selection until the stopping condition is met.In order to improve the performance of the algorithm, we have implemented the ideas on distributed genetic algorithms proposed by Tanese [27]. Hence, the population is divided into smaller subpopulations which evolve in an isolated manner producing offspring for the next generation. After a number of iterations, there is an information exchange operation as a result of which some selected individuals migrate to a different subpopulation. Moreover, while EA literature shows that on average the population improves over the iterations, sometimes the algorithm fails to generate near-optimal solutions and requires some form of intensification. Hence, we propose to use local search techniques to improve some randomly selected solutions. A sketch of the algorithm is shown in Fig. 3. Fig. 3a shows the steps of the algorithm and Fig. 3b displays the migration process.We encode the chromosome as a binary ∣V∣-dimensional vector C∈{0,1}∣V∣, so that for each i∈VCi=1,ifnodeiisonthecycle0,otherwiseNode 0 is always on the cycle, hence C0=1.Each chromosomeC¯can be associated with a feasible solution{z¯,x¯,y¯}of the BRSP, and thus a feasible solution of the RSP. The upper level variables can be directly obtained from the chromosome:z¯i=C¯i,i∈V. Having fixed the upper level variables, we can compute the remaining variables by solving both lower level problems. Follower 1’s problem is a TSP, thus it is difficult to solve. Since this procedure has to be applied to each chromosome generated by the algorithm, a compromise is needed between solution quality and computing time. Therefore, we have decided to use a procedure not very costly in terms of time and reasonable in terms of quality of the solution. We have selected a greedy algorithm based on least cost edges, followed by 2-opt local search. Moreover, with a probability of 0.5, 3-opt local search is also applied. Needless to say, other algorithms proposed in the literature for solving the TSP could also be applied [15,18]. Follower 2’s problem is a very easy optimization problem. For each node not on the cycle, it selects the closest one on the cycle. Hence, it is solved to optimality.The initial population is formed by randomly generated IP chromosomes. This population is divided into P subpopulations of size PS=IP/P. Let MI be the migration interval, i.e. the number of iterations between each migration. Then, each subpopulation evolves independently for MI iterations producing offspring via crossover, mutation and local search. Every MI iterations, the best individual of each subpopulation migrates to another subpopulation following the diagram shown in Fig. 3b.The crossover operator represents the process by which chromosomes selected from a population are combined to form offspring which are potential members of a successor population. In the BBEA we apply a uniform crossover operator which enables the parent chromosomes to contribute the gene level. For each subpopulation of size PS, the crossover operator randomly selects PS pairs of parents and generates one offspring from each pair. Each gene of the offspring is selected from one of the parents with a probability of 0.5. For instance, from the parents:Once offspring have been created, the mutation operator is applied to them. Each offspring is selected for the mutation operation with a probability of 0.5. After a chromosome has been selected, a gene is randomly selected and its allele value is switched.In order to improve the quality of the populations which are generated in successive iterations, we propose to apply local search techniques to some of the feasible solutions associated with offspring, aiming to improve their quality measured by means of the objective function (1a). Each offspring is selected for the local search operation with a probability of 0.5. LetC¯be a selected offspring and{z¯,x¯,y¯}be the associated feasible solution of the BRSP. In the implementation of the algorithm, cycle reduction, cycle augmentation and node exchange [25] are successively applied insofar as they improve the objective function value of the solution obtained. Fig. 4shows these techniques. Let {z∗, x∗, y∗} be the feasible solution of the RSP obtained after applying the local search procedures. The offspring resulting from the local search operation is C∗ so thatCi∗=zi∗,i∈Vand its associated feasible solution is {z∗,x∗,y∗}.The quality of a chromosome is evaluated by its fitness. Hence, we define the fitness as the value of the objective function (1a) of the associated feasible solution of the RSP:F(C)=∑i∈Vpizi+∑[i,j]∈Ecijxij+∑(i,j)∈AdijyijFinally, some of the parents and offspring are allowed to survive by applying the selection operator. Based on the chromosome fitness, we use the elitist strategy which keeps the best PS chromosomes in each subpopulation from one iteration to the next (without repetition).After the stopping condition of the algorithm is met, the chromosome with the least fitness value will be selected and the associated feasible solution of the RSP will be provided as the solution of the RSP.Having found the best solution provided by the algorithm, we have considered the possibility of applying an additional improvement in the implementation of the algorithm. This final step consists of applying version 2.0.6 of the implementation by Helsgaun [13] of the Lin and Kernighan heuristic [20] to the nodes in the cycle in order to obtain a possible better arrangement of the cycle. This implementation can be downloaded from http://www.akira.ruc.dk/∼keld/research/LKH/. As we will explain in the next section, this final improvement appears to be interesting in the case that the optimal solution of the RSP consists of a cycle with almost all the nodes in the network, but not otherwise.In order to analyze the performance of the BBEA, we have conducted a computational experiment divided into two parts. In the first part of the experiment, we have studied the effect of different parameters of the algorithm on the quality of the solution provided by the BBEA. Having selected the best value of the parameters, in the second part of the study we have compared the solutions provided by the BBEA with the optimal solutions available in the literature. Also in the second part, we have compared the BBEA with the RKEA, the evolutionary algorithm proposed by Renaud et al. [25]. The numerical experiments have been performed on a PC Intel® Core™ I7-3820 CPU at 3.6gigahertz×8 having 32gigabytes of RAM under Ubuntu Linux 12.04 LTS. The code has been written in C++, GCC 4.6.3.The performance of the algorithm has been tested on the above mentioned RSP benchmark problems. There are 124 problems which involve between 50 and 200 nodes. They are derived from the EUC-2D and EXPLICIT TSPLIB problems eil51 to kroB200 by modifying the original distance as proposed in [17,22]. For each of the 31 networks in the TSPLIB, four RSP benchmark problems are generated as follows. Let lijbe the distance between nodes i and j in the TSP instance. To obtain optimal solutions visiting approximately 100%, 75%, 50%, and 25% of the total number of nodes in the instances, the coefficients in the objective function of the RSP are defined as: cij=⌈αlij⌉, [i,j]∈E, dij=⌈(10−α)lij⌉, (i,j)∈A, for α={3,5,7,9} and pi=0, i∈V. To illustrate the effect of considering each value of α in the optimal solution, Fig. 5shows the optimal solution of problem KroA100 for the different values of α.Finally, we have solved larger RSP instances which have been derived from the EUC-2D and EXPLICIT TSPLIB problems tsp225 to rat783 from the TSPLIB following the same idea.The aim of the first part of the study was to assess the influence of five factors on the performance of the BBEA by defining a 4× 23×3 factorial design. The factors and levels are: Alpha (α=3, α=5, α=7, α=9), LS (local search=yes, local search=not), LKH (additional improvement=yes, additional improvement=not), population size (IP=400, IP=800) and subpopulation size (PS=IP, meaning that there are no subpopulations, PS=100, PS=50). Each combination of factors provides a configuration of the algorithm. Since we are going to assess the influence of the factor α in the achievement of the algorithm, instead of the above mentioned 124 benchmark problems, in this part of the study we take 31 test problems, each corresponding to a graph of the TSPLIB. Each of the test problems has been solved six times under each algorithm configuration. In order to facilitate the comparison of the results, the termination condition of the algorithm has been established in terms of computing time: 15seconds if the number of nodes n<100, 30seconds if 100⩽n<150 and 45seconds if 150⩽n. Moreover, the migration interval MI has been fixed at 10 iterations.Let f be the objective function value of the solution provided by the BBEA and fbest−knownbe the objective function value of the best known solution in the literature for the corresponding problem. As we have previously mentioned, most benchmark problems have been solved optimally, but an upper bound only of the optimal objective function value is known for just a few problems. If f−fbest−known⩽0, this is considered as success.The results of the Analysis of Variance (ANOVA) applied to the proportion of success indicate that the LS (29.4% of variability explained), Alpha (21.4% of variability explained) and LKH (7.5% of variability explained) factors are significant (the p-value being zero). The interactions between Alpha and the LKH (22.4% of variability explained), and the interaction between Alpha and LS (10.4% of variability explained) are also significant. Figs. 6and 7display the main factor plot and the interaction plot for the response variable proportion of success.From this study we can conclude that, as we might expect, it is better to apply the local search. When doing this, the population and subpopulation sizes are not so relevant. Otherwise, it seems that a larger population size and a smaller subpopulation size perform better. In fact, if local search is applied, in 8119 out of the 8928 problems solved, i.e. 90.94%, we have obtained success, showing that irrespective of the algorithm configuration, the BBEA with local search provides very accurate solutions within short computing times. The level of Alpha is also relevant and is especially important in terms of deciding whether or not to apply the LKH additional improvement. In fact, only if α=3 is it worth applying this improvement. Hence, we propose to select for the algorithm a configuration in which local search is applied but the LKH improvement is only applied to problems with α=3.In the second part of the study the goal is to obtain evidence of the quality of the BBEA by comparing the results yielded by the algorithm with the best solutions provided in the literature as well as with the results provided by the RKEA [25]. For this purpose, bearing in mind the considerations of the previous section, we have chosen to apply local search with a probability of 0.5 and to apply the LKH additional improvement if α=3. Moreover, we have selected IP=800 and P=16, i.e. each subpopulation has a size PS=50, and we have maintained the migration interval MI=10 iterations. With this configuration, we have solved 6 times each of the 124 benchmark problems using a termination condition based on the number of successive iterations without improvement. Based on pilot testing, we have fixed this number at 5 iterations if α=3 and at 50 if α=5, 7, 9.Moreover, due to the very different computational environments of the computational experiments provided in the literature, when displaying the results we have applied a correcting factor to the processing time in order to allow the comparison of computing times. This factor β is established as the ratio between the clocks of the machines on which the programs were run. It is worth pointing out that, although we had a multi-processor computer at hand, only one processor was used in our tests.Tables 1 and 2display the comparison with the best solution provided in the literature. The first and second columns show the names of the problems. The third column indicates the value of the optimum solution and the reference in which it is provided. Problems marked with an asterisk show the objective function value of the best solution known in the literature. The fourth column shows the computing time provided in the corresponding reference divided by the correcting factor β. This factor is β=4.15 for Ref. [17] and β=1.27 for Ref. [26]. The fifth and sixth columns display the minimum and the maximum of the objective function value of the solution obtained in the six runs of each problem. The =symbol means that the best result in the literature (third column) has been yielded by the BBEA. It is worth noting that in 115 out of the 124 problems (92.74%), the best known result in the literature has been matched in the six runs. Moreover, in the six runs of the problem pr152, α=5, the BBEA has provided a solution better than the best known solution. The seventh column shows the percentage of error defined as100×(f¯-fbest-known)/fbest-known, wheref¯is the average of the objective function value of the solution yielded by the BBEA in the 6 runs of the problem. When the BBEA yields the best known solution in all runs, there is no error, hence the seventh column is empty. For the problem pr152, α=5 this error is negative, meaning that the BBEA provides a better solution. For the problems in which the best known result has not been achieved in all the six runs, the error ranges from 0.001% to 0.125%, which is a remarkably close fit. The average computing time in seconds in the six runs is shown in the eighth column. It ranges from 0.20 to 40.88seconds, with an average of 7.17seconds.Table 3presents the data that allow us to compare the two evolutionary algorithms, the RKEA and the BBEA. The first and second columns show the names of the problems. Note that Renaud et al. [25] restrict their tests to 52 benchmark instances which had been exactly solved by Labbé et al. [17], hence only these benchmark problems are included. The third and the sixth columns display the percentage of error as defined above. Notice that the RKEA results were obtained by successively running the algorithm five times, whereas the BBEA was run six times. The fourth and the seventh columns present the minimum deviation defined as 100×(fbest−fbest−known)/fbest−known, where fbestis the best value of the objective function yielded by the corresponding algorithm. When the corresponding algorithm yields the optimum solution in all runs, there is no error, hence the %Error column is empty. Similarly if the algorithm reaches the optimum solution in any run, the minimum deviation column is empty. Finally, the fifth and the eighth columns show the average computing times for the algorithms RKEA and BBEA, respectively. Original computing times for the RKEA have been divided by the correcting factor β=4. It should be noted that the RKEA was stopped after 5 successive iterations without improvement, whereas for the BBEA the number of successive iterations without improvement was established at 50 if α=5, 7, 9.Summarizing data in Table 3, in 49 out of 52 instances, the BBEA reaches the optimum solution in all the six runs. The RKEA provides the optimum in all the five runs in 29 out of the 52 instances and reaches the optimum in at least one of the five runs in 41 out of the 52 instances. Moreover, the average minimum deviation from the optimum is 0.0026 and 0.0996, respectively for the BBEA and the RKEA. Also, the average of the percentage of error is 0.0034 against 0.1906. Finally, concerning the computing times, the average (per run) computing time is 7.378 against 36.560. Hence, we can conclude that the BBEA outperforms the RKEA.Taking into account the efficiency of the BBEA when applied to solving instances of the RSP with a number of nodes between 50 and 200, we have considered it useful to study its performance in larger problems. These RSP instances have been derived from the EUC-2D and EXPLICIT TSPLIB problems tsp225 to rat783 following the same idea as in [17,22]. We have used the same algorithm configuration and the same termination condition described in the previous subsection. Again, each problem has been solved six times.The results are presented in Table 4. The first and second columns indicate the names of the problem. The third column indicates the objective function value of the best solution obtained in the six runs of each problem. Similarly, the fourth column displays the maximum of the objective function value of the solution provided by the BBEA in the six runs of each problem. The = symbol means that both values are equal. The fifth column shows the percentage of error computed as100×(f¯-fmin)/fmin, where fminis the value contained in column three andf¯is the average of the objective function values of the six solutions. Finally, the last column displays the average computing time involved in seconds.Notice that for most of the smaller problems, the BBEA provides the same solution in all the six runs. When the algorithm does not provide in all the six runs the same solution, the percentage of error ranges from 0.000 to 0.320, thus confirming the accuracy of the algorithm. Moreover, the computing time ranges from 4.33seconds to less than 10minutes for most problems. Only some problems with more than 650 nodes need up to 23minutes to provide a solution. Confirming the results obtained in the previous subsection, we have also observed that applying the additional improvement LKH is only of interest for α=3. For problems with α=5,7,9 there are no differences whether the LKH is applied or not except for α=5 and the problems si535, rat575 and rat783 in which there are slight differences. In problem si535-5, the minimum computed is 241,700, in problem rat575-5 it is 32,395 and in problem rat783-5 it is 42,485.

@&#CONCLUSIONS@&#
A fast and efficient evolutionary algorithm for the RSP has been presented in this paper. It is based on a new formulation of this problem as a binary bilevel programming problem with one leader and two independent followers. The algorithm is based on an encoding scheme which handles the nodes on the ring. A computational study has allowed us to conclude that applying local search after the usual crossover and mutation operators vastly improves the performance of the algorithm. Also, the computational results show that the algorithm outperforms the heuristic algorithms proposed in the literature in terms of the number of benchmark problems which are solved optimally. In fact, in 92.74% of benchmark problems, the best known result in the literature has been matched in the six runs. Moreover, for one of the test problems, the algorithm has provided a solution better than the best known solution in all the six runs. The computing time can be considered very short (it ranges from 0.20 to 40.88seconds, with an average of 7.17seconds). In fact the computing times are much lower than those reported in the literature, even when we take into account the correcting factor due to the different characteristics of the computers used. The algorithm has also been tested on a set of larger benchmark problems (up to 783 nodes) and the computational results are very satisfactory in terms of accuracy and computing time. Future work involves the application of the underlying ideas of the problem reformulation proposed in this paper to other combinatorial problems. Sharing the decision process can help to improve the computing times in solving the problems.