@&#MAIN-TITLE@&#
A priori policy evaluation and cyclic-order-based simulated annealing for the multi-compartment vehicle routing problem with stochastic demands

@&#HIGHLIGHTS@&#
Estimate and exactly calculate the expected cost of an a priori MCVRPSD policy.Cyclic-order-based simulated annealing procedure for the MCVRPSD.Significantly improve best-known solution values for benchmark problem instances.

@&#KEYPHRASES@&#
Logistics,Stochastic multi-compartment Vehicle routing,Cyclic-order search,Simulated annealing,

@&#ABSTRACT@&#
We develop methods to estimate and exactly calculate the expected cost of a priori policies for the multi-compartment vehicle routing problem with stochastic demands, an extension of the classical vehicle routing problem where customer demands are uncertain and products must be transported in separate partitions. We incorporate our estimation procedure into a cyclic-order-based simulated annealing algorithm, significantly improving the best-known solution values for a set of benchmark problems. We also extend the updating procedure for a cyclic order’s candidate route set to duration-constrained a priori policies.

@&#INTRODUCTION@&#
Vehicle routing problems with stochastic demands (VRPSDs) underlie operational problems in logistics where routes must be planned without full knowledge of customer demand levels. In such cases, actual demands are first observed upon arrival to customer locations. In some situations, products must be transported in independent vehicle compartments, giving rise to the multi-compartment vehicle routing problem with stochastic demands (MCVRPSD), a generalization of the single-compartment case (see the review of Gendreau et al. (1996) or the work of Laporte et al. (2002) for examples). Applications of the MCVRPSD include the collection and delivery of different types and qualities of milk (Caramia and Guerriero, 2010), distribution of various grades of fuel (Brown et al., 1987), transport of animal food (El Fallahi et al., 2008), pickup and delivery of livestock (Oppen and Løkketangen, 2008), selective waste collection, and transport of groceries requiring different levels of refrigeration.A common approach to handle uncertainty in customer demands is to restrict attention to a priori policies (see Campbell and Thomas (2008) for a review). An a priori policy requires vehicles to visit customers in the order specified by a set of pre-defined routes, returning to the depot to replenish in the event vehicle capacity is inadequate to fully serve demand, i.e., a route failure. A priori routes are routinely used in industry (Erera et al., 2010) and create a regularity of service that can be beneficial for both the customers and the drivers – customers may be served at roughly the same time each day they require service and the drivers become familiar with their routes.We make two main contributions. First, we develop methods to estimate and exactly calculate the expected cost of an a priori MCVRPSD policy. Straightforward procedures exist to calculate the expected cost of an a priori policy when all products are transported in a single compartment (Teodorović and Pavković, 1992). However, in the multi-compartment case, a priori policy evaluation is more difficult. Mendoza et al. (2008); 2010) and Mendoza et al. (2011) derive an expression to calculate the expected cost of an a priori policy, but the expression requires probability calculations to be made over random variables representing partially unserved customer demands. The distributions of these random variables are unknown, thereby making it difficult to implement the expression. Recognizing this challenge, Mendoza et al. (2008) explore methods to approximate the expected cost of an a priori policy for the MCVRPSD. When the ratio of compartment capacities to customer demands is high, Mendoza et al. (2008) find a take-all approximation yields good estimates of the expected cost. However, the bias of the estimate increases as the ratio of compartment capacities to customer demands decreases.The method we propose to calculate the exact expected cost of an a priori MCVRPSD policy builds on Goodson et al. (2013) and applies to problem instances where customer demands follow discrete probability distributions with finite support. The method requires exponential time to execute and is not practical for use in optimization procedures. However, the exact method leads to a simulation scheme that provides unbiased and consistent estimates of a policy’s expected cost for both discrete and continuous customer demand distributions. Because the simulation scheme can be efficiently incorporated into local search procedures, it provides an attractive alternative when the bias of the take-all approximation is unacceptable.Our second contribution is the development of a cyclic-order-based simulated annealing procedure for the MCVRPSD. Goodson et al. (2012) propose cyclic-order neighborhoods as the basis of local search methods for a broad class of routing problems, of which the MCVRPSD is a member. We utilize our simulation scheme for a priori MCVRPSD policies to accelerate the initial iterations of the simulated annealing procedure. We also extend the cyclic-order updating procedure of Goodson et al. (2012) for the candidate route set to the duration-constrained a priori policies considered in this paper.As of this writing, our method appears to be the most effective heuristic for the MCVRPSD. Without tailoring the cyclic-order search procedure to the MCVRPSD, we improve the best-known solution values for 159 of 180 benchmark problem instances and match the best-known solution values for the remaining 21 instances. These results, in conjunction with the results of Goodson et al. (2012), support cyclic-order-based local search as an effective solution procedure for a variety of routing problems.The remainder of the paper is organized as follows. In Section 2, we formally state the MCVRPSD. In Section 3, we review related literature. In Section 4, we discuss methods to exactly calculate and estimate the expected cost of an a priori MCVRPSD policy. In Section 5, we present our cyclic-order-based simulated annealing procedure. In Section 6, we discuss the results of computational experiments. We make concluding remarks and suggestions for future research in Section 7. Appendix A provides a guide to the primary notation used in the paper.The MCVRPSD generalizes the classical vehicle routing problem, a NP-hard optimization problem (Toth and Vigo, 2001). The MCVRPSD is characterized by a complete graphG=(N,E),whereN={0,1,…,N}is a set of N + 1 nodes andE={(n,n′):n,n′∈N}is the set of edges connecting the nodes. Nodes 1, …, N represent customer locations and node 0 represents a depot from which a setM={1,2,…,M}of identical vehicles operates. Each vehicle contains a separate compartment for each product in the product setP={1,2,…,P}. The capacity of the compartment assigned to product p inPis Qp. Customer demands for products are assumed to be independent random variables. The random demand for product p inPat customer n inNis denoted Dn, p. We denote the distribution function byFDn,p(·)with supportS(Dn,p),which we require to be a subset of the range[0,D¯],whereD¯is a finite number. Prior to arrival at customer locations, customer demands are known only in distribution. Upon arrival, customer demands for each product are observed and served to the maximum extent possible, subject to available vehicle capacity for each product. When capacity in one or more compartments is exhausted (i.e., a route failure occurs), a vehicle returns to the depot and replenishes the capacity of all compartments. Vehicle routes begin and end at the depot and travel times among customers are known. The time to travel from location n to location n′ is denoted t(n, n′). The objective of the MCVRPSD is to obtain a policy that serves customer demand with minimal expected travel time subject to a route duration limit L (e.g., end of a working day), by which time all vehicles must return to the depot. To be consistent with the literature, we use travel time to represent cost, noting that t( ·, ·) may be replaced with a general cost function.We focus on a priori routing policies for the MCVRPSD. A priori policies are characterized by a priori routes, or predetermined sequences of customers. We denote an a priori route for vehicle m in vehicle setMby the sequence of customersvm=(v0m=0,v1m,…,vImm,vIm+1m=0). We denote by(vm)m∈Ma set containing an a priori route for each vehicle m inM. In a set of a priori routes, each customer appears exactly once on exactly one route. We adopt the classical detour-to-depot policy, the same policy employed by Mendoza et al. (2010); 2011). The policy requires vehicles to serve customers in the order they appear in a set of a priori routes. Vehicles must travel directly to the next customer on the route, i.e., preemptive capacity replenishment is not allowed. In the event of a route failure, vehicles must make return trips to the depot until customer demands are fully served. An a priori route is feasible if its expected travel time is less than or equal to the route duration limit L. If we denote byVthe set of all a priori route sets, byAvIm+1mthe random arrival time of vehicle m to final destinationvIm+1m,and byE[AvIm+1m]the expected arrival time of vehicle m tovIm+1m,then the problem we seek to solve is(1)min{∑m∈ME[AvIm+1m]:(2)E[AvIm+1m]≤L,m∈M,(3)(vm)m∈M∈V∑m∈M}.Throughout the remainder of the paper, because we refer primarily to a single a priori route, to ease the notation we drop the superscript m and refer to a route simply by v and to the ith customer on a route by vi.Research related to multi-compartment vehicle routing appears to begin with van der Bruggen et al. (1995), who consider the task of designing delivery routes for gasoline distribution. van der Bruggen et al. (1995) and others model customer demands as deterministic. In this section, we focus on literature treating customer demands as stochastic.Mendoza et al. (2008) study take-none and take-all approximations of the recourse cost component of a priori policies. The take-all approximation assumes that when a route failure occurs at a particular customer, all demands for all products at that customer are served in full before replenishing capacity at the depot; the take-none approximation assumes none of the demands are served. Both approximations circumvent the issue of making probability calculations over random variables with unknown distributions. Computational experiments conclude the take-all scheme is superior, but that the quality of both approximations degrades as the ratio of compartment capacities to customer demands decreases.The methods we propose to estimate and exactly calculate the expected cost of a priori policies serve as alternatives to the take-none and take-all approximations. Our methods differ in three ways. First, the take-none and take-all approximations can be used when demands follow discrete or continuous probability distributions, provided the convolution of random demands can be readily calculated (e.g., Poisson- or normally-distributed demands). In contrast, our exact evaluation procedure can only be used when customer demands follow discrete distributions, but there is no limit imposed by the need to calculate convolutions of random variables. The estimation procedure may be applied regardless of the nature of customer demand distributions. Second, our procedures do not depend on the assumption that demand realizations are less than or equal to compartment capacities, thereby accounting for the possibility of multiple route failures at one customer. Third, when fully serving a customer’s demands exhausts vehicle capacity, rather than require the vehicle to return to the current customer after replenishing capacities at the depot, our methods route the vehicle directly to the next customer on the a priori route.Using the take-all scheme to approximate expected route costs, Mendoza et al. (2010) build on the memetic algorithm of El Fallahi et al. (2008), improving solution values obtained by a constructive heuristic and by an alternative memetic procedure. Also using the take-all approximation, Mendoza et al. (2011) propose construction heuristics that yield good solutions with short computing times. Adapting our cyclic-order procedure to the take-all scheme, we improve many of the solution values obtained by Mendoza et al. (2010); 2011).Seeking to balance the trade-off between expected routing costs and variability, Mendoza et al. (2009) place a constraint on the probability that route cost exceeds a given threshold. Within a memetic algorithm, the expected route cost and the variance of the route cost are estimated via simulation. We also employ simulation to estimate expected route costs, explicitly showing how the simulation can be incorporated into local search procedures.For a given sequence of customers, Pandelis et al. (2012) develop a dynamic programming algorithm to determine an optimal restocking policy. Demonstrating a threshold-type structure on the optimal policy for any integer number of vehicle compartments, Pandelis et al. (2012) generalize the work of Tatarakis and Minis (2009), which applies to only two compartments. The restocking policies of Pandelis et al. (2012) and Tatarakis and Minis (2009) are a relaxation of the a priori policies we consider, which do not permit preemptive capacity replenishment prior to route failures. In contrast to the work of Pandelis et al. (2012) and Tatarakis and Minis (2009), which assumes a fixed delivery sequence, we search the space of a priori delivery sequences seeking lower-cost a priori policies.The procedures of Section 4 build on Appendix A of Goodson et al. (2013), which develops a priori policy evaluation methods for a single-compartment VRPSD with route duration constraints where the objective is to maximize expected demand served. We extend the methods of Goodson et al. (2013) to the multi-compartment case and to the objective of minimizing expected route costs. These extensions increase the computational complexity of a priori policy evaluation from pseudo-polynomial to exponential in the number of vehicle compartments.The heuristic developed in Section 5 builds on Goodson et al. (2012), which develops cyclic-order-based local search methods for a broad class of routing problems. Based on the concept of optimal partitioning (Beasley, 1983), a cyclic order maps a permutation of the customer set to a collection of many possible routing solutions, the best of which can be identified via the polynomial-time procedure of Ryan et al. (1993) and Boctor and Renaud (2000). Our heuristic uses the neighborhood structures proposed by Goodson et al. (2012), but extends the solution updating procedure to accommodate duration-constrained routes.In Section 4.1, we develop a procedure to calculate the expected travel time incurred by an a priori route. When customer demands follow discrete probability distributions, the procedure in Section 4.1 yields an exact calculation of the expected travel time. In Section 4.2, we discuss how to use simulation to estimate the expected travel time of an a priori route. The simulation scheme yields unbiased and consistent estimates of the expected travel time for both continuous and discrete customer demand distributions. Applying the methods of Section 4.1 or Section 4.2 to each a priori route in a set of routes allows for the calculation or estimation of the objective function (1) and the constraints (2).Below, we develop a method to calculate the expected time of initial arrival to a particular customer on an a priori route. Given a set of a priori routes v, the associated policy can be evaluated by applying the method to the last customer on each route, vI + 1, and summing the results.The initial arrival time at a customer on an a priori route is a function of the initial arrival time at the previous customer, the demands at the previous customer, and available vehicle capacities upon initial arrival to the previous customer. We denote byAvithe random time of the initial arrival of the vehicle to customer vion a priori route v. We denote byCvi,pthe random capacity of compartment p of the vehicle upon the initial arrival to customer vion a priori route v. We denote byaviandcvirealizations ofAviandCvi,respectively. If demand for a product is greater than or equal to the available capacity for that product, then return trips to the depot are required to fully serve demand at that customer. In such cases, if we define(4)ψ(vi)=maxp∈P{dvi,p−cvi,pQp},where ⌈ · ⌉ is the ceiling function anddvi,pis a realization ofDvi,p,then ⌈ψ(vi)⌉ is the number of return trips to the depot required to fully serve demand for all products at customer vi.We separate the calculation ofcvi,pandaviinto three cases:(5)cvi,p={cvi−1,p−dvi−1,p,dvi−1,p<cvi−1,p∀p∈P,Qp,ψ(vi−1)=⌈ψ(vi−1)⌉,min{⌈ψ(vi−1)⌉Qp−dvi−1,p+cvi−1,p,Qp},ψ(vi−1)<⌈ψ(vi−1)⌉,and(6)avi={avi−1+t(vi−1,vi),dvi−1,p<cvi−1,p∀p∈P,avi−1+(ψ(vi−1)+1)·t(vi−1,0)+ψ(vi−1)·t(0,vi−1)+t(0,vi),ψ(vi−1)=⌈ψ(vi−1)⌉,avi−1+t(vi−1,vi)+⌈ψ(vi−1)⌉·(t(vi−1,0)+t(0,vi−1)),ψ(vi−1)<⌈ψ(vi−1)⌉.The boundary conditions in Eqs. (5) and (6) arecv0,p=Qpfor all products p inPand for all vehicles andav0=0for all vehicles. In the first case, demand for each product at customer vi − 1 is less than the available capacity for that product, thus vehicle capacity for each product is simply decremented by the amount of demand for that product and the vehicle travels directly from vi − 1 to vi. The second and third cases account for situations where the demand for at least one product at customer vi − 1 is greater than or equal to vehicle capacity for that product upon arrival to vi − 1, thereby requiring ⌈ψ(vi − 1)⌉ return trips to the depot to replenish capacity. In the second case, satisfying demand for all products at vi − 1 exactly depletes vehicle capacity for at least one product, thereby requiring the vehicle to replenish at the depot one additional time and then travel directly to customer viwith full capacity in each compartment. In the third case, some capacity remains in all vehicle compartments after serving demands for all products at vi − 1. After making the necessary return trips to the depot, the vehicle travels directly from vi − 1 to vi.We denote byCvi=(Cvi,p)p∈Pthe vector of remaining capacities for the vehicle upon initial arrival to customer viand byDvi=(Dvi,p)p∈Pthe vector of random demands at customer vi. We denote bycvianddvirealizations ofCviandDvi,respectively. For clarity, we sometimes writecvi,pandavias functions of the terms they depend on. Specifically, we denote bycvi(d,c)=(cvi,p(d,c))p∈Pthe capacities upon initial arrival to customer viwhendvi−1=dandcvi−1=c. Similarly, we denote byavi(d,c,a)the time of initial arrival to customer viwhendvi−1=d,cvi−1=c,andavi−1=a. Further, we denote the pth element of a demand vector d and capacity vector c by dpand cp, respectively.Proposition 1 establishes a recursion to calculate the joint probability of initial arrival time at customer viand capacities upon initial arrival to customer vi. Proposition 1 also provides an expression to calculate the expected initial arrival time at customer vi. We assume customer demands follow a discrete probability distribution and we denote the probability mass function for demand at customer n for product p byfDn,p(·). A proof of Proposition 1 is provided in Appendix B.Proposition 1properties of a priori MCVRPSD policiesThe joint probability of arriving to customer viwith available capacities c and at time a is(7)P{Cvi=c,Avi=a}=∑d′∑c′∑a′1{c=cvi(d′,c′),a=avi(d′,c′,a′)}·P{Cvi−1=c′,Avi−1=a′}·∏p=1PfDvi−1,p(dp′),where 1{ · } is an indicator function that returns 1 if the statement { · } is true and 0 otherwise. The expected time of initial arrival at customer viis(8)E[Avi]=∑d∑c∑aavi(d,c,a)·P{Cvi−1=c,Avi−1=a}·∏p=1PfDvi−1,p(dp),whereP{Cvi−1=c,Avi−1=a}is calculated via Eq. (7).Algorithm 1employs Proposition 1 to calculate the expected time at which the vehicle first arrives to customer vi. Applying Algorithm 1 when index i = I + 1, the index of the last location on route v, results in the expected time required to serve all customer demands on a priori route v. To ease the notation, we defineg(vj,c,a)=P{Cvj=c,Avj=a}. We denote byS(Dn)=×p∈PS(Dn,p)the joint support of demands at customer n for the product setP,where × is the Cartesian product.Lines 1–4 of Algorithm 1 initialize the procedure. Line 1 assigns a probability of one to the initial state of the vehicle – the vehicle is initially located at the depot, with full capacity, and at time zero. Line 2 assigns a probability of zero to all other possible initial states. Line 3 initializes joint capacity and arrival probabilities for all other customers to zero and line 4 initializes to zero the expected time of initial arrival to customer vi; these quantities are updated as Algorithm 1 is executed. Lines 5–8 utilize Eq. (7) to build the joint probabilities of capacities and arrival times at customers v1, v2, …, vi − 1 . Finally, lines 9–11 apply equation (8) to calculate the expected time of initial arrival to customer vi.Under the assumption that customer demands, vehicle capacities, and travel times are all integer-valued, Proposition 2 establishes the worst-case complexity of Algorithm 1 is exponential in the number of products. A proof of Proposition 2 is provided in Appendix B. The driver of the exponential complexity is the size of the supports for demands at each customer. Even when other parameters take on small values, Algorithm 1 iterates over the supports, leading to a best-case complexity that is also exponential in the number of products.Proposition 2worst-case complexityLetQ¯=maxp∈P{Qp},letQ̲=minp∈P{Qp},letL¯=maxj=1,…,i−1{t(vj,0)+t(0,vj)},and letS¯=max{|S(Dvj,p)|:j=1,…,iandp=1,…,P}. Assume customer demands, vehicle capacities, and travel times are all integer-valued. Then, the worst-case computational complexity of Algorithm 1 isO(i·L¯·Q¯·P·⌈D¯/Q̲⌉·S¯P).Although Algorithm 1 can in principle be used to evaluate a priori MCVRPSD policies, the practical use of Algorithm 1 is limited. When route size, number of products, and support sizes exceed modest values, execution time and demands on computer memory become excessive. We explore the behavior of Algorithm 1 in Section 6.2. The computational limitations of Algorithm 1 motivate the simulation-evaluation method of Section 4.2.Because Algorithm 1 requires exponential time to execute, statistical estimation of the value of an a priori MCVRPSD policy may be an attractive alternative to exact evaluation. Below, we show how to estimate the expected time of initial arrival to a particular customer. We also discuss how the estimation procedure can be implemented within local search schemes.Letd^n,pbe a randomly generated demand from distribution functionF(·)Dn,pfor product p at customer n. Denote byd^n=(d^n,p)p∈Pa vector of randomly generated demands at customer n and byd^=(d^n)n∈N∖{0}a vector of randomly generated demands at all customers and for all products. Letd^1,d^2,…,d^Hbe H randomly generated demand vectors. Then, the expected arrival time at customer vican be estimated by(9)E^[Avi]=1H∑h=1Havid^h,whereavid^his the time of the vehicle’s initial arrival to customer viwhen customer demands ared^h. The quantityavid^hcan be calculated recursively using Eqs. (5) and (6). This is accomplished by initializingav0to 0 andcv0to(Qp)p∈P. Then, for j = 1, 2, …, i, calculatecvj=cvj(d^vj−1h,cvj−1)andavj=avj(d^vj−1h,cvj−1,avj−1),yieldingavid^hequal toavi. BecauseE^[Avi]is the sample mean of the arrival times across all H demand samples, it is an unbiased and consistent estimator ofE[Avi]. CalculatingE^[Avi]when index i = I + 1, the index of the last location on route v, results in an unbiased and consistent estimate ofE[Avi],the expected time required to serve all customer demands on a priori route v.Within a local search scheme, when calculatingE^[AvI+1],it may not be necessary to estimate the time of initial arrival to each customer in a priori route v. Because the time of initial arrival at a customer depends only on the preceding sequence of customers’ demands, capacities, and arrival times, it is only necessary to estimate the expected time of initial arrival where the preceding sequence of customers has changed; initial arrival times at other customers remain the same.More generally, suppose the current solution in a local search procedure contains a priori route v, thatE^[AvI+1]has been calculated, and that for each demand sampled^h,cviandavihave been stored for i = 0, 1, …, I + 1. Further, suppose a neighbor solutionv¯is generated by changing the customer sequence of v beginning at customer vk. For demand sample h, becausecv¯k−1andav¯k−1are known from the current solution,av¯I+1d^hcan be obtained by calculatingcv¯j=cv¯j(d^v¯j−1h,cv¯j−1)andav¯j=av¯j(d^v¯j−1h,cv¯j−1,av¯j−1)forj=k,k+1,…,|v¯|−1. Repeating this procedure for each demand sample and averaging the results yieldsE^[AvI+1]. We employ this updating procedure when estimating the cost of a priori routes in the cyclic-order-based local search we describe in Section 5.Because the computation required to calculateE^[Avi]grows linearly with the sample size H, Eq. (9) may be an attractive alternative to Algorithm 1. In accordance with Proposition 2, the computational experiments we present in Section 6.2 suggest the difference in computation time between estimation and exact evaluation grows exponentially with route size, number of products, and support sizes. Thus, for many problem instances, estimation-based local search for a priori MCVRPSD policies may be the only computationally tractable alternative.In Section 5.1, we describe a cyclic-order simulated annealing procedure for a priori MCVRPSD policies. Our procedure utilizes a cyclic-order solution encoding (based on Ryan et al. (1993)), which maps a permutation of the customer set to a collection of many possible MCVRPSD solutions, the best of which is identified via a polynomial-time algorithm. We employ the neighborhood structures of Goodson et al. (2012), which operate directly on cyclic orders. In Section 5.2, we extend to duration-constrained a priori policies the updating procedure of Goodson et al. (2012) for a cyclic order’s candidate route set. Although we summarize the cyclic-order approach and our modifications in this section, the reader is referred to Goodson et al. (2012) for more details.To compare the output of our simulated annealing procedure with solution values reported in the literature, we evaluate a priori policies using the take-all scheme of Mendoza et al. (2008); 2010); 2011). We do this because the literature does not report exact solution values for MCVRPSD problem instances, thus a comparison with such a benchmark is not possible.The take-all approximation assumes that when a route failure occurs at a particular customer, all demands for all products at that customer are served in full before replenishing capacity at the depot. The take-all approximation is achieved via a small modification to Eq. (5): in the third case, set the compartment capacity equal to Qp. Thus, the procedures outlined in Section 4 can be used to estimate and exactly calculate the take-all cost of an a priori MCVRPSD policy. Because exact evaluation via our procedures is limited to discrete customer demand distributions, we use the procedure of Mendoza et al. (2008); 2010); 2011) to evaluate the take-all cost when customer demands follow continuous distributions.Simulated annealing (Johnson et al., 1989; 1991; Kirkpatrick et al., 1983) is a local search algorithm in which non-improving moves are probabilistically accepted in an attempt to avoid becoming trapped in a low-quality, locally-optimal solution. Our simulated annealing procedure is executed in two phases. In the first phase, we estimate the take-all value of a priori MCVRPSD policies using the method outlined in Section 4.2, modified to accommodate the take-all scheme, as described above. The second phase seeks to improve the solution by exactly calculating the take-all value of a priori MCVRPSD policies. Because customer demands follow continuous distributions in the benchmark problem instances of Section 6.1, we employ the procedure of Mendoza et al. (2008); 2010); 2011) to calculate the take-all cost.The primary benefit of the two-phase procedure is reduction in computation time. Although the second phase can serve as a stand-alone solution procedure (and this yields good MCVRPSD solutions), initializing the second phase with the first-phase solution can accelerate discovery of high quality MCVRPSD solutions. Our experience suggests setting the number of randomly generated demand vectors to H = 3 in phase one is sufficient to identify quality initial solutions for phase two. For the problem instances we consider, setting H larger than 10 tends to negate the computational benefit of the first phase, i.e., the exact take-all calculation of Mendoza et al. (2008); 2010); 2011) is faster than estimating the take-all value via simulation. In Section 6.2, we present additional discussion on the effect of parameter H.Algorithm 2outlines the steps required to execute a single phase of our simulated annealing procedure. Three cyclic orders are maintained – πbest, πcurr, and πneigh – corresponding to the best-found, the current, and a neighbor cyclic order, respectively. An iteration of the inner loop begins on line 3 by randomly selecting one of five neighborhood structures proposed by Goodson et al. (2012): 1-shift, 2-shift, 3-shift, reverse, or exchange. Denoting the resulting neighborhood structure by U( · ), line 4 randomly selects a cyclic order πneigh in U(πcurr), the neighborhood of the current cyclic order. Line 5 probabilistically updates πcurr with πneigh, where ( y)+ = y if y > 0 and 0 otherwise, τ is the current temperature, and u( · ) is a function representing the evaluation of a cyclic order (see Goodson et al. (2012) for details) and returns the take-all value of the associated route set. Lines 6 and 7 update the best-found cyclic order. The inner loop terminates after β iterations. The outer loop implements a geometric cooling schedule and terminates after at least γ iterations and without having updated the best-found cyclic order for λ successive iterations.The first phase initializes πbest and πcurr with a radial ordering of customers about the depot (i.e., customers are ordered by their polar angle with respect to a horizontal axis through the depot). The second phase initializes πbest and πcurr with the best cyclic order returned in the first phase. In the first phase, we set the termination criteria via γ = 100 and λ = 20. In the second phase, we set γ = 200 and λ = 100. Phase one begins with an initial temperature of 10 and phase two begins with an initial temperature of 5. Based on computational tests that explore a wide set of parameters, we observe these parameters to perform well for the MCVRPSD instances considered in this paper. We vary the inner-loop iteration counter β as part of our computational experiments in Section 6.As discussed by Goodson et al. (2012), evaluation of a cyclic order is a two-step process. First, a set of candidate routes is generated. Second, the optimal routing solution with respect to the set of candidate routes is identified. When generating a neighbor cyclic order from a current cyclic order in a local search procedure, Goodson et al. (2012) show the respective sets of candidate routes may contain many of the same routes. To avoid the unnecessary task of generating these routes again, Goodson et al. (2012) develop an updating procedure to obtain the set of candidate routes for a neighbor cyclic order by updating the set of candidate routes for the current cyclic order.Goodson et al. (2012) employ their updating scheme to reduce the computational expense of a local search procedure for a single-compartment VRPSD. In their single-compartment problem, the primary operational constraint is a restriction on the expected demand assigned to an a priori vehicle route. The cyclic-order updating procedure of Goodson et al. (2012) exploits the fact that the expected load assigned to a route does not decrease when a customer is inserted into the route, regardless of the insertion point. In the MCVRPSD we consider in this paper, the main constraint is a limit on expected duration of an a priori route. Because the a priori MCVRPSD policy does not allow preemptive capacity replenishment, inserting a customer in an a priori route can lead to opportune route failures that decrease the expected route duration. Consequently, the cyclic-order updating procedure of Goodson et al. (2012) requires modification.The example in Fig. 1illustrates how the expected duration of an a priori route can decrease when an additional customer is inserted. The example displays a depot (node 0) and four customers (nodes 1, 2, 3, and 4) with Manhattan distances defined by a unit grid. The table in the top-right portion of Fig. 1 indicates that demands for customers 1, 2, and 4 are deterministic and that demand for customer 3 is stochastic. The table in the bottom-right portion of Fig. 1 displays the expected duration of two a priori routes for a single-compartment vehicle with a capacity of 30 demand units. When demand at customer 3 is 5 units, the duration of route (0, 2, 3, 4, 0) is 8; when demand at customer 3 is 15 units, a route failure occurs at customer 4, resulting in a duration of 16. Route (0, 1, 2, 3, 4, 0) experiences a route failure at customer 3 regardless of the demand realization, resulting in durations of 14. Thus, the expected duration decreases from 14.4 to 14.0 when customer 1 is added to the beginning of the visit sequence.To account for the possibility of a decrease in route duration when additional customers are inserted into an a priori route, we modify Proposition 1 of Goodson et al. (2012) by removing the latter portion of the proposition. Proposition 3 displays the modification, which uses the cyclic-order notation employed by Goodson et al. (2012). We modify the updating procedures accordingly by removing the “else break” statements in Algorithms 2, 3, and 4 of Goodson et al. (2012). Specifically, in Algorithm 2 of Goodson et al. (2012), we remove lines 15, 16, 26, 27, 37, and 38; in Algorithm 3 of Goodson et al. (2012), we remove lines 22 and 23; and in Algorithm 4 of Goodson et al. (2012), we remove lines 19, 20, 30, and 31. Removing the “else break” statements potentially requires additional iterations of the associated loops. However, the remaining lines in each loop require only a check of the cardinality of certain portions of the candidate route set, an O(1) operation. Thus, the modified updating procedure does not experience a significant slow down due to additional loop iterations.Proposition 3modified updating procedureFor all i, j ∈ {1, …, n}, if|R(π(i))|>dist(i,j),then|Λ(π(i),π(j))|=|R(π(i))|−dist(i,j).We perform two sets of computational experiments. Problem instances are described in Section 6.1. In Section 6.2, we explore the computational behavior of the exact MCVRPSD a priori policy evaluation procedure of Section 4.1 and examine the performance of the simulation-evaluation procedure proposed in Section 4.2. In Section 6.3, we study how our cyclic-order-based simulated annealing procedure performs relative to methods from the literature. As discussed in Section 5, because the literature does not report exact solution values for the benchmark problem instances, and to ensure a fair comparison, our simulated annealing procedure evaluates a priori policies via the take-all approximation. We implement our procedures in C++ and execute all computational experiments on 2.8 gigahertz Intel Xeon processors with 12–48 gigabytes of RAM running the CentOS 5.3 operating system.We perform computational experiments on the set of 180 benchmark problems employed by Mendoza et al. (2010); 2011). The problems are composed of three sets of 60 with N = 50, N = 100, and N = 200 customer instances, respectively. Customers are spread randomly over a Euclidian space. Each customer has demand for P = 3 products. Demand for product p at customer n is normally distributed with a mean value chosen randomly from the range [10, 100]. In each set of 60 problems, half of the instances set the standard deviation such that the coefficient of variation is 0.1 and half of the instances set the standard deviation such that the coefficient of variation is 0.3. The duration limit for a given problem is set toL=α·maxn∈N∖{0}t(0,n),where α is chosen randomly from the range [3, 4]. Compartment capacity Qpfor product p is set to10·maxn∈N∖{0}E[Dn,p],rounded to the nearest integer (this corrects a minor oversight in Mendoza et al. (2010); 2011)). Setting capacities in this fashion guarantees the ratio of compartment capacity to each customer demand is at least 10, thereby ensuring the take-all scheme yields a very accurate approximation of the expected cost of an a priori policy (Mendoza et al., 2008).To study the computational requirements of the exact MCVRPSD a priori policy evaluation procedure of Section 4.1, we apply Algorithm 1 to a priori routes with various numbers of products, locations, and support sizes. We allow the number of products P to take on values in the set {1, 2, 3, 4, 5, 6}. We consider route sizes |v| in the set {3, 4, 5, 6, 7}. Because the depot is the first and last location, these routes serve 1, 2, 3, 4, and 5 customers, respectively. Each customer on the route has the same support for each demand and for each product. Supports sizes|S(Dn,p)|take on values in the set {1, 3, 5}. These parameter combinations lead to 90 different a priori routes. For each route, we calculate the exact policy value via Algorithm 1 and estimate the policy value via Eq. (9) with the number of randomly generated demand vectors H taking on values in the set {10, 100, 1000, 10, 000, 100, 000}. In our implementation, expanding parameters beyond these values is often not possible due to Algorithm 1’s demands on computer memory.We perform our experiments on problem instance number 1 of Mendoza et al. (2010); 2011); Appendix C identifies this problem instance. We use only the customer locations specified in the problem. An a priori route with x customers is the sequence v = (v0 = 0, v1 = 1, v2 = 2, …, vx= x, vx + 1 = 0). We set all compartment capacities to 20 demand units. Customer demands for each product follow a discrete uniform distribution with mean 10 and support in the range [5, 15]. Specifically, for sizes of 1, 3, and 5, we set customer demand supports for each product to {10}, {5, 10, 15}, and {5, 7.5, 10, 12.5, 15}, respectively.Tables 1, 2, and 3display the computing time required for various numbers of products, support sizes, and route sizes, respectively. The first column of each table lists the respective parameters. The second and third columns of each table show the number of CPU seconds, averaged across all other parameters, required to exactly calculate and estimate the value of MCVRPSD a priori policies. Tables 1and 2 support Proposition 2: the computation required to execute Algorithm 1 is exponential in the number of products and the size of the supports. Table 3 demonstrates computation time also increases with route size, although not as dramatically.Because optimization routines often evaluate large numbers of MCVRPSD a priori policies, utilizing the exact evaluation procedure of Algorithm 1 is only practical for small problem instances where the result can be obtained in a reasonable amount of time. For problems of practical interest, policy value estimation provides a computationally viable alternative. In contrast to the exact evaluation procedure, Tables 1, 2, and 3 suggest computing time required to estimate policy values is nearly constant across product number, route size, and support size. Although in principle we should observe an increase in CPU time as various parameter values increase, this growth is insignificant compared to the computational overhead required to manage the data structures facilitating the experiment. As demonstrated by Table 4, the number of CPU seconds required to estimate policy values grows linearly with H, the number of randomly generated demand vectors. Thus, evaluation via simulation is a computationally attractive alternative to exact evaluation.For a route with size |v| = 7, P = 6 products, and customer supports of size|S(Dn,p)|=3,Fig. 2graphically depicts simulation estimation error relative to the exact policy value and to the take-all approximation. For each value of H, the error bars represent the 95 percent confidence interval around the estimate. As expected, the estimate becomes more accurate and confidence interval widths decrease with an increase in sample size. Because we use Algorithm 1 to obtain the take-all approximation (modified as described in Section 5), the computing time is comparable to the time required to calculate the exact value. When convolutions are straightforward to compute, the method of Mendoza et al. (2008); 2009); 2011) quickly obtains the take-all value. For a more in-depth comparison of exact versus approximate values, we refer to Mendoza et al. (2008).We explore the performance of our cyclic-order simulated annealing procedure with different values of β, the number of neighbor cyclic orders generated at each temperature in Algorithm 2. For each of the 180 benchmark problems, and for each value of β in the set {1000, 3000, 5000, 7000, 10, 000, 15, 000}, we execute our simulated annealing algorithm 10 times.Fig. 3summarizes the results of our experiments. The horizontal axis displays the values of β we consider, bars are associated with the left vertical axis, and lines are associated with the right vertical axis. We aggregate results by 50-, 100-, and 200-customer problem instances. For a given problem instance and value of β, we calculate the percent decrease in cost of our average solution value across 10 runs over the value of the best-found solution of Mendoza et al. (2010); 2011). We also calculate the percent decrease in cost of the best solution value across 10 runs over the value of the best-found solutions of Mendoza et al. (2010); 2011). The percent decreases in cost over best-known solution values are displayed in the bar series. Two numbers are displayed over each member of the “best” bar series. The top number indicates the number of problem instances, out of 60, for which our best-found solution value improves upon the best-found solution value of Mendoza et al. (2010); 2011). The bottom number indicates the number of problem instances, out of 60, for which our best-found solution value matches the best-found solution value of Mendoza et al. (2010); 2011). For example, when β = 1000 and N = 50 customers, the average percent decrease in cost of our best-found solution values over the best-found solution values of Mendoza et al. (2010); 2011) is 0.37 percent; our best-found solution values improve upon the best-found solution values of Mendoza et al. (2010); 2011) in 37 of 60 problem instances; our best-found solution values match the best-found solution values of Mendoza et al. (2010); 2011) in 21 of 60 problem instances; and our best-found solution values do not improve upon or match the best-found solution values of Mendoza et al. (2010); 2011) in 2 of 60 problem instances. For a given problem instance and value of β, we calculate the average CPU minutes across 10 runs of our simulated annealing procedure. A point on a line series aggregates this average across 60 problem instances. For example, when β = 1000 and N = 50 customers, the average number of CPU minutes required to execute a single run of the simulated annealing algorithm is 3.16. Disaggregated results of our computational experiments are provided in Appendix C.The bar series in Fig. 3 indicate that best and average percent decrease in cost over best-known solutions values increases as β increases. This trend is expected, although improvements over best-known solution values are more pronounced for problem instances with 100 and 200 customers. Moreover, for these larger problems, our cyclic-order simulated annealing procedure improves the best-known solution values on all 120 instances when β is 7000 and larger. Collectively, we improve the best-known solution values on 159 of 180 problem instances and match the best-known solution values on the remaining 21 problem instances. Because our cyclic-order solution procedure is not tailored to the MCVRPSD, these results, in conjunction with the results of Goodson et al. (2012), support cyclic-order-based local search as an effective solution procedure for a variety of routing problems.Fig. 3 shows computation times tend to increase linearly with β, but at a steeper rate for larger a positive correlation between computation time and percent decrease over best-known solution values, particularly for larger problem instances. Thus, the choice of parameter β may be used to manage the tradeoff between computation time and solution quality. Because most practitioners use a priori routes over extended periods of time (Savelsbergh and Goetschalchx, 1995), a large upfront investment in computing time may be acceptable. However, the computational requirements of our procedure may be prohibitive if the method is to be used as part of a heuristic scheme to dynamically manage vehicle operations (e.g., Goodson et al. 2013). In such cases, the construction heuristics of Mendoza et al. (2011) may yield adequate-quality solutions in acceptable CPU times.

@&#CONCLUSIONS@&#
