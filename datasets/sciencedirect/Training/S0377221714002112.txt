@&#MAIN-TITLE@&#
2DCPackGen: A problem generator for two-dimensional rectangular cutting and packing problems

@&#HIGHLIGHTS@&#
A general problem generator for all two-dimensional rectangular cutting problems is described and made available.A full characterization of every problem, in terms of input data, is given.Instances’ properties are controlled by a beta probability distribution, reflecting real-world characteristics.

@&#KEYPHRASES@&#
Cutting and packing,Two-dimensional rectangular cutting,Problem generator,

@&#ABSTRACT@&#
Cutting and packing problems have been extensively studied in the literature in recent decades, mainly due to their numerous real-world applications while at the same time exhibiting intrinsic computational complexity. However, a major limitation has been the lack of problem generators that can be widely and commonly used by all researchers in their computational experiments. In this paper, a problem generator for every type of two-dimensional rectangular cutting and packing problems is proposed. The problems are defined according to the recent typology for cutting and packing problems proposed by Wäscher, Haußner, and Schumann (2007) and the relevant problem parameters are identified. The proposed problem generator can significantly contribute to the quality of the computational experiments run with cutting and packing problems and therefore will help improve the quality of the papers published in this field.

@&#INTRODUCTION@&#
Cutting and packing problems are hard combinatorial optimization problems that arise in the context of several real-world applications, both in industry and services, whenever one or more large objects have to be divided into smaller items, so that waste is minimized. Typical problems include cutting paper rolls into narrower rolls in the paper industry, cutting large boards of wood into smaller rectangular panels in the furniture industry and cutting irregular shaped components of garment from fabric rolls, while its usage also extends to packing boxes into containers or loading items on pallets in logistics applications. Different variants and objectives may be considered depending on the practical context where the problem arises. However, all problems have in common the existence of a geometric sub-problem, originating from the natural item non-overlapping constraints.Due to their wide ranging applicability and level of difficulty, these problems have received an increasing amount of attention in the literature. With the seminal papers published in the sixties, the number of publications has grown extraordinarily. In order to provide organization to the cutting and packing problems and the literature on this topic, a first typology using categories was proposed by Dyckhoff (1990). However, a recent decisive contribution was given by Wäscher et al. (2007) with an improved typology for cutting and packing problems. In addition to the unification of definitions and notations, the recent typology also facilitated access to the relevant literature of each cutting and packing problem category. In this paper we will adopt the improved typology of Wäscher et al. (2007).Nevertheless, one limitation still impinges on researchers in the field of cutting and packing problems: the absence of appropriate test problems and problem generators which can be widely and commonly used by all researchers in their computational experiments.A problem generator was proposed by Gau and Wäscher (1995) for one dimensional problems. For the pallet loading problem a complete set of benchmark problems are available and a review can be found in Silva, Oliveira, and Wäscher (in preparation). However, for the remaining cutting and packing problems, and in particular for the two-dimensional rectangular cutting problem, computational experiments are conducted over classical sets, usually without any critical analysis of their current difficulty, with each author adding a few self-generated instances.To the best of our knowledge six problem generators have been proposed for two-dimensional (2D) rectangular cutting and packing problems, which will be described in the following paragraphs, together with their main limitations. A common, and arguably the most relevant limitation, is their lack of generality.The first problem generator for two-dimensional rectangular cutting problems was proposed by Berkey and Wang (1987) and addressed the 2D rectangular Bin Packing Problem. The length and width of the small items are sampled, following a uniform distribution, from three different intervals and, for each interval, two different square large object sizes are considered. Therefore, six classes of problem instances are created. Classes I and II consider the range[1,10]for the length and width of the small items and the sizes of the square large objects are10×10and30×30, respectively. For Classes III and IV the interval for the items’ dimensions is[1,35]and the square large objects have size40×40and100×100, respectively. Finally, Classes V and VI are obtained by considering the range[1,100]for the length and width of the small items and by considering square large objects with sizes100×100and300×300, respectively.In Martello and Vigo (1998) the generation of eight classes of instances is proposed, also for the 2D rectangular Bin Packing Problem. The length and the width of the large rectangular objects is fixed at 100 and four types of items are considered. By combining different ranges for the uniform probability distribution in the generation of the length and width of the small items, the shape of the items is controlled: items of type 1 are long and short, items of type 2 are tall and narrow, items of type 3 are square and long and items of type 4 are square and small. The different classes are generated by stipulating different percentages of the four item types, with the class with 70% of items being of type 4 (small and square) reported as the hardest one to solve. Each class is further divided into five subclasses by considering different numbers of items in each instance (20, 40, 60, 80 and 100) where the optimal solution for each instance is not known.Based on Martello and Vigo (1998)’s scheme of generating different classes of problems by combining different percentages of different item types, Fekete and Schepers (2000) presented a generator for the 2D rectangular Single Large Object Placement Problem. The problem instances are characterized by three parameters: the type of instance, the number of different large objects and the maximum number of copies of each item type. Three types of instances are considered: I, II and III, which are obtained through the combination of different percentages of four types of items: bulky in width, bulky in length, large and small. The number of different item types considered in Beasley (2004) was 40, 50, 100, 150, 250 and 1000. The maximum number of items of each type that can be placed on the large object is 1, 3 and 4. The small items sizes were obtained by sampling from the uniform distribution over specific ranges, as defined in Fekete and Schepers (2000), and the value of each item type is obtained by multiplying its area by an integer number randomly chosen from the set{1,2,3}.In Wang and Valenzela (2001) a procedure is proposed for the generation of data sets for the problems of packing as many rectangles as possible, from a given set of small rectangular items, on a single rectangular large object, with minimum waste, or on a (top) open strip with a minimum height (the strip packing problem). The procedure consists of recursively generating rectangles by applying guillotine cuts to the previously generated rectangles, which afterwards can be placed into rectangular regions with no waste. For these instances the value of the optimal solution is known and the optimal patterns have zero waste. In the generation process the user can control the aspect ratio and the area of the items, however the distribution of the shapes and sizes of the items are not controlled.Egeblad and Pisinger (2009) proposed the ep2 generator for the 2D rectangular Knapsack Problem. By randomly generating the dimensions of the items in specified ranges, five different shapes for the items are considered: tall (T), wide (W), square (S), uniform (U) and diverse (D). Additionally, two types of classes are considered: clustered (C) and random (R). In the clustered classes 20 items are randomly generated considering one item shape whereby some of the generated sizes are repeated, while in the random class all items are (randomly) independently generated. The instances are generated considering 30, 50, 100 and 200 items and the value of each item is equal to its area multiplied by 1, 2 or 3. The height of the large object is equal to two times its width and the large object area is equal to 25 % or 75% of the total area of the items. It is important to stress that in each instance only one type of shape is considered.A problem generator for the 2D rectangular Single Large Object Placement Problem with a single defect is presented in Neidlein and Wäscher (2008). This generator accepts the following set of parameters:L,W,n,sL,sU,ld,wd, where L and W are the length and width of the large objects, respectively, n is the number of different small item types,sLandsUare the lower and upper bound for the relative size of the items in relation to the large object area, respectively, andldandwdare the dimensions of the defect. The dimensions of the items are generated by first uniformly generating its areaaifrom[sL·L·W,sU·L·W]and then its dimensions are subsequently generated by considering the aspect ratiobi=lili+wiin the interval[0.1,0.9]andli=ai·bi1-biandwi=aili. The location of the defect is obtained by considering the intervals[0,L-ld]and[0,W-wd]for the lower left cornerxdandydof the defect. For the generation of values in the defined ranges a pseudo-random number generator is used, which ensures the reproducibility of the data. The authors point out that this generator can also be used for the 2D rectangular Single Large Object Placement Problem by ignoring the data on the defect.The lack of appropriate test problems for each type of cutting and packing problem also led to the adaptation of existing instances to solve problems for which they were not designed. A good example is the gcut data set, which was proposed by Beasley (1985) for the Single Large Object Placement Problem (SLOPP). This data set has been adapted and also used for testing algorithms for other problems, such as the Single Stock Size Cutting Stock Problem (SSSCSP), the Multiple Stock Size Cutting Stock Problem (MSSCSP) and the Open Dimension Problem (ODP) in Cintra, Miyazawa, Wakabayashi, and Xavier (2008) or the Single Knapsack Problem (SKP) in Caprara and Monaci (2004).Computational experiments are run to demonstrate the superiority of an algorithm regarding the quality of solutions or the computational times, as well as to identify its limits and its behavior. Therefore, when the right instances are not used to test the algorithms, the foundations for claiming the superiority of an algorithm over others may be rather weak. This is particularly important when most of the algorithms developed and published are heuristics, due to the computational complexity of cutting and packing problems.To overcome the drawback of the lack of general 2D cutting and packing problem generators, this paper proposes a problem generator for 17 types of 2D rectangular cutting and packing problems (2DCPackGen). The problem generator will allow the generation of a large number of problem instances under controlled conditions and with specific desired properties, which provides the ground for systematic testing by varying problem parameters, while also allowing faster access to test problems for different types of 2D rectangular cutting and packing problem.The remaining part of this paper is organized as follows: In Section 2, an overview of 2D cutting and packing problems, based on Wäscher et al. (2007)’s typology, will be presented. In Section 3, the parameters needed to describe a problem instance for each 2D rectangular cutting and packing problem are identified and summarized. The probability distributions used by 2DCPackGen are defined in Section 4 and a description of the value generation for each problem parameter is provided. In Section 5 a problem instance generation example is presented. In Section 6 some details of the 2DCPackGen generator implementation and of the warnings issued by it are described. Some conclusions are presented in Section 7 of the paper.According to the improved typology of Wäscher et al. (2007), cutting and packing problems can be classified into different basic problem types based on two criteria: the kind of assignment of the small items to the large objects and the assortment of small items.The kind of assignment of the small items to the large objects differs in the objective: output value maximization or input value minimization. In the output value maximization case, the goal is to assign a selection of items, with maximum value, to the large objects, whereas in the input minimization problem all items have to be assigned to a selection of large objects that has the minimum value.The assortment of small items is categorized into the following three types: identical, weakly heterogeneous and strongly heterogeneous. An identical assortment of small items means that all items are of the same size and shape. In a weakly heterogeneous assortment of small items, the items can be grouped into classes, in which they are equal according to their shape and size. Furthermore each class (item type) has a relatively large demand. In a strongly heterogeneous assortment of small items, very few items are equal with respect to their shape and size and if that occurs, the items are treated as belonging to different types, thus the demand of each item type is equal to one. Three basic problems are identified in the typology regarding the output maximization objective: the Identical Item Packing Problem (IIPP), if the small items are all identical, the Placement Problem (PP), if the assortment of small items is weakly heterogeneous and the Knapsack Problem (KP), if the assortment of small items is strongly heterogeneous. In these three problems types, the large objects are not sufficient to completely accommodate all the items. When the input minimization objective is considered, three basic problems are also defined: the Open Dimension Problem (ODP) in which one of the dimensions is variable, the Cutting Stock Problem (CSP) where the assortment of small items is weakly heterogeneous and the Bin Packing Problem (BPP), characterized by a strongly heterogeneous assortment of small items.Besides the definition of basic problem types, the classification of the cutting and packing problems is characterized by a third criterion, the assortment of the large objects, which combined with the basic problem types defines a new level, the intermediate problems. The assortment of large objects is divided in two types: one large object and several large objects. In the one large object case, either the dimensions of the single large object are fixed or one or more dimensions are variable. When several large objects are available, the assortment of the large objects can be divided into three types: identical large objects, weakly heterogeneous and strongly heterogeneous, in a similarly manner to the assortment of small items.The Identical Item Packing Problem has no intermediate level due to its very simple structure. If only one large object is used for the Placement problem, this problem is the called the Single Large Object Placement Problem (SLOPP); if several large objects are considered and if the large objects are identical, the problem is referred to as a Multiple Identical Large Object Placement Problem (MILOPP) and, finally, if the large objects are composed of a heterogeneous assortment, the problem is identified as a Multiple Heterogeneous Large Object Placement Problem (MHLOPP). The intermediate problem types of the Knapsack Problem are: the Single Knapsack Problem (SKP), if only one large object is used, the Multiple Identical Knapsack Problem (MIKP), if identical large objects are used, and the Multiple Heterogeneous Large Object Placement Problem (MHLOPP) if several large objects are used and are characterized by a heterogeneous assortment.Notice that in the improved typology of Wäscher et al. (2007), for the intermediate problem types related to the output maximization basic problem types, no distinction is made concerning the heterogeneity of the assortment of the large objects. Nevertheless, we will here distinguish between weakly and strongly heterogeneous assortments of large objects and the following notation is adopted: MHLOPP/W, MHLOPP/S for the Multiple Heterogeneous Large Object Placement Problem with a weakly and a strongly heterogeneous assortment of the large objects, respectively, MHKP/W and MHKP/S for the Multiple Heterogeneous Knapsack Problem with a weakly and a strongly heterogeneous assortment of the large objects, respectively, and ODP/W and ODP/S for the Open Dimension Problem with a weakly and a strongly heterogeneous assortment of the width of the large objects, respectively.For the input minimization basic problem types, the intermediate problem types of the Cutting Stock Problem and of the Bin Packing Problems are the following: if the large objects are identical, we have the Single Stock Size Cutting Stock Problem (SSSCSP) or the Single Bin Size Bin Packing Problem (SBSBPP), if the large objects’ assortment is weakly heterogeneous, the intermediate problem is the Multiple Stock Size Cutting Stock Problem (MSSCSP) or the Multiple Bin Size Bin Packing Problem (MBSBPP), and if the large objects’ assortment is strongly heterogeneous, the intermediate problem is the Residual Cutting Stock Problem (RCSP) or the Residual Bin Packing Problem (RBPP).A schematic diagram showing the relationships between the basic problem types and the intermediate problem types is presented in Fig. 1.The refined problem types are defined by means of the dimensionality and of the shape of the small items’ criteria. Dimensionality in this paper covers 2D problems and in terms of the small items’ shape we will focus on rectangular items.Therefore, in this work we will deal with the 2D rectangular cutting and packing problem that, generically, can be stated as follows: a set of small rectangular items, each itemi∈{1,2,…,n}of lengthli, widthwiand valuevihas to be assigned, with a minimum amount ofdiland a maximum amountdiu, to a set of large rectangular objects, each large objectj∈{1,2,…,m}of lengthLj, widthWj, valueVjand available in a limited amount ofDjunits, while respecting the geometric conditions, i.e. that the items lie entirely within the large object and do not overlap each other.In this section, the parameters required to characterize a problem instance for each 2D rectangular cutting and packing problem are identified. However, these problem parameters will not be used as an input for the generator. Instead, information regarding desired characteristics for the generator output data (e.g. maximum and minimum number of different large objects, shape and area of the rectangles, etc.) will be entered. The actual problem parameters will be automatically generated taking into account these characteristics. In this section we will focus on the problem parameters and in the following section on how these parameters will be handled by the generator.In Table 1the problem parameters for general 2D rectangular cutting and packing problems are presented. The tuplem,Lj,Wj,Dj,Vj,n,li,wi,dil,diu,viforj∈Jandi∈Ican be used to generically define a problem instance of the 2D rectangular cutting and packing problem.This general tuple serves as the basis for the definition of the particular tuple for any problem instance of each 2D rectangular intermediate problem type. The different specifications and characteristics of each intermediate problem type allows the values to be set for some additional parameters, which are not used in the tuple of the respective problem. This is the case of parameterVj, representing the value of the large object of type j, which is not considered in problems with output value maximization to be an assignment type problem. This type of problem is characterized by the complete utilization of the large objects, meaning that their value is not considered, unlike the value of the associated items. Similarly, the problems characterized by input value minimization do not require the value of the itemvias a parameter, since all the items have to be accommodated in the large objects.The IIPP consists of assigning the maximum number of identical small items to a given large object. The number of distinct small items and the number of distinct large objects is one, thusm=1andn=1. Thereby, a problem instance for the IIPP is characterized by the length and width of one large object and by the length and width of the small item type and can be represented by the tuple(L1,W1,l1,w1). Since only one large object is considered in this problem,D1=1, and with no value attributed to the large object, the parameterV1is not needed. The minimum and maximum number of small items that must be cut are generally set withd1l=0andd1u=∞and the value of the small item is one,v1=1, since the objective is to maximize the number of small items placed on the large object.The PP is defined by a weakly heterogeneous assortment of the small items that have to be assigned to a limited set of large objects. The items have a limit on the minimumdiland maximumdiuquantity which must be placed and can have values equal or different to their area (vi=li×wiorvi≠li×wi). The objective is to minimize the waste, or alternatively maximize the value of the items placed on the large object. The number of large objects available is not sufficient to accommodate all the small items.The SLOPP is characterized by the assignment of a weakly heterogeneous assortment of small items to a single large object, thusm=1andD1=1. A problem instance for the SLOPP can be characterized by the tupleL1,W1,li,wi,dil,diu,vifor alli∈I.The MILOPP is similar to the SLOPP, however more than one large object is considered. In this case one large object type is available i.e.m=1with several copies, which meansD1>1, but the set of large objects is still not enough to accommodate all the items. Consequently a test instance for the MILOPP can be described by the tupleL1,W1,D1,li,wi,dil,diu,vifor alli∈I.The MHLOPP/W consists of assigning a weakly heterogeneous assortment of small items to large objects of several sizes (m>1) with a weakly heterogeneous assortment, i.e.Dj>1. Therefore, a problem instance for the MHLOPP/W can be represented by the tupleLj,Wj,Dj,li,wi,dil,diu,vifor allj∈Jand for alli∈I.The difference between the MHLOPP/W and the MHLOPP/S is the assortment of large objects, which for the later problem is strongly heterogeneous. This means that the large objects are all different, thus only one copy of each size is available (Dj=1). A test problem for the MHLOPP/S is characterized by the tupleLj,Wj,li,wi,dil,diu,vifor allj∈Jand for alli∈I.The KP is characterized by a strongly heterogeneous set of small items which have to be placed onto a given set of large objects. The number of large objects is limited in such a way that not all items can be packed. Since the items are strongly heterogeneous their dimensions are all different and sodil=0diu=1fori∈I. The value of the items can be equal or different to their area (vi=li×wiorvi≠li×wi), such as in the PP.In the SKP only one large object is available, thereforem=1andDj=1and a problem instance can be represented by the tuple(L1,W1,li,wi,vi)fori∈I.The large objects in the MIKP are only of one type,m=1, and are available in a quantity greater than one, i.e.D1>1. The tuple which represents a problem instance for a MIKP is(L1,W1,D1,li,wi,vi)fori∈I.The MHKP/W consists of assigning a strongly heterogeneous assortment of small items to large objects of several sizes (m>1) with a weakly heterogeneous assortment, i.e.Dj>1. The tuple(Lj,Wj,Dj,li,wi,vi)withj∈Jandi∈Iis adopted to represent an instance for the MHKP/W problem.The MHKP/S is a KP in which the number of different large object types is greater than one and the large objects are all different. Therefore,m>1andDj=1and the tuple considered to represent the problem is(Lj,Wj,li,wi,vi)for allj∈Jand for alli∈I.In the CSP a given set of weakly heterogeneous small items has to be completely placed on a selection of large objects. The goal is to obtain the allocation that minimizes the value, the number, or the total size of the large objects.Since all the items have to be placed on the large objects, the minimum and maximum amount of each small item type, which has to be cut, is equal, i.e.dil=diufor alli∈I.In the SSSCSP a sufficiently large number of identical large objects is available to accommodate all small items. This means thatm=1andD1=∞and since the large objects are identical,V1=1. The tuple representing a problem instance for the SSSCSP isL1,W1,li,wi,dil.In the MSSCSP more than one large object type (m>1), in a limited quantity for each type (Dj>1) but globally sufficient to accommodate all small items, is available. For each large object type a value can be assigned, which can be equal or different to its area (Vj=Lj×WjorVj≠Lj×Wjfor allj∈J). A problem instance for the MSSCSP is represented by the tupleLj,Wj,Dj,Vj,li,wi,diufor allj∈Jand for alli∈I.The RCSP is characterized by a strongly heterogeneous assortment of large objects. This means that almost all large objects have different sizes, and, even if they are equal, those large objects are treated as belonging to distinct types, thusDj=1. As in the MSSCSP, in the RCSP a value can be assigned to the large objects, which can be equal or different to its area (Vj=Lj×WjorVj≠Lj×Wj). Any problem instance of the RCSP can be represented by the tupleLj,Wj,Vj,li,wi,diufor allj∈Jand for alli∈I.In the BPP a set of strongly heterogeneous small item types has to be assigned to a set of large objects, minimizing the value, the number, or the total size of the necessary large objects. Since the assortment of the small item types is strongly heterogeneous, for any BPP problem instance it is considered thatdil=diu=1for alli∈I.In the SBSBPP a sufficiently large number of identical large objects exists, meaningm=1andD1=∞, and a strongly heterogeneous set of small items is given. The objective is to pack all the items into the minimum number of large objects, and since the large objects are identicalV1=1. Any problem instance of the SBSBPP can be represented by the tuple(L1,W1,li,wi)for alli∈I.In this BPP the set of large objects has a weakly heterogeneous assortment. This means that several large objects are available in different types, thusm>1andDj>1for allj∈J, in a quantity large enough to accommodate all the items. As in the MSSCSP the large objects can have values associated with them which can be equal or different to the area (Vj=Lj×WjorVj≠Lj×Wjfor allj∈J). Any problem instance of the MBSBPP can be represented by the tuple(Lj,Wj,Vj,Dj,li,wi)for allj∈Jand for alli∈I.This problem is characterized by a strongly heterogeneous assortment, both of the large objects and of the small items. Therefore,m>1andDj=1and again a value can be associated with the large objects. An instance of the RCSP is characterized by the tuple(Lj,Wj,Vj,li,wi)for allj∈Jand for alli∈I.The ODP is characterized by a set of small items which has to be completely placed on one or more large objects (m⩾1). The large objects have one of their dimensions fixed and the other variable, with the objective being to determine the allocation of the items to the large objects which minimizes the large objects’ length used or the value of the used large objects’ area (Vj).The ODP/W is characterized by a weakly heterogeneous assortment of large objects, meaning that more than one widthWjis considered and there is a given quantity available of each typeDjwith a valueVj. An instance for the ODP/W can be described by the tupleWj,Dj,Vj,li,wi,diu.In the ODP/S the large objects have a strongly heterogeneous assortment, and therefore one or more (j⩾1) widthsWjare considered and only one copy of each width is availableDj=1. A test problem for the ODP/S is characterized by the tupleWj,Vj,li,wi,diu.In this paper, a problem generator for each 2D rectangular intermediate problem type is proposed. Depending on the problem type, different parameters have to be considered for the generation of the problem instances. The defined tuples for the different intermediate problem types have in common the dimensions of the large objects (LjandWj) and the dimensions of the small items (liandwi). However depending on the problem, the values of the parametersm,Dj,Vj,dil,diuandvican be free, fixed or not even used. Table 2provides an ID for each problem given their intermediate problem type along with a summary of the parameters and the tuples used. The dashes indicate the parameters that must be generated for each problem, in addition toLj,Wj,liandwi.The problems with output value maximization, defined by the assignment of the small items to the large objects, take into consideration the parameter for the value of the small items (vi) while, in contrast, the value of the large objectsVjis not used. The reverse occurs in problems of input value minimization, where the kind of assignment requires that all the small items must be placed and thus the value of the large objects (Vj) is used instead of the value of the small items (vi).A problem instance for a given 2D rectangular cutting and packing problem is described by the tuple previously defined. The role of the 2DCPackGen is to randomly fix the values for each parameter of the respective problem tuple.The distribution most commonly used for the generation of these parameters is the uniform distribution, however the 2DCPackGen is built on sampling the beta distribution Gupta and Nadarajah (2004), due to its extreme versatility. The standard beta distribution is a continuous probability distribution with probability density function given by:(1)f(x;α,β)=xα-1(1-x)β-1∫01μα-1(1-μ)β-1dμ,0⩾x⩾1andα>0andβ>0.The main advantage of using the beta distribution function is its flexibility, as it assumes a variety of different shapes, depending on the values of its parametersαandβ. In Fig. 2a graphical representation of the beta distribution is presented for seven combinations ofαandβparameters. Forα=β=1the beta distribution simply becomes a uniform distribution between 0 and 1 and forα=β=2a distribution with a parabolic shape is obtained. Generally, ifαandβare both greater than one, the beta distribution has a single mode atx=α-1α+β-2and with value zero at the end-points. Ifαand/orβis less than one, thenlimx→0f(x)=∞and/orlimx→1f(x)=∞and the distribution is said to be J-shaped. These seven combinations of the beta distribution, depicted in Fig. 2, were adopted in the 2DCPackGen.The inverse transform sampling technique is used for generating random numbers from the beta distribution. In order to ensure the portability and reproducibility of the test data, a uniform pseudo-random generator was implemented. This is the same pseudo-random generator used in Gau and Wäscher (1995) and in Neidlein and Wäscher (2008), which is a special variant of the multiplicative congruential method attributed to Lehmer (Hutchinson, 1966).A sequence of integer random numbersx1,x2,…is defined through the recursive formula:(2)xn+1=axnmodp,where p is a prime number anda∈{1,2,…,p-1}. The listx1,x2,…is obtained by assigning an initial seedx1, from the set{1,2,…,p-1}. It is considered thatp=231-1=2,147,483,647anda=16,807. Thus, the initial seed must be an integer belonging to the set{1;2;…;2,147,483,646}and the generator has a full period of length 2,147,483,646. The random numbers uniformly distributed in the open interval (0,1) are obtained by dividing the integer random numbersx1,x2,…by p.The product of a byxnproduces overflow on most contemporary computers. To avoid this problem an approximate factorization of p is adopted, that is,(3)p=aq+r,q=pa,r=pmoda,where⌊pa⌋is the integer part ofpa. Forr<qand0<xn<p-1,axnmodpcan then be calculated as follows:(4)axnmodp=a(xnmodq)-rxnqifa(xnmodq)-rxnq⩾0,a(xnmodq)-rxnq+potherwise.The valuesq=127,773andr=2836were adopted as suggested by Schrage (1979). The seedx1is not selected in advance and therefore it is essential that the seed used in the 2DCPackGen is always provided with the computational results, in order to enable other users to reproduce the respective data sets. It is important to stress that all values generated are integers.Both the large objects and the small items are rectangles and, as opposed to some previous problem generators, in 2DCPackGen their dimensions are not independently generated.The size and the shape of the rectangles, both the large objects and the small items, are controlled by the assignment of different values to theαandβparameters, leading to different beta distributions. By using the same interval[Min,Max]for both the length and width dimensions, combined with beta distributionsf(x,2,5),f(x,5,2),f(x,2,2)andf(x,0.5,0.5), sixteen different types of size and shape are obtained for the large objects and small items.In Fig. 3the sixteen different types of size and shape of the rectangles are presented. For example, iff(x,2,5)is used for generating the length and the width, then it is most likely that the pseudo-random generated values are close to the defined minimum, and thus the rectangle will be small and square.For the generation of the values related to the dimensions of the large objects (LjandWjforj∈J) in the 2DCPackGen, the user only has to define the minimum and maximum dimension and select one of the sixteen characteristics of their size and shape. For generating the dimension of the small items (liandwifori∈I) the procedure is similar.The problem parameters related to the number of distinct small item types (n), the number of distinct large object types (m), the limit on the availability of the large object of type j (Djforj∈J) and the parameters for the minimum and maximum number of small item types that must be cut (dil,diu, fori∈I) are generated using a user assigned minimum and a maximum value for each parameter, and through the selection of one of the seven types of beta distributions considered:f(x,1,3),f(x,2,5),f(x,2,2),f(x,0.5,0.5),f(x,1,1),f(x,3,1)andf(x,5,2). In Fig. 4a representation of these different shapes of the beta distribution is presented.For the parameters related to the value of each large object type (Vjforj∈J) and to the value of each item type (vifori∈I) the user must provide a interval between 0.5 and 1. The value for each rectangle type is then sampled from the Uniform distribution, which is the beta distributionf(x,1,1), between the minimum and the maximum value defined in the interval times the area of the large object type or the area of the item. If the range [1,1] is provided, the value of each large object type or of each item type is equal to its area.In conclusion, the generator parameters (data entered by the generator user), as applicable to each problem type, are outlined in Table 3.In this section an example utilizing 2DCPackGen is presented, in which two problem instances for the Single Stock Size Cutting Stock Problem (SSSCSP) are generated. The pseudo code of the 2DCPackGen is presented in Algorithm 1. A problem instance for the 2D rectangular SSSCSP is represented by the tupleL1,W1,li,wi,dil, and in this problemm=1,D1=1,V1=1anddil=diu. In Table 4the data entered by the 2DCPackGen user is presented.The size of the large object (L1,W1) is generated in the interval [100,200] and it is required that its shape and size is big and square, which means that the beta distributionf(x,5,2)is used for the generation of the length and the width. The number of different small items (n) is sampled in the interval[10,15]by the beta distributionf(x,1,1), which is the uniform distribution. The length and width of small items will be in the range[10,80]and their size and shape will be of type small and square or long and narrow. The interval[10,50]is used for the generation of the demanddilof the small items, as characterized by the beta distributionf(x,2,2).The instances generated by the 2DCPackGen generator are presented in Table 5.Algorithm 1Pseudocode of the 2DCPackGenThe generator described and proposed in this work (2DCPackGen) was coded in C++ and compiled with Microsoft Visual Studio 2008. A executable version compiled for Windows as well as the source code of 2DCPackGen are available at http://paginas.fe.up.pt/esicup/tiki-index.php.It is important to stress, once again, that the 2DCPackGen user must provide integer values as input parameter data and that the generator only creates integer values as outputs.Several tests on the input parameters are implemented in 2DCPackGen. For instance, it is ensured that each small item fits into at least one large object and it is guaranteed that there are no two item types with the same size in both problems with a weakly heterogeneous assortment of the small items (SLOPP, MILOPP, MHLOPP/W, MHLOPP/S, SSSCSP, MSSCSP and RCSP) and in the ODP.Although the generator detects and reports many other situations of inconsistency among the input parameters, care must be taken with the parameters such that that instances that make sense are generated.To assist the user in this analysis, warnings related to the easiness and feasibility of the generated test problems are also issued by the 2DCPackGen.For the Placement Problems (SLOPP, MILOPP, MHLOPP/W and MHLOPP/S) a warning is displayed by the 2DCPackGen if the total area of the item types times its maximum quantitydiu,i∈Iis smaller than 50% of the total large object area, since an instance with this characteristic can be very easy to solve. For the same problems a warning is also issued by the generator if the total area of the small items times its minimum quantity demand (dil, for alli∈I) is greater than the total large objects’ area, because this instance would be impossible to solve. Similarly for Knapsack Problems (SKP, MIKP, MHKP/W, MHKP/S), a warning is displayed if the total area of the items is smaller than 50% of the total large object area. All these problems are “output maximization” problems, where occurs a selection of the small items to cut/pack. If they all fit on the large object, unless some extreme geometric conditions arise, the problem is trivial. Also, if there is a minimum number of items to cut and their area is greater than the large object(s) area, there is nothing to decide because the problem is impossible.A similar reasoning can be applied to input minimization problems and for the Cutting Stock Problems and for the Bin Packing Problems a warning is issued by the 2DCPackGen for the SSSCSP and SBSBPP problem types if the total area of the items times their demand is smaller than 50% of the large object area, as in this case, and unless some extreme geometric conditions arise, there is no selection of large objects to make and the problem is trivial.The 2DCPackGen generator can also generate test problems for each type of 3D cutting and packing problems. A parallelepipedic box (either a small item or a large object) is generated by, firstly, defining the size and shape of one of its facings, which we will call base, and then the third dimension being materialized as the height of the box. The 2DCPackGen uses this strategy to generate boxes for both large objects and small items in 3D cutting and packing problems. The width and the length of the rectangular base a box are not independently generated. By combining the beta distributionsf(x,2,5),f(x,5,2),f(x,2,2)andf(x,0.5,0.5), an by using the same interval[Min,Max]for both the length and width dimensions, as was done in the 2D problems, sixteen different types of sizes and shapes can be considered. The generation of the box’s height is again based on the assignment of a minimum and a maximum value for that dimensions, and by the selection of one of seven types of beta distributions:f(x,1,3),f(x,2,5),f(x,2,2),f(x,0.5,0.5),f(x,1,1),f(x,3,1)andf(x,5,2). For 3D problems the data entered by the user is similar to the one considered for 2D problems, complemented by the information related to the third dimension, namely: the minimum and maximum value for the height of the large object (Hj), one of the seven beta distributions and the minimum and maximum value for the height of the small item (hi).

@&#CONCLUSIONS@&#
The motivation for the development of 2DCPackGen was the identification of a lack of problem generators and problem instances which can be widely and commonly used by all researchers studying 2D rectangular cutting and packing problems. The existing problem generators are not considered either flexible or general enough to fully explore and address the difficulty of current state-of-the-art algorithms and, partially because of this insufficiency, well-known instances have been used in problems for which they were not designed. The problem generator proposed in this work aims to fill this gap.The specific characteristics of each problem instance for each 2D rectangular cutting and packing problem were defined and the proposed generator is able to create test problems for each type of 2D cutting and packing problem: IIPP, SLOPP, MILOPP, MHLOPP, DKP, MIKP, MHKP, SSSCSP, MSSCSP, RCSP, SBSBPP, MBSMPP, RBPP and ODP.The main advantages of the 2DCPackGen are the use of a continuous probability distribution to sample the object sizes over the full range of dimensions, without any a priori discretization into artificial and discretionary sets, which brings the instances closer to real world problems; the control given to the user to generate problem instances with specific desired properties; and the guarantee of portability and reproducibility of the problem instances.2DCPackGen can provide a relevant contribution to the quality of computational experiments run on models and algorithms developed for 2D cutting and packing problems.