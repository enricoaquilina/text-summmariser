@&#MAIN-TITLE@&#
Calculating the medial axis of a CAD model by multi-CPU based parallel computation

@&#HIGHLIGHTS@&#
An efficient approach to generating MA in parallel by multiple CPUs is proposed.An adaptive division method is proposed to maximize the parallelism degree.Inter-dilation is proposed to ensure the correctness of final MA.

@&#KEYPHRASES@&#
Medial axis,CAD models,Distance dilation,Parallel computing,Model simplication,Voxelization-based method,

@&#ABSTRACT@&#
Computational efficiency is still a great challenge for the generation of the Medial Axis (MA) for complicated CAD models. Current research mainly focuses on CPU-based MA generation methods. However, most of the methods emphasize using a single CPU. The highly-efficient methods based on parallel computing are still missing. In this study, a parallel method based on multi-CPU is proposed for the efficient MA generation of CAD models using distance dilation. By dividing the whole model into several parts for which MAs are calculated in parallel and then combined, computational efficiency can be greatly improved in theory and the computation time can be reduced nearly K times if K CPUs are used. Firstly, an adaptive division method is proposed to divide the voxelized model into blocks which have nearly the same number of voxels to balance the computational burden. Secondly, the local Euclidean Distance Transform (EDT) is calculated for each block based on the existing distance dilation method. Thirdly, the complete inter-dilation method is proposed to compute the influence between different blocks to get a global EDT for each block. Finally, each block generates a sub-MA separately and then all the generated MAs are combined to obtain the final MA. The last three processes can be efficiently conducted in parallel by using multiple CPUs. Several groups of experiments are conducted which demonstrate the good performance of the proposed methods in terms of efficiency.

@&#INTRODUCTION@&#
The concept of Medial Axis (MA) was first introduced by Blum [1] as a tool for efficient 2D shape description, which has also been extended later on for the description of 3D models. Different from the curve/surface skeleton and the mid-surface, it has a rigid mathematical definition as follows: the MA of an object is the set of all the points having more than one closest point on the object’s boundary [2]. It has proven to be useful in many engineering fields, such as finite element analysis, form analysis, path planning in robotics, solid modeling, and mesh generation [3]. Generally, the methods of initial MA generation can be divided into three types, namely the thinning-based methods, the tracing methods and the methods based on the Voronoi graph.In the thinning-based methods, a model is usually approximated at first. For instance, Nackman put forward a method that substituted a polygon/polyhedron for the smooth boundaries and thus used the MA of the polygon/polyhedron as that of the input model [4]. Ma et al. [5] presented a method to approximate MA in which a set of points is sampled from a surface alongside the vectors that are normal to the surface at those points. Xia et al. [6] used Cartesian grids and calculated the distance field by solving the hyperbolic-natured Eikonal equation. Gao et al. [7] proposed a method based on distance dilation to compute the MA voxels for voxelized models. Those thinning-based methods may not be fast enough, as no parallel computing is employed.Based on local continuity, the tracing methods in essence generate an MA by tracing some special MA points. The key issue is to determine the crucial bifurcation points and offset the boundary inward. Lee proposed a method which achieves a computation complexity of O (nlogn) for convex polygons and a complexity O (n2) for concave polygons [8]. For the multiply connected region with h holes, Srinivasan and Nackman developed a method with a computational complexity of O(nh+nlogn) [9]. Recently, Chin provided a linear-time algorithm for computing the MA of a simple polygon [10]. However, it is not a simple task to extend the tracing method for complex models with freeform boundaries [11].Based on the duality relation between the Voronoi diagram and Delaunay triangulation, the Voronoi graph-based methods calculate an MA from the Voronoi diagram [12]. For instance, Lavender [13] generated Voronoi diagram based on Octree which divides a space into Voronoi zones according to a given resolution. Based on their work, Meijster et al. and Hirata made some improvements to develop a parallel method [14,15]. Dey et al. [16] proposed a hierarchical, simplified and efficient method which is scale and density independent. Smogavec and Zalik [17] proposed an efficient method for generating MAs of polygons based on the Delaunay triangulation of polygons. Giesen et al. [18] treated the union of inner Voronoi balls in a plane as the MA. However, a lack of parallel processing limits the efficiency of those methods.To improve computational efficiency, many researchers have proposed similar GPU-based parallel methods [5,19–22]. However, they can only be used to calculate the approximate skeletons formed by point clouds. In addition, as the density of discrete points is often high, the time complexity may also be quite high. The distance dilation-based method [7] can iteratively generate an MA of high quality with a complexity of O(rn3) in r dilation rounds and a resolution of n∗n∗n. However, the time complexity of this method is not satisfactory. The authors have proposed a Double Queues based Distance Dilation (DQDD) algorithm [23] based on existing distance dilation-based methods to improve time complexity from O(rn3) to O(n3).The method proposed in this study uses multiple CPUs, rather than a GPU, to generate an initial MA. The hypothesis of this study is that a parallel CPU, rather than a GPU, should be used to generate an initial MA, since there are many interactions in the parallel computations for different divided parts in the CAD model. This division usually makes the degree of parallelism quite low and GPU is not suitable for this parallel method since a GPU thread is generally much slower than a CPU thread. Moreover, multi-CPU processors are still widely used and thus it is worth researching how to speed up MA generation based on existing single-CPU solutions. In the proposed method, the whole model is divided into several blocks and the DQDD algorithm [23] is adapted for the parallel EDT computation in each block firstly. Then, the interactions between different blocks are handled and all the sub-MAs of these blocks are generated and combined to obtain the final MA for the whole model. By using the parallel method, the complexity of distance dilation is improved from O(n3) to nearly O(n3/K) with K processors. As such, the main objectives of this study include: (1) To achieve adaptive division of a CAD model into different blocks with nearly the same number of voxels by considering the balance of the computational burden. (2) To efficiently facilitate the interactions between different blocks to obtain the global EDT and the final MA.This paper is organized as follows. Some basic concepts and an introduction to the proposed method are given in Sections 2 and 3, respectively. The adaptive block division method is discussed in Section 4. The improved distance dilation method for global EDT computation of the whole part is detailed in Section 5. In Section 6, the generation of an MA using the EDT obtained using the distance dilation method is described. The strategies for computational efficiency improvement are discussed based on a complexity analysis detailed in Section 7. After that, the implementation of the algorithm and its applications to a number of examples are given in Section 8. Finally, the conclusions and future work are discussed in Section 9.Some frequently used concepts are defined and explained in this section. A 2D model alongside indications of the concepts being used on the model is given in Fig. 1to assist understanding.Definition 1A block in a voxelized model refers to an individual part obtained by dividing the model. Here, the dividing faces, which are perpendicular to coordinate axis X, Y or Z, are used to divide the bounding box of the model into several blocks. The number of voxels in a block is called the block size of that block, and the number of voxels in all blocks is called the total size. The boundary voxel set (referred to as boundary set throughout this paper) of a block/model refers to all boundary voxels of the block/model. As shown in Fig. 1, a dividing face F divides the voxelized model M into two blocks, namely P and Q. The boundary set of blocks P and Q is composed of several purple boundary voxels. This color convention is used throughout the paper.The dividing voxel layer (referred to as dividing layer throughout this paper) is a voxel layer in a block that is adjacent to the dividing face. For two adjacent blocks, P and Q, divided by a dividing face, dividing layer (P, Q) is in block P and adjacent to block Q, and dividing layer (Q, P) is in block Q and adjacent to block P. The two dividing layers form a dividing layer pair and have each other as their dual dividing layer. Take Fig. 1 as an example, dividing layer (Q, P) and dividing layer (P, Q), both of which are marked in yellow, form a dividing layer pair and belong to blocks Q and P, respectively. This color convention is used throughout the paper.The distance of a voxel A from a voxel setSis the Euclidean distance from the center of voxel A to the center of the nearest voxel in the boundary set ofS[23]. The corresponding nearest boundary voxel is called a touch voxel of voxel A fromS. Specifically, ifSis a block, the distance is a local distance within that block; and the distance is a global distance whenSis the whole model. The local/global Euclidean Distance Transformation (EDT) of a block is comprised of the local/global distances of all voxels in the block. As shown in Fig. 1, voxel A is the touch voxel of cyan voxel C from block P. The distance of voxel C from block P is the distance from the center of voxel C to that of voxel A.The distance dilation (referred to as dilation throughout this paper) from voxel A to its neighbor voxel B means updating the distance of voxel B using the distance of voxel A[23]. If the touch voxel of voxel A can provide a shorter distance for voxel B, the touch voxel becomes a new touch voxel of voxel B by replacing the previous one and the distance of voxel B is updated.As shown in Fig. 1, the touch voxel of voxel A is itself and the touch voxel of its red1For interpretation of color in Figs. 1–3, 5, 7, 10 and 11, the reader is referred to the web version of this article.1neighbor voxel B is not determined. During the dilation process from voxel A to voxel B, voxel A becomes a touch voxel of voxel B since it provides a shorter distance for voxel B. The dilation operations in a block can be conducted on some voxels repeatedly until all the voxels in the block have their distances. Those dilation operations from all the voxels in a block are called complete dilations from these voxels in the block. As shown in Fig. 1, the dilation operations are conducted from boundary voxel A to voxel B and then from voxel B to voxel C. Similarly, the dilation operations are conducted from other boundary voxels in block P. Finally, all the voxels in block P have their distances and these dilation operations are called complete dilations from the boundary set in block P.To explain the proposed parallel method for MA generation, the whole process is described briefly as follows with the help of a 2D model shown in Fig. 2.(i)Voxelization: In this step, a CAD model is discretized into a voxelized model. Fig. 2b shows the voxelized model for the input model in Fig. 2a. In Fig. 2b, the purple voxels are the voxelized boundary voxels.Adaptive block division: The voxelized model is automatically divided into several blocks with nearly the same number of voxels by an adaptive division scheme. This is used to balance the computational burden in multi-CPU based parallel computing in the following steps. As shown in Fig. 2c, the model is divided into 4 blocks by two dividing faces that are perpendicular to coordinate axes X and Y, respectively.Intra-dilation: The complete dilations from the boundary set within a block are conducted independently. These dilations constitute the intra-dilation of that block by which the local EDT of each block is generated. The arrows shown in Fig. 2d indicate the direction of intra-dilation.Inter-dilation: This step contains two sub-steps, namely inter-transfer and intra-renewal. The inter-transfer sub-step contains dilations from the voxels of a dividing layer to its neighbor voxels in the dual dividing layer without consideration of other voxels. As shown in Fig. 2e, the dilation is conducted in four dividing layer pairs in yellow, and the arrows show the dilation directions. After that, some voxels on the dividing layers update their distances. After inter-transfer, the complete dilations from those updated voxels on the dividing layers within a block are conducted in the block without the consideration of other blocks, which are called the intra-renewal of that block.The inter-dilation is conducted between all blocks repeatedly until no distances need to be updated in inter-transfer or intra-renewal. The complete inter-dilation is comprised of all these inter-dilations. As shown in Fig. 2f, no intra-renewal is further needed and thus the complete inter-dilation ends. Essentially, the inter-dilation is used to consider the interactions between different blocks to obtain the global EDT for the whole model.(v)MA generation, refinement and combination: Firstly, MA voxels are determined for each block in parallel. After that, the voxels on the dividing layers are rechecked to determine whether they are the MA voxels of the model by MA refinement. Finally, the resultant MA of the whole model is obtained by combining the sub-MAs generated for all the blocks. As shown in Fig. 2g, those voxels marked in brown are the MA voxels by MA generation and refinement. Fig. 2h shows the resultant MA generated using the proposed parallel method.As discussed above, distance dilation is an important step in the proposed parallel MA generation method. Initially, it was proposed in the authors’ previous work [23] on computing the EDT for a CAD model with only one block and based on a single CPU. In this study, it is improved in two aspects to support multi-CPU based parallel computation of global EDT. Firstly, it is adapted for computing the local EDT of the divided and unclosed blocks while the previous dilation method focused on closed models. The second improvement is its extension to compute the EDT for a CAD model with a group of blocks in parallel by considering the interactions between these blocks.The interactions between blocks are illustrated as follows. As shown in Fig. 3a, suppose the model is divided into three blocks and 3 CPUs are used to conduct the intra-dilation process in parallel for them separately. The local EDTs of these three blocks are computed in Fig. 3a. Here, the local distance of the red voxel is 5 and its local touch voxel is marked in cyan. After the interactions between different blocks are considered by conducting the complete inter-dilation, the distance information of each voxel will be changed, as shown in Fig. 3b. The global distance of the red voxel is renewed as 3 and its global touch voxel is renewal as the cyan voxel by the complete inter-dilation process which is used to update the global distance information of voxels. By considering the interactions between blocks, the existing DQDD algorithm is improved for multi-CPU based parallel computation of the global distance of voxels.As mentioned in Section 3, an input CAD model is voxelized first [24]. Then, it is divided into several blocks to conduct intra-dilation for each block in parallel.Since the maximum number of threads for parallel running is K for a computer with K CPU processors, the entire model is generally divided into k blocks (k⩽K) to allow the intra-dilations to be implemented by k processors in parallel. Although there are various methods for dividing a model, it is obvious that all parallel threads can finish the intra-dilations in the shortest time if k is equal to K and the block sizes of all the blocks are the same. However, it is not a trivial task to ensure that all the blocks have exact the same block size because of irregular and complex model shapes. As such, an adaptive division method is proposed to address this issue.To evaluate the performances of different block division modes before intra-dilation is conducted, some evaluation factors need to be identified and analyzed. Here, the initial block division is proposed first.Initial block division: Div(div_x, div_y, div_z): Suppose there are (div_x−1), (div_y−1), (div_z−1) dividing faces that are perpendicular to coordinate axes X, Y, Z, respectively for dividing the bounding box of a model equally. The number of the divided blocks is div_x∗div_y∗div_z. This division is called initial Div(div_x, div_y, div_z). Each block is called block (i, j, k) if it is located on the i-, j-, k-th position of the X, Y, Z axes, respectively. As shown in Fig 4, the bounding box of a model is divided into 6 blocks and is denoted as Div(3,1,2).Volume factor: It is defined as the ratio of the block size of the largest block to the average block size, which can be described using the following equation.(1)Volume factor=max(NBS(x,y,z))∗K∑x=1div_x∑y=1div_y∑z=1div_zNBS(x,y,z)Here, NBS(x, y, z) is the block size of Block (x, y, z). Suppose a model has four blocks whose sizes are 100, 200, 300 and 400 respectively. As 400 is the largest block size while 250 is the average block size, therefore the volume factor of the model is 1.6.Asmax(NBS(x,y,z))is the largest block size in all K blocks, Eqs. (2) and (3) can be deduced:(2)max(NBS(x,y,z))⩾∑x=1div_x∑y=1div_y∑z=1div_zNBS(x,y,z)/K(3)max(NBS(x,y,z))<∑x=1div_x∑y=1div_y∑z=1div_zNBS(x,y,z)From Eqs. (1)–(3), it is known that the volume factor for each division mode of the given model is between 1 and K. In addition, the value of volume factor is equal to 1 if and only if all blocks have the same block size.As the degree of parallelism of the proposed method depends on the total computational burden and the maximum computational burden of multiple CPUs, the following equation can be deduced by using Eq. (1).(4)Degree of parallelism=∑x=1div_x∑y=1div_y∑z=1div_zNBS(x,y,z)max(NBS(x,y,z))=KVolume_factorIt can be seen from Eq. (4) that the volume factor can be used to evaluate the balance of block volumes during the block division process.Edge factor: In initial block division, the bounding box of a given model is divided into some cuboids with the same size. The edge factor of a block is defined as the length ratio of the longest edge to the shortest edge of its cuboid using Eq. (5).(5)Edge factor=max(Edgex,Edgey,Edgez)min(Edgex,Edgey,Edgez)Here, Edgex, Edgeyand Edgezare the edge lengths of the cuboid on x, y, z coordinate axes, respectively. For example, a model is divided into 8 cuboids with the same size. Each cuboid has 10, 20, 30 voxels on x, y, z coordinate axes, respectively. As 30 is the maximum edge length and 10 is the minimum one, the edge factor of the model is 3.According to Eq. (5), the edge factor for each division mode of the given model is not less than 1. This parameter is used to evaluate the interactions between different blocks during inter-dilation and should be minimized.Renewal factor: This is defined as the ratio of the updated voxels during the complete inter-dilation to all voxels in a block, as described in the following equation.(6)Renewal factor=∑x=1div_x∑y=1div_y∑z=1div_zNUBS(x,y,z)∑x=1div_x∑y=1div_y∑z=1div_zNBS(x,y,z)Here, NUBS(x, y, z) is the updated block size of Block (x, y, z) by complete inter-dilation. Suppose a model has four blocks whose sizes are 100, 200, 300 and 400, respectively. The updated voxels by complete inter-dilation in these four blocks are then 10, 10, 20 and 20, respectively. As the average block size is 250 and the updated voxels in a block averagely is 15, the renewal factor of the model in this case is 0.06.In Eq. (6), updated block size of each block is equal to or smaller than the full block size of each block. As a result, the renewal factor for each division mode of a given model is between 0 and 1. This parameter thus can be used to evaluate the cost of complete inter-dilation caused by updating distances of voxels.There are many possible initial division modes for a single model when K processors are used. The aim of the adaptive division scheme is to find an optimal division automatically. To obtain the adaptive Div(div_x, div_y, div_z) by minimizing edge factor and volume factor, an adaptive division method is proposed in this study which mainly consists of the following two steps:(1)Initial division by minimizing edge factor: the model is divided firstly based on its bounding box in which the bounding box is divided equally. To achieve this for a voxelized model with a resolution of No_x∗No_y∗No_z, the numbers of voxels on the three edges of the blocks are No_x/div_x, No_y/div_y, No_z/div_z, respectively. Here, only the initial division which has minimum volume factor is chosen for the initial division and No_x, No_y, No_z cannot be equal or larger than 3 at the same time.Adaptive division by minimizing volume factor: The positions of div_x−1 dividing faces (each divided part is called an X part) are changed to satisfy the condition that those div_x X parts have nearly the same number of voxels. For each X part, the positions of div_y dividing faces (each divided part is called a Y part) are changed to satisfy the condition that each Y part has approximately the same number of voxels. For each Y part, the positions of div_z dividing faces (each divided part is called a Z part) are changed to satisfy the condition that each Z part has approximately the same number of voxels.After these two steps, the only adaptive division with the minimized volume factor and the minimized edge factor is computed automatically. As shown in Fig. 5, the initial division is achieved by achieving the smallest edge factor (shown in Fig. 5a). In this case, the block sizes of the four blocks are quite different. First, the number of voxels on the left X part and the right X part of dividing face F1 are calculated. In Fig. 5a, the former is larger than the latter. Therefore, dividing face F1 moves left until the number difference of voxels between them is minimized. As shown in Fig. 5b, the red dividing face F1 (in 2D space, it is a line) is moved. Then, dividing face F2 is divided into two dividing faces, namely F21 and F22, and for each X part, the divided dividing faces F21 and F22 move to minimize the difference between the block sizes of the upper block and the lower block, as shown in Fig. 5c. After the adaptive block size adjustment, the following approximate equations will be met for adaptive Div(2,2):(7a)Min{|NBS(1,1)+NBS(1,2)-[NBS(2,1)+NBS(2,2)]|}(7b)Min[|NBS(1,1)-NBS(1,2)|](7c)Min[|NBS(2,1)-NBS(2,2)|]As a result, the volume factor is minimized to nearly 1. This adaptive division has the minimum edge factor and the minimum volume factor among all possible division modes, and thus can in theory achieve the best performance of parallel computing. The detail efficiency analysis of adaptive division will be given in Section 7.2.After the model is divided into blocks, the intra-dilation and complete inter-dilation processes need to be conducted in parallel for distance update.The detailed DQDD algorithm has been published elsewhere and is out of the scope of this paper [23]. This algorithm uses the current queue and the next queue which are in the current range and the next range to conduct complete dilations from boundary set in a block. In this study, only a brief introduction is given to explain the whole process shown in Fig. 6. In the figure, the current queue is marked in blue and the next queue is marked in green; and computed voxels are marked in grey. This color convention is used throughout the paper. It is noteworthy that the initial distances of the internal voxels are set as infinity since they are unknown. Take Block(1,1) in Fig. 6 as an example, set both the queues that will be used in the DQDD algorithm first. Here, the current queue is set with the boundary voxels of Block(1,1) in current range and the next queue is set as NULL. The intra-dilation process is described as follows:(1)For each voxel A in the current queue (blue voxels in Fig. 6a), take it out of the current queue, update the distances of its 26 neighbor body voxels by dilation from voxel A to each of them, as shown in Fig. 6b. If the distance of any neighbor voxel is updated and the voxel is in next range, push it into the next queue (green voxels in Fig. 6b).If the next queue is not empty, set it to be the new current queue; then, the previous empty current queue is used as the new next queue and another round of dilation begins by updating current range and next range (Fig. 6c); go to Step (1) (Fig. 6d and e). Otherwise, the procedure ends if the next queue is empty (Fig. 6f).After these steps, local distances are correctly obtained for all the voxels of Block(1,1), and the local EDT of Block(1,1) is calculated. With the help of the updated distances by using double queues, the boundary set is dilated as touch voxels from the boundary to the inner part of the block.As mentioned above, the DQDD algorithm is conducted within the given block and is thus not affected by the other blocks. Therefore, the DQDD algorithm can be executed for each block independently without influencing other blocks and can thus be conducted in parallel for all the blocks.As mentioned above, only the interactions within a block is considered during the intra-dilation process. To compute the global EDT for a given model, interactions between different blocks must be considered as well. Inter-dilation is used to compute the inter-block interactions by distance dilation, which contains two steps: inter- transfer and intra-renewal. Specifically, the former is used to enable the voxels on a dividing layer to obtain distance information from other blocks. The latter is used to renew the distance information of other voxels using the distance information of the voxels on the dilation layer.For two adjacent blocks, the direct connecting part is the dividing layer pair that is adjacent to a dividing face. To obtain the touch voxels for voxels in a given block from its neighbor block, it is necessary to perform dilations between each dividing layer pair. Suppose that dividing layer(P, Q) and dividing layer(Q, P) are a dividing layer pair that belong to two adjacent blocks P and Q, respectively. To conduct inter-transfer between blocks P and Q, two inter-transfers between dividing layer(P, Q) and dividing layer(Q, P) are performed as follows:(1)For any voxel on dividing layer(P, Q), conduct the dilation from it to its 9 neighbor voxels on dividing layer(Q, P).For any voxel on dividing layer(Q, P), conduct the dilation from itself to its 9 neighbor voxels on dividing layer(P, Q). This is in essence reverse operation of Step 1.Fig. 7b and c illustrate the above two steps of the dilation process in an inter-transfer. Fig. 7a is the result of intra-dilation for the three divided blocks. In the figure, the yellow voxels are voxels on dividing layers. The dilation process is conducted between the voxels of each dividing layer and their neighbor voxels on the dual dividing layer. As shown in Fig. 7b, dilations are conducted from the left dividing layers to their right adjacent dividing layers, and the red voxels are the updated voxels. Then, a dilation process similar to Fig. 7b is carried out in a reverse direction. As shown in Fig. 7c, dilations are conducted from the right dividing layers to their left adjacent dividing layers, and the red voxels are the updated voxels.Moreover, a parallel computing strategy is also considered here to speed up the inter-transfer process. With the consideration that inter-transfers for different dividing layer pairs do not influence each other, every inter-transfer process on dividing layer pairs that are generated by the same dividing face can use one thread. Because there are div_x+div_y+div_z−3 dividing faces, the number of threads needed for a parallel inter-transfer is also the same, which is smaller than the block number div_x∗div_y∗div_z. Therefore, there are enough processors for implementing the parallel inter-transfer processes.The intra-renewal process can be regarded as special complete dilations from the updated voxels on the dividing layers. Compared with the general intra-dilation process, there are two characteristics for the intra-renewal process:(1)The updated voxels on dividing layers of a block have touch voxels from the boundary set of other blocks in the previous inter-transfer of the same inter-dilation. Those voxels are not in the initial current range.Each voxel of the block has already had its local distance. Its distance only needs to be updated by using voxels on dividing layers for which distances are updated by a previous inter-transfer of the same inter-dilation.Due to these characteristics, the DQDD algorithm needs to be extended for the intra-renewal after the following improvements are made in the procedure.(1)The updated voxels on dividing layers are set as the initial current queue of the intra-renewal since the boundary sets of other blocks may only exist as touch voxels of voxels on dividing layers, which are calculated by the previous inter-transfer. Thus, current queue and next queue are not required to be in current range and next range.Only the voxels that are affected by interactions between blocks will be involved in intra-renewal. This makes the computation time of intra-renewal much shorter than intra-dilation.The intra-renewal process is explained using the 2D blocks in Fig. 8. Here, the intra-dilation and one round of inter-transfer have been conducted for the model, and the updated voxels by the previous inter-transfer are computed using the method shown in Fig. 7. These voxels are marked in red, and are pushed into the initial current queue in Fig. 8a. And then the extended DQDD algorithm is implemented as follows after the corresponding improvements are made.(1)For each voxel A in the current queue (blue voxels in Fig. 8b), take it out of the current queue. If voxel A is in current range, it updates the distances of its 26 neighbor body voxels by dilation from voxel A to each of them. If any neighbor voxel is updated and not queued, push it into the next queue (green voxels in Fig. 8b). Else if voxel A is not in the current range, push it into the next queue.If the next queue is not empty, set it to be the new current queue; then, the previous empty current queue is used as the new next queue and another dilation round begins by updating the current range (Fig. 8c); go to Step (1). Otherwise, the procedure ends if the next queue is empty (Fig. 8d).It can be observed from Fig. 8 that the computational complexity of intra-renewal is much lower than that of intra-dilation. The reason is that during intra-renewal, the distances of most voxels have already been computed and cannot be updated. As a result, they do not need to be dilated.Moreover, it can be observed that during the intra-renewal of each block, only voxels of the block are involved. Therefore, similar to intra-dilation, it can also be conducted in parallel for different blocks.The aim of complete inter-dilation is to obtain the global distances for all the voxels. Although one round of inter-dilation is enough to obtain it in most cases, the theoretical maximum rounds of inter-dilations required for complete inter-dilation should be estimated.If a block P obtains its local EDT from boundary sets of block B1, B2,…Bk, then B1, B2,…Bkare called the known blocks of block P. During the intra-dilation of block P, every voxel A of block P obtains its local distance and block P obtains its local EDT. Therefore, block P is a known block of itself. During one round of inter-transfer of block P, the known blocks of the face-neighbor blocks of block P are also known by the dividing layers of block P by dilations from the dual dividing layers. During one round of intra-renewal, the known blocks of face-neighbor blocks of block P are known by block P by the complete dilations in block P. Therefore, one round of inter-dilation will result in the known blocks of the face-neighbor blocks of block P being added to the known block set of block P. In Fig. 9a–d, the known block set of each block after intra-dilation, and the three inter-dilations are shown on the corresponding block.Therefore, after |a−d|+|b−e|+|c−f| times of inter-dilation, the known blocks of block (d, e, f) will be added to the known block set of block(a, b, c). Here, 1⩽a, d⩽div_x, 1⩽b, e⩽div_y and 1⩽c, f⩽div_z.Based on the above analysis, the maximum times of inter-dilations in a complete inter-dilation is div_x+div_y+div_z−3 to ensure that any block gets EDT from all the blocks. After that, the EDT of any block is the global EDT, and the inter-dilation ends. As shown in Fig. 9a, a model is divided into six blocks by Div(3,1,2). During three inter-dilations, the known blocks of each block is marked on it as shown in Fig. 9b–d. In this way, after three rounds of inter-dilation, each block has got the global EDT from boundary sets of other blocks.Suppose model M has k blocks (B1, B2,…,Bk). After div_x+div_y+div_z−3 rounds of inter-dilations, the complete inter-dilation process ends. As div_x+div_y+div_z−3 is not a small number, the executed number of inter-dilations in complete inter-dilation needs to be reduced. Here, the boundary set of a block Bicannot contain the touch voxels of voxels in other blocks if all voxels of block Bistop dilation during complete inter-dilation. Obviously, voxels of block Bicannot dilate to more blocks in this case.Therefore, if voxels of all blocks stop dilation during the inter-transfer or intra-renewal processes, the complete inter-dilation will end, even though the inter-dilation number is not the maximum. This criterion is checked after each inter-transfer and intra-renewal process in complete inter-dilation for early termination. It will be observed in later experiments that inter-dilation mostly runs only one round in the complete inter-dilation.After the intra-dilation and complete inter-dilation processes, the global distances are obtained for all the voxels of the input model. The next task is then to find the correct MA voxels by using the distance information and refine the result. In this study, the dilation-based method is adapted to calculate the MA voxels [23]. As shown in Fig. 10a, the dilation region is generated first based on the distance of each voxel. In the figure, different colors mean different regions. The voxels (with two colors in Fig. 10b) that lie on the intersection of two different dilation regions and on two different boundary surfaces are chosen as the MA voxels because they have the same distance to two boundaries.It is noteworthy that in Fig. 10a only one voxel with a yellow boundary is selected as an MA voxel (the one with a red boundary in Fig. 10b). This is called the double-layer problem which is very typical for the voxelization-based methods. The solution for this problem is that only one layer of voxels is selected as the approximate MA voxels with a condition that the connectivity between the MA voxels must be kept.In the parallel MA generation method, each block is processed independently. However, the double-layer problem may occur between different blocks. Suppose the two red voxels in Fig. 10a are in different blocks, both of them will be considered as MA voxels. To handle this problem caused by parallel computing for MA, MA refinement needs to be devised on boundary layer pairs.The authors proved that the maximum MA error of the dilation-based method is3∗voxel size/2 and stated some special conditions in MA generation [23]. As a result, the resultant MA will converge when the voxel size is small enough and its quality is ensured.The computational efficiency of the proposed parallel MA generation algorithm mainly depends on the intra-dilation and the complete inter-dilation processes. The selection of block division strategies will affect the computational efficiency greatly. In this section, the factors influencing computational complexity are analyzed, and on this basis some improvement strategies are proposed to achieve optimal performance.Suppose that the bounding box of an input model has n voxels on the three edges and that the total number of voxels of the model is n3. Additionally, there are K threads used in parallel, and the model is divided into exactly K blocks.The total time cost for each MA generation operation of a CAD model is described as follows based on the degree of parallelism described in Eq. (4). The time for voxelization is not considered in the analysis and comparison because it is a common part for the voxelization method. In the following analysis, vf and rf refer to the volume factor and the renewal factor, respectively.(1)Time cost for intra-dilation: Suppose that the time for dilation for one voxel is Td. The cost time for intra-dilation is then vf∗Td∗n3/K.Time cost for inter-transfer: Dividing layer pairs that are generated by a dividing face have 2∗n2 voxels. With the consideration that inter-transfer for dividing layer pairs of different dividing faces are conducted in parallel, the time used for one round of parallel inter-transfer is Td∗2∗n2. NIT is the number of necessary inter-transfers, which is equal to or smaller than div_x+div_y+div_z−3.Time cost for intra-renewal: Suppose that the average number of voxels that need to be dilated in the intra-renewal of each block is rf∗n3/K. The time cost is vf∗rf∗Td∗n3/K when K threads are used in parallel. NIntraR is the number of required inter-transfers, which is equal or smaller than div_x+div_y+div_z−3.Time cost for MA generation: Suppose that MA generation for a voxel has a time cost Tr. Because all voxels need to be checked, the time cost is vf∗Tr∗n3/K when K threads are used in parallel.Time cost for MA refinement: Suppose that MA refinement for a voxel has a time cost Tr. There are 2∗(div_x+div_y+div_z)∗n2 voxels on dividing layers to be checked sequentially. Therefore, the time cost is nearly 2∗(div_x+div_y+div_z)∗n2∗Tr.It can be observed that the total time cost of this proposed method is Td∗n3+Tr∗n3 when only one thread is used, whereas that of the proposed parallel method is Td∗(vf∗n3/K+NIT∗2∗n2+NIntraR∗vf∗rf∗n3/K)+Tr∗(vf∗n3/K+2∗(div_x+div_y+div_z)∗n2) when K threads are used in parallel. Therefore, the proposed method can dramatically reduce the time complexity. The time cost of intra-dilation and MA generation is nearly reduced by a factor of K/vf compared with the time cost of using a single thread which is O(n3). As K is limited by the processor number, reducing the volume factor and the time cost of complete inter-dilation is the only way to speed up the proposed method.As mentioned above, the computational efficiency of the proposed method only depends on NIT, NIntraR, the renewal factor and the volume factor. Specifically, NIT, NIntraR and the renewal factor are in turn determined by the boundary set dependency between different blocks. For example, if most of the touch voxels of the voxels in each block are in the same block, NIT and NIntraR will be 0 or 1, while the renewal factor will be almost 0. However, NIT, NIntraR and the renewal factor will increase if most of the touch voxels of the voxels in each block are in different blocks. At this time, the renewal factor will be almost 1 because most voxels need to update their distances using the complete inter-dilation. Moreover, NIT and NIntraR will also be large if the block number between a voxel and its touch voxels is large.Based on the above analysis, the following strategies are used in this study to reduce boundary set dependency between different blocks.(1)NIT, NIntraR and the renewal factor are minimized by decreasing the edge factor as much as possible. For example, for Div(2,3) in Fig. 11a, the renewal factor is nearly 1 and NIT and NIntraR are 2 and 1, respectively. For Div(3,2) in Fig. 11b, the renewal factor is reduced to 0, and NIT and NIntraR are 1 and 0, respectively. Although both Div(2,3) and Div(3,2) contain six blocks, Div(3,2) has a smaller edge factor and its complete inter-dilation costs less.The values of div_x, div_y and div_z cannot be equal to or larger than 3 at the same time when conducting block division. If this condition cannot be met, at least one block has no boundary set. Therefore, the block does not have a local EDT in intra-dilation, and its renewal factor will be 1 in the subsequent intra-renewal. As shown in Fig. 11c, a rectangle (2D) is divided by Div(3,3). The red block(2,2) does not contain boundary set and its renewal factor is 1. Obviously, such a block division will heavily affect the efficiency of complete inter-dilation and needs to be avoided.In Section 4.2, the adaptive division scheme can choose the division which has minimum edge factor and ensures the values of div_x, div_y and div_z cannot be equal to or larger than 3 at the same time. Therefore, NIT, NIntraR, rf are minimized. Moreover, the adaptive division scheme minimizes volume factor by moving dividing faces. Finally, the adaptive division offers the minimum time complexity. Experiments in Section 8.1 below demonstrate these findings by comparing the adaptive division and other possible divisions.The proposed parallel MA generation method has been implemented with visual studio 2008 and the geometric modeling kernel ACIS R20. HOOPS 17.00 is used for visualization. The computer used in the experiments has an Intel Core i7 3770 with 4 CPU processors. To demonstrate the efficacy and efficiency of the proposed method, three groups of experiments have been conducted and detailed descriptions of the results are as follows. The first group is used to compare the time cost of the proposed method for all possible division modes with all 4 CPU processors. Meanwhile the influence of the volume factor and the edge factor is also analyzed. The second group is used to compare the time cost of the proposed method with different numbers of threads by adaptive divisions. On this basis, four examples were used in the third group to demonstrate the performance of the proposed method using all 4 CPU processors by adaptive divisions. To unify the examples, all models were voxelized with a resolution of 180 in the longest coordinate direction. Specifically, the MA voxels on boundary layers are colored with yellow to discriminate them from other MA voxels. Red voxels are the MA voxels newly generated during the complete inter-dilation to discriminate them from the brown MA voxels that are generated during intra-dilation.In this experiment, the model Fig. 12a is used to conduct time comparison of all possible block division modes. Without loss of generality, all four processors are used in the experiment. All the division modes which divide the bounding box equally with four processors are given in Figs. 12b–12h. The time cost of each division mode is listed in Table 1, and values of the edge factors and the volume factors for each division mode are tabulated in Table 2.It can be observed from Table 1 that when 4 processors are used the time cost of the proposed parallel MA generation method has been reduced by a factor of 1.5–3 compared with that of the method with a single thread,. Meanwhile, it can also be observed that the computation time of different division modes is quite different, even though the same number of processors is used. The reason is that they have different volume factors and edge factors. As shown in Table 2, Div(2,1,2) has the smallest volume factor and edge factor, whereas Div(1,4,1) has the largest volume factor and edge factor. As a result, Div(2,1,2) is the best division by considering volume factor and edge factor. Table 1 illustrates that Div(2,1,2) actually achieves the best performance in terms of speed while Div(1,4,1) is the worst. As pointed out in Section 7.2, this group of experiment demonstrates that the adaptive division has achieved the minimum volume factor and minimum edge factor and is thus the optimal division.In this experiment, the time cost of different numbers of threads is compared with an example, as shown in Fig. 13. Based on the analysis in Section 7, the adaptive block division of each number of threads is used for comparison, and the results are given in Fig. 13c–e. Table 3shows the time cost of different division modes. It can be observed that less time is spent when more threads are used. It can also be observed from Table 3 that the time for the complete inter-dilation is much less than that of intra-dilation, which ensures a high efficiency of the proposed method with multi-threads. Meanwhile, as the adaptive division is used as the optimal division, the performance is further improved.To further illustrate the performance of adaptive block division in the proposed method, four different models are used, as shown in Figs. 14–17. Their medial axes are generated by adaptive divisions with 4 processors to achieve the best performances. The results are shown in Table 4. Specifically, the shapes of the models in Figs. 14 and 15 are more symmetrical than those in Figs. 16 and 17. As a result, the performances of models in Fig. 14 and 15 are better than that of models in Fig. 16 and 17 in terms of running time. Some other models are also tested in the experiments, and similar results have been obtained.

@&#CONCLUSIONS@&#
Recently, some studies have been conducted on the parallel generation of skeletons for models to improve computational efficiency. All of these studies are devised based on GPU processors. However, they may not be satisfactory for the generation of MAs for CAD models since the interactions between different blocks is too complex when calculations for multiple MAs are conducted in parallel. In addition, a parallel method is needed for CPU-based systems since there are a wide range of applications for these systems. Therefore, this study aims to address the research gap by developing a parallel method on the CPU platform. The contribution of the study is concluded as follows:(1)An approach to generating MA of a CAD model in parallel using multiple CPUs is proposed, which enables the main steps of intra-dilation, inter-transfer, intra-renewal, MA generation and refinement to be conducted in parallel for different parts. Computational efficiency can be greatly improved compared to existing methods that use only one thread.An adaptive block division method is proposed to maximize the degree of parallelism in MA generation by minimizing both the volume factor and the edge factor while reducing the time complexity of the method.The distance dilation method is adapted and improved to implement obtaining the global distances for all the voxels by using the boundary sets of other blocks and reusing the computed local EDT within each block. Meanwhile, the homotopy is also preserved even if the genus is destroyed during the division of the model into several parts.Future work will be focused on three areas. The first will be on conducting a performance test with more CPU processors. The second involves analyzing the influence of voxel size and in particular multi-scale voxelization will be considered to satisfy the requirement of homotopy in some extreme cases. The third regards more applications of the proposed method. For example, applications of the proposed method in efficient 3D model retrieval and CAD/CAE integration will be considered.