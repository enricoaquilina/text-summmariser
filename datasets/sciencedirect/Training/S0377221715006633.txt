@&#MAIN-TITLE@&#
A branch-and-cut framework for the consistent traveling salesman problem

@&#HIGHLIGHTS@&#
We study multi-period routing problems with arrival-time consistency requirements.We present the first-ever exact method for the Consistent Traveling Salesman Problem.We propose novel valid inequalities and associated separation techniques.Instances with up to 50 customers and 5 periods are solved to guaranteed optimality.Consistency can be enforced with a modest ( < 2 percent on average) increase in routing costs.

@&#KEYPHRASES@&#
Traveling salesman problem,Multi-period routing,Service consistency,Branch-and-cut,

@&#ABSTRACT@&#
We develop an exact solution framework for the Consistent Traveling Salesman Problem. This problem calls for identifying the minimum-cost set of routes that a single vehicle should follow during the multiple time periods of a planning horizon, in order to provide consistent service to a given set of customers. Each customer may require service in one or multiple time periods and the requirement for consistent service applies at each customer location that requires service in more than one time period. This requirement corresponds to restricting the difference between the earliest and latest vehicle arrival-times, across the multiple periods, to not exceed some given allowable limit. We present three mixed-integer linear programming formulations for this problem and introduce a new class of valid inequalities to strengthen these formulations. The new inequalities are used in conjunction with traditional traveling salesman inequalities in a branch-and-cut framework. We test our framework on a comprehensive set of benchmark instances, which we compiled by extending traveling salesman instances from the well-known TSPLIB library into multiple periods, and show that instances with up to 50 customers, requiring service over a 5-period horizon, can be solved to guaranteed optimality. Our computational experience suggests that enforcing arrival-time consistency in a multi-period setting can be achieved with merely a small increase in total routing costs.

@&#INTRODUCTION@&#
Vehicle routing problems with explicit focus on service quality and customer satisfaction have seen a recent surge in popularity and applicability. A key characteristic of high-quality customer service is its consistency over time, and this is particularly important when companies are faced with routing decisions spanning over multiple time periods. In such cases, it is generally desirable to provide consistent service to regular customers, i.e., customers who require frequent service across the different periods. Kovacs, Golden, Hartl, and Parragh (2014a) provide a review of routing problems in which explicit considerations of service consistency have been addressed. They define and classify service consistency as any of the requirements for arrival-time consistency, for which a customer should be visited at roughly the same time during the day, person-oriented consistency, for which a customer should always be visited by the same driver, and delivery consistency, for which a customer should be receiving roughly the same quantity of goods each time service is provided. Applications in which such consistent service considerations are particularly relevant include small package shipping services (Groër, Golden, & Wasil, 2009), transportation of people with disabilities (Feillet, Garaix, Lehuédé, Péton, & Quadri, 2014) and Vendor-Managed Inventory distribution (Coelho, Cordeau, & Laporte, 2012).This paper focuses on the aspect of arrival-time consistency. In this context, the supplier aims to reduce the variability in the actual times during the routing horizon at which a customer is served, since doing so generally increases the value of service for the customer. For example, in the context of VMI distribution, arrival-time consistency reduces the need for the customer to commit loading-dock resources throughout the day. In the home-care industry, the elderly and disabled are sensitive to changes in their daily routines and developing consistent schedules is of particular importance. Moreover, from the service provider’s point of view, reducing the variability across repetitive deliveries over multiple time periods can expose efficiencies that add up to significant cost savings.The Consistent Traveling Salesman Problem (ConTSP) is a variant of the well-known Traveling Salesman Problem (TSP) that attempts to address the issue of arrival-time consistency in multi-period routing applications. In the ConTSP, we aim to design minimum-cost (or, minimum-makespan) routes over a finite, multi-period horizon so as to serve a set of customers with known demands and service durations using a single (uncapacitated) vehicle. In general, a customer may or may not require service in a given time period and, thus, only a subset of customers need to be visited in each period. The consistency requirement applies to every customer who requires service in more than one time period, meaning that every such customer must be visited at roughly the same time in each period for which service is required. The exact time of service remains a decision variable, but the arrival times across the multiple periods at each customer site must not differ by more than some prespecified, constant bound, which we call the maximum allowable arrival-time differential. In practice, this bound may be set by either the customer or by the service provider. Note that, if the maximum allowable arrival-time differential is chosen to be equal to infinity, then the ConTSP reduces to a set of separable TSPs (one for each time period); hence, the ConTSP isNP–hard, just like the TSP (Karp, 1972).Kovacs et al. (2014a) remark that the problem of visiting customers at consistent times over the different periods in a planning horizon is similar to single-period, multi-vehicle routing problems with temporal synchronization of vehicles (Drexl, 2012). In particular, consistent routes in a multi-period setting can be viewed as equivalent to several synchronized vehicles that must arrive to customer sites almost simultaneously during a single-period; the solution of the latter problem can be recovered as the union of all single-vehicle routes in the former problem. Another related problem that addresses periodicity in routing is the Periodic Vehicle Routing Problem (Campbell & Wilson, 2014), wherein each customer requires one or more visits over a planning horizon and the decision-maker must select in which time periods to provide these visits, while minimizing the total distance traveled over the planning horizon.We highlight that the ConTSP constitutes a special, single-vehicle case of the Consistent Vehicle Routing Problem (ConVRP), originally introduced by Groër et al. (2009). The ConVRP utilizes multiple capacitated vehicles in order to provide consistent service to a set of customers over multiple periods while minimizing total transportation cost. In addition to considering arrival-time consistency, the ConVRP also requires driver consistency, for which each customer must be visited by the same driver in all periods of the planning horizon. A number of metaheuristic approaches to solve the ConVRP have been proposed in the literature. Groër et al. (2009) present an algorithm that is based on generating a “template” route by following a precedence principle: if customer a is visited before customer b in a time period, then a should be visited before b in every time period. The template route is built by considering only customers that require service in more than one time period. The individual routes in each time period are then generated by deleting those customers in the template who do not require service in that period, while those customers that require service in this period but are not part of the template route are inserted into the solution at the best position. Kovacs, Parragh, and Hartl (2014c) build upon this algorithm by allowing deviations from the precedence template using an adaptive large neighborhood search procedure; Tarantilis, Stavropoulou, and Repoussis (2012) modify both the template route and the actual single period routes using tabu search. Note that, in all of the above approaches, waiting is not allowed; that is, the vehicle is not allowed to wait at a customer location before providing service. Moreover, in the papers by Groër et al. (2009) and Tarantilis et al. (2012), the departure times of the vehicles from the depot are fixed: vehicles must depart from the depot at time zero in each period. Kovacs et al. (2014c) relax the latter requirement by allowing the vehicle to delay its departure from the depot and demonstrate that service quality can be improved without increasing driver working time. In a more recent paper, Kovacs, Golden, Hartl, and Parragh (2014b) consider a generalization of the ConVRP in which a limited number of different drivers may visit a customer, the maximum difference in the earliest and latest arrival times is penalized in the objective (i.e., arrival-time consistency is treated as a soft requirement), and each customer is associated with either of two available time windows (e.g., AM or PM). Finally, Luo, Qin, Che, and Lim (2015) study a multi-period variant of the Vehicle Routing Problem with Time Windows, wherein each customer may be visited by only a limited number of drivers over the routing horizon, in addition to being serviced within a given time window.In this work, we present a new, branch-and-cut-based algorithm to address the ConTSP, which to the best of our knowledge is the first attempt in the open literature to address a routing problem with consistency requirements in an exact framework. Our motivation to address the special, single-vehicle case of the ConVRP is three-fold: (i) an exact approach, even if only applicable to single-vehicle instances, has the potential to provide higher quality solutions with provable guarantee of optimality for those instances, (ii) an efficient solution scheme for the ConTSP could serve as a component of a hybrid metaheuristic approach, or even a decomposition-based11For example, if the assignment of customers to vehicles/drivers is fixed, then the ConVRP decomposes into several ConTSPs, i.e., one for each vehicle/driver.exact approach, for the ConVRP, and (iii) our contribution can influence the development of new exact algorithms to address more complex problem settings for consistent routing. We note that branch-and-cut approaches have, in fact, been employed successfully in the past to address the “basic” TSP (Applegate, Bixby, Chvatal, & Cook, 2007; Fischetti, Lodi, & Toth, 2007) and many of its variants and extensions, including among others the TSP with Time Windows (Ascheuer, Fischetti, & Grötschel, 2001), the TSP with Pickups and Deliveries (Dumitrescu, Ropke, Cordeau, & Laporte, 2010), the Prize-collecting TSP (Bérubé, Gendreau, & Potvin, 2009) and the Capacitated Vehicle Routing Problem (Lysgaard, Letchford, & Eglese, 2004). The development of these approaches has largely contributed towards extending the results of polyhedral combinatorics developed for the TSP by Grötschel and Padberg (1979).We present three alternative mixed-integer linear programming formulations for the ConTSP and compare their performance when serving as the basis of our branch-and-cut scheme. In order to strengthen these formulations, we separate valid single-period TSP cutting planes. More specifically, in our implementation we use Subtour Elimination Constraints and 2-matching Constraints. We further derive a new class of valid inequalities for the ConTSP, which we refer to as Inconsistent Path Elimination Constraints, and present an efficient heuristic to separate them. These new inequalities are cross-period cutting planes which forbid the simultaneous occurrence of two paths that, if allowed to co-exist in the solution, would violate the arrival-time consistency requirement for one or more customers (here, a “path” is a sequence of customers appearing consecutively in a tour). Our algorithm is able to address instances containing up to 50 customers that require service over a 5-period horizon. In the instances we considered, we observed that increasing the quality of provided service by visiting each customer at consistent times does not have to come at a high price. In fact, the average routing cost increase was a modest 1.3 percent of the costs that would have been incurred if consistency considerations were not taken into account.We can synopsize the contributions of this paper as follows:•We develop a branch-and-cut-based solution framework that can solve instances of the ConTSP to guaranteed optimality.We propose the novel class of Inconsistent Path Elimination Constraints, which are valid for the ConTSP, and we present a polynomial-time algorithm to separate these cuts in the context of the above solution framework.We show that, unlike the case of the TSP, the Subtour Elimination Constraints and the 2-matching Constraints are not, in general, facet-defining for the ConTSP polytope.We compile a comprehensive database of benchmark instances for the ConTSP by extending single-period TSP instances from the TSPLIB library.We calculate, for the above database, the additional cost that a distributor must incur, on average, in order to implement consistent delivery schedules; that is, we quantify the “price of consistency.”The remainder of the paper is structured as follows. In Section 2, we formally define the problem and introduce necessary notation. In Section 3, we present three formulations of the ConTSP and discuss some empirical dominance relationships. In Section 4, we present a number of valid inequalities for the above formulations and we discuss their lack of the facet-inducing property. In Section 5, we discuss the implementation of our branch-and-cut algorithm, including separation routines for each of the valid inequalities. Finally, in Section 6, we present computational results on a set of ConTSP benchmark problems, elucidating the cost of providing consistent service.LetG=(V,A)be the complete directed graph onn+1nodes, whereV:={0,1,…,n}is the node set and A ≔ {(i, j) ∈ V × V: i ≠ j} is the arc set. Node 0 represents the depot, while the node subsetVc=V∖{0}represents the set of customers. Associated with every arc (i, j) ∈ A is a travel cost cij≥ 0 and a travel duration tij≥ 0. Service (a.k.a., processing) times can be easily incorporated into the travel durations via the operationtij←tij+si,where si≥ 0 is the service time of each customer i ∈ Vcands0=0. We remark that we do not require symmetric costs or travel times; that is, we allow cij≠ cjior tij≠ tjifor any (i, j) ∈ A. In either case, since in general service times differ among nodes, the ConTSP constitutes an asymmetric problem even if the costs and travel times are themselves symmetric.Let alsoP={1,…,h}denote the set of time periods such that h ≥ 2. For each periodp∈P,we define the node subset Vp⊆ Vcto be the set of customers requiring service in this period, and we define the associated subset of arcs to be Ap≔ {(i, j) ∈ (Vp∪ {0}) × (Vp∪ {0}): i ≠ j}. W.l.o.g, we assume for each periodp∈PthatVp∩[∪q∈P:q≠pVq]≠∅; that is, each set Vpis non-empty22If the input data provides for a period in which no customers require service, then that period can be removed from consideration.and it in fact includes at least one customer requiring service in some additional period.33If the input data provides for a time period p in which every customer that requires service in that period does not require service in any additional period q ≠ p, then we can independently address period p by solving its corresponding TSP instance and appending its solution to the solution of the ConTSP instance induced by the remaining periods.A tour in period p is a Hamiltonian cycle in Gp≔ (Vp∪ {0}, Ap). We refer to such a tour via notationTp=〈0,v1,v2,…,v|Vp|,0〉p,where it is implied that each customer vkis unique. Given a tour Tp, we define its cost asc(Tp):=∑k=1|Vp|cvk−1vk+cv|Vp|0. We also define the arrival time at the ith node, vi∈ Vp, asavip=∑i′=1itvi′−1vi′,wherev0=0is introduced for notational convenience. We assume that no waiting is allowed; that is, the vehicle departs in each period at time 0 and does not wait at customer locations before starting service. The above definition of arrival time reflects this assumption.A ConTSP solution is a collection of tours{T1,T2,…,Th},i.e., one tour for each periodp∈P. Given such a collection, we defineΔaimax:=maxp∈P:i∈Vpaip−minp∈P:i∈Vpaipto be the arrival-time differential for a customer i. In the ConTSP, we want to enforce that this arrival-time differential does not exceed a maximum allowable value L > 0 for all customers i ∈ Vc; that is, a ConTSP solution is feasible if and only ifmaxi∈VcΔaimax≤L. A collection of tours is said to be consistent if they induce a feasible ConTSP solution. The objective of the ConTSP is then to determine the collection of consistent tours with the minimum sum of costs,∑p∈Pc(Tp).Throughout the paper, we use the following notation. For each customer i ∈ Vp∪ {0}, letNp+(i)denote the set of nodes j for which there is an arc from i to j in the graph Gp, i.e.,Np+(i):={j∈V:(i,j)∈Ap}. Similarly, letNp−(i):={j∈V:(j,i)∈Ap}. Finally, given a subset of nodes S ⊆ Vp∪ {0}, let A(S) be the set of arcs with both end points in S, i.e., A(S) ≔ {(i, j) ∈ S × S: i ≠ j}, and let δ(S) be the set of arcs with exactly one end point in S, i.e., δ(S) ≔ {(i, j) ∈ S × Sc} ∪ {(i, j) ∈ Sc× S}, whereSc=(Vp∪{0})∖S.We now present three alternative mixed-integer linear programming formulations that can serve as the basis for a branch-and-cut approach. These formulations differ in how they encode the various useful quantities (e.g., the arrival times at customer locations) and how they enforce the ConTSP’s requirements, namely the requirement that each period’s tour corresponds to a Hamiltonian tour (i.e., each node is incident to one outgoing and one incoming arc and there are no subtours) as well as that the tours across all periods are consistent (in the sense described in Section 2). Sometimes, a requirement is described via a superpolynomial set of constraints, which will have to be added dynamically in the context of a branch-and-cut framework. In the following, we will discuss the various strategies that can be followed in each case with regards to which constraints are to be utilized as cutting planes.Let binary variables xijpbe defined as follows:xijp={1,ifarc(i,j)∈Apisusedinthetourofperiodp0,otherwiseUsing these variables, the ConTSP can be cast with the following conceptual formulation:(1)min∑p∈P∑(i,j)∈Apcijxijp(2)s.t.xijp∈{0,1}∀(i,j)∈Ap,∀p∈P(3)∑j∈Np+(i)xijp=1∀i∈Vp∪{0},∀p∈P(4)∑j∈Np−(i)xjip=1∀i∈Vp∪{0},∀p∈P(5){(i,j)∈Ap:xijp=1}=Tp∀p∈P(6){Tp,Tq}isconsistent∀(p,q)∈P×P:p<qIn this formulation, the assignment (degree) constraints (3) and (4) ensure that each node is incident to one outgoing and one incoming arc in each period where it appears. Constraints (5) eliminate subtours by imposing that only Hamiltonian circuits be considered in each time period. Finally, constraints (6) ensure that the tours across all periods are consistent (in the sense described in Section 2).The formulations we are about to present below differ in the way they achieve the requirements of constraints (5) and (6). The first formulation involves only the binary arc variables xijpdefined above and utilizes a superpolynomial number of constraints to eliminate subtours and enforce consistency. In addition to binary arc variables xijp, the second formulation utilizes continuous node variables αipto represent the arrival time at customer i in period p, and employs big-M constraints to appropriately encode them. The use of big-M constraints is a common way to encode arrival times in formulations for the Vehicle Routing Problem with Time Windows (see, Desrochers & Laporte, 1991). The third formulation uses continuous arc variables yijpin addition to binary variables xijpand is based on a single-commodity flow representation of travel time.This model does not utilize any additional variables beyond the binary variables xijpdefined above. Constraints (5) are modeled via Eq. (7), which constitute the standard Subtour Elimination Constraints (SEC) originally proposed by Dantzig, Fulkerson, and Johnson (1954).(7)∑(i,j)∈A(S)xijp≤|S|−1∀S⊆Vp∪{0}:2≤|S|≤|Vp|−1,∀p∈PThe consistency constraints (6) are modeled using a new class of infeasible path elimination constraints (see, Ascheuer, Fischetti, & Grötschel, 2000), which we introduce in this work and refer to as Inconsistent Path Elimination Constraints (IPEC). Note that two paths in two different periods are said to be “inconsistent” if their simultaneous occurrence as sub-paths in the tours of their respective time periods renders the ConTSP solution infeasible, and each IPEC will forbid such an occurrence for a pair of inconsistent paths.LetP=(v1,…,vk)pdenote a non-empty path in period p that is formed by the arcs in the set{(vi,vi+1):i=1,…,k−1},where(vi,vi+1)⊆Apfor alli=1,…,k−1. We assume this path to be open and simple, i.e., k > 1 and vi≠ vjfor i ≠ j, and we use|P|=k−1to denote the path length, which is equal to the cardinality of the above arc set. Let alsoτ(P)=∑i=1k−1tvivi+1denote the time spent traveling on this path and processing all its nodes except the last one, vk. Given these definition, sufficient conditions for inconsistency of a pair of paths are given in Lemma 1.Lemma 1A pair of paths {P, Q}, whereP=(v1,…,vs)p,Q=(w1,…,wt)qand p ≠ q, is inconsistent, if any of the following conditions holds:(i)w1=v1=0,wt=vsand|τ(P)−τ(Q)|>Lw1=v1≠0,wt=vs≠0and|τ(P)−τ(Q)|>2Lw1=vs≠0,wt=v1≠0andτ(P)+τ(Q)>2LConsider a ConTSP solution in which P and Q appear as sub-paths in time periods p and q respectively. Denote byacpthe arrival time at customer c in period p. It holds from their definitions thatτ(P)=avsp−av1pandτ(Q)=awtq−aw1q. Let us take into account these relationships in the context described by each of the three conditions:(i)Sincewt=vs,we haveawtq=avsq. Furthermore, since the vehicle always departs from the depot at time 0, we haveav1p=aw1q=0. Therefore, the condition|τ(P)−τ(Q)|>Limplies that|avsp−avsq|>L; that is, customer vsviolates the maximum allowable arrival-time differential, rendering the pair of paths {P, Q} to be inconsistent.Sincew1=v1andwt=vs,we haveaw1q=av1qandawtq=avsq. Therefore, the condition|τ(P)−τ(Q)|>2Limplies that|avsp−av1p−avsq+av1q|>2L,which in turn implies that either|av1q−av1p|>Lor|avsp−avsq|>L(or both); that is, at least one of the two customers v1 and vsviolates the maximum allowable arrival-time differential, rendering the pair of paths {P, Q} to be inconsistent.Sincew1=vsandwt=v1,we haveaw1q=avsqandawtq=av1q. Therefore, the conditionτ(P)+τ(Q)>2Limplies that(avsp−av1p+av1q−avsq)>2L,which in turn implies that|avsp−av1p+av1q−avsq|>2L; that is, the same conclusion as in case (ii) above can be reached.□Lemma 1 states that if P and Q have common end nodes and if one of them, say v1, is to be visited at consistent times in periods p and q, then the other common end node, vs, cannot be visited at consistent times in those time periods, if the travel times to vsalong paths P and Q are sufficiently different.The basic form of the inequality that forbids the simultaneous occurrence of P and Q in a solution is presented in Eq. (8).(8)∑(i,j)∈Pxijp+∑(i,j)∈Qxijq≤|P|+|Q|−1Every feasible ConTSP solution must satisfy constraints (8) for every inconsistent pair of paths {P, Q}. Moreover, every solution to the set of constraints (2)–(4) and (7) (i.e., a set of tours) that violates the arrival-time consistency requirement for at least one customer must satisfy condition (i) of Lemma 1 for at least one pair of paths. Therefore, every solution that satisfies the set of constraints (2)–(4), (7) and (8), where the latter is imposed for all possible pairs of paths that meet the conditions of Lemma 1, constitutes a feasible ConTSP solution. As a result, the model consisting of Eqs. (1)–(4), (7) and (8) is a complete and valid ConTSP formulation. Note that this formulation is similar to the TSP with Time Windows (TSPTW) formulation of Ascheuer et al. (2001), which also consisted of only binary arc variables.We remark that the number of distinct SEC isO(2nh). Similarly, the number of distinct IPEC in the worst case, when every possible pair of paths is inconsistent, isO(n!2h2). Therefore, since the number of these constraints grows very fast (exponentially and factorially, respectively) with the size of the instance, we treat these inequalities as cutting planes and add them dynamically in a branch-and-cut solution framework. In practice, the number of such inequalities added is relatively small. Our separation procedures and associated separation protocols are discussed in detail in Section 5. Note that, although it may be more challenging in the case of a fractional solution, one can immediately and exactly (i.e., with guarantees to identify a violation, if one exists) separate these inequalities in the context of an integral solution (see Section 5 for details). To that end, the branch-and-cut framework is guaranteed to locate the optimal solution, as long as it is afforded enough computational resources. We discuss our computational experience in Section 6.This formulation explicitly encodes the arrival times at customers. To that purpose, we introduce continuous variables αip≥ 0 to capture the arrival time at each customer i ∈ Vpin each periodp∈P. These variables attain appropriate values via their participation in Miller–Tucker–Zemlin (MTZ) expressions (Miller, Tucker, & Zemlin, 1960), which are cast here in terms of travel time.44In the typical setting, MTZ expressions are cast in terms of order of customer visits or cumulative demand served (see, e.g., Desrochers & Laporte, 1991).For eachp∈P,let us define parametersfip:=mink∈Np+(i)tik,rip:=mink∈Np−(i)tki,for all i ∈ Vpand f0p≔ 0, r0p≔ 0; also defineξip:=maxj∈Np+(i){tij+fjp},for all i ∈ Vp. Constraints (9) apply.(9a)αip−αjp+tijxijp−tjixjip≤(Mp−fip−rjp)(1−xijp−xjip)∀(i,j)∈A(Vp),∀p∈P(9b)αip≥∑j∈Np−(i)(rjp+tji)xjip∀i∈Vp,∀p∈P(9c)αip+∑j∈Np+(i)(tij+fjp)xijp≤Mp(1−x0ip)+(t0i+ξip)x0ip∀i∈Vp,∀p∈P(9d)αip≤(Mp−fip)(1−x0ip)+t0ix0ip∀i∈Vp,∀p∈PThe parameters Mpare big-M coefficients that must be large enough so as not to exclude the optimal solution. If zUB is the objective value of a known feasible solution, obtained via a heuristic or otherwise, and ifζp*is the optimal objective of the TSP in period p, then the valueMp=zUB−∑q∈P:q≠pζq*suffices.55If no feasible solution to the problem is known, one may replace zUB with the sum of the maximal traveling salesman tours across all periods.This also implies that the value of the parameter Mpcan be dynamically tightened during the search as new incumbent solutions are identified.We remark that the MTZ expressions as presented in Eq. (9) incorporate several applicable liftings, which we have proposed here for the first time. We further remark that, if the triangle inequality on the travel time vector t is satisfied, namely if(10)tij+tjk≥tik∀i,j,k∈Vthen one may further lift the formulation by updating the definitions of its parameters as follows: fip≔ ti0, rip≔ t0i, andξip:=maxj∈Np+(i){tij+tj0}.Constraints (9) suffice to exclude subtours.66On a rather technical remark, note that MTZ constraints suffice to exclude a potential subtour only when the total travel time along this subtour is strictly positive (which is the typical case). For data sets that involve arcs of zero travel time, which may give rise to subtours of zero total travel time, one should pay attention to consider the relevant SEC explicitly (e.g., by adding them as a lazy cut).Furthermore, the introduction of variables αipenables the explicit enforcement of arrival-time consistency via constraints (11), achieving the arrival-time consistency requirement (6).(11)αip−αiq≤L∀i∈Vp∩Vq,∀(p,q)∈P×P:p≠qTherefore, the model consisting of Eqs. (1)–(4), (9) and (11) is a complete and valid ConTSP formulation.This is a single-commodity flow formulation, where the cumulative travel time is represented as a commodity, originating at the depot and flowing through the arcs. The single-commodity flow formulation for the TSP was originally proposed by Gavish and Graves (1978), where one unit of commodity was picked up along each traveled arc. A similar model was proposed by Maffioli and Sciomachen (1997) for the sequential ordering problem with time windows; the version presented here can be obtained from the latter by ignoring the precedence constraints. After introducing a set of continuous variables yijp≥ 0 to capture the commodity flow on each arc (i, j) ∈ Apin each periodp∈P,the following constraints apply.(12a)∑k∈Np+(j)yjkp=∑i∈Np−(j)(yijp+tijxijp)∀j∈Vp,∀p∈P(12b)∑j∈Np+(0)y0jp=0∀p∈P(12c)0≤yijp≤(Mp−tij−fjp)xijp∀(i,j)∈Ap,∀p∈PThe parameters Mpand fjpare as described in Section 3.2. The implications of the triangle inequality (10) on the definitions of fjpalso carry over from the discussion there.Constraints (12a) represent commodity-flow balances and enforce that the arrival time at node j equals the arrival time at its predecessor node plus the time it takes to travel from that predecessor to node j. Constraints (12b) simply require the vehicle to start from the depot at time 0 in each period. These constraints lead the commodity variables yijpto attain the value of the arrival time at node i, whenever (i, j) ∈ Apis part of the tour in period p, i.e., wheneverxijp=1. At the same time, constraints (12c) will ensure thatyijp=0,wheneverxijp=0.The commodity-flow constraints (12) suffice to eliminate subtours.77The remark of the previous footnote applies also for the case of commodity-flow constraints.Furthermore, the presence of commodity variables yijpenables us to explicitly enforce arrival-time consistency via constraints (13), achieving the arrival-time consistency requirement (6).(13)∑j∈Np+(i)yijp−∑j∈Nq+(i)yijq≤L∀i∈Vp∩Vq,∀(p,q)∈P×P:p≠qTherefore, the model consisting of Eqs. (1)–(4), (12) and (13) is a complete and valid ConTSP formulation.Finally, we remark that an alternative formulation results by utilizing commodity-flow constraints merely to eliminate subtours while using the IPEC (8), instead of constraints (13), to enforce arrival-time consistency. In such a case, one could apply projection techniques as in (Gouveia, 1995) to obtain a formulation in the space of the binary arc variables xijponly. Conversely, we also note that it is possible to model the ConTSP without introducing binary arc variables at all. This technique, which was used by Langevin, Desrochers, Desrosiers, Gélinas, and Soumis (1993) to model the TSPTW, utilizes a two-commodity flow representation of the cumulative travel time that is subsequently exploited in a branch-and-bound solution framework. The lower bound given by the linear programming relaxation of the two-commodity flow formulation would be identical to that of the single-commodity flow formulation (Desrochers & Laporte, 1991).Formulation 1 utilizes only the binary variables xijp, but features a factorially-large set of constraints. In contrast, Formulations 2 and 3 feature a polynomial number of constraints, but utilize additional variables. Table 1provides a synopsis of the sizes of the three formulations.Formulation 1 can be viewed as an example of a ConTSP formulation where an asymmetric TSP formulation (the one introduced by Dantzig et al. (1954), in this case) is utilized to achieve requirement (5), while the arrival-time consistency requirement (6) is enforced via Eq. (8). In principle, any valid asymmetric TSP formulation can be used to model (5), and we refer the interested reader to Öncan, Altınel, and Laporte (2009), Godinho, Gouveia, and Pesneau (2011) and Roberti and Toth (2012) for recent surveys of such formulations. As long as binary arc variables are encoded explicitly, one can in conjunction use Eq. (8) to enforce requirement (6) for a comprehensive ConTSP formulation. Consequently, known tightness results and relationships between the utilized asymmetric TSP formulations will persist in their ConTSP counterparts. On that note, Roberti and Toth (2012) conducted a comparison of exact algorithms for the asymmetric TSP and found the branch-and-cut algorithm of Fischetti et al. (2007), which is based on the TSP formulation by Dantzig et al. (1954), to be the most efficient computationally; hence, our Formulation 1 is expected to also be the most efficient among the formulations in its class. Formulations 2 and 3, however, follow a different modeling paradigm. These formulations encode travel times explicitly, and they use this information to enforce requirement (6) without having to introduce the IPEC (8). While this precludes a straightforward analysis of tightness relationships among our three ConTSP formulations, we present in Section 6.1 empirical evidence indicating that the dual bound obtained using the LP relaxation of Formulation 1 is always stronger than the bounds obtained using the LP relaxations of Formulations 2 and 3, while no empirical dominance relationship can be inferred between the latter two formulations.Let us define the ConTSP polytope, PCONTSP, to be the convex hull of all integer feasible solutions of Formulation 1,PCONTSP=conv{x∈R∑p∈P|Ap|:xsatisfies(2),(3),(4),(7),(8)}.Several families of inequalities are valid for PCONTSP. These include all inequalities that are valid for the asymmetric TSP. Note that an inequality that is valid for any of the asymmetric TSP instance associated with a periodp∈Pcan be directly applied on the ConTSP instance. In our study, we consider Subtour Elimination and 2-matching Constraints. In addition, we consider the cross-period Inconsistent Path Elimination Constraints introduced earlier in Section 3.1. As discussed, the inclusion of SEC and IPEC is necessary for Formulation 1, which relies on these inequalities to eliminate subtours and enforce arrival-time consistency, respectively. The inequalities are redundant for Formulations 2 and 3, as long as the integrality restrictions (2) on the variables xijpare retained; however, they are still capable of strengthening the linear relaxation and should, thus, be used in conjunction with these formulations as well. In fact, the use of these inequalities as cutting planes is of fundamental importance from a practical point of view. For the instances we considered in our computational study (see Section 6), adding the cutting planes was very helpful in expediting the proof of optimality.These inequalities, which were introduced as constraints (7), forbid the occurrence of subtours and enforce the overall connectivity of the tour. Note however that, because of the degree constraints (3) and (4), the SEC defined by a vertex set S ⊂ Vp∪ {0} and its complementSc=(Vp∪{0})∖S(see Eq. 14 below) are equivalent. To that end, one may use form (14) as an alternate to form (7). Numerical criteria, such as constraint sparsity (which depends on the size of set S), can be used to decide which of the two forms to utilize as a cutting plane in each case.(14)∑(i,j)∈A(Sc)xijp≤|Sc|−1∀S⊆Vp∪{0}:2≤|S|≤|Vp|−1,∀p∈PThe 2-matching Constraints (also known as Blossom Inequalities) are particular cases of a more general class of inequalities that is referred to as Comb Inequalities (Fischetti, 1991). For a given periodp∈Pand given vertex setsH,T1,T2,…,Tk⊂Vp,where k ≥ 3 and odd, satisfying (i)|H∩Ti|=1fori=1,…,k,(ii)|Ti∖H|=1fori=1,…,k,(iii)Ti∩Tj=∅for 1 ≤ i < j ≤ k, the corresponding 2-matching Constraint (2MC) is presented in Eq. (15).(15)∑(i,j)∈A(H)xijp+∑i=1k∑(i,j)∈A(Ti)xijp≤|H|+k−12Such constraints are obtained by adding the degree constraints (3) and (4) for all i ∈ H, adding the subtour elimination constraints (7) defined by the vertex setsS=Tifor alli∈{1,…,k},dividing by 2, and rounding down the right hand side to the nearest integer. More general Comb Inequalities may be obtained by relaxing conditions (i) and (ii) above as follows: |H ∩ Ti| ≥ 1 and |Ti∖H| ≥ 1 fori=1,…,k. Constraint (15) may be equivalently cast in the form (16). As before, constraint sparsity can be used in each case to decide whether a cutting plane should be represented in form (15) or form (16).(16)∑(i,j)∈δ(H)∖(⋃i=1kA(Ti))xijp−∑i=1k∑(i,j)∈A(Ti)xijp≥1−k.These inequalities, which were introduced in Section 3.1, are cross-period constraints that forbid pairs of paths belonging to different periods that are inconsistent to simultaneously appear in the solution. Given a pair of paths {P, Q}, whereP=(v1,…,vs)pandQ=(w1,…,wt)q,the basic form of the inequality that forbids their simultaneous occurrence is presented in Eq. (17).(17)∑i=1s−1xvivi+1p+∑i=1t−1xwiwi+1q≤s+t−3However, it is possible to strengthen this basic form (see also Ascheuer et al. (2000) for how to strengthen the infeasible path elimination constraints they proposed in the context of the TSPTW). In particular, it can be strengthened into the so-called Tournament Constraint (18).(18)∑i=1s−1∑j=i+1sxvivjp+∑i=1t−1∑j=i+1txwiwjq≤s+t−3Furthermore, for a given inconsistent pair of paths {P, Q} as described above, let the paths obtained by reversing paths P and Q be denoted asP′=(vs,…,v1)pandQ′=(wt,…,w1)q,respectively. If all three pairs of paths {P, Q′}, {P′, Q} and {P′, Q′} are also inconsistent, then the symmetric inequality (19), which corresponds to a lifting of inequality (17), is also valid and can be used instead of the latter.(19)∑i=1s−1(xvivi+1p+xvi+1vip)+∑i=1t−1(xwiwi+1q+xwi+1wiq)≤s+t−3Finally, if {P1, Q1} and {P2, Q2} are two inconsistent pairs of paths in periods p and q, such that P1 is contained in P2 and Q1 is contained in Q2, then the IPEC defined by {P2, Q2} is dominated by the one defined by {P1, Q1}.A polyhedral analysis to determine whether the inequalities considered above are facet-defining for PCONTSP is typically a difficult task. For a fixed graph size, |Vp|, and for fixed L, small changes in the travel times tijcan change the dimension of PCONTSP or even make the entire instance infeasible. Although there may exist specific instances in which individual inequalities coincide with facets of PCONTSP, in general none of the three families of inequalities induces facets of the polytope, even if the instance is feasible. This observation is interesting inasmuch it implies that known polyhedral results for asymmetric TSP do not carry over to the case of ConTSP. For example, all SEC are known to induce facets of the asymmetric TSP polytope for the case of n ≥ 4 (Grötschel & Padberg, 1985), while all 2MC are known to be facet-defining for the asymmetric TSP polytope for the case of n ≥ 6 (Fischetti, 1991). However, as Proposition 1 shows, this is not true for the ConTSP.Proposition 1The Subtour Elimination, 2-matching and Inconsistent Path Elimination Constraints do not induce facets of PCONTSP, in general.Consider a ConTSP instance withn=7,h=2,V1={1,2,3,4,5,6}andV2={1,7}. The arrival-time consistency requirement applies only to node 1, since node 1 is the only customer node common to both periods 1 and 2. Assume that the travel times are symmetric and are as depicted in Fig. 1. For a maximum allowable arrival-time differential ofL=1,it is straightforward to see that all feasible ConTSP solutions are of the form{〈0,1,i2,…,i6〉1,〈0,1,7〉2},wherei2,…,i6is some permutation of nodes 2 through 6. In this case, one may verify that the rank of the set of feasible solutions is 20 and that 0 does not participate in the affine hull of this set.88This may be verified numerically by showing the following linear system (in variablesλi∈R) to be infeasible:∑i∈Fxiλi=0,∑i∈Fλi=1. Here, {xi}i ∈ Fis the set of feasible ConTSP solutions.Therefore, the affine rank of PCONTSP is 20 anddim(PCONTSP)=19.By a similar reasoning as above, it can be verified that the face induced by the SEC of the form (7), wherep=1andS={0,2,3},is of dimension equal to 8 and, therefore, this inequality does not induce a facet of PCONTSP. The face induced by the 2MC of the form (15), wherep=1,k=3,H={0,1,2},T1={0,3},T2={1,4}andT3={2,5},is of dimension equal to 7 and, therefore, this inequality does not induce a facet of PCONTSP. In fact, it can be verified that none of the Comb Inequalities that are possible in period 1 (which include, as a special case, all 2-matching Constraints), induce facets of PCONTSP. Finally, consider the IPEC of the form (8), whereP=(0,2,1)1andQ=(0,7,1)2. It can be verified that this inequality does not induce a face of PCONTSP, i.e., there is no integral point in PCONTSP that satisfies this inequality as an equality; therefore, it is not facet-defining for PCONTSP.□We implemented three separate branch-and-cut algorithms, one based on each of the formulations presented in Sections 3.1, 3.2 and 3.3. At the interest of working with sufficiently tractable linear programming (LP) relaxations, a subset of applicable constraints are initially ignored and added later as cutting planes, if necessary. More specifically, in the case of Formulation 1, the initial LP relaxation consisted only of the degree constraints (3) and (4), along with continuous bounds on the x variables (relaxation of the integrality restrictions (2)). In the case of Formulation 2, constraints (9)–(11) were considered, along with the degree constraints and variable bounds, while in the case of Formulation 3, the initial LP relaxation consisted of constraints (12) and (13), in addition to the degree constraints and variable bounds.The SEC, 2MC and IPEC were considered in all cases as cutting planes and dynamically added back to the applicable model, when found to be violated, at each node of the search tree. At the root node, if we are unable to generate any additional violated inequalities, we permanently fix nonbasic x variables to their current values using reduced cost information. Let UB be the current (incumbent) upper bound (obtained through a heuristic or otherwise) and let LB be the global (root-node) lower bound obtained from the applicable LP relaxation. Letc¯ijpbe the reduced cost of each nonbasic variable xijpin the root-node LP solution. Then, ifxijp=0andLB+c¯ijp>UB,we can fix this variable to zero. Conversely, ifxijp=1andLB−c¯ijp>UB,then we can fix this variable to one. In a similar manner, using a local lower bound, one may set non-basic x variables to their current values in the sub-tree associated with each node of the search process. These fixings ensure that the variables are never branched upon in the corresponding sub-trees. The remainder of this section elaborates on our separation routines and associated protocols.In our implementation, we utilize both heuristic procedures and an exact scheme to separate violated SEC. In particular, we first attempt to separate these cuts using the separation heuristics described in Applegate et al. (2007, chap. 6). The advantage of these routines is that they often lead to the identification of several violated inequalities, as opposed to the one most violated inequality, and we have found it beneficial to be adding all such identified inequalities in a single cutting-plane iteration. When the heuristic routines do not identify any violations, we employ the exact separation scheme that was introduced by Padberg and Rinaldi (1990). This is a polynomial-time routine that is based on a minimum-cut algorithm. The overall running time of our separation routine is dominated by the maximum-flow computations in the exact scheme, for which we use the Boost graph library (Siek, Lee, & Lumsdaine, 2000).In our implementation, we utilize both heuristic procedures and an exact scheme to separate violated 2MC. More specifically, we first attempt to separate these cuts using the so-called odd-component, Grötschel-Holland and block heuristic routines described in Applegate et al. (2007, chap. 7). Note that the latter heuristic also identifies violated general Comb Inequalities. As before, each of these heuristics may identify several violated inequalities, and we have found it beneficial to be adding all of them in a single cutting-plane iteration. If none of the heuristic routines succeeds in generating a violated cut, we employ the polynomial-time exact routine proposed by Letchford, Reinelt, and Theis (2004). The running time of this routine is dominated by the constructor of the Gomory-Hu cut-tree and, in our implementation, we utilize a code written by Skorobohatyj (2004) for this purpose. Given its computational burden, we only employ the exact routine during cutting-plane iterations at the root node. Alternatively, one may use the polynomial-time exact algorithm proposed by Padberg and Rao (1982) to separate violated 2MC.Our separation routines to identify violated IPEC is guided by Lemma 1. We use the following polynomial-time enumerative procedure to identify inconsistent pairs of paths. Given a (fractional) solution x*, consider the support graph in each time period p. This support graph has the same node set as Gpand involves those arcs (i, j) ∈ Apfor whichxijp*>0. By considering every node in each period’s support graph as a start node, elementary paths are grown in a depth-first fashion by moving along the incident outgoing arcs of strictly positive flow. Each pathP=(v1,…,vs)pis extended as long as the following two conditions hold: (i) the total flow on the path,∑i=1s−1xvivi+1p*,is strictly greater than|P|−12=(s−1)−12,and (ii) vs≠ 0, i.e., the path has not reached the depot. Because of the first condition, an arc (i, j) ∈ Apis added to the path only ifxijp*>0.5,while the path-growing procedure stops as soon as all incident outgoing arcs have weight strictly less than 0.5. The degree constraint∑j∈Np+(i)xijp*=1ensures that, for each node i, there is at most one incident outgoing arc withxijp*>0.5. Hence, there is at most one (unique) path extending out of each node and the path-growing procedure terminates in polynomial time.After all such paths have been identified in all time periods, violated inequalities (17) are identified as follows: for each pair of nodes v1, vs∈ (Vp∪ {0}) ∩ (Vq∪ {0}), we consider all pairs of paths in periods p and q such that each path contains both v1 and vs. If any of the conditions (i)–(iii) in Lemma 1 are satisfied for the pair of sub-paths corresponding to v1 and vsas terminal nodes, then we have identified a violated inequality.For every pair of paths that satisfy either condition (ii) or (iii) in Lemma 1, we check whether the corresponding IPEC of the form (17) can be lifted to the symmetric inequality (19) (see Section 4.3). If such a lifting is not possible, we add the corresponding Tournament Constraint (Eq. 18), because any pair of paths which violates inequality (17) also violates (18), and we have found it computationally beneficial to enforce the IPEC via the latter, stronger form. We remark that, if the solution x* is integral and does not contain any subtours, then condition (i) of Lemma 1 is sufficient to guarantee the exactness of the separation procedure.Our computational experiments indicated that the number of violated IPEC identified during a given cutting-plane iteration at a node of the branch-and-cut tree may be very large, especially for Formulation 1. For this reason, we attempt to reduce the number of constraints added to the constraint matrix in the following two ways: (i) we remove any dominated inequalities (see Section 4.3), and (ii) whenever the number of violated inequalities exceeds 2|V|, we calculate for each cut (considered here as being of form 18) the ratio between its absolute violation at the current solution and the number of non-zero coefficients in the cut, namely∑i=1s−1∑j=i+1sxvivjp*+∑i=1t−1∑j=i+1txwiwjq*−(s+t−3)12s(s−1)+12t(t−1),and we only add to the constraint matrix the 2|V| cuts with the highest such ratio.We attempt to separate violated inequalities at each node of the branch-and-cut tree in the following sequence: (i) SEC for each time periodp∈P,(ii) 2MC for each time periodp∈P,and (iii) IPEC for each pair of time periodsp,q∈P:p<q. When we identify violated members of any of the above families of cuts in a given time period, then no attempt is made to separate members of other families of cuts that appear further in the separation sequence and that involve variables from that time period. At any given node other than the root node, whenever new cuts are added but the objective function value did not improve by at least 0.1 percent in the last 20 cutting-plane iterations, we exit the separation sequence and resort to branching. At the root node, we have found it beneficial to keep separating as many cuts as possible before branching, even if the lower bound does not show significant improvement at that moment. Finally, we remark that, since all inequalities considered are valid globally (i.e., throughout the branch-and-cut tree), any violated inequality identified is added as a global cut.Since no benchmark data sets are currently available for the ConTSP in the open literature, we compiled a set of benchmark problems by extending symmetric and asymmetric TSP instances from the well-known TSPLIB library (Reinelt, 1991) into 3- and 5-period ConTSP instances. In particular, we considered all 23 instances that involve up to 50 customers (i.e., 51 nodes). For each TSPLIB instance, we constructed 3- and 5-period ConTSP instances in a manner similar to that proposed by Groër et al. (2009) for the ConVRP. More specifically, we considered each of the n customers to have a probability f of requiring service in each period, where f ∈ {0.5, 0.7, 0.9}. Note that, in general, this results in instances in which a different number of customers require service in each time period; however, the average number of customers (across periods) is approximately fn. The distances acquired from the TSPLIB data99As per the TSPLIB standard, all distances were rounded down to the nearest integer. Note, however, that this assumption is not restrictive and does not invalidate any of the theoretical results presented in this paper.were interpreted as being both travel costs (cij) and travel times (tij), while we assumed all service times (si) to be zero. The first node in each of these data sets was arbitrarily regarded to be the depot. For every resulting multi-period instance, we selected the maximum allowable arrival-time differential, L, to be 10, 15 or 20 percent of the maximum (across periods) travel time of the corresponding optimal (single-period) traveling salesman tours,1010We computed the optimal tours of these TSP instances with an in-house exact TSP solver implementation. We found this to be a rather trivial task, as each single period of a ConTSP instance involved no more than 50 customers.which correspond to practically reasonable selections for a required level of consistency.1111Assuming the optimal traveling salesman tours are to be traversed along an 8-hour shift of driving, a value ofL=10%corresponds to a maximum arrival time-difference of 48 minutes (i.e., a guaranteed arrival time within 24 minutes of some nominal time), whileL=20%corresponds to double that amount. To further put this into perspective, it should be remarked that, for the benchmark problems we considered, the maximum arrival-time difference (across all customers) of the multi-period solution that consists of the optimal traveling salesman tours in each period (whereby no consistency is enforced) is approximately 68% of the maximum vehicle travel-time across periods, i.e., a 5 hours and 26 minutes window within the 8-hour shift, on average. Therefore, arrival-time consistency at reasonable levels would not be enforced using a purely cost-based routing approach, further motivating the need for considering the ConTSP.The overall process resulted in nine 3-period and nine 5-period instances for each of the original TSPLIB problems, for a total of 414 ConTSP benchmark instances. These instances are available for download at http://gounaris.cheme.cmu.edu/datasets/contsp/.In order to fairly compare among the different formulations we consider in this study, we explicitly supplied in each case the best available solution as an initial incumbent and we disabled any heuristic effort by the solver to obtain a better incumbent. By doing so, we eliminate the effect of the solver’s (heuristic) primal bounding effort, and we can better appreciate the performance of our (exact) branch-and-cut framework in terms of its ability to generate dual bounds and prove optimality. All implementations were developed in the C++ programming language using the C API of ILOG CPLEX 12.6 and compiled using the GCC 4.8.2 compiler with optimization level -O2. We used the default CPLEX strong branching and best-bound node selection strategies. Moreover, unless otherwise mentioned, all CPLEX-generated cuts were disabled because we observed that using these general-purpose cuts increased overall computation times. All computations were conducted on a single-core (non hyper-threaded) of an Intel Xeon 2.8 GHz processor with a software-imposed memory limit of 3 GB RAM. Computational times reported correspond to actual “wall-clock” times.In order to gain some insight about the tightness of the three formulations proposed in Section 3, we compare in Table 2the corresponding root-node gaps.1212Optimality gaps in this study are defined asUB−LBUB×100%percent, where UB is the global upper bound and LB is the global lower bound of the branch-and-cut tree. Root-node gaps correspond to optimality gaps after processing the root of the search tree.The reported gap values constitute an average across all nine 3-period and nine 5-period ConTSP instances constructed from the TSPLIB data indicated in the first column. Furthermore, we report in each case, four characteristic root-node gap quantities, as follows: (C0) the gap obtained using the initial LP relaxation (as described in the preamble of Section 5), before any cut separation; (C1) the gap obtained after separation of SEC; (C2) the gap obtained after separation of SEC and 2MC; (C3) the gap obtained after separation of SEC, 2MC and IPEC. This analysis helps us appreciate the effect that each of the three families of cuts we consider in this study has on each formulation’s tightness. Note that, in order to ensure a fair comparison, we had disabled all CPLEX options pertaining to performing any possible MIP-based bound strengthening.We observe that the initial LP bounds (gaps C0) are generally weak, in the order of 10 to 20 percent, but these bounds get significantly reduced, down to roughly 1.6 percent, when violated SEC are added as cutting planes (gaps C1). The additional separation of 2MC further reduces the gaps by 0.14 percent, on average. The gaps C2 are indicative of the strength of the lower bounds possible after separating over all the structural, TSP-related cuts. Finally, the separation of IPEC further improves the bounds, on average, by 0.11 percent for Formulation 1 and by 0.01 percent for Formulations 2 and 3 (gaps C3). Note that the gaps C3 constitute the effective “root-node gaps” of our branch-and-cut framework.Comparing across formulations, Formulation 1 has the weakest initial LP bound, while the strongest initial LP bound is featured by Formulation 2. However, Formulation 1 appears to be more amenable for bound improvement after separation of valid inequalities. More specifically, after the separation of all three families of cuts considered in this study (gaps C3), the lower bounds of Formulation 1 become stronger and are higher by 0.10 and 0.08 percent, on average, compared to the respective bounds of Formulations 2 and 3. In 81 out of the 414 instances considered, the final root-node gaps (C3) were equal in all three formulations. In the remaining 333 instances, the root node bound of Formulation 1 was strongest in 215 instances, while those of Formulations 2 and 3 were strongest in 9 and 93 instances, respectively. Table 2 also shows the averages across the symmetric and asymmetric instances separately. It is interesting to note that Formulation 3 provided the strongest bound in most of the asymmetric instances, while Formulation 1 gave the strongest bound in most of the symmetric instances. This can be attributed to the fact that, while Formulation 3 is inherently asymmetric, Formulation 1 takes into account any asymmetry only through the IPEC. It remains to be investigated whether the addition of any cuts specific to the asymmetric TSP polytope (see, e.g., Fischetti & Toth, 1997) can significantly improve our lower bounds.Table 3presents the time spent and the number of cuts added at the root node during the runs that resulted in gaps C3; that is, after separation of all three families of cuts (SEC, 2MC and IPEC). Each reported value is averaged across 18 instances (similarly to Table 2). The average time spent at the root node is lowest in Formulation 1 and highest in Formulation 3. Thus, Formulation 1 is able to provide a stronger bound in a smaller amount of time, on average. We further observe that, at the root node, the number of IPEC added in the cases of Formulations 2 and 3 is negligible. This is probably because the explicit arrival-time consistency constraints (11) and (13) in these formulations prevent the frequent occurrence of (fractional) inconsistent paths for us to separate.We attempted to solve all of our 414 benchmark problems using each of the branch-and-cut algorithms under a time limit of 2 hours. The goal of this study was to determine if there is a clear “winner” amongst the formulations. In Table 4, we report for each formulation the number of instances (out of 18) for which optimality was proved as well as the total number of branch-and-cut nodes explored and time required (averaged across all instances for which optimality was proved). For those instances which could not be solved in 2 hours, the residual gap (i.e., optimality gap at the time limit) is reported as an average. The three formulations are also compared in Fig. 2, in which we plot performance profiles (Dolan & Moré, 2002) across the totality of our data set.Within the imposed time limit of 2 hours, Formulations 1, 2 and 3 were able to prove the optimality of 308, 291 and 297 instances respectively. Out of the 414 instances, the optimality of 96 instances could not be proved by any of the 3 formulations within the time limit. In the remaining 318 instances, the branch-and-cut framework based on Formulation 1 was fastest in 90 percent (285) of the instances, the one based on Formulation 2 in 2 percent (7), while the one based on Formulation 3 was fastest in 8 percent (26) of the instances. For the 96 instances in which none of the algorithms could prove optimality after 2 hours, the final optimality gap featured by Formulation 1 was tightest in 71 instances and was second best in 13 instances; Formulation 2 was best in 9 instances and second best in 72 instances, while Formulation 3 was best in 16 instances and second best in 11 instances. Although there does not appear to be any one formulation that performs best across the whole range of instances, Formulation 1 clearly dominates in terms of number of instances solved, quality of lower bounds obtained and solution times. Table 4 also summarizes separately the computational performance on instances with low, medium and high levels of the maximum allowable arrival-time differential (L), on 3-period and 5-period instances, as well as on symmetric and asymmetric instances. We observe that, on average, the instances with lower values of L (higher service quality), higher number of periods and asymmetric travel costs are harder to solve than their counterparts with higher values of L (lower service quality), lower number of periods and symmetric costs, respectively.To better demonstrate the usefulness of the proposed branch-and-cut framework, we also attempted to solve all of the 414 instances with CPLEX in its default setting; that is, with a branch-and-cut implementation that uses general-purpose cuts only, and without separation of the valid inequalities described in Section 4. We utilized Formulations 2 and 3, which are our two formulations that are polynomial in size (as opposed to Formulation 1, which is not), and can thus serve as the basis for this experiment. As before, the best available solution was provided from the beginning as the upper bound in each case, and a time limit of 2 CPU hours was imposed. The performance of default CPLEX is also compared in Fig. 2. In summary, using Formulations 2 and 3, default CPLEX was able to prove the optimality of 182 and 246 instances, respectively. The average times were 845.9 and 664.8 seconds, the average numbers of nodes were 284,085 and 35,819, while the average optimality gaps for the unsolved instances were 6.46 and 5.13 percent, respectively. We observe that the computational performance of these formulations with default CPLEX branch-and-cut is significantly worse than the performance of the same formulations in the context of our proposed framework, both in terms of number of instances solved and in terms of residual optimality gaps. This observation eludes to the fact that a custom-built algorithm, such as the one developed in this study, is necessary to efficiently address the ConTSP instances we considered.Table 5 reports, for each of the formulations, the time spent in separation routines as a percentage of the total computation time (subject to a time limit of 2 CPU hours, as in Table 4) as well as the number of different families of violated cuts identified during the course of the search process. It is evident that separation time is not a major part of the total computing time, especially in the case of Formulations 2 and 3. The majority of the time is instead spent towards the solution of the LP relaxations. On average, more cuts are added in the case of Formulation 1 (predominantly IPEC), while fewer cuts are added in the case of Formulation 3. Comparing with the data reported in Table 3, it is interesting to note that, although SEC are the majority of cuts violated early in the solution process, IPEC violations become more common, raising the relative percentage of separated IPEC. This can be attributed to the fact that, at deeper levels of the search-tree, the tours are refined enough to not admit any more subtour or 2-matching violations, leading to more cut separation effort towards IPEC.To conclude, we highlight that the size of an instance does not necessarily correlate with solution tractability. Sometimes, instances of larger size may solve significantly faster than some of their smaller counterparts. For example, the 3-period 34 node instanceftv33,at the service frequencyf=0.7and medium consistency level, is very difficult to solve with any of the 3 formulations. After 2 hours of computation time, the branch-and-cut algorithm based on Formulation 1 was only able to close the gap down to 2.17 percent. To that end, 19,408 nodes were opened and 10,034 cuts were added. On the other hand, the 3-period 48 node instancegr48,at the same service frequency and consistency levels, can be solved to optimality in under a second, requiring only 66 nodes and generating 286 cuts in the process. The largest instance solved to guaranteed optimality features 51 nodes and 5 time periods. However, a number of smaller instances could not be solved by the framework. The smallest unsolved instance features 34 nodes and 3 time periods.In this section, we aim to estimate the additional cost that one must incur, on average, in order to provide consistent service. To that purpose, we report in Table 6 the difference between the optimal ConTSP cost and the sum across all time periods of the costs of the optimal traveling salesman tours (without consistency), as a percentage of the latter. This quantity is reported separately for each different level of service frequency (f ), length of the planning horizon (h) and maximum allowable arrival-time differential (L) considered in this study, in order to also investigate the effect of these parameters on the overall cost increase.Our study shows that an arguably small cost increase, 1.31 percent, must be incurred, on average, in order to provide consistent service. Across all instances we considered, the required additional cost varies between 0 and 8.25 percent, with four out of five instances commanding less than 2 percent of a cost increase. For low values of the maximum allowable arrival-time differential, i.e., high levels of service consistency, the additional cost that must be incurred reaches 1.65 percent, on average, and this number decreases to 1.05 percent when consistency levels are reduced (high L). Moreover, it is interesting to observe that a relatively higher cost must be incurred when the service frequency is 70 percent, as opposed to when it is 50 or 90 percent, and when the number of time periods is 5, as opposed to when it is 3. We also remark that the price of consistency is, on average, higher for asymmetric instances.

@&#CONCLUSIONS@&#
Multi-period routing problems with consistency requirements represent a practically relevant class of problems, as distributors can gain significant competitive advantages by providing consistent service to their customers. Arrival-time consistency, i.e., the requirement to visit customers at approximately the same time during the routing horizon, has been identified as one plausible avenue to add such value. In this paper, we introduced three mixed-integer linear programming formulations for the Consistent Traveling Salesman Problem and analyzed their potential worthiness in a branch-and-cut framework. This constitutes the first exact approach in the open literature that addresses a routing problem with consistency constraints. The effectiveness of the branch-and-cut algorithm was tested on a set of benchmark problems that was compiled by extending the well-known TSPLIB database. Instances with up to 50 customers that require service over a 5-period planning horizon were solved to guaranteed optimality. A formulation that uses only binary variables and that relies on cutting planes to enforce all consistency requirements was shown to be the most attractive from a computational viewpoint. Finally, our study suggests that a modest routing cost increase of the order of 1–2 percent would typically suffice so as to provide consistent service. Expected benefits for the distributor, however, may well make up for this small cost increase. Evidently, consistency of service constitutes a value proposition that distributors should consider further.