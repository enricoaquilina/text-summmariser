@&#MAIN-TITLE@&#
Isogeometric local h-refinement strategy based on multigrids

@&#HIGHLIGHTS@&#
An isogeometric local h-refinement based on multigrid resolution is proposed.It leads to a solution on a quasi-optimal mesh for a given precision criterion.It solves the problem of non-straight boundaries in multigrid resolution with FEA.

@&#KEYPHRASES@&#
Isogeometric analysis,Local h-refinement,Controlled accuracy,Full-multigrid method,

@&#ABSTRACT@&#
This paper presents an isogeometric local h-refinement algorithm based on localized multigrid resolution dedicated to computational mechanics. This algorithm leads to a solution on a quasi-optimal refined mesh initially unknown for a given precision criterion. Moreover, it allows us to circumvent the obstacle of refinement of non-straight geometric boundaries existing in full multigrid algorithms with isoparametric finite element analysis.

@&#INTRODUCTION@&#
Multigrid algorithms are iterative solvers showing interesting rates of convergence [1–3]. They were originally introduced to solve fluid mechanics problems using finite differences by Brandt and Livne [4] and were extended to solve solid mechanics problems with finite element analysis by Parsons and Hall [5,6]. Multigrid resolution has already been used with IGA as a way to reduce computational time by Gahalaut et al. [7]. This kind of resolution is designed for problems where the fine discretization is known a priori.There has been in the recent years quite an extensive work on designing efficient solvers and preconditioners that are well suited to isogeometric analysis (IGA). Up to our knowledge the first work on specific isogeometric preconditioners is attributed to Beirão da Veiga et al. [8] and Buffa et al. [9]. Multigrid (MG) and multilevel methods were also coupled with IGA to design efficient iterative solvers, see for example the work of Gahalaut et al. [7,10] and Donatelli et al. [11]. Finally one can also cite the work of Collier et al. [12] on the performance of standard iterative solvers for IGA. It is important to note that in the work presented in this paper, our goal is not to design efficient iterative solvers for IGA based on multigrid methods. We suggest that multigrid methods can be used to obtain a new local h-refinement strategy for IGA with controlled accuracy of the solution. Consequently, the proposed work falls into the class of isogemetric methods with local h-refinement such as T-splines [13,14], LR splines [15] and hierarchical b-splines [16,17].The use of the full multigrid algorithm (FMG) with finite element analysis (FEA) combined with an error indicator has been developed as a solver with adaptative refinement. This algorithm is very efficient but presents a loss of accuracy when the refinement of non-straight boundaries is required as shown in Adams and Taylor [3] and Biboulet et al. [18]. One way to deal with this difficulty is to go back to the CAD geometry each time a refinement is needed. We propose here a way to circumvent this problem using IsoGeometric Analysis. Indeed, IGA allows an exact description of the CAD geometry even with non-straight boundaries [19]. Refinement of such meshes can be done keeping the exact description of the CAD geometry. In this paper, the MG resolution is used as an automatic local mesh refinement tool with controlled accuracy. Here the desired fine mesh is not known a priori and depends on the required level of accuracy on the solution.This paper is organized as follows. First a short introduction to MG techniques with FEA and a short introduction to IGA with NURBS are presented. Then, we present a localized FMG with IGA algorithm. Finally, the performances of this algorithm are analyzed on several examples.MG methods are mainly based on the smoothing properties of iterative solvers such as Gauss–Seidel or preconditioned conjugate gradients. In other words, MG methods are based on the ability of these solvers to capture the high frequency error in the solution (see [5,6,20]). One iteration of the chosen iterative solver is called a smoothing step. The first idea is to exploit this property using two grids, in the well-known correction scheme. These two nested meshes of the same geometry cover the whole considered domain which is therefore a global MG approach. Quantities on the fine and coarse grid are noted respectively by the f and c subscript. K is the stiffness matrix, F are the generalized forces and U is the discretized displacement field we are looking for using a FE discretization of a given linear solid mechanics problem.Here, the aim of the CS is to solve the equilibrium equation arising from a static linear elastic analysis on the fine gridKfUf=Ff.1.The first step is to do ν1 smoothing steps on the fine grid with an iterative solver initialized with an initial guessUf0, obtaining a solutionU¯f0.Assuming that the iterative solver decreases the high frequency error, then the differenceEf0betweenU¯f0and the exact solution we are looking forUf(Ef0=Uf−U¯f0) is only composed by low frequency error. ConsequentlyEf0can be computed on the coarse grid.Therefore, the residualRf0=Ff−KfU¯f0is transferred on the coarse grid with a restriction operatorR, and the low frequency error is computed with a direct solve on the coarse gridKcEc0=R(Rf0).Then, the displacement coarse correction is transferred on the fine grid with a prolongation operatorP, and the solution on the fine grid is corrected asU^f0=U¯f+P(Ec0).Finally, ν2 smoothing steps are done onU^f0to correct the high frequency error introduced by the prolongation operator giving the solutionUf1.These operations form a two grids MG cycle. The two grids MG cycle is repeated until convergence of the solution is reached. The algorithm is presented in Fig. 1.This algorithm can be generalized for N grids. Indeed, if the direct solve on the coarse grid is too expensive, the CS can be applied recursively with a limited number of MG cycles γ. Fig. 2shows a MG cycle with three grids forγ=1(V-cycle) andγ=2(W-cycle). Applied to N grids, MG solvers can be quasi-optimal and reach a complexity inO(n)(wheren=size(Kf)).In practice, the convergence rate of a MG resolution can depend on the quality of the initial guessUf0. A way to avoid such a dependency is the FMG resolution. For a two grid resolution with the CS, the idea consists in using as an initial guess on the fine gridUf0as the prolongation of the solution computed on the coarse gridUf0=P(Uc)withKcUc=Fc. The generalization to N grids is represented in Fig. 3. Solutions boxed in Fig. 3 represent the converged solutions on a given level of discretization.In the previous part prolongation and restriction operatorsPandRare mentioned. There are some constraints on these operators dealing with primal quantities (U) and dual quantities (R). We can see in Fig. 4a representation of the relation between these quantities in the two grids case.A condition we can impose to these operators is to preserve internal work for any couple(Uc,Ff)(1)〈Uc,Fc〉=〈Uf,Ff〉,∀(Uc,Ff)⇔UcTRFf=UcTPTFf,∀(Uc,Ff)⇔R=PTThe conservation condition on the internal work gives us a relation between the two operatorsPandR. For a given prolongation operatorPwe have no choice on the restriction operator if we want this condition to be verified (Eq. (1)).It is possible to impose another kind of condition: for allUc, a prolongation, a solve on the fine grid, a restriction and a solve on the coarse grid have to keepUcunchanged(2)KcUc=Fc,∀Uc⇔KcUc=RKfPUc,∀Uc⇔Kc=RKfPIt gives a condition on stiffness matrices of the two grids (Eq. (2)). MG resolution using this approach are algebraic MG resolutions (see [21]). We are not going to use that kind of approach here because it implies a new computation of all stiffness matrices each time a new grid is added which can become expensive.Usually in MG resolution with FEA, interpolation operators are used as prolongation operators. We will see further in this paper that this solution is not pertinent in MG resolution with IGA.The FMG solver presented in Section 1.1.1 is suited for problems with a known final mesh. It is possible to build an algorithm with automatic refinement using an error indicator with an FMG resolution. In this case only the coarse discretization is known a priori and the successive grids are built locally with information from the error indicator (see Fig. 5).This algorithm uses several levels of discretization, but all the meshes are defined on the whole structure. It implies that quantities of interest (displacement in the linear elastic case) are computed on areas with identical discretization on several meshes. An example with three levels of discretization is displayed in Fig. 6. With a MG algorithm with global refinement, quantities of interest are computed on blue areas which have the same discretization on the three grids and on red areas which have the same discretization on the last two grids. It is possible to save computational cost by avoiding the calculation on blue and red areas for each grid. It is the principle of localization in MG algorithms.The idea of localization is to refine only the area where the level of accuracy is not satisfied (see Fig. 7).This kind of refinement creates internal interfaces. With ΓNbeing the boundary of ΩAwith Neumann boundary conditions, the internal interfaces ΓAB(between ΩAand ΩB) and ΓBC(between ΩBand ΩC) areΓAB=ΩA∩∂ΩB\ΓNandΓBC=ΩB∩∂ΩC\ΓN(in red in Fig. 7). Dirichlet boundary conditions from the lower level of discretization are imposed on these interfaces. WithuΩkbeing the displacement solution on the Ωkdomain, we wantuΩA,uΩBanduΩCto verify(3){u|ΓABΩB=u|ΓABΩA,u|ΓBCΩC=u|ΓBCΩB.Further details are given in Cavin et al. [2], Rannou et al. [22], Biotteau et al. [23].We briefly review the concept of NURBS-based IGA first presented in Cottrell et al. [19] and Hughes et al. [24], where a detailed account may be found. NURBS are a generalization of B-splines and standard in CAD and computer graphics for geometry modeling (see [25–27]).B-splines are piecewise polynomial functions with a prescribed degree of continuity. Univariate B-spline basis functions are constructed from a knot vector, a set of coordinates in parametric space,Ξ={ξ1,ξ2,…,ξn+p+1}, whereξi∈Ris the ith knot, i is the knot index,i=1,2,…,n+p+1, p is the polynomial order, and n is the number of basis functions. More than one knot can be placed at the same location in the parametric space. If m is the multiplicity of a given knot, the functions areCp−mcontinuous at that location. If the knots are equally spaced, the knot vector is said to be uniform. A knot vector is referred to as open if its first and last knots have multiplicity p+1. This results in the basis being interpolatory at the endpoints of the interval.B-spline basis functions for a given order p are defined recursively in the parametric space by way of the knot vector Ξ. Beginning with piecewise constants (p=0) we have(4)Ni,0(ξ)={1ifξi≤ξ<ξi+1,0otherwise.Forp=1,2,3,…, the basis is defined by the Cox–de Boor recursion formula(5)Ni,p(ξ)=ξ−ξiξi+p−ξiNi,p−1(ξ)+ξi+p+1−ξξi+p+1−ξi+1Ni+1,p−1(ξ).Let dsdenote the number of spatial dimensions. A B-spline curve inRdsis defined as follows:(6)C(ξ)=∑i=1nPiNi,p(ξ),wherePi∈Rdsdenotes control point i.The univariate B-spline concept can be extended to multiple dimensions with the use of tensor products, but representation of many desired shapes of engineering interests, such as conic sections, require further generalization. Non-Uniform Rational B-Splines (NURBS), rational projections of higher dimensional B-splines, can be introduced for this purpose and consequently share many of the same properties as B-splines. More details can be found in Cohen et al. [25], Rogers et al. [27] and Piegl and Tiller [26], as well as Cottrell et al. [19].Analogues of finite element h-and p-refinement are available in IGA. h-refinement is termed knot insertion and consists in adding new knots in the knot vectors. Knot insertion does not change the geometric modeling and preserves continuity as long as new knots are not already present in the knot vector. p-refinement is termed order elevation and consists in increasing the polynomial order of the basis functions. As with knot insertion, neither the geometry nor the parametrization is changed during the process. Moreover, continuity is preserved at element boundaries by increasing knot multiplicity. The main difference in IGA when comparing refinement strategies with finite element ones is that h-and p-refinement do not commute. The flexibility of knot insertion and order elevation allows us to introduce k-refinement in which order and continuity of the basis functions can be simultaneously increased. This can be attained by performing order elevation on the coarse geometric mesh followed by knot insertion up to the desired mesh refinement. It is important to note that k-refinement will produce maximum continuity on a patch if the coarsest mesh is composed of a single element. If the initial mesh comprises constraints on continuity across element boundaries, these will exist on all meshes. For more insight on mesh generation and refinement in IGA see Cottrell et al. [19, Chapter 2].Here, we propose an isogeometric local h-refinement strategy based on the localized FMG algorithm (see Section 1.1.3) for a given precision criterion. First, prolongation and restriction operators between a coarse grid and a localized fine one have to be defined for IGA. Then, a way to evaluate error between these two successive grids has to be chosen. Finally, the local h-refinement procedure developed will be exposed.We want to build a prolongation operatorPbetween two successive nested grids, a coarse one and a fine one. WithUfbeing the control variables of the displacement on the fine grid, andUcbeing the control variables of the displacement on the coarse grid, we wantPto satisfy(7)Uf=P(Uc).The case of order 1 NURBS basis functions correspond to order 1 finite element functions. The classical prolongation operator for order 1 finite element basis functions for nested grids is based on interpolation. In this particular case, the h-refinement process does not modify current control points and the computing of new control points is localized by elements. Hence, the prolongation operator is easy to build a priori, knowing only the element refinement rule (see Fig. 8).In the case of higher order NURBS basis functions, the h-refinement process of an element depends on his neighboring elements. Hence, the prolongation operator is not known a priori and depends on the elements that are to be refined (see Fig. 8). The problem has to be treated at the patch level rather that at the element level. In order to build the prolongation operator, the isoparametric concept is used. The prolongation operator will be built during the geometry refinement and will be used for the prolongation of the displacement fields. For the piecewise linear case, this procedure is identical to the one presented for the particular case ofC0linear finite elements.We consider nested meshes emanating from NURBS based IGA and with h-refinement. With IGA, basis functions used to describe the displacement field are the same as the ones used to describe the geometry. Therefore, withQfandQcbeing respectively the control points of the geometry on the fine grid and the coarse grid,Psatisfies(8)Qf=P(Qc).In the FMG algorithm, the fine grid is always obtained from a nested refinement of the coarse grid. The prolongation operator we chose is obtained under a matrix form during the h-refinement procedure of a NURBS mesh as presented in Cohen et al. [25].In the 2D case, h-refinement is done in two steps. h-refinement is performed in one parametric direction η, an intermediate grid is obtained. Then h-refinement is done in the other parametric direction ξ. We define two intermediate prolongation operatorsPηandPξwhich are respectively the prolongation operators in the first parametric direction η and in the second parametric direction ξ (Fig. 9). Therefore we have(9)P=Pξ○Pη.Using this decomposition of the prolongation operator(Pξ,Pη)instead of the full operatorPallows an important saving of computational memory. This is a direct consequence of the tensor product structure of NURBS based IGA.This method works well for building a prolongation operator between two nested grids obtained from a global refinement of the coarse one. We saw in Section 1.1.3 that localized multigrid resolution methods are more efficient than global ones. Therefore, a local prolongation operator has to be defined.To build a local prolongation operator, a small adaptation of the previous method is done. Actually, it has to allow the extraction of a part of the domain, and ensure the same smoothness of the solution across the internal grid interfaces as the one used on the coarse grid.In order to build this local prolongation operator, the extraction operatorPeis introduced. The principle of this extraction operation is detailed in Fig. 10. This is a one dimension example with B-splines quadratic basis functions. The part of the domain to be extracted is[0.375,0.875]. Control points associated to dotted black basis functions are removed, control points associated to red basis functions will be imposed in a strong way in order to ensure the same smoothness as for the underlying coarse grid and control points associated to blue basis functions will be the unknowns of the problem.The construction of local prolongation operator is detailed in Fig. 11. Elements to be refined are colored in red. The global prolongation operatorPgbetween the two first grids is built with the previous method. Now, the NURBS mesh of the convex containing the elements to be refined is extracted with the extraction operatorPedefined previously. The local prolongation operatorPlocis obtained with the composition of these two operatorsPloc=Pe○Pg. Each of the operators can be decomposed with the two parametric directionsPi=Pξi○Pηi,i∈[e,g].This proposed local refinement allows us to impose the conditions detailed in Eq. (3) (Section 1.1.3) in a strong sense. Indeed, the discretization of Eq. (3) leads toU|Γ2=Ploc(U|Γ1), with Γ being the internal boundary between Ω2 and Ω1. This operator ensures the desired smoothness of the solution across the internal interface (in blue in Fig. 11). Fig. 12is an example of localization for a one dimensional and a two dimensional problem.In the implemented algorithm, several areas of a NURBS mesh can be locally refined. For each of these areas a prolongation operator is built (Fig. 13).Now, we are ready to define an error indicator able to identify elements to be refined.In FMG, we need to know the error between the converged solution at the end of a multigrid cycle and the exact solution in order to build a finer localized grid to reach a given level of accuracy. In practice, the true useful information is not the exact value of the error, but which elements have to be refined. As a consequence, we will define an error indicator which allows us to have an approximate of the exact error. Furthermore, a keypoint is that it has to be not expensive in term of CPU time (see for instance [18,22,23]).The error indicator with the solutions on the two fine grids Ωkand Ωk+1 of the current grid set(Ω1,Ω2,…,Ωk,Ωk+1)is always computed on grid Ωk. For clarity, a quantity α computed from the converged solution on the grid Ωiis noted αi.They are several error indicators which can be used in localized FMG algorithm [2]:•displacement error indicator :∥uk+1−uk∥L2∥u0∥L2,stress error indicator :VM(σk+1−σk)VM(σ0),energy density error indicator :|ek+1−ek|e0,energy error indicator :∫Ω|ek+1−ek|dΩ∫Ωe0dΩ,It is shown in Cavin et al. [2] that displacement and energy error indicator are the only ones that behave well in singular problems. Moreover, with NURBS based IGA, it is cheaper to compute the energy error indicator knowing the non-assembled stiffness matrix than computing the displacement error indicator which requires the evaluation of all the basis functions. The energy error indicator is a global indicator. In order to build a local refinement strategy, a local criterion is needed. In the next section is presented a local criterion derived from the global energy error indicator.For a given set of grids(Ω0,…,Ωk,Ωk+1), we define(10){Di=Ωi\Ωi+1,∀i∈[[0;k]],Dk+1=Ωk+1,D¯i=Ωi∩Ωi+1,∀i∈[[0;k]],D¯k+1={∅}.With these notations, we have(11){⋃i∈[[0;k+1]]Di=Ω,∫Di∩DjdΩ=0,∀i≠j\(i,j)∈[[0;k+1]]2.D¯k=Dk+1The definition of these domains is illustrated for a four grids set in Fig. 14.Here we use the energy error indicator as a global indicator. Due to the localization, the quantityei,i∈[[0;k+1]]cannot be defined on the whole domain Ω. The energy error indicator η is redefined as(12)η2=∑1≤i≤k+1∫Di|ei−ei−1|dΩ∫Ω0e0dΩThe energy error indicator has to verifyη2≤ϵ2, with ϵ being the precision criterion on the whole structure imposed by the user.For each grid, we define the following:(13){ηi2=∫D¯i|ei+1−ei|dΩ∫Ωe0dΩ,ϵ02=ϵ2,ϵi2=ϵi−12−∫Di|ei−ei−1|dΩ∫Ωe0dΩ,∀i∈[[1;k]].The localized FMG with IGA algorithm stops whenηk2≤ϵk2. Indeed, with this condition, the global precision criterion is checked:(14)ηk2=η2−∑1≤i≤k∫Di|ei−ei−1|dΩ∫Ωe0dΩ≤ϵk2⇔η2≤ϵk2+∑1≤i≤k∫Di|ei−ei−1|dΩ∫Ωe0dΩ=ϵ2For the given set of grids(Ω0,…,Ωk,Ωk+1), a grid Ωk+2 will be built if the arrest criterionηk2≤ϵk2is not verified. In order to build the next grid Ωk+2, a local refinement criterion is needed to select the possible refined elements of the grid Ωk+1.As explained in Section 2.2, the error indicator is computed on the grid Ωk. Therefore the local refinement criterion is on the grid Ωk. The way to choose the elements of the grid Ωk+1 to be refined is detailed in the next section.We define the quantities(15)ΩD¯ke:elementofthegridΩkonthedomainD¯k,(ηke)2=∫ΩD¯ke|ek+1−ek|dΩ∫Ωe0dΩ×∫D¯kdΩ∫ΩD¯kedΩ.The local criterion chosen is to flag all the elementsΩD¯kewhich are not satisfying(ηke)2≤ϵk2for a further refinement. Indeed, if all elements ofD¯kcheck this criterion, we have(16)(ηke)2=∫ΩD¯ke|ek+1−ek|dΩ∫Ωe0dΩ×∫D¯kdΩ∫ΩD¯kedΩ≤ϵk2,∀ΩD¯ke⊂D¯kThe summation on everyΩDk¯eleads to(17)∑ΩD¯ke⊂D¯k∫ΩD¯ke|ek+1−ek|dΩ∫Ωe0dΩ≤ϵk2×∑ΩD¯ke⊂D¯k∫ΩD¯kedΩ∫D¯kdΩand knowing thatDk+1=D¯k, we have(18){∫D¯k|ek+1−ek|dΩ∫Ωe0dΩ=∫Dk+1|ek+1−ek|dΩ∫Ωe0dΩ=ηk2∑ΩD¯ke⊂D¯k∫ΩD¯kedΩ∫D¯kdΩ=1which leads toηk2≤ϵk2Therefore, if the local criterion(ηke)2≤ϵk2is checked for each elementΩD¯keofD¯k, the arrest criterion previously presented is checked and the localized FMG with IGA algorithm stops.The next section details how are chosen the elements on the grid Ωk+1 knowing the elements flagged on the grid Ωk.Elements on the grid Ωkon which the error indicator is higher than the required level of accuracy are flagged for a further refinement. The solution is not accurate enough in these areas. So all the basis function having support on these elements have to be refined too. Consequently, for each of these elements, thefloor((p+1)/2)neighbor in the ξ direction and thefloor((q+1)/2)elements in the η direction (where p and q are respectively the polynomial degree of basis functions in the ξ and the η direction) are flagged for a further refinement.The local refinement procedure is detailed in Fig. 15for a given grid set(Ω1,Ω2,…,Ωk,Ωk+1)for the creation of a finer grid Ωk+2.All the results presented here are obtained for two dimensional problems with linear elasticity in the static case. The iterative solver used as a smoother in the FMG algorithm is a preconditioned conjugate gradient with the symmetric Gauss‐Seidel preconditioner [28]. The error indicator used for refinement is the energy error indicator. The considered numbers of relaxation areν1=ν2=3. Results for three classical problems are presented. The infinite plate with elliptic hole under in-plane tension has an analytic solution (presented in Appendix A, for further details see [29]). Cook׳s membrane presents a singularity in its solution, and the L-shaped plate presents a singularity of higher order in its solution.The first example is the infinite plate with a elliptic hole under in-plane tension. We study the problem for linear elasticity under plane strain conditions. Due to the symmetries, the domain is restricted to a quarter. The exact solution of this problem is known and applied as a Neumann boundary condition on the finite quarter plate, Fig. 16.This example is used to show the advantages of a local FMG IGA algorithm on a global FMG IGA algorithm.Quantities used to quantify performances of these algorithms are•the evolution of the exact energy error on the whole domain (computed with the analytic solution, see Fig. 16) depending on the total number of degrees of freedom. For a set of grids(Ω1,Ω2,…,Ωk), the total number of degrees of freedomndof=∑i=1kdof(Ωi),the number of MG cycles done for the solving on each level of grid, which is directly related to the computational cost.The geometry used as initialization for the FMG IGA algorithm is the geometry from the CAD software (Fig. 17(a)). The final mesh obtained with the global FMG IGA algorithm is shown in Fig. 17(b) and the final mesh obtained with the local FMG IGA algorithm is displayed in Fig. 17(c).We can see in Fig. 18(a) that the localized FMG IGA algorithm gives a more accurate solution than the solution from the global FMG IGA algorithm with fewer dofs. Moreover, Fig. 18(b) shows that the localized FMG IGA algorithm converges with fewer MG iterations than the global FMG IGA algorithm. These results validate the use of the localization in the FMG IGA algorithm.In this part the good performances of the FMG IGA algorithm are highlighted with two numerical examples: Cook׳s membrane and the L-shaped plate. These problems are still solved for a two dimensional case in linear elasticity under plane strain conditions. First, performances of the FMG algorithm with FEA and with IGA will be compared, then the good behavior of the FMG IGA algorithm regarding the degree of basis functions will be highlighted.In this part, we will show the good numerical behavior of the algorithm solving singular problems and show the interest of usingC1quadratic basis functions instead ofC0quadratic basis functions used in FEA. In the first case a classical h-refinement for IGA keeping the solutionC1through element boundaries is used and in the second case, a h-refinement giving a solutionC0through element boundaries is done.Final meshes, the error indicator convergence and the number of MG cycles until convergence will be compared.Data used for solving these two problems are given in Fig. 19.The initial mesh from the CAD software and the final mesh obtained when the FMG IGA algorithm converges are given in Fig. 20.Figs. 21(a) and 22(a) show that aC1discretization has better convergence rate than aC0one. Once the algorithms converged, theC1discretization deals with a set of 15 grids and theC0one with a set of 16 grids.We can note that the convergence rates obtained for these two benchmarks are not as good as the convergence rate obtained for the infinite plate with elliptic hole. This is due to the singularities in the solution of these two problems.The computational cost of the solving with aC1discretization (as in IGA) and a solving with aC0discretization is not easy to compare. TheC1discretization allows convergence to a given error level with fewer degree of freedom compared to aC0discretization, but a MG cycle is more expensive with theC1discretization due to the fact that we are dealing with less sparse matrices. For the numerical examples presented here, the computational costs were approximately the same. These results highlight the interest of using aC1discretization (as in IGA) compared to aC0discretization (as in FEA). For the same amount of computational work, a solution with a higher continuity degree is obtained.Here, the Cook׳s membrane problem is solved using the FMG IGA algorithm for linear, quadratic and cubic basis functions. Fig. 23(a) and (b) show the energy error indicator and the number of MG cycles until convergence for the three cases. As expected, the number of degrees of freedom needed to reach convergence decreases when the degree of the basis functions increase. However, the computational cost of the solving is not easy to interpret, as MG cycle is more expensive regarding the bandwidth of matrices involved.

@&#CONCLUSIONS@&#
