@&#MAIN-TITLE@&#
Control of Condorcet voting: Complexity and a Relation-Algebraic approach

@&#HIGHLIGHTS@&#
We study the constructive control by deleting voters for Condorcet voting.We prove that this problem is NP-hard if the uncovered alternatives win.We present a relation-algebraic model of Condorcet voting.We apply it to solve control problems.We demonstrate how the computer system RelView can be used to execute the developed algorithms.

@&#KEYPHRASES@&#
Artificial intelligence,Condorcet voting,Control problem,Uncovered set,Relation algebra,

@&#ABSTRACT@&#
We study the constructive variant of the control problem for Condorcet voting, where control is done by deleting voters. We prove that this problem remains NP-hard if instead of Condorcet winners the alternatives in the uncovered set win. Furthermore, we present a relation-algebraic model of Condorcet voting and relation-algebraic specifications of the dominance relation and the solutions of the control problem. All our relation-algebraic specifications immediately can be translated into the programming language of the OBDD-based computer system RelView. Our approach is very flexible and especially appropriate for prototyping and experimentation, and as such very instructive for educational purposes. It can easily be applied to other voting rules and control problems.

@&#INTRODUCTION@&#
Elections have been studied by scientists from different disciplines for more than a thousand years. In addition to the obvious moral and political issues, elections also give rise to several computational questions, which are studied in the field of computational social choice. The most basic of these questions is the requirement of an algorithm that efficiently computes the winner(s) of an election. Surprisingly, unless P = NP, such algorithms do not exist for all natural voting rules, see Hemaspaandra, Hemaspaandra, and Rothe (1997) for an example.However, elections also give rise to computational problems which ideally should be hard to solve. One of them is the manipulation problem (see e.g., Bartholdi & Orlin, 1991). It asks to determine a way for a group of voters to vote that serves their interest best, even though their votes might not represent their true preferences. Unfortunately, classic results show that every reasonable voting rule gives voters incentives to vote strategically in this way (Gibbard-Satterthwaite theorem, cf. Gibbard, 1973; Satterthwaite, 1975). In the present paper, we are concerned with the related control problem (see e.g., Bartholdi, Tovey, & Trick, 1992). Here, the authority conducting the election (usually called the chair) knows all preferences of the voters and her goal is to achieve a specific result. To do this, she can remove or add alternatives or voters from the election, or partition the election. We focus on control by removing voters: Here the chair’s goal is to make her preferred alternative win by removing as few voters as possible in order to remain inconspicuous. The chair’s knowledge of all individual preferences and the ability to delete or add voters by ‘dirty tricks’ are worst-case assumptions that are not entirely unreasonable in some settings, e.g., in case of governing boards, commissions of political institutions, and meetings of members of a club.The resulting computational problem is as follows: Given an election consisting of a set of alternatives, voters along with information on how they will vote, and a preferred alternative a*, determine the smallest number k such that there is a set Y of at most k voters such that removing all voters in Y makes a* win the election. Following the above-mentioned paper (Bartholdi & Orlin, 1991), numerous papers have studied the complexity of manipulation and control problems for elections (see e.g., Conitzer, Sandholm, & Lang, 2007; Faliszewski, Hemaspaandra, & Schnoor, 2008; Hemaspaandra, Hemaspaandra, & Rothe, 2007 and also the surveys Brandt, Conitzer, & Endriss, 2013; Faliszewski, Hemaspaandra, & Hemaspaandra, 2010; Faliszewski & Procaccia, 2010). For many voting rules, control or manipulation is NP-complete; such voting rules are deemed to be ‘computationally resistant’ against this attempt to influence the outcome of the election.In this paper, we contribute to the investigation of the complexity of the control problem. We focus on two voting rules, both of which are based on the Condorcet criterion. This criterion requires that if there is a so-called Condorcet winner (an alternative a that beats every other alternative b in the sense that more voters prefer a to b than vice versa), then this alternative wins the election. Note that the Condorcet winner is unique if there is one, but there can be elections without a Condorcet winner. We study two voting rules, which differ in their behavior for the case that there is no Condorcet winner:•The Condorcet voting rule (cf. Bartholdi et al., 1992) states that no alternative wins the election in this case.The Uncovered alternatives rule (cf. Brandt & Fischer, 2008; Duggan, 2011) states that each uncovered alternative wins the election in the absenceof a Condorcet winner. An alternative a is ‘uncovered’ if there is no alternative b such that b beats a, and every alternative c which beats b also beats a.For the first of the above voting rules, NP-hardness of the control problem has been shown in Bartholdi et al. (1992), for the second rule, we prove NP-hardness in this paper. Hence both voting rules are what is also called ‘computationally resistant’ against control by deleting voters. However, it has long been observed that efficient algorithms that work for many cases can exist for NP-hard problems, the very successful history of SAT solvers being an impressive example. In the context of computational social choice, Conitzer and Sandholm (2006) demonstrate a fast and simple algorithm for the manipulation problem that works correctly on ‘most’ inputs (according to a suitably chosen probability distribution) and is allowed to compute an incorrect result on the remaining inputs.We pursue an alternative approach, and use the relation-algebraic tool RelView (see e.g., Berghammer, Neumann, & Vorozhtsov, 2005) to solve the control problem for both voting rules mentioned above. Due to the NP-hardness of both problems, our algorithms do not run in polynomial time. However, since RelView represents relations as OBDDs (a special kind of branching programs), the worst-case exponential running time can be improved for many practical instances. To the best of our knowledge, this is the first paper that uses relation algebra for computational social choice by directly taking the voter’s preferences into account. The only comparable previous results that we are aware of allow to determine the winner(s) of an election, provided that the dominance relation (essentially the election’s tournament-representation that abstracts away the individual votes) is precomputed (Berghammer, 2013). Our contribution is twofold:1.We prove that the control problem is NP-hard for the Uncovered alternatives voting rule.We apply a relation-algebraic approach to algorithmically solve the control problem for both voting rules: Condorcet voting and Uncovered alternatives. These algorithms perform well also on non-toy instances.The paper is organized as follows: In Section 2, we introduce the two voting rules we study and the associated control problems. In Section 3, we prove our NP-hardness result. In Section 4, we give an introduction to relation algebra using elections as an example. In Section 5, we show how to perform a computation in the relation-algebraic model, namely the computation of the ‘dominance’ relation for Condorcet voting. Our relation-algebraic algorithms for the control problem are stated in Section 6. In Section 7, we conclude and mention some directions for future research.Usually, an election consists of a non-empty and finite set N of voters (agents, individuals,…), normally N = {1, …, n}, a non-empty and finite set A of alternatives (candidates, parties,…), the individual preferences of the voters, and a voting rule that aggregates the winners from the individual preferences. A well-known voting rule is the Condorcet voting rule. Here each voter ranks the alternatives from top to bottom, i.e., the individual preferences of the voters i ∈ N are expressed via linear strict orders >ion A. An instance of a Condorcet election consists of the sets N, A, and the relations >ion A for all i ∈ N.We say that a dominates b iff the number of voters i with a >ib is (strictly) greater than the number of voters i with b >ia. We then say that a beats b with p points, where p is the (positive) difference between these numbers. The dominance relation C contains all pairs (a, b) such that a dominates b. Since C may contain cycles and ties, an alternative that dominates all other ones—the above-mentioned Condorcet winner—does not necessarily exist. To get around this problem, choice sets have been introduced which specify the winners (see e.g., Brandt, 2009; Laslier, 1997 for more details).We study the choice set uncovered set, on which the Uncovered alternatives voting rule is based. The uncovered set is usually defined via an induced transitive subrelation of the dominance relation C, called covering relation. In the literature different such relations are discussed. We concentrate on one such relation G on A that in Duggan (2011) is called Gilles covering and in Brandt and Fischer (2008)upward covering. G relates the alternatives b, a ∈ A (i.e., b covers a) iff b dominates a and for all alternatives c ∈ A, if c dominates b then c dominates a. The upward (or Gilles) uncovered set is the set of all a ∈ A such that there exists no b ∈ A that covers a. It is non-empty because G is a strict order and A is finite. The winner set of an election according to the Uncovered alternatives voting rule is the uncovered set in the above sense.The main focus of our paper is the constructive control by deleting voters problem (in the sequel, we will often only write “control problem”). This problem is defined as follows: Given a specific alternative a* ∈ A, determine a smallest set of voters Y such that the removal of Y from the set N of all voters makes a* win the election. (See the end of Section 3 for a brief discussion on related control problems.)The computational complexity of this problem of course depends on the voting rule that is used to determine the winner of the election. For the two voting rules we study in this paper, the complexity is as follows;•The control problem is NP-hard for the Condorcet voting rule. This result is due to Bartholdi et al. (1992).In this paper, we show that the problem is also NP-hard for the Uncovered alternatives voting rule.Concerning the second point, we want to note that the proof presented in Bartholdi et al. (1992) cannot be applied to obtain our result. In fact, our construction is much more involved than the one in the above-mentioned proof.In this section we prove that constructive control by deleting voters is NP-hard for the voting rule Uncovered alternatives. We first introduce an auxiliary problem:Definition 3.1The problem X4C (exact cover by 4-sets) is the following:Input:SetsS1,…,Sk⊆{1,…,n}such that for alli∈{1,…,k}it holds|Si|=4and|{i|j∈Si}|=3for allj∈{1,…,n}.Question:Is there some setI⊆{1,…,k}such that⋃i∈ISi={1,…,n}andSi∩Sj=∅for alli,j∈Iwithi≠j?The specific problem X4C is similar to the standard covering problem X3C. The main difference—except for the cardinalities of the sets—is that in the problem X4C, each element of {1, …, n} appears in the same number of sets Si. This feature gives us more control over the construction of the election instance in the proof of our hardness result; in particular this allows us to compute quite narrow bounds on the points for each alternative. First note that for every positive instance of X4C, the cardinality of the solution I must be|I|=14n,since each Sihas cardinality 4 and the union must have cardinality n. On the other hand, if an I with⋃i∈ISi={1,…,n}exists and|I|=14n,then by a simple counting argument, Si∩Sj= ∅ for all i, j ∈ I with i ≠ j. Also, the value k in each positive instance must be equal to34n,since each Sihas 4 elements and each j ∈ {1, …, n} appears in exactly 3 of the sets Si. In particular, n is a multiple of 4 in every positive X4C instance.We now prove that this problem is indeed NP-complete, using a reduction from a specific variant of the satisfiability problem as introduced in Faliszewski et al. (2008).Lemma 3.1The problem X4C is NP-hard.We reduce from 1-in-3-Sat’ introduced in Faliszewski et al. (2008). An instance of the problem 1-in-3-Sat’ is a formula of the formφ=⋀i=1n1-in-3(x1i,x2i,x3i),where 1-in − 3(x, y, z) is a clause which is true iff exactly one of the variables x, y, and z is true. Additionally, φ has the following properties: In each clause the 3 appearing variables are distinct, and each variable appears in exactly 4 clauses. Note that this implies that the number of distinct variables in φ is34n.If an arbitrary instance φ of the problem 1-in-3-Sat’ is given, then it can be transferred into an instance of the problem X4C as follows:•Each of the n clauses in φ becomes an element of {1, …, n},Each variable xibecomes a set Sicontaining the clauses in which xiappears.First assume that φ is satisfiable. Then there is an assignment I with I ⊧ φ. Since I satisfies exactly one variable in each clause, we know that n variable occurrences are satisfied by I. Since each variable, in particular each of the satisfied variables, appears in 4 clauses, we get that14nmany variables are satisfied by I. We can naturally interpret I as the set of indices i with I ⊧ xiand claim that I satisfies the conditions of X4C. As mentioned above, since|I|=14n,it suffices to show that⋃i∈ISi={1,…,n}. This follows from the construction: Since I (seen as a truth assignment to the variables) satisfies each clause, we know that for each clause, there is a variable satisfied by I. For the X4C instance, this implies that for each element i ∈ {1, …, n}, there is an index j ∈ I with i ∈ Sj.For the converse, assume that there is an index set I satisfying the conditions of X4C. We can interpret I as a truth assignment for the variables in φ in the obvious way: A variable is set to 1 iff its corresponding set is in the selection I. We show that I, seen as a truth assignment, satisfies the formula φ. Hence let1-in-3(x1i,x2i,x3i)be a clause in φ. Since I is a set cover, we know that for this clause, an element containing the set element corresponding to the clause is selected in I. Hence I satisfies at least one of the variablesx1i,x2i,andx3i. Since I is an exact cover, we also know that each set element appears only in one of the selected sets, hence only one of the variables is true, which completes the proof.□Having completed the proof of Lemma 3.1, we can now show the main result of this section. It concerns the constructive control of Condorcet voting by deleting voters for the Uncovered alternatives voting rule.Theorem 3.1The constructive control problem by deleting voters is NP-hard for the Uncovered alternatives voting rule.We reduce from X4C. Let an X4C instance consisting of the setsS1,…,S34nbe given. (Recall from the above thatk=34nin every positive instance of X4C, hence ifk≠34n,we produce a trivial negative instance of the control problem.) Without loss of generality we assume n ≥ 16. From the instance, we construct an election E as follows. First we definet=14n−2(recall that in every positive instance of X4C, n is a multiple of 4, hence t is always an integer). Next we introduce alternatives a* (the alternative that the chair wants to win), s1, …, snand b1, …, bn. To specify the voters we introduce in the reduction, we use the following sets:S≠i={sj|j≠i}B≠i={bj|j≠i}B∉Si={bj|j∉Si}B∈Si={bj|j∈Si}We now introduce four groups of voters, with preferences as follows:1.For each i ∈ {1, …, n} we introduce t voters voting S≠i> si> bi> B≠i> a*.For each i ∈ {1, …, n} we introduce t voters voting B≠i> a* > si> bi> S≠i.For each set Siwe introduce a voter votingB∉Si>a*>S>B∈Si.We introduce a single vote voting a* > S > B.The above notation of the voter’s preferences using sets means that the order of the alternatives inside the sets is irrelevant. For instance, a* > S > B means that the final voter prefers a* to all other alternatives, then s1, …, snfollow in any order and, finally, the alternatives b1, …, bnfollow, again, in any order. Note that, by definition of X4C, we get|B∉Si|=n−4and|B∈Si|=4. Now, the question in our constructed instance of the control problem is whether the specific alternative a* can be made uncovered by deleting at most14nvoters.We first study the relationship between each of the relevant alternatives in the constructed election before any deletion of voters is performed. Note that if the point difference between two alternatives is at least14n+1,then deleting at most14nvoters cannot change which of these alternatives dominates the other. The following relationships can be verified with a complete case distinction:Each bibeats a* with a surplus of at least14n+1points. To see this, we consider all voters introduced in the election. For each j ≠ i, the 2t voters of the first two groups place biahead of a*. From the voters introduced for i, one puts biahead of a* and the other puts a* ahead of bi. We now consider the voters introduced for the sets Sj: There are 3 sets Sjin which i appears (these place a* ahead of bi) and i does not appear in the remaining34n−3many (these place biahead of a*). Finally, a* > S > B put a* ahead of bi. Hence the lead of biover a* is2t(n−1)+1−1−3+34n−3−1=2t(n−1)+34n−7,which is at least14n+1,since we assumed n ≥ 16.The alternative a* beats each siwith a surplus of at least14n+1points. Note that half of the voters introduced in the first two groups place siahead of a* and the other half put a* ahead of si. Hence a* and sitie in the sub-election consisting of these voters. In the34nvoters introduced for the sets Si, however, a* is always placed ahead of si. Finally, a* is ahead of siin a* > S > B. As a consequence a* beats each siwith34n+1many points, which is at least14n+1.If i ≠ j, then bibeats sjwith a surplus of at least14n+1points. To see that this is true, note that the voters introduced in the first two groups are neutral between biand sj, as half of them have biahead of sjand the other half have sjahead of bi(recall that i ≠ j). Now consider the voters introduced for the sets Si. There are 3 such orders which place sjahead of bi(the ones corresponding to sets Slwith i ∈ Sl), and the remaining34n−3many place biahead of sj(these are the ones corresponding to sets Slwith i ∉ Sl). In a* > S > B, siis voted ahead of bi. Hence bibeats sjby34n−7points, which is at least14n+1,since again n ≥ 16.Alternative bibeats siwith a surplus of exactly14n−3points. This holds due to the following: The voters introduced in the first two groups for j ≠ i are neutral with respect to the relationship between siand bi(half of them put siahead of bi, the other half put biahead of si). The 2t many voters introduced for i in the first two groups all put siahead of bi.Now we consider the voters introduced for the sets Sj. If i ∈ Sj, then siis ahead of bihere, this happens three times. In the remaining34n−3voters introduced for the sets Sj, we have that i ∉ Sjand hence in these voters, biis ahead of si. In a* > S > B the alternative siis voted ahead of bi. Together we have that bibeats siwith−2t−3+34n−3−1=34n−2t−7points. Sincet=14n−2,it follows that34n−2t−7=14n−3as required.Since in all of the above relationships except for the final one, one of the alternatives has a surplus of more than14nvoters over the other, the results of these pairwise contests cannot be changed with deleting at most14nvoters. Therefore, by deleting at most14nvoters, the only relevant relationships that can be influenced are those between biand si(we will see that the relationships between biand bjor siand sjfor i ≠ j are not relevant). Each of these relationships can in fact be changed by deleting 3 voters.We now show that the reduction is correct: The instance of X4C is positive iff a* can be made a winner of the election by deleting at most14nvoters.First, assume that the instance is positive, and let I be a corresponding index set. We delete the14nvoters corresponding to the elements in I and denote the resulting election with E′. Then a* indeed is uncovered in E′. To show this, it suffices to prove that none of the bicovers a*, since a* wins against all of the si(since a* leads against siwith at least14n+1voters, this remains true also after deleting at most14nvoters). Hence, assume that some bicovers a* in E′. It suffices to prove that sidominates biin E′, then, since a* dominates siin E′, it follows that bidoes not cover a*. Note that in the original election E, the alternative bibeats siwith14n−3points. Deleting the14nvoters corresponding to I has the following effect:(a)For the deleted voters corresponding to sets Sjwith i ∉ Sj, the alternative sigains a point against bi. Since i appears in exactly one of the chosen sets and14nvoters are deleted, this means that sigains14n−1points against bifrom these voters.For the single deleted voter corresponding to a set Sjwith i ∈ Sj, the alternative siloses a point against bi.Altogether, sigains14n−2points against biand now beats biwith one point. As a consequence, as claimed, bidoes not cover alternative a*.For the converse direction, assume that it is possible to make a* a winner of the election by deleting at most14nvoters. Again, let E′ be the election resulting from E by the deletions. Since the relationship between the bi’s and a* cannot be changed by deleting at most14nvoters and biwins against a* in the original election E, all bialso win against a* in E′. Since a* is a winner in E′, it follows that for each bithere must be an alternative dominating biwho does not dominate a*. Since for i ≠ j, we know that biwins against sjin the election E′, it follows that for all relevant i the alternative siwins against biin E′. Since biwins against siwith14n−3points, it follows that each simust gain at least14n−2points against biby the removal of voters. Hencen(14n−2)=14n2−2npoints need to be gained collectively by all siagainst their corresponding bi. Obviously, only deleting voters introduced for the sets Sjhelps to let sigain points against bi. Deleting one of these voters gains n − 8 points (since it hurts for the 4 values of i with i ∈ Sj, and helps the remaining n − 4 ones). Hence, by deleting14nvoters we can gain at most14n·(n−8)=14n2−2npoints. Since this is the total number of points that need to be gained, we know that exactly14nvoters are deleted to obtain the election E′, and each of these voters is one introduced for a set Sj. Now assume that there is some i such that two voters corresponding to setsSj1andSj2are deleted, wherei∈Sj1andi∈Sj2and j1 ≠ j2. Then sigains a point against biin at most14n−2of the deletions and loses in at least 2 of them. Hence, sigains at most14n−4points against biand this implies that siloses against biin E′, which is a contradiction. Therefore, it follows that each i is contained in at most one of the Sjwhose corresponding linear strict order is deleted. Due to cardinality reasons (14nvoters corresponding to sets of 4 elements each are deleted), it follows that each i appears in exactly one set. Hence we have obtained a set cover as required.□Theorem 3.1 thus implies what Bartholdi, Tovey, and Trick in Bartholdi et al. (1992) call ‘computational resistance,’ i.e., assuming P ≠ NP, it is algorithmically infeasible to control an election using the Uncovered alternatives voting rule by deleting voters. However, such an argument neglects that NP-hardness only means that a (suitably large) set of instances is ‘difficult’ to solve; it does not imply that all instances are difficult to solve or even that the average-case complexity is high. An NP-completeness result therefore is a first step in establishing the difficulty of a control (or manipulation) problem; in practice, the problem may still be feasible to solve. We refer the reader to Conitzer and Sandholm (2006), Rothe and Schend (2012, 2013) for a discussion regarding these issues. In the remainder of this paper, we introduce a new computational approach to solve control problems, namely the application of relation-algebraic tools.We note that there are three related forms of control, namely adding and deleting alternatives, and adding voters. It has been shown in Bartholdi et al. (1992) that controlling Condorcet elections by adding alternatives or by deleting alternatives is computationally easy, with the following arguments:1.A candidate can never be made a Condorcet winner by adding alternatives: If an alternative c is not a Condorcet winner, then there is some alternative b who beats a, and this remains true after another alternative has been added.It can easily be checked how many alternatives must be deleted to make an alternative c a Condorcet winner, since to make c a Condorcet winner, exactly the alternatives that beat c must be deleted.These arguments do not directly transfer to Condorcet voting with the uncovered set as winning condition, as we will now argue:1.Assume that in a Condorcet election, an alternative c is not a winner with respect to the uncovered set winning condition, since c is covered by b. Then adding an alternative a such that a beats b, but a does not beat c ensures that c is not covered by b anymore, and hence c may become a winner. Therefore, Condorcet elections with the uncovered set as winning condition are not immune to control by adding alternatives.As above, assume that c is not a winner, and let B be the set of alternatives that cover c. Then it is possible that after removing all alternatives in B, there is some other alternative a ∉ B that covers c now, but did not cover c before the removal of the alternatives in B (this can happen if B contains alternatives that beat a, but do not beat c). Therefore, the straight-forward polynomial-time algorithm used in Bartholdi et al. (1992) does not directly transfer to the winning condition uncovered set.It was also shown in Bartholdi et al. (1992) that control for Condorcet voting by adding voters is NP-complete, we conjecture that this is also the case for the uncovered set winning condition (but this result does not follow from their reduction).We now present an approach to the algorithmic solution of election problems based on relation algebra and the tool RelView for the manipulation and visualization of relations and relational programming. We first introduce the required basics of relation algebra, see Schmidt and Ströhlein (1993), Schmidt (2010) for more details. As a general assumption, we always assume a pair u (an element of a direct product of sets) to be of the form u = (u1, u2) such that u1 denotes the first component of u and u2 denotes the second component. Thenu^denotes the transposed pair (u2, u1).A binary relation is a set R ⊆ X × Y for some sets X and Y. We write R : X ↔ Y to denote such a relation, and say that X ↔ Y is the type of R. If the sets X and Y are finite, we consider R as a Boolean matrix, and often use matrix terminology and matrix notation. Especially, we speak about the rows, columns and 0- or 1-entries of a relation and write Rx, yinstead of (x, y) ∈ R or x R y.As a start, we show how to model a Condorcet election relation-algebraically. It is preferable to have a single relation that contains the entire election instance as input for our relation-algebraic algorithms. This relation has to contain the individual preferences of each voter. We now describe how to construct this relation.Suppose that the preferences of each voter i are given as a relation >i. See Fig. 1 for an example with four such individual relations, presented in matrix notation. The set of alternatives for this election is {a, …, h}. For example, the voter with preference relation >1 represented in the left-most matrix prefers alternative a to all other alternatives, hence the relation contains the pairs (a, u2) for all u2 ≠ a. This can be seen in the first row of the matrix representation: The white square for the pair (a, a) represents the fact that (a, a) is not an element of >1, the black squares denote that all pairs (a, u2) with u2 ≠ a are elements of >1. From the third row, we can see that all pairs (c, u2) with u2 ∉ {a, c} are elements of >1; hence the voter prefers the alternative c to all alternatives except for the alternatives a and c.We hence get the following preference relations: The left-most voter ranks the alternatives from most-preferred to least-preferred as a, c, e, g, b, d, f, h, the second one ranks them as a, b, c, d, e, f, g, h, the third one as b, a, d, c, f, e, h, g and the preference of the right-most voter is h, g, f, e, a, b, c, d.We now combine the individual preferences of the voters into a single relation. As an example, assume that the voters 1-3 vote according to the left-most preference relation from Fig. 1 and the voters 4-6, 7-9 and 10-13 vote according to the second, third and fourth relation from Fig. 1, respectively. The combined relation can be seen in Fig. 2. For each pair u = (u1, u2) of alternatives, there is a column which for each voter i ∈ {1, …, 13} contains a positive entry (black square) if that voter prefers u1 to u2, and a negative entry (white square) otherwise. All this leads to the following general definition:Definition 4.1The relation P : N ↔ A2models the instance (N, A, (>i)i ∈ N) of a Condorcet election if Pi, uis equivalent to u1 >iu2, for all i ∈ N and u ∈ A2.We now have seen how the input to our control problem can be specified relation-algebraically. To describe computations in the relation-algebraic model, we introduce the basic ‘building blocks’ of relation algebra, namely the basic relations and the operators that we will use in our computations.Relation algebra knows three basic relations. The identity relationI:X↔Xsatisfies for all x, y ∈ X thatIx,yiff x = y; for the universal relationL:X↔Yit holdsLx,yfor all x ∈ X and y ∈ Y; and for the empty relationO:X↔Yit holdsOx,yfor no x ∈ X and y ∈ Y. We usually overload the symbols, e.g., we use the same symbolIfor all identity relations regardless of the type.Relations are sets. So, we may form the union R∪S : X ↔ Y and intersection R ∩ S : X ↔ Y of R, S : X ↔ Y and state the inclusion R ⊆ S and equality R = S. The meaning of the operations is that for all x ∈ X and y ∈ Y we have Rx, yor Sx, yfor R∪S and both Rx, yand Sx, yfor R∩S. In case of the tests we get that R ⊆ S iff for all x ∈ X and y ∈ Y from Rx, yit follows Sx, y, and R = S iff for all x ∈ X and y ∈ Y the relationships Rx, yand Sx, yare equivalent. The complement of R : X ↔ Y is denoted byR¯:X↔Yand for all x ∈ X and y ∈ Y we haveR¯x,yiff ¬Rx, y.A lot of the expressive power of relation algebra is due to the possibility to form the composition R; S : X ↔ Z of R : X ↔ Y and S : Y ↔ Z and the transpositionRT:Y↔Xof R. Their logical definitions are that for all x ∈ X and z ∈ Z we have (R; S)x, ziff there exists y ∈ Y such that Rx, yand Sy, z, and thatRx,yTiff Ry, x, for all x ∈ X and y ∈ Y. In the Boolean matrix representation, composition corresponds to the multiplication of Boolean matrices and transposition to matrix transposition, as known from linear algebra.For relations R : X ↔ Y and S : X ↔ Z, bysyq(R,S)=RTS¯¯∩RT¯S¯their symmetric quotientsyq(R,S):Y↔Zis defined. Then for all y ∈ Y and z ∈ Z it holdssyq(R,S)y,ziff for all x ∈ X the relationships Rx, yand Sx, zare equivalent, that is, iff the y-column of R equals the z-column of S.In relation algebra vectors are used to model subsets of a given set X. Vectors are relations r : X ↔ 1 (we prefer in this context lower case letters), where 1 denotes the specific singleton set 1 ≔ {⊥}. The vector r then describes the subset of X containing all x ∈ X with rx, ⊥. We omit the second subscript, i.e., write rxinstead of rx, ⊥. Such a relation r can be considered as a Boolean column vector. A point p : X ↔ 1 is a vector with precisely one 1-entry. Consequently, it describes a singleton subset {x} of X and we then say that it describes the element x of X. If r : X ↔ 1 is a vector and Y the subset of X it describes, theninj(r):Y↔Xdenotes the embedding relation of Y into X. In Boolean matrix terminology this means that the relationinj(r)is obtained from the identity relationI:X↔Xby deleting all rows which do not correspond to an element of Y, and point-wisely this means that for all y ∈ Y and x ∈ X it holdsinj(r)y,xiff y = x. Hence,inj(r)is nothing else than the relational counterpart of the identity function from Y to X.A central object in the modeling of the control problem for elections is the set of subsets of the set of voters, i.e., the power set 2N(recall that N is the set of voters). For power sets 2Xwe will use membership relationsM:X↔2Xand size comparison relationsS:2X↔2X. Point-wisely they are defined for all elements x ∈ X and sets Y, Z ∈ 2Xas follows:Mx,Yiff x ∈ Y andSY,Ziff |Y| ≤ |Z|. A combination ofMwith embedding relations allows a column-wise enumeration of an arbitrary subsetSof 2X. Namely, if the vector r : 2X↔ 1 describesSin the sense defined above and we defineS=M;inj(r)T,then we getX↔Sas type of S and that for all x ∈ X andY∈Sit holds Sx, Yiff x ∈ Y. In the Boolean matrix representation, this means that the sets ofSare precisely described by the columns of S, if the columns are considered as vectors of types X ↔ 1.Fig. 3demonstrates the description of sets by vectors and the column-wise enumeration of subsets of power sets by means of a small example. It depicts the membership relationM:X↔2Xbetween the set X ≔ {a, b, c} and its power set as a Boolean matrix. If, for example, the first column ofMis considered as a vector of type X ↔ 1, then this vector describes the empty set. The second column ofMis a point and describes the subset {c} of X or the element c from X. Below the Boolean matrix ofMthe transpose of a vector r : 2X↔ 1 is shown. We use in the figure the transpose of r instead of r, since in combination withMthe Boolean row vector forrT:1↔2Ximmediately makes clear that r describes the subsetS:={∅,{b},{a},{b,c},{a,b,c}}of 2X. Now, the Boolean matrix ofM;inj(r)Tresults from the Boolean matrix ofMby a removal of all columns which correspond to a white square of the row vector. In Fig. 4the size comparison relation for the power set of the set X is depicted as a Boolean matrix. The order of the sets (i.e., labels) is induced by that of the membership relation.To model direct products X × Y of sets X and Y relation-algebraically, the two projection relations π : X × Y ↔ X and ρ : X × Y ↔ Y proved to be the convenient means. These relations are the relational variants of the well-known projection functions and, hence, fulfil for all pairs u = (u1, u2) ∈ X × Y and elements x ∈ X and y ∈ Y the following equivalences: πu, xiff u1 = x and ρu, yiff u2 = y. The projection relations enable us to specify the well-known pairing operation of functional programming relation-algebraically. The (right) pairing of R : Z ↔ X and S : Z ↔ Y is defined as[R,S]]=R;πT∩S;ρTand this yields [R, S]]: Z ↔ X × Y and that [R, S]]z, uiffRz,u1andSz,u2,for all z ∈ Z and u = (u1, u2) ∈ X × Y. The latter fact is shown by the following calculation:[R,S]]z,u⟺(R;πT∩S;ρT)z,u⟺(∃x∈X:Rz,x∧πu,x)∧(∃y∈Y:Sz,y∧ρu,y)⟺(∃x∈X:Rz,x∧u1=x)∧(∃y∈Y:Sz,y∧u2=y)⟺Rz,u1∧Sz,u2Here we apply the definition of the pairing operation in the first step, the definition of intersection, composition, and transposition of relations in the second step, and the definition of the projection relations in the third step. Such calculations are typical for the next sections.Using the projection relations π and ρ we can also establish a bijective correspondence between the relations of type X ↔ Y and the vectors of type X × Y ↔ 1. The transformation of R : X ↔ Y into its corresponding vectorvec(R):X×Y↔1is given byvec(R)=(π;R∩ρ);Land the step back from r : X × Y ↔ 1 to its corresponding relationrel(r):X↔Ybyrel(r)=πT;(ρ∩r;L). Point-wisely this means that for all pairs u ∈ X × Y the following equivalences hold:vec(R)uiffRu1,u2andrel(r)u1,u2iff ru. Based on the operationvec,the relation P : N ↔ A2 now can be constructed from the strict orders >i; A ↔ A by purely relation-algebraic means. We number the voters from 1 to n, transform each relation >iintovec(>i)T:1↔A2,i.e., the transpose of its corresponding vector, and finally combine the transposed vectors row by row into a Boolean matrix. The latter means that we form the so-called relation-algebraic sumvec(>1)T+⋯+vec(>n)T(see e.g., Schmidt, 2010; Schmidt and Ströhlein, 1993 for more details concerning sums).In the table of Fig. 5we summarize the basic constants and basic operations of relation algebra, which we have introduced in this section. Notice, thatsyq,[ · , · ]],vec,andrelare derived operations and, therefore, mentioned as an own group in the table. Concerning precedence, we assume that complementation and transposition bind stronger than composition and the latter binds stronger than union and intersection.Up to now, we have modeled the input to an election as a relation. Our first development shows how to compute the dominance relation C with relation-algebraic means. Recall that the relationshipCa1,a2holds iff more voters prefer a1 to a2 than vice versa. To compute C, we use the projection relations π, ρ : A2 ↔ A of the direct product A2, the membership relationM:N↔2N,and the size comparison relationS:2N↔2N. Each of these relations is available in RelView as a pre-defined function and their OBDD-implementations are rather small (cf. Leoniuk, 2001; Milanese, 2003).The following Theorem 5.1 shows how to obtain the dominance relation C from the relation P by purely relation-algebraic means:Theorem 5.1Suppose that the relation P : N ↔ A2models the instance (N, A, (>i)i ∈ N) of a Condorcet election. If we define relationsE:=syq(P,M):A2↔2N,F:=syq(P;[ρ,π]],M):A2↔2N,C:=rel((E∩F;(S∩ST¯));L):A↔A,whereL:2N↔1is the universal relation, then for all pairs u ∈ A2we getCu1,u2⟺|{i∈N∣Pi,u}|>|{i∈N∣Pi,u^}|.For a given arbitrary pair u ∈ A2 we prove in a preparatory step for all sets Y ∈ 2NthatEu,Y⟺syq(P,M)u,Y⟺∀i∈N:Pi,u↔Mi,Y⟺∀i∈N:Pi,u↔i∈Y⟺{i∈N∣Pi,u}=Y.Using that the exchange relation [ρ, π]]: A2 ↔ A2 relates the pair u precisely with its transpositionu^=(u2,u1),in a rather similar way we can prove that for all sets Z ∈ 2Nthe following property holds:Fu,Z⟺{i∈N∣Pi,u^}=ZBy means of these two auxiliary results, we now get:Cul,u2⟺rel((E∩F;(S∩ST¯));L)u1,u2⟺((E∩F;(S∩ST¯));L)u⟺∃Y∈2N:Eu,Y∧(F;(S∩ST¯))u,Y∧LY⟺∃Y∈2N:Eu,Y∧∃Z∈2N:Fu,Z∧SZ,Y∧¬SY,Z⟺∃Y∈2N:Eu,Y∧∃Z∈2N:Fu,Z∧|Z|≤|Y|∧|Y|>|Z|⟺∃Y,Z∈2N:{i∈N∣Pi,u}=Y∧{i∈N∣Pi,u^}=Z∧|Z|<|Y|⟺|{i∈N∣Pi,u}|>|{i∈N∣Pi,u^}|This concludes the proof.□The theorem states that the relation-algebraic ‘algorithm’ computing C from P in the three steps E, F, and C is correct. These steps are:•We first compute the relations E and F, which contain pairs (u, Y), where u is a pair (u1, u2) of alternatives and Y is the set of voters that prefer u1 to u2 (u2 to u1) in the case of E (respectively F). Essentially, this step ‘parses’ the input relation N.The main computation happens in the final step, where the size comparison relationSis used to compare, for each pair (u1, u2) of alternatives, the size of the set of voters preferring u1 to u2 to the number of voters voting u2 ahead of u1.Representing intermediate results as relations may seem inefficient, since the relations are very large: The relation E is of type A2 ↔ 2N, where 2Nis the power set of voters. As a Boolean matrix, E has |A|2 rows and 2|N| columns; for our example election above with 8 alternatives and 13 voters, hence, E has64×213=524,288Boolean entries. Working with this representation would be impossible for realistic instances. Therefore, RelView uses a very compact OBDD-representation of the occurring relations. To give an impression, for our example above RelView reported that both relations E and F can be represented with an OBDD (essentially a labelled graph) with 111 nodes, where, as mentioned above, the Boolean matrix representation has 524, 288 entries. See Berghammer et al. (2005), Leoniuk (2001), Milanese (2003) for a detailed description of RelView’s OBDDs-representation of relations.The specifications of Theorem 5.1 can be executed by means of RelView after a straightforward translation into its programming language. To give an impression only, in the following we present the code, where the second argument w : A ↔ 1 is used for typing reasons only.In the declaration part of the program DomRel, first AA is introduced as product domain for A2. Then six variables for relations are declared. In the body of the program, first the projection relations π, ρ : A2 ↔ A of the direct product A2 are computed and assigned to pi and rho, respectively. The next two statements compute the membership relationM:N↔2N,and the size comparison relationS:2N↔2Nand store them as M and S, respectively. The remaining two statements and the RETURN-clause are nothing else than the formulations of the specifications of E : A2 ↔ 2N, F : A2 ↔ 2N, and C : A ↔ A in Theorem 5.1 in RelView syntax.In case of the input relation P of Fig. 2 the tool computed the dominance relation C of Fig. 6. From the first row of C we see that alternative a is the Condorcet winner since it dominates all other alternatives. This relation is asymmetric and complete; C is a tournament relation and this property implies the uniqueness of a Condorcet winner in the case that one exists.In the preceding section, we have specified how to express the input of a Condorcet election relation-algebraically, and shown how one can parse this input to compute the dominance relation. We now use similar tools for a relation-algebraic solution of the control problem introduced in Section 2. In that section we have formulated the task as a minimization-problem: Given a specific alternative a* ∈ A, determine a minimum set of voters Y such that the removal of Y from the set N of all voters makes a* a winner. To allow for an easier relation-algebraic representation, we consider the dual maximization problem, i.e., we ask for a maximum set of voters X such that a* wins subject to the condition that only voters from X are allowed to vote. Clearly, from X a desired Y is then obtained via Y = N∖X.We start with the Condorcet voting rule. As shown in Bartholdi et al. (1992), control for Condorcet voting by deleting voters is NP-hard. That is, it is NP-hard to decide, for a* ∈ A andk∈Nand the election instance as inputs, whether it is possible to find k voters whose removal makes a* a Condorcet winner.As a first step toward a relation-algebraic solution of the maximization problem, we relativize the dominance relation C by additionally considering the sets of voters X which only are allowed to vote. Concretely this means that we specify a relation R that relates a set X ∈ 2Nwith the alternatives a, b ∈ A iff |{i ∈ X∣a >ib}| > |{i ∈ X∣ b >ia}|. Since we work with binary relations, we have to combine two of the three objects X, a and b to a pair. We do this with a and b, i.e., relate X with u under the assumption that u1 equals a and u2 equals b. Then the following theorem shows how the relativized dominance relation R : 2N↔ A2 can be specified relation-algebraically. Again we assume the relations π, ρ : A2 ↔ A,M:N↔2NandS:2N↔2Nto be at hand.Theorem 6.1Suppose again that the relation P : N ↔ A2models the instance (N, A, (>i)i ∈ N) of a Condorcet election. If we define relationsE:=syq([M,P]],M):2N×A2↔2N,F:=syq([M,P;[ρ,π]]]],M):2N×A2↔2N,R:=rel((E∩F;(S∩ST¯));L):2N↔A2,whereL:2N↔1is the universal relation, then for all sets X ∈ 2Nand pairs u ∈ A2it holdsRX,u⟺|{i∈X∣Pi,u}|>|{i∈X∣Pi,u^}|.Assume an arbitrary set X ∈ 2Nand an arbitrary pair u ∈ A2 to be given. Then, we have for all sets Y ∈ 2Nthe following equivalence:E(X,u),Y⟺syq([M,P]],M)(X,u),Y⟺∀i∈N:[M,P]]i,(X,u)↔Mi,Y⟺∀i∈N:Mi,X∧Pi,u↔Mi,Y⟺∀i∈N:i∈X∧Pi,u↔i∈Y⟺{i∈X∣Pi,u}=YIn a similar way we can show for all sets Z ∈ 2Nthe following fact, using the property of the exchange relation [ρ, π]]: A2 ↔ A2 mentioned in the proof of Theorem 5.1:F(X,u),Z⟺{i∈X∣Pi,u^}=Z.Now, we calculate as follows:RX,u⟺rel((E∩F;(S∩ST¯));L)X,u⟺((E∩F;(S∩ST¯));L)(X,u)⟺∃Y∈2N:E(X,u),Y∧(F;(S∩ST¯))(X,u),Y∧LY⟺∃Y∈2N:E(X,u),Y∧∃Z∈2N:F(X,u),Z∧SZ,Y∧¬SY,Z⟺∃Y,Z∈2N:{i∈X∣Pi,u}=Y∧{i∈X∣Pi,u^}=Z∧|Z|<|Y|⟺|{i∈X∣Pi,u}|>|{i∈X∣Pi,u^}|This shows the claim.□In the second step, we now take the relativized dominance relation R of Theorem 6.1 and specify with its help a vector cand : 2N↔ 1 that describes the subset of 2Nthe members of which are the sets X which are possibilities for the solution of our control problem. The latter property means that a* is a Condorcet winner, provided that only voters from X are allowed to vote. From the vector cand we finally compute the vector description sol : 2N↔ 1 of the maximum possible solution sets, which are the solutions we are looking for. The next theorem shows how to get cand and sol from R and a*. To enhance readability we usea≻Xb:⟺|{i∈X∣Pi,(a,b)}|>|{i∈X∣Pi,(b,a)}|for all alternatives a, b ∈ A and sets X ∈ 2N.Theorem 6.2Let R : 2N↔ A2be the relation defined inTheorem 6.1and the specific alternative a* ∈ A be described by the point p : A ↔ 1. If we define vectorscand:=R¯;(π;p∩ρ;p¯)¯:2N↔1,sol:=cand∩ST¯;cand¯:2N↔1,then the vector cand describes the set{X∈2N∣∀b∈A∖{a*}:a*≻Xb}and the vector sol describes the set of its maximum sets.Since the point p describes the specific alternative a*, for all pairs u ∈ A2 we have (π; p)uiff u1 = a*, andρ;p¯uiffu2≠a*. We now assume an arbitrary set X ∈ 2Nto be given and calculate as follows, where in the fifth step Theorem 6.1 is applied:candX⟺R¯;(π;p∩ρ;p¯)¯X⟺¬∃u∈A2:R¯X,u∧(π;p)u∧ρ;p¯u⟺¬∃u∈A2:R¯X,u∧u1=a*∧u2≠a*⟺∀u∈A2:u1=a*∧u2≠a*→RX,u⟺∀u∈A2:u1=a*∧u2≠a*→|{i∈X∣Pi,u}|>|{i∈X∣Pi,u^}|⟺∀b∈A:b≠a*→|{i∈X∣Pi,(a*,b)}|>|{i∈X∣Pi,(b,a*)}|⟺∀b∈A∖{a*}:|{i∈X∣Pi,(a*,b)}|>|{i∈X∣Pi,(b,a*)}|Hence, the first claim follows from the definition of the set a vector describes. To prove the second claim, we take again an arbitrary set X ∈ 2N. Then, we get:solX⟺(cand∩ST¯;cand¯)X⟺candX∧ST¯;cand¯X⟺candX∧¬∃Y∈2N:S¯Y,X∧candY⟺candX∧∀Y∈2N:candY→SY,X⟺candX∧∀Y∈2N:candY→|Y|≤|X|This equivalence implies that sol describes the set of maximum sets of voters X for which candXholds, that is, for which a* wins subject to the condition that only voters from X are allowed to vote.□Using the RelView system we have solved our control problem with Condorcet winners as winning alternatives for the input relation P of Fig. 2 and each of the eight alternatives. The tool showed that only the alternatives a, b and h can be made Condorcet winners by deleting voters. Some of the results for these alternatives are presented in Fig. 7. The left-most vector in the figure says that the alternative a is a Condorcet winner if all voters are allowed to vote and the corresponding dominance relation next to it is the original dominance relation C. To make the alternative b a Condorcet winner at least eight voters must be deleted. RelView computed that altogether there are 45 possibilities for this. The vector on position 3 shows one of them, where the voters from 1 to 6 and the voters 10 and 11 are deleted. On position 4 the resulting dominance relation is depicted. To get the alternative h as Condorcet winner requires a removal of at least 6 voters. According to RelView there are 85 possibilities for this. One of them and the resulting dominance relation are depicted at positions 5 and 6.Now we study the second of our voting rules, viz. Uncovered alternatives. From Section 3 we know that Condorcet voting with the Uncovered set winning condition remains computationally resistant to control with deleting voters. For computing solutions with relation-algebraic means, we use the same idea as in the above relativization of the relation C to the relation R by additionally considering the set of voters X which are allowed to vote. The next theorem shows how to obtain the relativized covering relation U from the relativized dominance relation R.Theorem 6.3Suppose again that R : 2N↔ A2is the relation specified inTheorem 6.1. If we define relationsE:=[π;ρT,ρ;ρT]]T∩vec(π;πT);L:A2×A2↔A2,U:=R∩[R,R¯]];E¯:2N×A2↔2N,whereL:1↔A2is the universal relation, then for all sets X ∈ 2Nand pairs u ∈ A2we haveUX,u⟺RX,u∧∀c∈A:RX,(c,u1)→RX,(c,u2).Let the set X ∈ 2Nand the pair u ∈ A2 be given. In a first step we show for all pairs v, w ∈ A2 the following property, where we use the equivalence of(π;ρT)u,vand u1 = v2, of(ρ;ρT)u,wand u2 = w2, and of(π;πT)v,wand v1 = w1 (that these equivalences hold are immediate consequences of the definition of the projection relations):E(v,w).u⟺([π;ρT,ρ;ρT]]T∩vec(π;πT);L)(v,w),u⟺[π;ρT,ρ;ρT]]u,(v,w)∧(vec(π;πT);L)(v,w),u⟺(π;ρT)u,v∧(ρ;ρT)u,w∧vec(π;πT)(v,w)⟺u1=v2∧u2=w2∧(π;πT)v,w⟺u1=v2∧u2=w2∧v1=w1We now can calculate as follows:UX,u⟺(R∩[R,R¯]];E¯)X,u⟺RX,u∧[R,R¯]];E¯X,u⟺RX,u∧¬∃v,w∈A2:[R,R¯]]X,(v,w)∧E(v,w),u⟺RX,u∧¬∃v,w∈A2:RX,v∧R¯X,w∧u1=v2∧u2=w2∧v1=w1⟺RX,u∧¬∃c∈A:RX,(c,u1)∧R¯X,(c,u2)⟺RX,u∧∀c∈A:RX,(c,u1)→RX,(c,u2)This shows the desired result.□After this result we are able to solve our control problem also for the voting rule Uncovered alternatives. We use again the vector cand for the description of the candidate sets and the vector sol for the description of the solutions.Theorem 6.4Let U : 2N↔ A2be the relation ofTheorem 6.3and the specific alternative a* ∈ A be described by the point p : A ↔ 1. If we define vectorscand:=U;(π;p¯∩ρ;p)¯:2N↔1,sol:=cand∩ST¯;cand¯:2N↔1,then the vector cand describes the set{X∈2N∣¬∃b∈A∖{a*}:UX(b,a*)}and the vector sol describes the set of its maximum sets.Because the alternative a* is described by the point p, for all pairs u ∈ A2 we haveπ;p¯uiffu1≠a*,and (ρ; p)uiff u2 = a*. Now, for all sets X ∈ 2Nwe can calculate as follows to show the first claim:candX⟺U;(π;p¯∩ρ;p)¯X⟺¬∃u∈A2:UX,u∧π;p¯u∧(ρ;p)u⟺¬∃u∈A2:UX,u∧u1≠a*∧u2=a*⟺¬∃b∈A:UX,(b,a*)∧b≠a*⟺¬∃b∈A∖{a*}:UX,(b,a*)The proof of the second claim is identical to the proof of Theorem 6.2.□As already mentioned, the uncovered set is always non-empty. The degenerate case is that no voter is allowed to vote. Then the resulting dominance relation and the induced covering relation are empty and the uncovered set equals N. RelView showed that in our running example this situation occurs if the alternatives c or d shall win. We already know that the alternative a wins without a removal of voters. RelView determines that at least five voters must be deleted to ensure victory for the alternatives e, f, g or h and the corresponding numbers of possibilities are 11, 111, 15 and 126. And, finally, the alternative b can win if at least seven voters are not allowed to vote. To reach the goal there exist 120 possibilities. We end this section with the three RelView pictures of Fig. 8 that concern alternative e. The vector on the left shows that the alternative e is in the uncovered set if the voters 1, 2, 4, 5 and 6 are deleted, the relation in the middle is the dominance relation resulting from this, and the relation on the right is the induced covering relation. The empty columns show that, besides the alternative e, the removal of 1, 2, 4, 5 and 6 also make the alternatives a, f and h uncovered.

@&#CONCLUSIONS@&#
We proved a new complexity result concerning Condorcet voting, viz. that the constructive control problem by deleting voters remains NP-hard if the classical winning condition ‘to be a Condorcet winner’ is replaced by ‘to be in the uncovered set’. The latter one is more general and also more appropriate for practical applications, since in such cases frequently no Condorcet winner exists due to remiss situations or cyclic dominations. Our result seems to be one of the first in this direction and it is an interesting question whether our proof technique can be transferred to other efficiently computable choice sets, e.g., the top cycle or the Condorcet non-losers.We also demonstrated how to use relation algebra for modeling and problem-solving in the area of voting rules. We believe that this is also a worthwhile continuation of Berghammer, Rusinowska, and de Swart (2013) and Berghammer (2013), where from a given dominance relation the most important choice sets are computed relation-algebraically. In the case of voting rules the dominance relation is the result of the aggregation of the individual preferences to a common one using a certain rule. Theorem 5.1 shows how the rule of Condorcet voting can be realized relation-algebraically. In a similar way other well-known voting rules, like those of approval voting or plurality voting, can be treated.While we of course do not obtain polynomial-time algorithms for the control problem, the algorithms can work with instances of “realistic” size: For 8 alternatives and 20 voters, RelView took 8 minutes to compute the solution, using standard personal computer hardware. Using a further optimized relation-algebraic specification (left out from the paper for ease of presentation), the computation can be performed in just over 3 minutes. Concerning efficiency, of course, our general and model-oriented approach cannot compete with algorithms that are specifically tailored for such hard problems and implemented in a conventional programming language like C or Java. But we believe that it has some decisive advantages, which we will describe now.For the presentation of the results of this paper we have used the prevalent mathematical theorem-proof-style to enhance readability. But actually we have obtained all relation-algebraic specifications by developing them from the original logical specifications of the problems in question. We regard this formal and goal-oriented development of algorithms from logical specifications, that are correct by construction, as the first main advantage. In respect thereof it is also beneficial that the calculations are formalized in such a way that the danger of making errors is minimized and the use of theorem-provers or proof-supporting tools seems to be possible. Presently we investigate the use of the tool Prover9 (described and available via Prover9-homepage) for automated verification. First case studies are described in Berghammer, Höfner, and Stucke (2014).As the second main advantage of our approach we consider its generality and flexibility. It allows to treat related problems for different election rules with only small modifications of the relation-algebraic specifications and the corresponding RelView-programs. In the following we present some examples to prove this fact.The notion of dominance we have used so far is strict and, hence, leads to single winners. Sometimes also a weak dominance and possibly multiple winners are considered. Here a dominates b iff the number of voters i with a >ib is greater or equal than the number of voters i with b >ia. All our results can immediately be transferred to this version. We only have to remove in the definition of the relation C : A ↔ A in Theorem 5.1 the intersection withST¯,i.e., to work withC:=rel((E∩F;S);L),and we have to do the same in the definition of the relation R : 2N↔ A2 in Theorem 6.1. The correctness proofs are obtained by slight modifications of those we have presented in Sections 5 and 6; we only have to use thatSX,Yis equivalent to |X| ≤ |Y|, whereas(S∩ST¯)X,Yis equivalent to |X| < |Y|.In Young (1977) Young proposes a generalization of Condorcet voting, where an alternative wins iff it becomes a Condorcet winner after deleting as few as possible alternatives. As shown in Rothe, Spakowski, and Vogel (2003), winner detection in Young elections is a computationally hard problem. Assuming the set A = {a1, …, am} of alternatives and that for all i ∈ {1, …, m} the alternative aiis described by the relational point p(i): A ↔ 1, e.g., by the ith column of the identity relationI:A↔A,the solution of the control problem given in Theorem 6.2 can be used for the computation of the Young winners as follows: For all points p(i), first compute the vector sol of Theorem 6.2, then select a point contained in this vector, and, finally, compose the membership relationM:N↔2Nwith this point. It may happen, that sol is an empty vector, which means that the alternative aidescribed by the point p(i) cannot made to a Condorcet winner by deleting voters. In such a case no point is contained in sol and the empty vector of type N ↔ 1 is taken instead of the composition ofMwith a point from sol. This procedure yields a list r(i): N ↔ 1, 1 ≤ i ≤ m, of vectors such that r(i) either is empty or describes a single solution of the control problem with a* ≔ ai. As a consequence, an alternative aiis a Young winner iff r(i) contains a minimum number of 0-entries. All this easily can be realized in RelView by a program with a loop, that yields a relation Y : N ↔ A with r(i) as the ith column, for all i ∈ {1, …, m}. Of course, this RelView-program is slower than the RelView-program for a single control. But, as experiments with RelView have shown, it is not dramatically slower, since the hardest part, the computation of the relativized dominance relation R : 2N↔ A2 of Theorem 6.1, has to be done only once. Furthermore, it is not difficult to refine the program in such a way that instead of Y : N ↔ A a vector description of the set of Young winners is computed.In Figs. 9 and 10 we demonstrate an application of the RelView-program for computing Young winners. Fig. 9 shows an example of an input relation P : N ↔ A2 for a Condorcet election with N ≔ {1, 2,…, 10} and A ≔ {a, b, …, h} as a Boolean matrix. The left Boolean matrix of Fig. 10 represents the dominance relation C : A ↔ A of this election. From C we get that no alternative is a Condorcet winner. The right Boolean matrix of the figure depicts the output relation Y : N ↔ A that column-wisely enumerates the vectors r(1) to r(8). Here the empty first column with label a describes the fact that it is impossible to make a a Condorcet winner by deleting voters and, to give a second example, the second column with label b says that b wins if at least five voters are deleted. Counting the white squares of the columns we get that h is the only Young winner of the given election.A specific feature of RelView is that, when a relation is displayed in its so-called relation window, then additional information is displayed. Especially the number of 1-entries is shown. In case of the vectors sol of Theorems 6.2 and 6.4 these numbers state how many possibilities exist to make a* a winner by deleting as few as possible voters. Hence, our results also solve the problem of counting solutions. Counting solutions is closely related to Venetian voting studied in Walsh and Xia (2012), and to the predicting-winners problem of Wojtas and Faliszewski (2012).In real live elections it frequently happens that a voter considers certain alternatives as incomparable or to be of the same value. In such a case its preferences are not specified by linear strict order relations but by partial order relations or even pre-order relations on the set of alternatives. The first case is studied in Faliszewski, Hemaspaandra, Hemaspaandra, and Rothe (2009). Since within our developments of relation-algebraic solutions we never use that the preferences are linear or order relations, our approach automatically covers the above generalizations.Finally, it should be mentioned that our approach easily can be generalized to other voting rules (we already have mentioned approval voting and plurality voting) and other kinds of control (like destructive control, removal of alternatives and addition of voters and alternatives).As the third main advantage of our approach we regard the support by means of an appropriate Computer Algebra system. The results we have obtained with RelView show that Computer Algebra tools can be used to obtain practical algorithms for hard problems without relying on domain knowledge for optimizations, if the data structures used in the Computer Algebra package—like the OBDDs in the case of RelView —automatically exploit the ‘easyness’ that may be present in practical instances. This supports the point of view that proving NP-hardness is not sufficient in order to conclude that a voting rule is ‘safe’ from attempts to influence the outcome of an election. RelView also generates visualizations of both the input and output of the algorithms and has some further features, like step-wise execution, test of properties, and generation of random relations. This allows prototyping of specifications, testing of hypotheses, experimentation with concepts, exploration of new ideas, generation of examples and counterexamples etc., while avoiding unnecessary overhead, and makes the tool very useful for scientific research and also for university education. In this regard the OBDD-implementation of relations in RelView proved to be of immense help, since it allows to treat also non-trivial examples.