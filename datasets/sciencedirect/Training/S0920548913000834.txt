@&#MAIN-TITLE@&#
Simultaneously accelerating OpenVG and SVG tiny with multimedia hardware

@&#HIGHLIGHTS@&#
OpenVG and SVG Tiny are most suitable for accelerating 2D vector graphics output.Most previous OpenVG and SVG implementations need fully-dedicated VLSI chips.We alternatively accelerate them with widely-used multimedia-processing hardware.Our result shows 3.5 to 30 times accelerations without fully-dedicated hardware.

@&#KEYPHRASES@&#
OpenVG,SVG Tiny,Middleware,Multimedia processor,Implementation,

@&#ABSTRACT@&#
Graphical abstract

@&#INTRODUCTION@&#
Vector graphics features have many advantages such as scalability with respect to the display size, small file size, lossless compression capability, no compression artifacts, and so on [1,2]. Currently, the needs for such features are high and increasing, especially on handheld devices, where attractive user interfaces and standardized services should be supported. Example services include standards from Open Mobile Alliance (OMA) such as WAP [3], MMS [4], and DCD [5], Java Standards (including JSR226 [6], JSR287 [7], and JSR271 [8]), ISO/IEC JTC1 SC29 MPEG standard (mainly for MPEG4 part 20 — LASeR [9]), W3C HTML5 [10] (for its canvas 2D element), E-book standard (EPUB [11]) and others. Recently, smart phones, smart TVs and set-top boxes require vector graphics features for their graphical user interface (GUI) rendering, various services and applications.Although vector graphics features are available as various drawing API's and file formats, including Flash [12], SVG [1,2], Cairo [13], Silverlight [14], PDF [15], PostScript [16] and so on, OpenVG from Khronos Group is now one of the most suitable API's on the handheld devices. OpenVG is a royalty-free, cross-platform API that provides a low-level hardware acceleration interface for various vector graphics libraries and application programs.Hardware accelerations of the vector graphics are required to support big screens with higher resolutions, for finally realizing vivid user interfaces and rich media services. Currently available hardware accelerations for vector graphics features can be summarized into two major categories: SVG acceleration based on the OpenVG hardware, or accelerating both SVG and OpenVG based on the OpenGL/OpenGL ES semiconductor chips.OpenVG [17] from Khronos Group is one of the most suitable middleware for accelerating SVG on the handheld devices, since the SVG mobile player is one of the major target applications of OpenVG. OpenVG primarily targets handheld devices that require portable acceleration of high-quality vector graphics for user interfaces and texts. Nowadays, there are some fully-dedicated hardware solutions [18] as well as full software implementations [19] and OpenVG accelerated solutions over the OpenGL ES hardware [20]. However, OpenVG or OpenGL ES semiconductor chips are relatively expensive for ordinary consumer markets while software implementations show relatively low performances.SVG [21] is an open format developed by WWW consortium. The official SVG 1.0 specification provides graphics, animation, and some more advanced features. The current SVG 1.2 specification consists of SVG full version and SVG Tiny version which is optimized for embedded systems [22,23]. The 3GPP (3rd generation partnership project) selected SVG Tiny as the standard MMS (multimedia messaging service) format for the next generation on the mobile phone platforms.In this paper, we present a way of accelerating both Open VG and SVG Tiny applications. We modified our OpenVG software implementation [19] to be accelerated with the existing multimedia processing hardware, which is widely adopted for image and/or video processing on a variety of handheld devices and multimedia terminals. Our major goal is to enable SVG Tiny to provide reasonably high performance graphical user experiences with less CPU utilization, without additional hardware or re-design of hardware, allowing other applications to be concurrently executed on the CPU, to finally provide more vivid rendering results.In Section 2, we present some related works. A few previous works for hardware-supported OpenVG accelerations are all based on the fully-dedicated OpenVG chips or OpenGL ES chips, and showed relatively high costs. Our design and implementation for the OpenVG and SVG acceleration is presented in Section 3. Implementation results are summarized in Section 4, and conclusions and future work are followed in Section 5.The OpenVG group was formed on July 2004, and they released OpenVG 1.0 specification [17] on August 2005. Although the OpenVG reference implementation was also released at that time, the purpose of this reference implementation is only to show the feasibility of the official specification. Thus, they did not focus on its efficiency to finally show disappointing performances.Although they can use any internal architecture, most implementations of OpenVG are based on the overall pipeline with 8 stages, as described in the OpenVG official specification [17]. Since the official release of the OpenVG specification, there are many implementation results including full hardware solutions, full software solutions, and hybrid approaches [24–26]. Most of them use fully-dedicated semiconductor chips to accelerate OpenVG. However, this kind of semiconductor chips are expensive and thus, hard to be widely used for the consumer market. In this paper, we use multimedia processors, which are already equipped for video and image processing on most mobile phones, to cost-effectively accelerate both OpenVG and SVG Tiny.Results on the acceleration of SVG and/or SVG Tiny are concentrated on the application level optimizations, and thus, it is hard to find any results on the acceleration of SVG features itself. Our work accomplished the acceleration of both OpenVG and SVG Tiny, which were hard to find in previous works. In contrast, OpenVG and SVG are now widely used for various applications. We have a lot of research works on them, including the recent ones [17,27,28].Typical implementations of OpenVG have 8-stage pipelines, as described in the OpenVG official specification [18] and also shown in Fig. 1. In Fig. 1, we marked OpenVG features suitable for acceleration by the multimedia processors with the reddish backgrounds: stages 3, 5, 7 and 8. The following features are commonly supported by multimedia processors which can be used for accelerating OpenVG pipeline:•double buffering and fast frame buffer access: Control on the rendering canvas is highly related to EGL [16], another graphics standard from the Khronos group, not a part of OpenVG features. EGL API is used for managing drawing canvases and their synchronization. Hardware-based double buffering and fast frame buffer access make fast rendering switching and interleaving possible. Therefore, those features are very essential to accelerate graphics rendering.blending: For typical full software OpenVG implementations, more than 50% of their CPU usages are dedicated to the blending operations. In OpenVG, there are 10 different blending modes including much complex ones such as Potter-Duff blending [17]. However, most of OpenVG applications only use the SrcOverDst mode blending. Furthermore, SVG Tiny supports only the SrcOverDst mode blending. Since even the low-cost multimedia hardware supports this SrcOverDst mode blending, we can achieve remarkable performance enhancement, even with the hardware support only for this blending mode and software blending for other modes.image copy and bit-blt operations: Block-by-block image copy operations are frequently requested in vector graphics rendering and child image features in the OpenVG specification. Thus, hardware support on these operations is required.image transform with re-sampling: OpenVG requires affine and perspective transformation of images with bi-linear or other re-sampling techniques. In the case of SVG Tiny, they only require affine transformations. In both cases, hardware-supported image transformation can accelerate the overall implementation.masking and scissoring operations: These functions can be used for partial drawing and/or update of screen areas. It can be effectively used for drawing of small images like icons and buttons. Masking is also used in the rasterization stage (the 4-th stage) in the OpenVG rendering pipeline and anti-aliasing processing.color conversion and color transformation: These features should be used for transparency features of SVG Tiny 1.2 and image format conversion.After carefully analyzing the above features of the target acceleration device, we isolated the corresponding code areas from our software implementation [12]. We reconstructed the original software implementation into several modules, each of which can be compiled to use the exiting full software implementation or the new multimedia processor accelerated implementation.Vector drawing requests are executed in the stages 1 to 4 of the OpenVG pipeline and then changed into masking image, which can be used in bitmap graphics hardware. Paint drawing like a gradation and a pattern must be generated as an image in advance.We also have some implementation issues not directly related to the multimedia processors as follows:•non-scaling stokes: SVG Tiny 1.2 has the non-scaling stroke of the vector-effect, while the OpenVG 1.1 specification does not support non-scaling strokes [15]. We implemented the non-scaling strokes by swapping the execution order of OpenVG pipeline stages 2 and 3, while OpenVG fixed hardware pipelines are hard to support it.sequence scheme: Some bitmap acceleration hardware support only the batch drawing of bitmap images, while OpenVG and SVG elements must be drawn with respect to the order of appearing. So we implemented sequencing scheme to solve special synchronization issues (e.g. reading pixels from canvas) and recovering from the shortage of bitmap resources.precision and scaling: OpenVG API requires processing of floating point numbers for input coordinates and parameters for painting operations. However, most of the multimedia hardware only supports integer operations or fixed point number operations with limited precision. Therefore, there may be some conversion error from floating point numbers to fixed point numbers, and some extremely big or small floating numbers cannot be processed in the fixed point number system. We should coerce range of input numbers. Fortunately, SVG Tiny requires only fixed point numbers to prevent this problem.The results of our final implementation are followed in the next section.Our implementation is tested on several existing multimedia processors, including baseband communication chips with bitmap processors, image processing chips for cameras on the mobile devices, and DSP vector processors targeted for multimedia codec processing. We tested our implementation with a lot of OpenVG applications, SVG Tiny animation files, and image-oriented user interface demonstrations. OpenVG rendering results are shown in Fig. 2. We also used a set of SVG Tiny files shown in Fig. 3to measure their performances. When applying SVG Tiny 1.2 conformance tests, all results passed except some text rendering features, which is not fully-implemented intentionally for copyright reasons. General font systems, including OpenType or TrueType font systems, use special rendering features such as hinting for high quality text rendering, which are subject of some copyright issues. We will add these features in near future.We selected a commercially-available baseband chip with multimedia acceleration hardware and its 2D graphics API for the sample implementation and its benchmark tests. The baseband chipsets are for 2G or 2.5G low price feature phones. It means that these chipsets do not target at high-end phones like smart phones. This multimedia processing system provides most of the acceleration features in Section 2 with several image blending functions and affine transform of images, as shown in Fig. 4.Table 1shows the rendering performances for the OpenVG test drawings. Notice that most of the user experiences are easy to be unsatisfactory with the refresh rate of less than 15 frames per second. Due to the larger screen sizes of nowadays mobile phones, our original software implementation could render 4 to 6 frames per second with almost 100% CPU usage. Our multimedia processor accelerated implementation shows dramatic performance improvement. Additionally, we can avoid the large variance in the frame rates, which are mainly due to the CPU and memory competitions with other applications.For the test with SVG Tiny players, as shown in Table 2, we show a set of frame rates for the fully accelerated cases, and then another set for the slow-down version, which targets at approximately 15 frames per second with the SVG Tiny Player. Note that the 100% CPU utilization for the full software implementation was lowered to about 40% to 50%, which enhances the real-time multi-tasking capabilities.Another implementation is based on the camera control hardware on the mobile phones. We used 6M pixel camera controller which has 128×SIMD image processing hardware with a 200MHz processor and local memory, as shown in Fig. 5. We get more than 20 frames per seconds to draw GUI menu animations with less than 10% of CPU usage.

@&#CONCLUSIONS@&#
