@&#MAIN-TITLE@&#
Branch-and-price and constraint programming for solving a real-life technician dispatching problem

@&#HIGHLIGHTS@&#
Design of optimal routes for technicians that was motivated by a real problem.Treatment of soft time windows for arrival times at client locations.An exact solution procedure for the VRPSTW is proposed.A branch-and-price framework using constraint programming is implemented.Results obtained compare favorably with the current practice.

@&#KEYPHRASES@&#
Branch-and-price,Constraint programming,Routing,Technician dispatch problem,

@&#ABSTRACT@&#
We consider a real problem faced by a large company providing repair services of office machines in Santiago, Chile. In a typical day about twenty technicians visit seventy customers in a predefined service area in Santiago. We design optimal routes for technicians by considering travel times, soft time windows for technician arrival times at client locations, and fixed repair times. A branch-and-price algorithm was developed, using a constraint branching strategy proposed by Ryan and Foster along with constraint programming in the column generation phase. The column generation takes advantage of the fact that each technician can satisfy no more than five to six service requests per day. Different instances of the problem were solved to optimality in a reasonable computational time, and the results obtained compare favorably with the current practice.

@&#INTRODUCTION@&#
This research was motivated by a real problem, which is the dispatch of technicians from a large company that provides repair services for their machines to overcome failures that occur over a typical working day. The company offers black-and-white digital printers, digital presses, multifunction devices, and digital copiers. Of the services that the firm provides to its clients, the maintenance of its machines distributed over Santiago is probably one of the most important for building a positive image of the company in terms of level and quality of service over time. It is therefore critical to carefully route the available technicians to satisfy the client requirements occurring in certain service areas on a typical working day. In this research, we propose a formulation and solution for this problem, satisfying the typical routing constraints as well as soft time-window constraints. The latter constraints arise from the fact that service requests come from clients with different priorities. The company defines different promised service times (denoted hereinafter target service times) according to the importance of each customer. These promises of technician arrival can be violated, so these conditions can be added as penalties in the objective function. From this, we see that the proposed scheme is based on the classical formulation of the vehicle routing problem with soft time windows (VRPSTW), which is formulated and solved using constraint programming (CP)-based column generation (Section 3).The vehicle routing problem (VRP) involves constructing routes for a set of vehicles to serve a set of customers, given a number of requirements. There are many classes of the VRP, depending on the requirements and constraints.One of the best-known versions is the vehicle routing problem with time windows (VRPTW), which has the characteristic that each of the clients must be served within a predefined time interval. VRPTW has been one of the most intensively studied NP-hard problems in the last decades. Exact methods are still restricted to solve a limited number of real instances, and their performance strongly depend on the time-window characteristics. Heuristic and meta-heuristic approaches have been developed for many cases and potential applications of VRPTW. A complete review of the models and methods to solve the VRPTW can be found in Cordeau, Desaulniers, Desrosiers, Solomon, and Soumis (2002, chap. 7). Later on, Bräysy and Gendreau (2005a, 2005b) performed deep reviews of VRPTW solution methods, focused on the description of heuristic route constructions methods, local search algorithms and meta-heuristic methods for solving capacitated problems of different size and time-window configurations. Nowadays, state of the art results are currently offered by the hybrid genetic algorithm due to Nagata, Bräysy, and Dullaert (2010). Their method combines powerful route minimization procedures, proposing an effective edge assembly crossover along with very efficient local search algorithm. In the same line of research, Ibaraki et al. (2008) and Pisinger and Ropke (2007) developed two simple, efficient and flexible methods able to address various VRP variants, namely the Iterated Local Search (ILS) method and the Adaptive Large Neighbourhood Search (ALNS), respectively. Recently, Vidal, Crainic, Gendreau, and Prins (2013) proposed an efficient Hybrid Genetic Search with Advanced Diversity Control for a large class of time-constrained vehicle routing problems, adding to the method new features to properly handle the temporal dimension.The most successful exact methods are based on column generation for linear programs with decomposable structures; this was originally introduced in Dantzig and Wolfe (1960). The first application of this approach to the VRP was developed by Desrochers, Desrosiers, and Solomon (1992) (see also Desrosiers, Solomon, & Soumis, 1995, chap. 2). The basic idea is to decompose the problem into sets of customers visited by the same vehicle (routes) and to select the optimal set of routes among all possible routes. The decomposition is based on two structures: a master problem and a subproblem. The former optimizes the global route objective function and includes the constraint that each customer must be covered exactly once, resulting in a set partitioning formulation. The latter creates new routes that improve the solution, using dynamic programming to solve a shortest path problem with time windows. More recently column generation methods have been extended to include cuts, heuristic pricing and relaxed elementarity constraints (Desaulniers, Lessard, & Hadjar, 2008) to produce better lower bounds for the master problem and to speed up the generation of columns. Exact solution approaches using column generation without requiring Branch and Price have been proposed by Baldacci, Mingozzi, and Roberti (2012).With regard to vehicle routing schemes for technician dispatch problems, it is worth mentioning a real application of technicians dispatch for emergency calls of an important electricity company in Chile (Weintraub, Abud, Fernandez, Laporte, & Ramirez, 1999). Blakeley, Bozkaya, Cao, Hall, and Knolmajer (2003) and Weigel and Cao (1999) also develop and implement technician dispatch systems for large companies using heuristics and GIS data. Recent publications related to service technician routing and scheduling are not many. We can mention the work by Cordeau, Laporte, Pasin, and Ropke (2010), who address a service technician scheduling problem arising in large telecommunications companies, focusing on team configurations and assignment of tasks respecting specific skills, priorities and precedence constraints for the tasks assigned, with the objective of minimizing a weighted function related to the makespan. Xu and Chiu (2001) also perform task scheduling for a telecommunication company with the objective of maximizing the realized orders. Tang, Miller-Hooks, and Tomastik (2007) implement a tabu search heuristic for a real world maintenance dispatch system which is formulated as a Multiple Tour Maximum Collection Problem with Time-Dependent rewards. Liberatore, Righini, and Salani (2011) present an exact solution procedure for the VRPSTW. The proposed algorithm is a column generation scheme, with ad hoc heuristics based on dynamic programming to generate new columns. We use CP for that purpose instead. Liberatore et al. (2011) model explicitly the time window violation for early and late arrivals. By contrast, in our work we just penalize for late arrivals due to the nature of the real application we are trying to solve; nevertheless, in our model and solution algorithm it is straightforward to incorporate penalization for early arrivals as explained later in Section 3.2. Kovacs, Parragh, Doerner, and Hartl (2012) formulate a service technician routing and scheduling problem motivated by a real problem faced by infrastructure service and maintenance providers. The objective is to minimize the sum of total routing and outsourcing costs, considering hard time windows for reaching customers sites. They solve the problem through an Adaptive Large Neighborhood Search algorithm, tested on both artificial and real-world instances. Pillac, Gueret, and Medaglia (2013) adapt the large neighborhood search algorithm (Shaw, 1998) for the VRPTW with resource constraints. Finally, Souyris, Cortés, Ordoñez, and Weintraub (2013) formulate a robust optimization version of a column generation scheme for a technician dispatch problem, putting the focus on properly handling the uncertainty associated with service time in such kind of real applications.The CP-based column generation (CG) framework was introduced by Junker, Karisch, Kohl, Vaaben, Fahle, et al. (1999) and Yunes, Moura, and de Souza (2000) for two different crew rostering problems. Their work was motivated by the difficulties that arose in standard column generation approaches when modeling complex rules from legislation and union agreements. To overcome these difficulties, they proposed solving the pricing subproblem using CP models of resource-constrained shortest paths on acyclic graphs. The most attractive feature of CP, compared with dynamic programming, was the expressiveness of its modeling languages. Rousseau, Gendreau, Pesant, and Focacci (2004) and then Chabrier (2006) extended this framework to cyclic graphs, thus allowing VRPTW problems to be solved. In the last decade, the CP-CG framework has been used in several applications that are discussed in a recent survey by Gualandi and Malucelli (2009).In this paper we use a CP-based pricing model similar to that proposed by Yunes et al. (2000) and Yunes, Moura, and De Souza (2005) in the context of bus driver scheduling, which allows for a flexible and simple modeling of the technician-route requirements. This straightforward model, which takes advantage of the fact that each technician visits only a small fraction of the overall daily clients, has significantly fewer variables than the graph-inspired models normally used for routing problems (Rousseau et al., 2004). Although it may be somewhat less efficient, this model does not require the implementation of complex shortest-path constraints such as those proposed for airline crew rostering problems (Junker, Karisch, Kohl, Vaaben, Fahle, et al., 1999). To obtain optimal solutions for different service request distributions, we implement a branch-and-price approach based on the efficient branching strategy of Ryan and Foster (1981), again taking advantage of CP flexibility when we include these branching constraints.The main contributions of this paper are threefold: (i) we provide an efficient exact solution procedure for the VRPSTW using CP; (ii) it is the first to show that the approach proposed by Yunes et al. (2000, 2005) for crew scheduling problems can be applied to problems whose underlying structure is a cyclic graph, and to integrate it into a branch-and-price framework; (ii) as stated above, the approach that we propose has some advantages over the alternatives; it can thus prove attractive for similar practical applications.The remainder of this paper is organized as follows. In the next section we state the problem formally and provide a mathematical formulation. Section 3 presents the column generation approach, while the branch-and-price methodology is described in Section 4. Experiments on a real-case scenario are reported in Section 5.The strategic objective of the firm is based on client satisfaction. Within this context, the maintenance of their machines is one of the most important activities of the company in Chile. As explained in Section 1, service requests have different priorities, and there are different target response times for service requests at different priority levels. Strictly, the target response time is defined as the maximum allowable time for a technician to reach the service location, measured from the time of the service request. If the technician reaches the location after the target response time, a penalty will be incurred by the system; this is considered in the formulation.To consider this effect, we use a compound objective function for assigning technicians and jobs. The function minimizes two components: the sum of the differences between the target response times of requests and the effective service times provided by the firm, plus the travel times. This objective function seems to meet the needs of the company since it takes into account both service quality and the effective use of technicians.The approach considers expected travel and service times, which are estimated from historical company data. In further developments, we will include uncertainty in the service times to make the model more robust and realistic. Travel times are less important than service times in the results, and therefore the assumption of deterministic travel behavior is reasonable in this case.The set of service requests assigned during a given day come from the previous days, usually the day before, since the company attempts to enforce a 24-hour service policy. It is assumed that the dispatcher in charge of service selects which requests should be handled during the coming day. Furthermore, the dispatcher will choose a set of high-priority requests to be served first. A technician will begin his working day at one of these high-priority customer locations, under the reasonable assumption that the number of service requests is larger than the number of available technicians. In some cases, a technician can start the working day at the depot because he was not assigned to a specific client. In addition, all the tasks assigned to each technician must be completed during the day.The modeling scheme was adapted from the classical formulation of the VRPSTW (Cordeau et al., 2002, chap. 7) with the following adjustments:•For this problem, only the upper bound of the soft time window (related to the target response time of each service request) is considered, since the objective is to serve each requirement as soon as possible.Service times are quantitatively longer and are known less accurately than travel times; therefore, the former will play a more important role than the latter in the proposed decision rules.Although the VRPSTW considers soft time windows by penalizing the objective function, we add the hard constraint that all tasks scheduled for a specific day must be completed during that day. To ensure feasibility, we modified the classical formulation slightly to be able to decide which service requests can be handled during the day by the available technicians; any remaining requests are then postponed to the next day and given a very high priority.LetK={1,…,K}be the set of technicians available to work during the day. As mentioned earlier, the technicians must start the day at the location of a service request with a very high priority or at the depot. LetI1={1,…,K}be the set of these locations; andI2={K+1,…,C}be the set of locations of the service requests that remain to be scheduled, where C is the cardinality ofI1∪I2. We setC+1as a dummy depot to which all technicians must be sent after their schedule is finished. To simplify the notation, we define the arc setA={(i,j)|i∈I1∪I2,j∈I2∪{C+1},i≠j}to represent all feasible trips between locations. Additionally, letbibe the time-window upper bound of service request i, andsithe expected repair time for service requesti,i∈I1∪I2. Lettijbe the travel time from service request i to service request j,(i,j)∈A. We assume that travel times satisfy the triangular inequality. The end of the working day is set at instant F, which represents the latest time a technician can start the last job of the day.β∈[0,1]is a multiobjective parameter.We next formulate a mixed integer model, including both {0–1} (binary) and continuous variables. Specifically, we define flow variablexijk, which is equal to 1 if technician k attends service request i and service request j sequentially, and 0 otherwise,(i,j)∈A,k∈K. Two continuous variables are also included:wikis the time that technician k arrives at the location of service requesti,i∈I1∪I2∪{C+1},k∈K; andδikrepresents the amount of time by which technician k violates the soft time window of service requesti,i∈I2,k∈K. Finally, we define the binary variablevi, which allows the model to handle the demand not served during the day with the available fleet by scheduling those service requests for the beginning of the next day,i∈I2. In the model, such requests are assigned to virtual paths at a high penalty P. Thus,viis equal to 1 if i is sent through a virtual path, 0 otherwise. To simplify the notation we define the setsO(i)andD(i)associated with nodei:O(i)={j|(i,j)∈A},i∈I1∪I2,andD(i)={j|(j,i)∈A},i∈I2∪{C+1}. The formulation is as follows:(1)minx,w,v,δβ∑k∈K∑i∈I2δik+(1-β)∑k∈K∑(i,j)∈Atijxijk+∑i∈I2Pvi(2)s.t.∑k∈K∑j∈O(i)xijk=1i∈I1(3)∑k∈K∑j∈O(i)xijk=1-vii∈I2(4)∑j∈O(i)xijk-∑j∈D(i)xjik=1i=k-1i=C+10otherwise.i∈I1∪I2∪{C+1},k∈K(5)wik+si+tij-wjk⩽1-xijkF(i,j)∈A,k∈K(6)wik⩽F∑j∈D(i)xjiki∈I2,k∈K(7)wik-δik⩽bii∈I2,k∈K(8)xijk∈{0,1}(i,j)∈A,k∈K(9)vi∈{0,1}i∈I2(10)wik,δik⩾0i∈I2,k∈K.The objective function (1) accounts for the total cost, computed as a convex combination of the sum of soft time-window violations and the total travel time. An additional term is added to penalize the unsatisfied demand. Constraints (2) and (3) restrict the assignment of each service request scheduled during the day to exactly one technician; if the request is postponed to the next day, the conditionvi=1together with constraint (3) ensure that no technician attends it on the current day. Next, constraints (4) ensure flow conservation, considering the dummy node where each path must end. Constraints (5) guarantee schedule feasibility with respect to precedence-time consistency (i.e., if technician k travels from customer i to customer j, then the arrival time at node j will be greater than or equal to the arrival time at node i plus the service time there). Ifxijk=1, then k goes from i to j, and we can start serving j no earlier than the start of service at i, plus the time spent in i, plus the travel time from i to j. Ifxijk=0, technician k does not go from i to j and constraint (5) becomes inactive. Note that, for a given k, constraints (6) forcewik=0if service request i is not met by technician k and require k to reach i before time F if service is going to be provided (i.e.,vi=0). Constraints (7) defineδik, the violation of the soft time window. Finally, (8)–(10) impose binary conditions on the flow variables and state the nonnegativity restriction on the time-arrival variables.The VRP problem with soft time windows is hard to solve as mentioned in Taillard, Badeau, Gendreau, Guertin, and Potvin (1997). We propose to solve this problem using column generation, as described in the next section.By working with actual company data, we realized that most real instances were not solvable using the arc-based formulation presented in the previous section, because the number of variables was too large to handle. Therefore, we looked for an alternative formulation and solution approach.Column generation approaches have provided promising results for various types of VRPs (see for example Desrochers et al., 1992). Moreover, column generation approaches are very flexible in the sense that the problem under consideration can be split into two parts: a main model, the master problem, which chooses the routes with the minimum total cost from a pool of feasible routes; and a secondary model, the subproblem, which generates feasible routes that could potentially reduce the total cost.In the literature, the subproblem is usually solved via dynamic programming (DP). We decided to use CP instead, for several reasons. First, it seems that CP works well when the length of each route is relatively small, which is the case for this application. Second, the CP model we implement is simple and easy to code. Third, under a CP approach, any additional constraint can be incorporated directly into the code without a special modeling technique. This is crucial when we use the branch-and-price algorithm (see Section 4) improved by the branching strategy proposed by Ryan and Foster (1981). Imposing some constraints on routes turned out to be straightforward with CP. For example, the proposed branching strategy forces two specific service requests to appear in a specific route, which can be included easily under CP, whereas in a DP implementation incorporating such constraints could become cumbersome. In Sections 3.2 and 4 we describe these features in detail.The master problem can be formulated as a set partitioning model assuming that it is possible to choose routes for each technician from an existing set of routes R. We use the result presented in Barnhart, Johnson, Nemhauser, Savelsbergh, and Vance (1998), which shows that the set covering relaxation is numerically far more stable and thus easier to solve than the set partitioning version. Also the authors argue that it is easy to construct a feasible integer solution from a solution of the set covering relaxation.Each router∈Ris characterized by a technician who initiates the route r at a specific service locationi1∈I1, and then follows a sequence of service requests{i2,…,ie}⊆I2, wherei2is the second one andieis the service request at the end of route r. For each service request in positionl∈{2,…,e}of the route, the technician’s arrival time iswil=wil-1+sil-1+til-1il, and thus the time-window violation becomesdil=max{0,wil-bil}. Additionally,wi1=di1=0. Hence, the total cost of the route iscr=β∑l=2edil+(1-β)∑l=1e-1til,il+1. In this formulation, the binary variableθrindicates whether or not router∈Ris chosen.airis a binary parameter that indicates whether or not route r contains service request i, and the binary variableviis equal to 1 if service request i is not included in any route, incurring a high penalty P. Then the master problem is the following:(11)(MP)minθ,v∑r∈Rcrθr+∑i∈I1∪I2Pvi(12)s.t.∑r∈Rairθr+vi⩾1i∈I1∪I2(13)θr∈{0,1}r∈R(14)vi∈{0,1}i∈I1∪I2.Note that in the MP formulation, the pool R of routes can be empty, and there still exists a feasible solution:vi=1,i∈I1∪I2, with costC×P, where C is the cardinality ofI1∪I2as defined before.To generate new columns, we replace the integrality constraints (13) and (14) byθr∈[0,1],r∈R, andvi∈[0,1],i∈I1∪I2, respectively. Thus, for a given pool of routes R, the optimal solution of MP provides the dual values of constraint (12) to the subproblem that generates new routes. This procedure is described below.Given a pool R of columns and the associated optimal solution of the LP relaxation of problem (11)–(14), it is well known from linear programming theory that a new column r, not in R, has the potential to improve the objective function only if it has a negative reduced cost. The reduced cost of a column is defined as the cost of the route,cr, minus the sum of the dual variables of the service requests that belong to that route, which come from constraint (12).At each iteration, the subproblem identifies a route of minimum reduced cost. We solve the master problem over the current set of columns using the simplex method and obtain the dual variables. Letαibe the dual variables associated with constraint (12). The subproblem generates the optimal route by minimizing the real costcr(the sum of the time-window violations and travel times) minus the sum of the dual variables of the service requests included in the route, subject to the constraints that ensure that the route is feasible. By this process, a route with minimum reduced cost is generated. If the resulting reduced cost is negative, this new column can be included in the basis to improve the objective function of the master problem.Constraint programming models have been used to solve pricing subproblems within hybrid column generation for almost a decade (Gualandi & Malucelli, 2009). There are essentially three families of models in the literature that specifically address routing and scheduling problems. One of the first models, proposed by Yunes et al. (2000, 2005), is based on an array of finite-domain variablesXp∈T,p∈P, that identify which task in T is to be performed by a bus driver in positionp∈P. Junker, Karisch, Kohl, and Vaaben (1999); Junker, Karisch, Kohl, Vaaben, Fahle, et al. (1999) and Fahle et al. (2002) proposed using a single set variableS⊆Tto identify the subset of tasks in T to be covered by a crew pairing. In order for their model to be valid and efficient, they introduced a new shortest path constraint, as well as a negative-reduced-cost constraint on S. Finally, in the context of vehicle routing with time windows, Rousseau, Pesant, and Gendreau (2001), Rousseau et al. (2004) based their model on successor variablesNt∈T,t∈T, that identify the task to be performed immediately after t. This approach also required the use of specially designed global constraints and a search strategy based on dynamic programming.In this paper, we adapt the simple model proposed by Yunes et al. (2000) for the following reasons. First of all, it is straightforward, is flexible, and works without the addition of dedicated global constraints. In constraint programming, a global constraint is a relationship among decision variables for which an efficient algorithm is available that can find the set of all infeasible values for each of the included decision variables. For example, the global constraintalldifferent(x1,x2,x3)ensures that the three variablesx1,x2, andx3are all different. Modern constraint programming packages offer a set of global constraints, and associated algorithms, that can model a generous number of relationships. The algorithms to find feasible sets are based on the principles of constraint propagation and domain reduction. When it is not possible to model a particular relationship with the existing global constraints, it is necessary to design a dedicated global constraint and an associated algorithm. A detailed explanation of these concepts is found in the exhaustive survey by Régin (2011).Second, in contrast with the model of Rousseau et al. (2004), which defines one variable for every node or task in the problem, Yunes et al. (2000) introduce only a number of variables equivalent to the number of tasks that can be performed by one technician. Since in our context this number is small (from three to six), this model seems particularly appropriate. Moreover in both these models the size of domains of the main decision variables are equal as they correspond to the number of nodes in the graph.In the subsequent model (15)–(25), the new route to be generated is represented by the array of variablessc[l],l=1,…,L, where L is the maximum number of service requests that a technician can satisfy in one day. Thelthelement of sc is the service request scheduled in position l of the route. The route must start at an initial location of a technician (which could be either a high-priority service request or the depot, in case there are more available technicians than high-priority requests), that is a location fromI1. The route must contain at least one service request that remains to be scheduled, that is a service request from setI2. Any position of the route that is not used by a service request must be utilized by fictitious nodes that are added for CP modeling purposes. Hence, the maximum number of fictitious nodes that a route can contain isL-2. Let us define the set of fictitious nodes to beI3={C+1,…,C+L-2}, where, as before, C is the cardinality ofI1∪I2. Therefore, the domain of thesc[l]variables,l=1,…,L, is set toI1∪I2∪I3. The distinction between the fictitious nodes inI3is necessary in order to impose the global constraintalldifferent(sc), which will be discussed after the presentation of the model. The travel time between a service request inI2and any fictitious node inI3is set to 0, as is the travel time between any pair of nodes inI3. Fig. 1shows an example of a route that starts servicing request 3, then proceeds to requests 5, 10, and 14, and finishes with the fictitious nodesC+1andC+2.Variablesw[l]andd[l]define the start time of service and the time-window violation respectively for the service request in positionl=1,…,L. Variablea[i],i∈I1∪I2∪I3takes the value 1 if request i is served by the route, and 0 otherwise,l=1,…,L. These definitions are useful for the control of the branch-and-price method as described in Section 4. The constraint programming model for the subproblem is thus the following:(15)(SP)minβ∑l=1Ld[l]+(1-β)∑l=1Ltsc[l-1],sc[l]-∑l=1Lαsc[l](16)s.t.w[1]=0(17)w[l]=w[l-1]+ssc[l-1]+tsc[l-1],sc[l]l=2,…,L(18)d[l]=max(0,w[l]-bsc[l])l=1,…,L(19)alldifferent(sc)(20)sc[l]∈I1l=1(21)sc[l]∈I2l=2(22)sc[l]∈I2∪I3l=3,…,L(23)sc[l]=i,i∈I3⇒sc[l+1]=i+1l=3,…,L(24)a[sc[l]]=1l=1,…,L(25)∑i∈I1∪I2∪I3a[i]=LThe objective function (15) minimizes the convex combination of time-window violation and travel cost, which is the real cost of the route minus the sum of the dual values,α, associated with the service requests in the route. Fori∈I3, which is not in constraint (12) of MP, we setαiequal to 0. Constraint (16) ensures that the start time of the path is associated with the start time of the day, and (17) sets the starting time of next service requests that are visited by the route. CP constraint (18) sets the late time-window violations. Note that the model can also include early time window violations; for adding that feature, we just have to change the right hand side of constraint (18) bymax(fsc[l]-w[l],w[l]-bsc[l]), whereficorresponds to the time window lower bound associated with service request i. Thus, the CP algorithm presented next can be easily adapted to incorporate this modification. Constraint (19),alldifferent(sc), is a global constraint that ensures that all of the variables sc are different, so any request is served by the path no more than once (for an explanation of this global constraint see, for example, Régin, 2011). Constraint (20) ensures that the first request served by the route is assigned to a location where a technician is initially positioned, (21) ensures that the second position of the route is a service request without a technician initially allocated, and (22) restricts the other positions along the path to be either service requests or fictitious nodes. (23) ensures that, if position l is used by a fictitious node, the next service request in the route must be the next fictitious node (proceeding to any other service request is not allowed in order to reduce the search space as much as possible). Variable a is useful to impose new constraints for the service requests that can belong to a specific route, which are needed to implement the search procedure in the branch-and-price methodology, as explained below and detailed in Section 4. Finally, constraints (24) and (25)impose logical restrictions between the different variables in sc and a.CG frameworks depend heavily on marginal costs to guide the search at the subproblem level. In some cases it is possible that, during the first iterations, the marginal cost associated with each customer is not accurately estimated by the dual values. For instance, in some routes some service requests pick up most of the total dual values. This undesirable behavior is illustrated by the example in Fig. 2. A path that visits each of overweighted service requests (2 and 3’s dual values are exactly twice 1 and 4’s dual values) will be considered a good route (with a reduced cost of −5), but it is not (it is unlikely to be selected in an optimal IP solution). With a more realistic distribution of the dual values, all the nodes would have been given a value of 15 and no more reduced-cost paths would have been found, thus removing the need for a last iteration.In this example, described in Rousseau, Gendreau, and Feillet (2007), such undesirable behavior may occur because the master problem is degenerate, and thus its dual has an infinite number of optimal solutions. The bases of the primal solutions all exhibit a common set of strictly positive variables, but different sets of null variables. A different dual solution is associated with each of these equivalent primal optimal solutions.The standard function that returns dual values in the LP codes returns an extreme point of the dual polyhedron. Extreme solutions are characterized by large values for some marginal costs while others are at zero. Therefore, the subproblem tends to build routes that have very low reduced costs but potentially large travel times and time-window violations. To avoid this, we instead optimize over the real objective function (cr). Negativity of the reduced cost can then be enforced through a constraint, since the necessary condition imposed by the CG framework to ensure convergence is that we add, at each iteration, a set of negative-reduced-cost routes or prove that none exists. The objective function (15) thus becomes (26) and constraint (27) is added to the subproblem model:(26)minβ∑l=1Ld[l]+(1-β)∑l=1Ltsc[l-1],sc[l](27)β∑l=1Ld[l]+(1-β)∑l=1Ltsc[l-1],sc[l]-∑l=1Lαsc[l]<0After experimenting with our CP implementation, we decided to split the subproblem into a two-step procedure (SP1 and SP2); we found a considerable reduction in the running time when many interesting columns are generated at each iteration of the pricing problem. SP1 attempts to select service requests such that the reduced cost is negative (i.e., constraint (27) is satisfied), but the order of the service requests in the route is not necessarily the best. Thus, SP1 is not an optimization problem but a CP feasibility problem with feasible region (17)–(27). SP2 then optimizes the sequence to find the lowest real cost given by (26) subject to (17)–(25). SP1 passes the selected service request to SP2 by fixing the variables a in constraint (24). Fig. 3shows an example of the process. First, SP1 chooses service requests 0, 2, 3, 5, 8, and 10, and then SP2 rebuilds the route with only these service requests. Notice that the reduced cost of the resequenced route can only be lower than the original route or equal in case the sequence does not change, because the real cost of the re-sequenced route decreases and the sum of the dual variables remains the same.Empirically, we found a considerable improvement in terms of the number of columns generated using this procedure, which reduces the computational time by about 30%.To help SP1 find routes of good quality faster, we implement a simple but efficient search consistent with our problem. It guides the local search logically, by exploring a neighborhood matrix for each service request.For a given set of dual valuesα, we define the neighborhood matrixN(α)to be a square matrix of C rows and columns (recall thatC=|I1∪I2|). The element in row i and columnp,nip, is thepthclosest service request to request i. We considered different distance measures, and the one that performs the fastest in computational terms is the following. For a new route that has been created and includes the service request i, we would like to have the sequence(i,j)if two conditions hold: first, j’s time-window upper bound,bj, is close tobi+si+tij(recall thatsiis the expected service time of i, andtijis the expected travel time between i and j); and second, j has a large dual value. If j has a small dual value, then it is already efficiently covered by a route belonging to pool R. Thus, for each pair(i,j)we define the distance measured(i,j)=γ((bj-(bi+si+tij))++ρ(bi+si+tij-bj)+)+(1-γ)1αj, where(x)+=max{0,x},ρ>1andγ∈[0,1]. The larger penalization whenbi+si+tij>bjis to avoid a time-window violation at j. The implemented search for SP1 that usesN(α)is described in Algorithm 1.Algorithm 1SP1 constructs a new route with negative reduced cost, but not necessarily in the optimal orderWe also notice an additional improvement in the performance of the subproblem when adding some redundant constraints that do not modify the solution set but improve the constraint propagation. These constraints improve the tree pruning, filtering processes, and domain reduction. We impose(28)sc[l]>first(I3)⇒sc[l-1]=sc[l]-1l=3,…,L(29)sc[l]⩽first(I3)⇒sc[l-1]<first(I3)l=3,…,Lwherefirst(I3)represents the first fictitious service request; i.e.,C+1. Thus, constraints (28) and (29) eliminate identical solutions from the domain, taking into account the fact that all the fictitious nodes are the same, although their identification codes are different. Without these constraints, the solver does not realize early in the search tree that a service request cannot follow a fictitious node. In the CP literature, redundant constraints have often been used to create a set of different links between variables and to generate new potential for propagation.In the implementation, instead of adding only one route per iteration of the column generation, we generate a number of routes with negative reduced costs. To do this, we take advantage of the CP search tree of SP1. Each final node of the search tree is a route solution that has a negative reduced cost; therefore, each has the potential to improve the solution of MP if it is added to the pool R. We add the first Q columns found. Between iterations, we tune Q depending on the time that SP1 is taking to find solutions. For the first iterations we set Q to a large number, and for the last iterations we set Q to 1.We implemented a simple strategy to control the size of the pool of columns. At every iteration of the CG process, columns with high positive reduced costs are eliminated from the pool.Finally, we implemented a branch-and-price method that guarantees finding the optimal solution. The method allows us to explore additional routes with negative reduced costs in the branch-and-bound tree, by inspecting each node of the tree rather than only the root node. The method performs significantly better when an ad hoc branching strategy is implemented, as explained below.Many successful implementations of branch-and-price schemes can be found in the literature. Barnhart, Hane, and Vance (2000) presented a CG model that is solved with a branch-and-price-and-cut algorithm for an origin–destination integer multicommodity flow problem. Savelsbergh and Sol (1991) solved a dynamic vehicle routing problem with heuristic optimization techniques based on dynamic programming, together with a sophisticated column management scheme. Theoretical aspects of several versions of the branch-and-price algorithm are discussed by Barnhart et al. (1998), Vanderbeck (2000, 2005, 2006), and Vanderbeck and Savelsbergh (2006). Specifically, the authors concentrate on topics such as the formulation of the decomposition, proper ways to perform the branching, and column-management efficiency.In this application, we use the branching strategy proposed by Ryan and Foster (1981) for generic set partitioning problems. Barnhart et al. (1998) proved the following proposition:Proposition: If A is a 0–1 matrix, and a basic solution ofAθ=1is fractional i.e., at least one of the components ofθis fractional, then there exist two rows i and j in the master problem such that:(30)0<∑r:air=1,ajr=1θr<1The pairi,jestablishes the following pair of branching constraints:∑r:air=1,ajr=1θr=1and∑r:air=1,ajr=1θr=0, i.e., rows i and j must be covered by the same column on the first (left) branch and by different columns on the second (right) branch. The CP model can incorporate constraints of this type in an efficient way.Thus, for the left branch, constraint (31) must be added to SP1 to restrict the columns to those containing either both service requests i and j, or neither of them:(31)a[i]+a[j]≠1Similarly, for the right branch, constraint (32) can be added to restrict the columns to those containing at most one of the service requests, either i or j:(32)a[i]+a[j]⩽1Many possible pairs of service requests(i,j)could be chosen. For efficiency, we use a rule similar to that proposed by Vance et al. (1997) to choose a pair of service requests with a large probability of being covered by the same route in a good feasible solution of the IP. We compute for each pair(i,j)the scalarf(i,j)=∑r:air=1,ajr=1θr. We choose the pair with the largestf(i,j)for branching, and the depth-first search strategy is applied along the left branch, ensuring that the chosen pair of service requests will be on the same route. As mentioned before, the structure of the proposed CP model allows us to implement the branching strategy in a straightforward way.Our branch-and-price procedure is terminated when either we find an acceptable gap or the running time exceeds three hours. The gap is computed as the ratio of the integral objective value minus the linear relaxation objective value, and the linear relaxation objective value ((upper bound-lower bound)/lower bound).In the next section, we report some empirical results for different service-request sets, using real data for a typical day.The model was coded in Ilog Concert Technology and solved using CPLEX 9.0 (Ilog, 2003a) for the master problem and SOLVER 6.0 (Ilog, 2003b) for the subproblems. We test our algorithms in an Intel Pentium M 1.5gigahertz, with 2gigabyte of RAM. In this section, the branch-and bound-method (B&B), the optimal branch-and-price scheme (B&P), and the linear relaxation at the root node are run for several real instances of different sizes and service-request configurations, all from real data provided by the firm.The consistency of the CG approach was empirically checked by observing the convergence pattern toward the optimal solution in small problems. In fact, for small instances the optimal solution was obtained directly by solving the IP corresponding to the original arc-based formulation presented in Eqs. (1)–(10).In our results, each technician was assigned to no more than six service requests per day. For a larger number of requests, it was necessary to reschedule some for the next day, since serving all the requests on the same day was not feasible.We used a data set for the southern region of Santiago, Chile. Let us denote this region AB, since it can be further split into two subregions, namely A and B. A normal day was considered in terms of the number of service requests and the number of technicians working. Thus, 41 calls were received in zone A with 10 technicians available, while 35 were received in zone B with 9 technicians available. Note that the company presently schedules service for the two subregions separately. In our tests, we consider three basic instances, one for region A, another for region B, and one for the entire region AB. Fig. 4shows a map of the city and the two zones.The travel times between service-request locations were estimated by dividing the complete region AB into microzones. We decided to use the administrative divisions of Santiago (the microzones then match what are denoted comunas by the Chilean authorities). This allows us to use historical information for average travel times between each pair of comunas and within each comuna. Microzones (comunas) are required because the travel times between service requests are not available. The expected service time is computed as the average service time reported by the technicians for each type of request over the year. Finally, target response times (as defined in the first paragraph of Section 2) were also provided by the company, depending on the priority assigned to each service request. In most cases, the observed travel times followed the triangular inequality. If they did not, we perturbed them with the smallest possible amount necessary to satisfy the triangular inequality. As mentioned earlier, travel times are much smaller than service times, therefore this perturbation does not significantly change the solution.We consideredβ=0.3,0.6,0.9, which should cover the different priority levels a modeler would assign to the two components of the objective function (travel times versus time-window violations) according to the company’s goals. In this scheme, if it is infeasible to insert a specific service request into any route, that request will be assigned for service at the beginning of the next day, with a cost-function penalty of 500. Thus, the first columns generated for each service request are conceptually similar to the virtual paths defined in the original model through the variablesvito handle infeasibility. They are assigned a high penalty to provide an initial feasible solution to the master problem. Under these conditions, with the original IP model, Eqs. (1)–(10), we obtain the same optimal solution as that obtained by B&P. Unfortunately, this result can be verified only for very small instances, since the original arc-based formulation becomes intractable as the number of requests increases.Under these conditions, we run our model using the B&P algorithm separately for each subregion (A and B), in order to compare our results with the manual dispatch used by the company (company operation) for each subregion. Table 1compares the objective values of the results. Table 2compares the results in terms of time-window violation and travel time for the entire system. In Table 2, columnΔreports the total time-window violation observed for all service requests on all prescribed routes, and column T reports the sum of the travel time over all vehicle routes.Table 1 shows that the model improved performance for all instances (with improvements between 15% and 45%). We notice a more significant improvement for region A, probably because access and routing are more complicated in this region. Moreover, asβincreases, the improvement provided by the model becomes more significant. This is not surprising since larger values ofβplace more emphasis on time-window violations in the objective function. Increasingβthus yields routes in which most technician arrival times fall in a range quite close to the target response times.Table 2 shows that in both cases (zones A and B), the results are sensitive to the value ofβ. This is reflected in the ratio of time-window violations to travel times in each case (namelySH=ΔT). Thus, in the case of zone A (B) SH goes from 1.8 to 0.5 (from 1.9 to 0.4) whenβincreases from 0.3 to 0.9. From the results obtained for this particular instance, we can observe how important the selection of the parameterβcould become in the final performance of the model, both in terms of time-window violations and travel times.We also carried out a sensitivity analysis with respect to two other parameters, to test not only the quality of the solutions but also the performance of the B&P algorithm. The parameters are the number of technicians (for the A instance ranging from 6 to 11 and for the B instance from 5 to 10) and the upper bound for the time window assigned to each service request with respect to the actual limit (denotedtw1). The idea is to run the model under tighter time-window conditions. We do this by decreasing the upper bound by 15% to 40%, thus generating new upper levels,tw2=0.85·tw1andtw3=0.6·tw1. Table 3gives the results of these tests for instance A withtw1,tw2, andtw3, while Table 4gives the results for instance B withtw1,tw2, andtw3.When we integrate regions A and B, the problem has 76 service requests (instance AB). This allows testing on a larger instance and also allows the dispatcher to consider more flexible options than those provided by a zoning fixed a priori. Eventually, the zoning could be defined by a more formal method than the traditional subdivision of the service area by the company. Zoning may no longer be necessary (the company could completely rely on the optimization), or a clustering-type method could be used to define zones in a more systematic way. Table 5gives the results of these experiments for 11, 13, 15, 17, 19, and 21 technicians, considering also the sensitivity with respect to the time-window upper boundstw1,tw2, andtw3.The columns of Tables 3–5 represent the following: (tw) the upper bound considered for time windows, (β) the objective weighting parameter, and (#Tec) the number of technicians. For each instance generated by a combination of these parameters, we report the objective function obtained by the linear relaxation at the root node, the integer solution obtained using the default B&B implemented in CPLEX with only the columns found at the root node, and the integer solution obtained with the proposed B&P procedure (columns LR, BB, and BP respectively). We then report the gaps between (BB-LR) and (BP-LR), the number of columns generated at the root node (BB), the number of columns generated during the B&P (discounting the columns generated at the root node), the number of nodes explored by the CPLEX B&B, and the number of nodes explored by the B&P algorithm. Finally, the total running time to solve the master problem (MP) and the subproblem (SP) for both steps, namely B&B and B&P, are reported in seconds.When the gap between the B&B solution and the linear relaxation at the root-node solution (column BB-LR) was lower than 3%, we did not run the B&P procedure. The tables report “–” for these cases.To assign the technicians manually, the dispatchers were forced to split the region into zones A and B. Comparing the results for instances A and B in Tables 3 and 4 with those for instance AB in Table 5, we can see that this division leads to solutions of significantly lower quality in all cases. If, for example, we consider instance (tw1,β=0.9) with 6 technicians in zone A and 5 in zone B (thus, a total of 11 for AB), we see that the objective-function value obtained is 66 for case A and 1117 for case B, while that for case AB is 194. This deterioration in the objective value is due to the loss of flexibility when each zone is managed independently, since in zone B many customers need to be postponed to the next day. One conclusion to draw from these results is the considerable advantage of having an implementation of the B&P algorithm that can find an optimal solution for the larger 70-customer problem.We allowed a maximum of 300seconds to solve the subproblem at each iteration. We mark with a * those instances where this limit was reached before an optimal solution was found. It is clear that in these cases the bound obtained is not valid and the final solution is not optimal. As noted earlier, after solving the MIP with the columns found at the root node (B&B), if the gap between the linear relaxation at the root node and B&B was below 3%, we did not run the B&P. When used (28 of the 162 cases), the B&P algorithm reduced the gap by 3.5% on average. And the gap was reduced for more than 0.1% in 17 of the 28 cases. Most of the computational time was spent on the subproblem phase. Instance A took much longer than instance B (mainly because there are more service requests in instance A), and instance AB took the longest. Except in five cases (all from instance B) when the B&P procedure was used, fewer nodes were explored than those inspected by the B&B algorithm.With regard to the number of columns generated, for B instances it suffices to generate around 500 columns at the root node of the B&B to solve the linear relaxation to optimality. In the larger AB instances around 2500 columns are required. When the B&P algorithm is used, the number of columns required does not seem to follow a clear pattern. Note that some values in column BP-LR (Table 5) are negative, reflecting the difference between the B&P and the linear relaxation at the root node. These correspond to cases where the column generation at the root-node LP was terminated before reaching optimality.Recall that we run the B&P algorithm only if the difference between LR and BB is larger than3%. This does not occur often, indicating that the observed gap between LR and BB is generally small. However, the solution of the linear relaxation at the root node in terms ofθis fractional in most cases.To illustrate the behavior of the solutions, we consider two instances in Tables 6 and 7. The first case (instance 1:tw2,β=0.9,#Tec=6) shows a considerable BB-LR gap (12.4%), justifying the application of the B&P procedure. In contrast, the second case (instance 2:tw3,β=0.3,#Tec=8) yields a small BB-LR difference (0.3%), and the B&B algorithm obtains a close-to-optimal solution without having to explore nodes other than the root. In the tables, we show the columns considered in the linear relaxation at the root-node solution in each case, with the correspondingθ>0value associated with each column. Although both solutions are fractional, there are two aspects that could explain the difference in the BB-LR gap: the nature of the fractions (θvalues) and the number of columns in the solution. The LR of instance 1 (large gap) results in a large range ofθvalues. However, instance 2 has only threeθvalues (0.25,0.5,0.75) in all the chosen columns. This occurred in most of the cases with a small BB-LR gap (see Tables 3–5). Moreover, the number of columns included in the linear relaxation at the root-node solution of instance 1 is much larger than the number for instance 2 (more than 50 compared with 22).In summary, most of the solutions with a small BB-LR gap have a small number of columns in the linear relaxation at the root-node solution and a limited number ofθvalues (0.25,0.5,0.75). These examples show that when the BB-LR gap is large, the linear relaxation at the root-node solution has a range of fractional values (see instance 1) shared among a large number of columns.

@&#CONCLUSIONS@&#
In this paper, a technician dispatch problem is modeled as a vehicle routing problem with soft time windows. We solved several real examples provided by the operation of a large company in different service areas of Santiago, reformulating the problem using a set covering model and using constraint programming to solve the subproblems. Constraint programming allowed the subproblems to be solved easily and effectively.Our model allows us to optimize the dispatching of technicians in two actual instances (areas A and B as shown in Fig. 4), showing the advantages of the proposed B&P algorithm over the manual solutions implemented by the company. In addition, we were able to run our model over the entire area AB (70 service requests), obtaining in some cases significant performance improvements by not restricting the solution to the prespecified subregions A and B.Most instances had a small gap between the linear relaxation at the root node and the B&B solution, so it was not necessary to use B&P to explore beyond the root node. When B&P was used, it reduced the gap by 3.5% on average.