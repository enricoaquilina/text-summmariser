@&#MAIN-TITLE@&#
Chaospy: An open source tool for designing methods of uncertainty quantification

@&#HIGHLIGHTS@&#
Software for modeling uncertainty using Monte Carlo and polynomial chaos expansions.Used from Python with a programming syntax close to the mathematical theory.Can equip forward model with uncertainty quantication results from minimal code.Highly modular software structure, aimed to serve both experts and non-experts.Software compares favorably in functionality with competing packages.

@&#KEYPHRASES@&#
Uncertainty quantification,Polynomial chaos expansions,Monte Carlo simulation,Rosenblatt transformations,Python package,

@&#ABSTRACT@&#
The paper describes the philosophy, design, functionality, and usage of the Python software toolbox Chaospy for performing uncertainty quantification via polynomial chaos expansions and Monte Carlo simulation. The paper compares Chaospy to similar packages and demonstrates a stronger focus on defining reusable software building blocks that can easily be assembled to construct new, tailored algorithms for uncertainty quantification. For example, a Chaospy user can in a few lines of high-level computer code define custom distributions, polynomials, integration rules, sampling schemes, and statistical metrics for uncertainty analysis. In addition, the software introduces some novel methodological advances, like a framework for computing Rosenblatt transformations and a new approach for creating polynomial chaos expansions with dependent stochastic variables.

@&#INTRODUCTION@&#
We consider a computational science problem in spacexand time t where the aim is to quantify the uncertainty in some response Y, computed by a forward model f, which depends on uncertain input parametersQ:(1)Y=f(x,t,Q).We treatQas a vector of model parameters, and Y is normally computed as some grid function in space and time. The uncertainty in this problem stems from the parametersQ, which are assumed to have a known joint probability density function pQ. The challenge is that we want to quantify the uncertainty in Y, but nothing is known about its density pY. The goal is then to either build the density pYor relevant descriptive properties of Y using the density pQand the forward model f. For all practical purposes this must be done by a numerical procedure.In this paper, we focus on two approaches to numerically quantify uncertainty: Monte Carlo simulation and non-intrusive global polynomial chaos expansions. For a review of the former, there is a very useful book by Rubinstein, Reuven and Kroese [1], while for the latter, we refer to the excellent book by Xiu [2]. Note that other methods for performing uncertainty quantification also exist, such as perturbation methods, moment equations, and operator based methods. These methods are all discussed in [2], but are less general and less widely applicable than the two addressed in this paper.The number of toolboxes available to perform Monte Carlo simulation is vastly larger than the number of toolboxes for non-intrusive polynomial chaos expansion. As far as the authors know, there are only a few viable options for the latter class of methods: The Dakota Project (referred to as Dakota) [3], the Opus Open Turns library (referred to as Turns) [4], Uncertenty Quantification Toolkit[5], and MIT Uncertenty Quantification Library[6]. In this paper we will focus on the former two: Dakota and Turns. Both packages consist of libraries with extensive sets of tools, where Monte Carlo simulation and non-intrusive polynomial chaos expansion are just two tools available among several others.It is worth noting that both Dakota and Turns can be used from two perspectives: as a user and as a developer. Both packages are open source projects with comprehensive developer manuals. As such, they both allow anyone to extend the software with any functionality one sees fit. However, these extension features are not targeting the common user and require a deeper understanding of both coding practice and the underlying design of the library. In our opinion, the threshold for a common user to extend the library is normally out of reach. Consequently, we are in this paper only considering Dakota and Turns from the point of view of the common user.Dakota requires the forward model f to be wrapped in a stand-alone callable executable. The common approach is then to link this executable to the analysis software through a configuration file. The technical steps are somewhat cumbersome, but has their advantage in that already built and installed simulation software can be used without writing a line of code.Alternative to this direct approach is to interact with an application programming interface (API). This approach requires the user to know how to program in the supported languages, but this also has clear benefits as an interface through a programming language allows for a deeper level of integration between the user's model and the UQ tools. Also, exposing the software's internal components through an API allows a higher detailed control over the tools and how they can be combined in statistical algorithms. This feature is attractive to scientists who would like the possibility to experiment with new or non-standard methods in ways not thought of before. This approach is used by the Turns software (using the languages Python or R) and is supported in Dakota through a library mode (using C++).For example, consider bootstrapping [7], a popular method for measuring the stability of any parameter estimation. Neither Dakota nor Turns support bootstrapping directly. However, since Turns exposes some of the inner components to the user, a programmer can combine these to implement a custom bootstrapping technique.This paper describes a new, third alternative open source software package called Chaospy [8]. Like Dakota and Turns, it is a toolbox for analysing uncertainty using advanced Monte Carlo simulation and non-intrusive polynomial chaos expansions. However, unlike the others, it aims to assist scientists in constructing tailored statistical methods by combining a lot of fundamental and advanced building blocks. Chaospy builds upon the same philosophy as Turns in that it offers flexibility to the user, but takes it significantly further. In Chaospy, it is possible to gain detailed control and add user defined functionality to all of the following: random variable generation, polynomial construction, sampling schemes, numerical integration rules, response evaluation, and point collocation. The software is designed from the ground up in Python to be modular and easy to experiment with. The number of lines of code to achieve a full uncertainty analysis is amazingly low. It is also very easy to compare a range of methods in a given problem. Standard statistical methods are easily accessible through a few lines of R or Pandas [9] code, and one may think of Chaospy as a tool similar to R or Pandas, just tailored to polynomial chaos expansion and Monte Carlo simulation.Although Chaospy is designed with a large focus on modularity, flexibility, and customization, the toolbox comes with a wide range of pre-defined statistical methods. Within the scope of Monte Carlo sampling and non-intrusive polynomial chaos expansion, Chaospy has a competitive collection of methods, comparable to both Dakota and Turns. It also offers some novel features regarding statistical methods, first and foremostly a flexible framework for defining and handling input distributions, including dependent stochastic variables. Detailed comparisons of features in the three packages appear throughout the paper.The paper is structured as follows. We start in Section 2 with a quick demonstration of how the software can be used to perform uncertainty quantification in a simple physical problem. Section 3 addresses probability distributions and the theory relevant to perform Monte Carlo simulation. Section 4 concerns non-intrusive polynomial chaos expansions, while conclusions and topics for further work appear in Section 5.To demonstrate how Chaospy is used to solve an uncertainty quantification problem, we consider a simple physical example of (scaled) exponential decay with an uncertain, piecewise constant coefficient:(2)u′(x)=−c(x)u(x),u(0)=u0,c(x)=c0,x<0.5c1,0.5≤x<0.7c2,x≥0.7Such a model arises in many contexts, but we may here think of u(x) as the porosity at depth x in geological layers and cias a (scaled) compaction constant in layer number i. For simplicity, we consider only three layers with three uncertain constants c0, c1, and c2.The model can easily be evaluated by solving the differential equation problem, here by a 2nd-order Runge–Kutta method on a mesh x, coded in Python as:Alternatively, the model can be implemented in some external software in another programming language. This software can either be run as a stand-alone application, where the Python function model runs the application and communicates with it through input and output files, or the model function can communicate with the external software through function calls if a Python wrapper has been made for the software (there are numerous technologies available for creating Python wrappers for C, C++, and Fortran software).The Chaospy package may be loaded byEach of the uncertain parameters must be assigned a probability density, and we assume that c0, c1, and c2 are stochastically independent:The sample points (c0, c1, c2) in probability space, where the model is to be evaluated, can be chosen in many ways. Here we specify a third-order Gaussian Quadrature scheme tailored to the joint distribution:The next step is to evaluate the computational model at these sample points (object nodes):Now, samples contains a list of arrays, each array containing u values at the 101 x values for one combination (c0, c1, c2) of the input parameters.To create a polynomial chaos expansion, we must generate orthogonal polynomials corresponding to the joint distribution. We choose polynomials of the same order as specified in the quadrature rule, computed by the widely used three-term recurrence relation (ttr):To create an approximate solver (or surrogate model), we join the polynomial chaos expansion, the quadrature nodes and weights, and the model samples:The model_approx object can now cheaply evaluate the model at a point (c0, c1, c2) in probability space for all x points in the x array. Built-in tools can be used to derive statistical information about the model response:The mean and deviation objects are arrays containing the mean value and standard deviation at each point in x. A graphical illustration is shown in Fig. 1.The accuracy of the estimation is comparable to what Dakota and Turns can provide. Fig. 2shows that the estimation error in the three software toolboxes are almost indistinguishable. The error is calculated as the absolute difference between the true value and the estimated value integrated over the depth x:ɛE=∫01|E(u)−E(uapprox)|dxɛV=∫01|V(u)−V(uapprox)|dxBoth the point collocation method and the pseudo-spectral projection method are included. The former is calculated using two times the random collocation nodes as the number of polynomials, and the latter using Gaussian quadrature integration with quadrature order equal to polynomial order. Note that Turns does not support pseudo-spectral projection, and is therefore only compared using point collocation.Numerical methods for uncertainty quantification need to generate pseudo-random realizations{Qk}k∈IKIK={1,…,K},from the density pQ. EachQ∈{Qk}k∈IKis multivariate with the number of dimensions D>1. Generating realizations from a given density pQis often non-trivial, at least when D is large. A very common assumption made in uncertainty quantification is that each dimension inQconsists of stochastically independent components. Stochastic independence allows for a joint sampling scheme to be reduced to a series of univariate samplings, drastically reducing the complexity of generating a sampleQ.Unfortunately, the assumption of independence does not always hold in practice. We have examples from many research fields where stochastic dependence must be assumed, including modelling of climate [10], iron-ore minerals [11], finance [12], and ion channel densities in detailed neuroscience models [13]. There also exists examples where introducing dependent random variables is beneficial for the modelling process, even though the original input was stochastically independent [14]. In any cases, modelling of stochastically dependent variables are required to perform uncertainty quantification adequately. A strong feature of Chaospy is its support for stochastic dependence.All random samples are in Chaospy generated using Rosenblatt transformations TQ[15]. It allows for a random variableU, generated uniformly on a unit hypercube [0, 1]D, to be transformed intoQ=TQ−1(U), which behaves as if it were drawn from the density pQ. It is easy to generate pseudo-random samples from a uniform distribution, and the Rosenblatt transformation can then be used as a method for generating samples from arbitrary densities.The Rosenblatt transformation can be derived as follows. Consider a probability decomposition, for example for a bivariate random variableQ=(Q0, Q1):(3)pQ0,Q1(q0,q1)=pQ0(q0)pQ1∣Q0(q1∣q0),werepQ0is an marginal density function, andpQ1∣Q0is a conditional density. For the multivariate case, the density decomposition will have the form(4)pQ(q)=∏d=0D−1pQd′(qd′),where(5)Qd′=Qd∣Q0,…,Qd−1qd′=qd∣q0,…,qd−1denotes that Qdand Qdare dependent on all components with lower indices. A forward Rosenblatt transformation can then be defined as(6)TQ(q)=(FQ0′(q0′),…,FQD−1′(qD−1′)),whereFQd′is the cumulative distribution function:(7)FQd′(qd′)=∫−∞qdpQd′(r∣q0,…,qd−1)dr.This transformation is bijective, so it is always possible to define the inverse Rosenblatt transformationTQ−1in a similar fashion.To implement the Rosenblatt transformation in practice, we need to identify the inverse transformTQ−1. Unfortunately, TQis often non-linear without a closed-form formula, making analytical calculations of the transformation's inverse difficult. In the scenario where we do not have a symbolic representation of the inverse transformation, a numerical scheme has to be employed. To the authors’ knowledge, there are no standards for defining such a numerical scheme. The following paragraphs therefore describe our proposed method for calculating the inverse transformation numerically.The problem of calculating the inverse transformationTQ−1can, by decomposing the definition of the forward Rosenblatt transformation in (6), be reformulated asFQd′−1(u∣q0,…,qd−1)=r:FQd′(r∣q0,…,qd−1)=ud=0,…,D−1.In other words, the challenge of calculating the inverse transformation can be reformulated as a series of one dimensional root-finding problems. In Chaospy, these roots are found by employing a Newton–Raphson scheme. However, to ensure convergence, the scheme is coupled with a bisection method. The bisection method is applicable here since the problem is one-dimensional and the functions of interest are by definition monotone. When the Newton–Raphson method fails to converge at an increment, a bisection step gives the Newton–Raphson a new start location away from the previous location. This algorithm ensures fast and reliable convergence towards the root.The Newton–Raphson-bisection hybrid method is implemented as follows. The initial values are the lower and upper bounds [lo0, up0]. IfpQd′is unbound, the interval is selected such that it approximately covers the density. For example for a standard normal random variable, which is unbound, the interval [−7.5,7.5] will approximately cover the whole density with an error about 10−14. The algorithm starts with a Newton–Raphson increment, using the initial value r0=(up0−lo0)u+lo0:(8)rk+1=rk−FQd′(rk∣q0,…,qd−1)−upQd′(rk∣q0,…,qd−1),where the densitypQd′can be approximated using finite differences. If the new value does not fall in the interval [lok, upk], this proposed value is rejected, and is instead replaced with a bisection increment:(9)rk+1=upk+lok2.In either case, the bounds are updated according to(10)(lok+1,upk+1)=(lok,rk+1)FQd′(rk+1∣q0,…,qd−1)>u(rk+1,upk)FQd′(rk+1∣q0,…,qd−1)<uThe algorithm repeats the steps in (8)–(10), until the residual|FQd′(rk∣q0,…,qd−1)−u|is sufficiently small.The described algorithm overcomes one of the challenges of implementing Rosenblatt transformations in practice: how to calculate the inverse transformation. Another challenge is how to construct a transformation in the first place. This is the topic of the next section.The backbone of distributions in Chaospy is the Rosenblatt transformation TQ. The method, as described in the previous section, assumes that pQis known to be able to perform the transformation and its inverse. In practice, however, we first need to construct pQ, before the transformation can be used. This can be a challenging task, but in Chaospy a lot of effort has been put into constructing novel tools for making the process as flexible and painless as possible. In essence, users can create their own custom multivariate distributions using a new methodology as described next.Following the definition in (6), each Rosenblatt transformation consists of a collection of conditional distributions. We express all conditionality through distribution parameters. For example, the location parameter of a normal distribution can be set to be uniformly distributed, say on [−1, 1]. The following interactive Python code defines a normal variable with a normally distributed mean:We now have two stochastic variables, uniform and normal, whose joint bivariate distribution can be constructed through the cp.J function:The software will, from this minimal formulation, try to sort out the dependency ordering and construct the full Rosenblatt transformation. The only requirement is that a decomposition as in (4) is in fact possible. The result is a fully functioning forward and inverse Rosenblatt transformation. The following code evaluates the forward transformation (the density) at (1, 0.9), the inverse transformation at (0.4, 0.6), and draws a random sample from the joint distribution:Distributions in higher dimensions are trivially obtained by including more arguments to the cp.J function.As an alternative to the explicit formulation of dependency through distribution parameters, it is also possible to construct dependencies implicitly through arithmetic operators. For example, it is possible to recreate the example above using addition of stochastic variables instead of letting a distribution parameter be stochastic. More precisely, we have a uniform variable on [−1, 1] and a normally distributed variable with location at x=0. Adding the uniform variable to the normal variable creates a new normal variable with stochastic location:As before, the software automatically sorts the dependency ordering from the context. Here, since the uniform variable is present as first argument, the software recognises the second argument as a normal distribution, conditioned on the uniform distribution, and not the other way around.Another favorable feature in Chaospy is that multiple transformations can be stacked on top of each other. For example, consider the example of a multivariate log-normal random variableQwith three dependent components. (Let us ignore for a moment the fact that Chaospy already offers such a distribution.) Trying to decompose this distribution is a very cumbersome task if performed manually. However, this process can be drastically simplified through variable transformations, for which Chaospy has strong support. A log-normal distribution, for example, can be expressed asQ=eZL+b,whereZare standard normal variables, and L andbare predefined matrix and vector, respectively. To implement this particular transformation, we only have to writeThe resulting distribution is fully functional multivariate log-normal, assuming L andbare properly defined.One obvious prerequisite for using univariate distributions to create conditionals and multivariate distributions, is the availability of univariate distributions. Since the univariate distribution is the fundamental building block, Chaospy offers a large collection of 64 univariate distributions. They are all listed in Table 1. The list also shows that Dakota's support is limited to 11 distributions, and Turns has a collection of 26 distributions.The Chaospy software supports in addition custom distributions through the function cp.constructor. To illustrate its use, consider the simple example of a uniform random variable on the interval [lo, up]. The minimal input to create such a distribution isHere, the two provided arguments are a cumulative distribution function (cdf), and a boundary interval function (bnd), respectively. The cp.constructor function also takes several optional arguments to provide extra functionality. For example, the inverse of the cumulative distribution function –the point percentile function – can be provided through the ppf keyword. If this function is not provided, the software will automatically approximate it using the method described in Section 3.2.Dakota and Turns do not support the Rosenblatt transformation applied to multivariate distributions with dependencies. Instead, the two packages model dependencies using copulas [16]. A copula consists of stochastically independent multivariate distributions made dependent using a parameterized function g. Since the Rosenblatt transformation is general purpose, it is possible to construct any copula directly. However, this can quickly become a very cumbersome task since each copula must be decomposed individually for each combination of independent distributions and parameterization of g. To simplify the user's efforts, Chaospy has dedicated constructors that can reformulate a copula coupling into a Rosenblatt transformation. This is done following the work of Lee [17] and approximated using finite differences. The implementation is based of the software toolbox RoseDist [18]. In practice, this approach allow copulas to be defined in a Rosenblatt transformation setting. For example, to construct a bivariate normal distribution with a Clayton copula in Chaospy, we do the following:A list of supported copulas are listed in Table 2. It shows that Turns supports 7 methods, Chaospy 6, while Dakota offers 1 method.As noted in the beginning of Section 3, by generating samples{Qk}k∈IKand evaluating the response function f, it is possible to draw inference upon Y without knowledge about pY, through Monte Carlo simulation. Unfortunately, the number of samples K to achieve reasonable accuracy can often be very high, so if f is assumed to be computationally expensive, the number of samples needed frequently make Monte Carlo simulation infeasible for practical applications. As a way to mitigate this problem, it is possible to modify{Qk}k∈IKfrom traditional pseudo-random samples, so that the accuracy increases. Schemes that select non-traditional samples for{Qk}k∈IKto increase accuracy are known as variance reduction techniques. A list of such techniques are presented in Table 3, and it shows that Dakota, Turns and Chaospy support 4, 7, and 7 variance reduction techniques, respectively.One of the more popular variance reduction technique is the quasi-Monte Carlo scheme[1]. The method consists of selecting the samples{Qk}k∈IKto be a low-discrepancy sequence instead of pseudo-random samples. The idea is that samples placed with a given distance from each other increase the coverage over the sample space, requiring fewer samples to reach a given accuracy. For example, if standard Monte Carlo requires 106 samples for a given accuracy, quasi-Monte Carlo can often get away with only 103. Note that this would break some of the statistical properties of the samples [19].Most of the theory on quasi-Monte Carlo methods focuses on generating samples on the unit hypercube [0, 1]N. The option to generate samples directly on to other distributions exists, but is often very limited. To the authors’ knowledge, the only viable method for including most quasi-Monte Carlo methods into the vast majority of non-standard probability distributions, is through the Rosenblatt transformation. Since Chaospy is built around the Rosenblatt transformation, it has the novel feature of supporting quasi-Monte Carlo methods for all probability distributions. Turns and Dakota only support Rosenblatt transformations for independent variables and the Normal copula.Sometimes the quasi-Monte Carlo method is infeasible because the forward model is too computationally costly. The next section describes polynomial chaos expansions, which often require far fewer samples than the quasi-Monte Carlo method for the same amount of accuracy.Polynomial chaos expansions represent a collection of methods that can be considered a subset of polynomial approximation methods, but particularly designed for uncertainty quantification. A general polynomial approximation can be defined as(11)fˆ(x,t,Q)=∑n∈INcn(x,t)Φn(Q)IN={0,…,N},where{cn}n∈INare coefficients (often known as Fourier coefficients) and{Φn}n∈INare polynomials. Iffˆis a good approximation of f, it is possible to either infer statistical properties offˆanalytically or through cheap numerical computations wherefˆis used as a surrogate for f.A polynomial chaos expansion is defined as a polynomial approximation, as in (11), where the polynomials{Φn}n∈INare orthogonal on a custom weighted function space LQ:(12)〈Φn,Φm〉=EΦn(Q)Φm(Q)=∫…∫Φn(q)Φm(q)pQ(q)dq=0n≠m.As a side note, it is worth noting that in parallel with polynomial chaos expansions, there also exists an alternative collocation method based on multivariate Lagrange polynomials [28]. This method is supported by Dakota and Chaospy, but not Turns.To generate a polynomial chaos expansion, we must first calculate the polynomials{Φn}n∈INsuch that the orthogonality property in (12) is satisfied. This will be the topic of Section 4.1. In Section 4.2 we show how to estimate the coefficients{cn}n∈IN. Last, in Section 4.7, tools used to quantify uncertainty in polynomial chaos expansions will be discussed.From (12) it follows that the orthogonality property is not in general transferable between distributions, since a new set of polynomials has to be constructed for each pQ. The easiest approach to construct orthogonal polynomials is to identify the probability density pQin the so-called Askey-Wilson scheme [29]. The polynomials can then be picked from a list, or be built from analytical components. The continuous distributions supported in the scheme include the standard normal, gamma, beta, and uniform distributions respectively through the Hermite, Laguerre, Jacobi, and Legendre polynomial expansion. All the three mentioned software toolboxes support these expansions.Moving beyond the standard collection of the Askey-Wilson scheme, it is possible to create custom orthogonal polynomials, both analytically and numerically. Unfortunately, most methods involving finite precision arithmetics are ill-posed, making a numerical approach quite a challenge [30]. This section explores the various approaches for constructing polynomial expansions. A full list of methods is found in Table 4. It shows that Dakota, Turns and Chaospy support 4, 3 and 5 orthogonalisation methods, respectively.Looking beyond an analytical approach, the most popular method for constructing orthogonal polynomials is the discretized Stieltjes procedure [33]. As far as the authors know, it is the only truly numerically stable method for orthogonal polynomial construction. It is based upon one-dimensional recursion coefficients that are estimated using numerical integration. Unfortunately, the method is only applicable in the multivariate case if the components of pQare stochastically independent.Generalized polynomial chaos expansions. One approach to model densities with stochastically dependent components numerically, is to reformulate the uncertainty problem as a set of independent components through generalised polynomial chaos expansion [34]. As described in detail in Section 3.1, a Rosenblatt transformation allows for the mapping between any domain and the unit hypercube [0, 1]D. With a double transformation we can reformulate the response function f asf(x,t,Q)=f(x,t,TQ−1(TR(R)))≈fˆ(x,t,R)=∑n∈INcn(x,t)Φn(R),whereRis any random variable drawn from pR, which for simplicity is chosen to consists of independent components. Also,{Φn}n∈INis constructed to be orthogonal with respect to LR, not LQ. In any case,Ris either selected from the Askey-Wilson scheme, or calculated using the discretized Stieltjes procedure. We remark that the accuracy of the approximation deteriorate if the transformation compositionTQ−1∘TRis not smooth [34]. Dakota, Turns, and Chaospy all support generalized polynomial chaos expansions for independent stochastic variables and the Normal/Nataf copula listed in Table 2. Since Chaospy has the Rosenblatt transformation underlying the computational framework, generalized polynomial chaos expansions are in fact available for all densities.The direct multivariate approach. Given that both the density pQhas stochastically dependent components, and the transformation compositionTQ−1∘TRis not smooth, it is still possible to generate orthogonal polynomials numerically. As noted above, most methods are numerically unstable, and the accuracy in the orthogonality can deteriorate with polynomial order, but the methods can still be useful [14]. In Table 4, only Chaospy's implementation of Bertran's recursion method [31], Cholesky decomposition [35] and modified Gram-Schmidt orthogonalization [32] support construction of orthogonal polynomials for multivariate dependent densities directly.Custom polynomial expansions. In the most extreme cases, an automated numerical method is insufficient. Instead, a polynomial expansion has to be constructed manually. User-defined expansions can be created conveniently, as demonstrated in the next example involving a second-order Hermite polynomial expansion, orthogonal with respect to the normal density [29]:Φnn∈I6=1,Q0,Q1,Q02−1,Q0Q1,Q12−1The relevant Chaospy code for creating this polynomial expansion looks likeChaospy contains a collection of tools to manipulate and create polynomials, see Table 5.One thing worth noting is that polynomial chaos expansions suffers from the curse of dimensionality: The number of terms grows exponentially with the number of dimensions [36]. As a result, Chaospy does not support neither high dimensional nor infinite dimensional problems (random fields). One approach to address such problems with polynomial chaos expansion is to first reduce the number of dimension through techniques like Karhunen–Loeve expansions [37]. If software implementations of such methods can be provided, the user can easily extend Chaospy to high and infinite dimensional problems.Chaospy includes operators such as the expectation operatorE. This is a helpful tool to ensure that the constructed polynomials are orthogonal, as defined in (12). To verify that two elements in phi are indeed orthogonal under the standard bivariate normal distribution, one writesMore details of operators used to perform uncertainty analysis are given in Section 4.7.There are several methodologies for estimating the coefficients{cn}n∈IN, typically categorized either as non-intrusive or intrusive, where non-intrusive means that the computational procedures only requires evaluation of f (i.e., software for f can be reused as a black box). Intrusive methods need to incorporate information about the underlying forward model in the computation of the coefficients. In case of forward models based on differential equations, one performs a Galerkin formulation for the coefficients in probability space, leading effectively to a D-dimensional differential equation problem in this space [38]. Back et al. [39] demonstrated that the computational cost of such an intrusive Galerkin method in some cases was higher than some non-intrusive methods. None of the three toolboxes discussed in this paper have support for intrusive methods.Within the realm of non-intrusive methods, there are in principle two viable methodologies available: pseudo-spectral projection [40] and the point collocation method [41]. The former applies a numerical integration scheme to estimate Fourier coefficients, while the latter solves a linear system arising from a statistical regression formulation. Dakota and Chaospy support both methodologies, while Turns only supports point collocation. We shall now discuss the practical, generic implementation of these two methods in Chaospy.The pseudo-spectral projection method is based on a standard least squares minimization in the weighted function space LQ. Since the polynomials are orthogonal in this space, the associated linear system is diagonal, which allows a closed-form expression for the Fourier coefficients. The expression involves high-dimensional integrals in LQ. Numerical integration is then required,(13)cn=EYΦnEΦn2=1EΦn2∫…∫pQ(q)f(x,t,q)Φn(q)dq≈1EΦn2∑k∈IKwkpQ(qk)f(x,t,qk)Φn(qk)IK={0,…,K−1},wherewkare weights andqknodes in a quadrature scheme. Note that f is only evaluated for the nodesqk, and these evaluations can be made once. Thereafter, one can experiment with the polynomial order since any cndepends on the same evaluations of f.Table 6shows the various quadrature schemes offered by Dakota and Chaospy (recall that Turns does not support pseudo-spectral projection). All techniques for generating nodes and weights in Chaospy are available through the cp.generate_quadrature function. Suppose we want to generate optimal Gaussian quadrature nodes for the normal distribution. We then writeMost quadrature schemes are designed for univariate problems. To extend a univariate scheme to the multivariate case, integration rules along each axis can be combined using a tensor product. Unfortunately, such a product suffers from the curse of dimensionality and becomes a very costly integration procedure for large D. In higher-dimensional problems one can replace the full tensor product by a Smolyak sparse grid [48]. The method works by taking multiple lower order tensor product rules and joining them together. If the rule is nested, i.e., the same samples found at a low order are also included at higher order, the number of evaluations can be further reduced. Another feature is to add anisotropy such that some dimensions are sampled more than others [49]. In addition to the tensor product rules, there are a few native multivariate cubature rules that allow for low order multivariate integration [43]. Both Dakota and Chaospy also support the Smolyak sparse grid and anisotropy.Chaospy has support for construction of custom integration rules defined by the user. The cp.rule_generator function can be used to join a list of univariate rules using tensor grid or Smolyak sparse grid. For example, consider the trapezoid rule:The cp.rule_generator function takes positional arguments, each representing a univariate rule. To generate a rule for the multivariate case, with the same one-dimensional rule along two axes, we do the following:Software for constructing and executing a general-purpose integration scheme is useful for several computational components in uncertainty quantification. For example, in Section 4.1 when constructing orthogonal polynomials using raw statistical moments, or calculating discretized Stieltjes’ recurrence coefficients, numerical integration is relevant. Like the ppf function noted in Section 3.3, the moments and recurrence coefficients can be added directly into each distribution. However, when these are not available, Chaospy will automatically estimate missing information by quadrature rules, using the cp.generate_quadrature function described above.To compute the Fourier coefficients and the polynomial chaos expansion, we use the cp.fit_quadrature function. It takes four arguments: the set of orthogonal polynomials, quadrature nodes, quadrature weights, and the user's function for evaluating the forward model (to be executed at the quadrature nodes). Note that in the case of the discretized Stieltjes method discussed in Section 4.1, the nominatorEΦn2in (13) can be calculated more accurately using recurrence coefficients [32]. Special numerical features like this can be added by including optional arguments in cp.fit_quadrature.The other non-intrusive approach to estimate the coefficients{ck}k∈IKis the point collocation method. One way of formulating the method is to require the polynomial expansion to equal the model evaluations at a set of collocation nodes{Qk}k∈IK, resulting in an over-determined set of linear equations for the Fourier coefficients:(14)Φ0(q0)⋯ΦN(q0)⋮⋮Φ0(qK−1)⋯ΦN(qK−1)c0⋮cN=f(q0)⋮f(qK−1)Unlike pseudo spectral projection, the locations of the collocation nodes are not required to follow any integration rule. Hosder [41] showed that the solution using Hammersley samples from quasi-Monte Carlo samples resulted in more stable results than using conventional pseudo-random samples. In other words, well placed collocation nodes might increase the accuracy. In Chaospy these collocation nodes can be selected from integration rules or from pseudo-random samples from Monte Carlo simulation, as discussed in Section 3.5. In addition, the software accepts user defined strategies for choosing the sampling points. Turns also allows for user-defined points, while Dakota has its predefined strategies.The obvious way to solve the over-determined system in (14) is to use least squares minimization, which resembles the standard statistical linear regression approach of fitting a polynomial to a set of data points. However, from a numerical point of view, this might not be the best strategy. If the numerical stability of the solution is low, it might be prudent to use Tikhonov regularization [50], or if the problem is so large that the number of coefficients is very high, it might be useful to force some of the coefficients to be zero through least angle regression [51]. Being able to run and compare alternative methods is important in many problems to see if numerical stability is a potential problem. Table 7lists the regression methods offered by Dakota, Turns, and Chaospy.Generating a polynomial chaos expansion using linear regression is done using Chaospy's cp.fit_regression function. It takes the same arguments as cp.fit_quadrature, except that quadrature weights are omitted, and optional arguments define the rule used to optimize (14).Irrespectively of the method used to estimate the coefficients ck, the user is left with the job to evaluate the forward model (response function) f, which is normally by far the most computing-intensive part in uncertainty quantification. Chaospy does not impose any restriction on the simulation code used to compute the forward model. The only requirement is that the user can provide an array of values of f at the quadrature or collocation nodes. Chaospy users will usually wrap any complex simulation code for f in a Python function f(q), where q is a node in probability space (i.e., q contains values of the uncertain parameters in the problem). For example, for pseudo-spectral projection, samples of f can be created asor perhaps done in parallel if f is time consuming to evaluate:The evaluation of all the f values can also be done in parallel with MPI in a distributed way on a cluster using the Python module like mpi4py. Both Dakota and Turns support parallel evaluation of f values, but the feature is embeded into the code, potentially limiting the customization options of the parallelization.There is much literature that extends on the theory of polynomial chaos expansion [36]. For example, Isukapalli showed that the accuracy of a polynomial expansion could be increased by using partial derivatives of the model response [59]. This theory is only directly supported by Dakota. In Turns and Chaospy the support is indirect by allowing the user to add the feature manually.To be able to incorporate partial derivatives of the response, the partial derivative of the polynomial expansion must be available as well. In both Turns and Chaospy, the derivative of a polynomial can be generated easily. This derivative can then be added to the expansion, allowing us to incorporate Isukapalli's theory in practice. This is just an example on how manipulation of the polynomial expansions and model approximations can overcome the lack of support for a particular feature from the literature.To be able to support many current and possible future extensions of polynomial chaos, a large collection of tools for manipulating polynomials must be available. In Dakota, no such tools exist from a user perspective. In Turns, there is support for some arithmetic operators in addition to the derivative. In Chaospy, however, the polynomial generated for the model response is of the same type as the polynomials generated in Sections 4.1 and 4.2, and the rich set of manipulations of polynomials is then available forfˆas well.Beyond the analytical tools for statistical analysis offˆ, either from the toolbox or custom ones by the user, there are many statistical metrics that cannot easily be expressed as simple closed-form formulas. Such metrics include confidence intervals, sensitivity indices, p-values in hypothesis testing, to mention a few. In those scenarios, it makes sense to perform a secondary uncertainty analysis through Monte Carlo simulation. Evaluating the approximationfˆis normally computationally much cheaper than evaluating the full forward model f, thus allowing a large number of Monte Carlo samples within a cheap computational budget. This type of secondary simulations are done automatically in the background in Dakota and Turns, while Chaospy does not feature automated tools for secondary Monte Carlo simulation. Instead, Chaospy allows for simple and computationally cheap generation of pseudo-random samples, as described in Section 3.5, such that the user can easily put together a tailored Monte Carlo simulation to meet the needs at hand. Within a few lines of Python code, the samples can be analyzed with the standard Numpy and the Scipy libraries [60] or with more specialized statistical libraries like Pandas [9], Scikit-learn [61], Scikit-statsmodel [62], and Python's interface to the rich R environment for statistical computing. For example, for the specificfˆfunction illustrated above, the following code computes a 90 percent confidence interval, based on 105 pseudo-random samples and Numpy's functionality for finding percentiles in discrete data:Since the type of statistical analysis offˆoften strongly depends on the physical problem at hand, we believe that the ability to quickly compose custom solutions by putting together basic building blocks is very useful in uncertainty quantification. This is yet another example of the need for a package with a strong focus on easy customization.The last step in uncertainty quantification based on polynomial chaos expansions is to quantify the uncertainty. In polynomial chaos expansion this is done by using the uncertainty in the model approximation f_approx as a substiute for the uncertainty in the model f. For the most popular statistical metrics, like mean, variance, correlation, a polynomial chaos expansion allows for analytical analysis, which is easy to calculate and has high accuracy. This property is reflected in all the three toolboxes. To calculate the expected value, variance and correlation of a simple (here univariate) polynomial approximation f_approx, with a normally distributed ξ0 variable, we can with Chaospy writeA list of supported analytical metrics is listed in Table 8.Until now there have only been a few real software alternatives for implementing non-intrusive polynomial chaos expansions. Two of the more popular implementations, Dakota and Turns, are both high-quality software that can be applied to a large array of problems. The present paper has introduced a new alternative: Chaospy. Its aim is to be an experimental foundry for scientists. Besides featuring a vast library of state-of-the-art tools, Chaospy allows for a high degree of customization in a user-friendly way. Within a few lines of high-level Python code, the user can play around with custom distributions, custom polynomials, custom integration schemes, custom sampling schemes, and custom statistical analysis of the result. Throughout the text we have compared the built-in functionality of the three packages, and Chaospy do very well in this comparison, which is summarized in Table 9. But the primary advantage of the package is the strong emphasis on offering well-designed software building blocks, with a high abstraction level, that can easily be combined to create tailored uncertainty quantification algorithms for new problems.Although the primary aim of the software is to construct polynomial chaos expansions, the software is also a state-of-the-art toolbox for performing Monte Carlo simulation, either directly on the forward model or in combination with polynomial chaos expansions. Variance reduction techniques are included to speed up the convergence, and because Chaospy is based on Rosenblatt transformations, efficient quasi-Monte Carlo sampling is available for any distribution. Another novel feature of Chaospy is the ability to handle stochastically dependent input variables through a new mathematical technique.

@&#CONCLUSIONS@&#
