@&#MAIN-TITLE@&#
Exact and heuristic solutions for the Minimum Number of Branch Vertices Spanning Tree Problem

@&#HIGHLIGHTS@&#
A branch-and-cut algorithm is designed for the Minimum Number of Branches Spanning Tree Problem.Large instances can be exactly solved for the first time in the literature.A heuristic procedure is also developed for larger instances which produces good approximate solutions.

@&#KEYPHRASES@&#
Integer programming,Spanning tree,Branch vertices,

@&#ABSTRACT@&#
The Minimum Number of Branch Vertices Spanning Tree Problem is to minimize the number of vertices of degree greater than two in a spanning tree. We present a branch-and-cut algorithm based on an enforced Integer Programming formulation, which can solve many more instances than previous methods. Since the problem is NP-hard, very large instances cannot be solved exactly. For such cases, a new heuristic two-stage method that gives very good approximate solutions is developed.

@&#INTRODUCTION@&#
In an undirected connected graph, a spanning tree (ST) is defined by a connected subgraph, maintaining all the nodes of the graph and with a minimum number of edges. When considering weighted edges, the Minimum Spanning Tree Problem (MSTP) aims to find the spanning tree with the minimum sum of weights. The number of spanning trees in a given graph can be huge, but finding an ST of minimum weight is a simple task, which can be carried out, for instance, using Prim’s algorithm (Prim, 1957). The efficiency of MST algorithms makes it unnecessary to design Integer Programming models to solve this problem. Nevertheless, there are many other STs of interest in a graph: to cite only a few, the degree-constrained ST (Narula & Ho, 1980) the ST of Hubs (Contreras, Fernández, & Marín, 2009) and edge-equitable STs (Landete & Marín, 2014). The difficulty of finding these and other optimal trees by means of an efficient ad hoc algorithm has led to the development of different IP formulations. The key point in these formulations is either (i) guaranteeing connectivity, or (ii) avoiding the formation of cycles, since both ensure the tree structure of the resulting subgraph when the number of edges is fixed. A relatively successful approach that we will follow partially in this work is to consider the ST problem as a network design problem where some flow between the nodes of the network is sent. Here, two variables associated to each edge (one per arc) indicate whether or not the arc is available to carry any flow. Thus, an order is imposed on the nodes of the graph and cycles cannot be closed.At another level, we find ST optimization problems with no weights associated to the edges. In this case the objective is related to the structure of the tree. Some problems within this family are the Minimum Leaf STP (Cerrone, Cerulli, & Raiconi, 2014; Salamon & Wiener, 2008), the Full Degree STP (also called Degree Preserving STP) (Bhatia, Khuller, Pless, & Sussmann, 1999; Gendron, Lucena, Salles da Cunha, & Simonetti, 2013; Khuller, Bhatia, & Pless, 2003), which keeps the maximum number of nodes with the same degree as in the original graph, and the Minimum-Degree STP (Fürer & Raghavachari, 1990), where the maximum degree of the nodes in the tree is to be minimized. Still in this family, there is a sub-family of interesting problems which optimize a measure that depends only on the so-called branch vertices (alternatively branching nodes, branches), those nodes in the tree with a degree greater than two. One of these problems is the Minimum Degree Sum of Branch Vertices STP, whose objective function is the sum of the degrees of all the vertices except those of degrees 1 and 2 (Cerrone et al., 2014; Cerulli, Gentili, & Iossa, 2009; Sundar, Singh, & Rossi, 2012). Finally, the Minimum Number of Branch Vertices STP, MBV, looks for the spanning tree with minimum number of vertices of degree greater than two, which is what we are interested in. The optimization problems corresponding to all the mentioned graphs are different and NP-hard (see the cited papers and references therein).Regarding the problem in question, the MBV, it seems to be have been proposed first in Gargano, Hell, Stacho, and Vaccaro (2002), justified by the design of optical networks, where a light signal can traverse a degree-two node without additional help, but must be split by a switch in the branching nodes. These switches must then be located in all the branching nodes and the cost of the network depends on their number. Cerulli et al. (2009) propose an Integer Programming formulation for the MBV and designed different heuristic strategies. Their formulation guarantees connection by sending a unit of flow from a root to any other node of the graph. They also generate many different instances, comparing the heuristic solutions with the optima reported by CPLEX solver running the IP formulation. Optimal solutions could only be obtained for some small instances. Silva et al. (2011) propose an adaptation of the Iterative Refinement approach to solve MBV, choosing to penalize violating edges and replace them with edges with less violation. They report better computational results than those obtained by Cerulli et al. (2009) on a set of small instances. Sundar et al. (2012) design two heuristic algorithms, one that starts with an ST and interchanges one tree edge and one edge outside the tree, keeping the acyclic structure and trying to improve the solution, together with an ant colony heuristic. They use the same IP formulation as in Cerulli et al. (2009), and generate similar random instances to make a comparison with the results in Cerulli et al. (2009). Xpress solver is used here, and the authors concluded that their heuristics work better than previous ones. Merabet, Durand, and Molnar (2012) consider again the same IP formulation as in Cerulli et al. (2009) to approach a variant of the problem. Carrabs, Cerulli, Gaudioso, and Gentili (2013) consider four IP formulations. The first contains an exponential number of constraints. The second is very similar to the formulation previously used in the literature, sending a unit of flow from a root node to any other node, and they also consider a multi-commodity flow formulation. The last uses additional variables and constraints in the style of Miller, Tucker, and Zemlin (1960). Although Carrabs et al. (2013) considered all the formulations to generate bounds (by means of different relaxations), the one that was used to optimally solve some instances was again the single commodity flow formulation. Their instances, available on the web page of the first author, were obtained when trying to produce a significant number of branch vertices in the optimal solution (implying the graphs were very sparse). CPLEX 11 was applied to the formulations. From 250 nodes on, there were instances that could not be optimally solved with any formulation. Silva et al. (2014) checked a different edge-swap heuristic on new sets of instances, and compared it with some instances of the previous authors, concluding that the new algorithm performed better, in general, that the previous approaches. Although they revisited one of the previous IP formulations, it was not used in their study. The last paper on MBV problem is Cerrone et al. (2014). The three smallest IP formulations were again reconsidered and relaxed, and another heuristic method (a memetic algorithm) proposed. Old and new instances were used in their computational study, obtaining relatively good approximate solutions.There is little in the literature to optimally solve the MBV problem. The formulations used are straightforward adaptations of classical formulations designed for similar spanning tree problems. Here we intend to modify the single commodity flow formulation to (i) adapt it better to the problem in question and (ii) enforce it to produce better bounds. We will also consider several properties that a spanning tree must satisfy, that will allow us to preprocess the instances, some of them very effectively. Moreover, since good heuristic solutions can be used to reduce the time needed to solve the instances, and they are the only way to produce a good solution when an instance is too difficult, we will also devote a lot of attention to the development of a two-stage heuristic method. As will be seen in the computational results section, the conjunction of these strategies in a branch-and-cut algorithm will lead to a spectacular improvement of previous results.Section 2 introduces the problem and some notations. Section 3 contains the details of a preprocessing phase, and a two-stage heuristic method is presented in Section 4. In Section 5 we present and improve the formulation previously used in the literature, and Section 6 is devoted to obtaining valid inequalities to tighten it. All these tools are combined in a branch-and-cut algorithm in Section 7. Computational results are obtained and compared with previous results in Section 8. An extension of the problem, incorporating weights on the edges and fixed costs associated with the branch vertices is also introduced in Section 9 and computationally studied in Section 10. Some conclusions close the paper.Let G′ = (V′, E′) be a connected, undirected graph with set of vertices (nodes) V′ = {1, …, n′} and set of edges E′⊆{e = {i, j}: i ≠ j ∈ V′} with |E′| = m′. LetT′be the set of spanning trees in G′. Let δj(G′) be the degree in G′ of node j, i.e., δj(G′) ≔ |{e ∈ E′: j ∈ e}|. Similarly, given any treeT=(V′,ET)∈T′,let δj(T) be the degree in T of node j, i.e., δj(T) ≔ |{e ∈ ET: j ∈ e}|.The Minimum Number of Branch Vertices Problem, MBV, is defined asminT∈T′|{j∈V′:δj(T)≥3}|.A node j ∈ V′ such that δj(T) ≥ 3 will be called a branching vertex, a branch nodeor simply a branch of T. We also define the neighborhood (set of neighbors) of j ∈ V′ in G′ asNG′(j):={i∈V′:{i,j}∈E′}.An edge e ∈ E′ such that (V′, E′∖{e}) becomes disconnected will be called a bridge of G′. A set of two different edges {e, e′} such that (V′, E′∖{e, e′}) becomes disconnected but both (V′, E′∖{e}) and (V′, E′∖{e′}) are still connected will be called a 2-cocycle or a cocycle of size two in G′.We will also split each edge {i, j} ∈ E′ into two arcs (i, j) and (j, i). We call A′ this set of arcs. If {i, j} is a bridge, we say that (i, j) is an arc bridge (or simply a bridge) in G′ if all oriented paths from i to n′ traverse node j (i.e., if (i, j) is oriented towards n′). When {e, e′} is a 2-cocycle, we call the set of two arcs obtained orienting e and e′ towards n′ 2-cocircuit.All bridges of a connected graph must be in the set of edges of any spanning tree. When removing all bridges some nodes can become isolated. In the left hand side of Fig. 1we show a graph with six bridges. The removal of five of them (dotted lines) leaves five nodes isolated, as shown in the right hand side of the figure. After identifying the set of isolated nodesVI′⊆V′,we will remove them and the corresponding edges from G′, producing the subgraph induced byV:=V′∖VI′,called G = (V, E). For the sake of simplicity, we will assume that V = {1, …, n} and then VI≔ {n + 1, …, n′}. Since some of the removed nodes may be branches (like node 2 in the figure), we must add the corresponding constant to the objective function. There will be also some nodes in V which have two or more neighbors among the removed nodes (like node 16 in the figure). These other nodes will also be branches. And nodes j ∈ V′ with δj(G′) ≤ 2 will never be branches. To take note of the interesting nodes, we create a new set V′′, obtained from V by removing all the nodes which definitely are either branches or not. Bridges whose removal do not produce isolated nodes (like the thick edge of the left hand side of the figure) will be included a priori in the optimum spanning tree. We call the number of deleted nodes among the neighbors of jδjp:=|NG′(j)∩VI|.Identifying bridges in G′ can be done efficiently with the algorithm proposed in Schmidt (2013). The method has two stages. In the first, using depth-first search, a spanning arborescence (oriented spanning tree) with all arcs pointing towards root node n′ has to be built. The details are given in Fig. 2. In step 1, all nodes are initially unmarked (m(j) ≔ 0), the level of all nodes except node n′ is fixed to − 1 (ℓ(j) ≔ −1) and the level of node n′ is fixed to 0. A is going to be the set of arcs of the arborescence, which is initially empty. Step 2 is repeated until all the nodes are marked (m(j) = 1). An unmarked node of maximum level i is first identified. There are two possibilities: (i) all neighbors of i were previously marked; this means that they have been already included in the arborescence, and then node i is in turn marked, and (ii) there exists at least one unmarked node k in the neighborhood of i; since i has the maximum possible level among the nodes of the arborescence with unmarked neighbors, arc (k, i) is included in A, and k is labeled ℓ(i) + 1. The process is illustrated in Fig.3, using the same graph as in Fig. 1. The root node n′ = 17 is gray and the numbers inside the nodes are the values of ℓ(j). Starting with i = 17, its neighbor k = 5 is chosen and the arc (5, 17) is included in A (bold arrow). The level of 5 is now 1, and then 5 is chosen as node i. Its neighbor 6 is then chosen, and so forth until arriving at node 1 and the situation of Fig.3, top-left. Since node 1 has no neighbors with level − 1, it is marked and node 2 is chosen as i. There is a neighbor of 2 with level − 1, namely node 3, and so 3 is chosen as k and arc (3, 2) is included in A, as seen in the top-right part of the figure. Now 3 and 2 are marked, 16 is chosen as i and 4 is chosen as k, with level 8 as indicated in the down-left part. The final arborescence and corresponding levels are shown in the lower-right part of the figure.Consider now an edge not in the arborescence. The way in which the previous algorithm works guarantees that both extremes of the edge have different levels, and also the existence of an oriented path from the extreme with maximum level to the other extreme. We illustrate this in Fig. 4, choosing edge (8, 11) (dotted edge). The extreme with maximum level is 11, with level 7. The oriented path (inside the arborescence) from 11 to 8 is depicted in the figure with dashed arrows. Since all the edges of this path plus the dotted edge close a cycle, they cannot be bridges. Using this fact, the second stage of the method for identifying bridges, given in Fig. 5, iteratively considers all edges not in the arborescence, goes over the corresponding cycle and discards the edges in the cycle. The remaining edges will be the bridges of the graph. Moreover, a bridge oriented as in the arborescence will be an arc bridge (thick arc in the figure).Identifying 2-cocycles (and 2-cocircuits) can be done by removing any edge other than a bridge from E (one at a time) and then applying the algorithm to identify the bridges of the resulting subgraph.The importance of finding good feasible solutions to MBV is twofold. On the one hand, tight upper bounds will help to solve the problem exactly by reducing the search of any Integer Programming solver. On the other hand, difficult instances which cannot be exactly solved will be approximately solved by means of the heuristic procedure. Several heuristics have been developed in the literature. An edge weighting strategy, a node coloring strategy and a combination of both were the first (Cerulli et al., 2009). In Silva et al. (2011) an Iterative Refinement approach gave better computational results than those of Cerulli et al. (2009) on a set of small instances. In Sundar et al. (2012), an ant colony heuristic was tested, and reported to perform better than the previous ones. The dual ascent based on an IP formulation of Carrabs et al. (2013), the edge-swap heuristic of Silva et al. (2014) and the memetic approach of Cerrone et al. (2014) close the list of approaches that, to the best of our knowledge, are all the methods published to date.Here we present a heuristic method which starts with a spanning tree built with a dynamically modified version of Prim’s algorithm. This tree is then improved with several exchange strategies. Some of the strategies reduce the number of branches of the current tree, but several others only perturb it, without increasing the number of branches. Since the first part of the heuristic uses randomized weights, and given that the overall process is very fast, a multi-start method is used.The basic structure of the heuristic is given in Fig. 6. The weights of step 1a are only relevant when one of the extremes of {i, j}, say i, is marked and the other extreme is unmarked. Let τ be the current tree, M a large amount and α a random uniform variable between 0 and 1. Then the weight assigned to {i, j} will beα+δj(G′)+δi(τ)ifδi(τ)≥3orδip≥2,α+M+δj(G′)ifδi(τ)=1,α+M2otherwise.The effect of these weights is that edges with a marked extreme which is going to be a branch are prioritized, and preferred if their original degree is low, since their incident edges will be more probable in any spanning tree. Edges that are leaves in the current tree are then prioritized and randomly ordered. The rest of the nodes are also randomly ordered.There are two different improving movements in step 2a, IMP1 and IMP2. IMP1 is first repeated until not possible. How IMP1 works is illustrated in Fig. 7. Edges e from outside the tree are iteratively considered, and selected if none of the extremes have degree two in the current tree (dotted edge in the left hand side). Edges in the tree that close a cycle with e are identified (thick edges). If replacing one of the edges in the cycle by e reduces the degree of any node in the tree from 3 to 2, the replacement is made and the objective value is reduced by one (or perhaps by two). IMP2 is applied only once and then the graph is returned to IMP1. How IMP2 works is illustrated in Fig. 8. Edges e from outside the tree are iteratively considered. Each of these edges closes a cycle when added to the tree. e is selected if (i) one of its extremes has a degree not equal to two in the current tree and (ii) the edge that is incident to the other extreme of e that belongs to the cycle (thick edge) is also incident to a second node ji(gray node) of degree 3. It can be seen in the figure that on replacing the thick edge by the candidate edge (dotted edge) there is one less branch vertex in the new tree.When no improvement is possible by applying IMP1 and IMP2, the perturbation phase modifies the tree without improving the objective value but by reducing the degree of some branch in the tree. PER1 is similar to IMP2, but will be applied when the degree of jiis greater than 3. PER2 is similar to IMP1, and will be applied whenever the degree of some branch in the closed cycle is reduced in case of replacement. Finally, PER3 is similar to PER2, but the exchange is made when the degree in the tree of a branch is reduced from 3 to 2 and another node of size 2 is converted into a branch. To avoid cycling, each candidate edge is considered only once if no new improvement is obtained in step 2a.The formulation we are going to use starts with the preprocessed graph G = (V, E) with |V| = n and |E| = m, where all the vertices that become isolated after removing the bridges from the graph have been eliminated, and there is a constant that has to be added to the optimal value of the problem. We also make use of the corresponding set of arcs A and the set V′′ that contains the nodes that could be branches or not. On the other hand, the (basic) formulation we take (developed in Carrabs et al., 2013) and we show first does not use V′′ and, for the sake of simplicity, will be explained in graph G (note that, in the literature, it is used directly in graph G′ and set of arcs A′).Standard binary decision variablesxij={1if(i,j)belongstoET0otherwise∀(i,j)∈Awill be used to characterize a spanning tree in G. Non-negative variables zijassociated to the arcs will be used to represent the amount of flow traversing them. Finally, and necessary to calculate the objective value of a solution, binary variables yjdefined as follows are incorporated:yj={1ifjhasdegreeatleast3inT0otherwise∀j∈V.The formulation commonly used in the literature is(1)(L)min∑j∈Vyjs.t.∑i∈V:(i,n)∈Azin−∑i∈V:(n,i)∈Azni=n−1,(2)∑i∈V:(j,i)∈Azji=∑i∈V:(i,j)∈Azij+1∀j<n,(3)zij≤(n−1)xij∀(i,j)∈A,(4)zij≥xij∀(i,j)∈A,(5)∑i∈V:(j,i)∈Axji=1∀j<n,(6)∑i,j∈V:(i,j)∈Axij=n−1,(7)∑i∈V:(i,j)∈Axij+∑i∈V:(j,i)∈Axji≤2+δj(G)yj∀j∈V,xij∈{0,1}∀i,j∈V:(i,j)∈A,yj∈{0,1}∀j∈V,zij≥0∀i,j∈V:(i,j)∈A.Note that there is a flow of n − 1 units towards n (any other node could also be chosen as destination of the flow), according to constraint (1), and one unit of this flow is created in all other nodes, according to constraints (2). Constraints (3) and (4) make xijtake value 1 if and only if there is a positive flow traversing arc (i, j). Along with constraints (5) and (6), which fix the number of arcs with first node j to 1 and to n − 1 the total number of arcs, the result is that x-variables taking value 1 configure an arborescence (oriented towards n). Due to constraints (7), if the degree of j in the arborescence – left hand side – is at least 3, yjmust take value 1. Otherwise, coefficient δj(G) guarantees that yjis free and will take value 0 in the optimal solution.Starting from formulation (L), we have carried out several improvements. First, some nodes must be branches since they are incident to several bridges and their degree will consequently be at least three. The corresponding y-variables are fixed to one. Some other nodes, those j ∈ V′ with δj(G′) ≤ 2, will never be branches. Their y-variables are fixed to zero. All this information results in creating y-variables only for j ∈ V′′. Note that since we work on G, n′ is replaced by n as the root of the arborescence.We then fix the z- and x-variables that correspond with arcs (n, j) to zero, since no flow will leave node n. We remove constraint (6), since it is obtained as the sum of constraints (5) for all j < n. Constraints (4) were also eliminated, since they are not needed, are many, and we did not observe any advantage in using them.Regarding constraints (3), note that the important effect they produce is to let xijtake value 1 if a flow zij≥ 1 traverses arc (i, j). To improve (3), the upper bound n − 1 on the total amount of flow that can traverse i should be reduced. To this end, we calculate dj, the length of the path with fewest edges from node j to node n in G. In the worst case, the flow from j to n will follow this path, incorporating djunits after leaving j. Therefore, for a given arc (i, j), the associated constraint in (3) can be replaced byzij≤(n−1−dj)xij.Another improvement of (3) we have incorporated is to consider the situation in which j ∈ NG(n) and k ∈ NG(j), k ≠ n. Then, constraint(8)zkj≤(n−3)xkj+xjnmeans that the flow going from k to j through a single arc, which is known to be less than or equal to n − 2 since j ≠ n, will be also less than or equal to n − 3 if arc (j, n) is not in the tree.Consider the original version of constraints (7) on graph G′. We take into account that, for any j < n′,∑i∈V′:(i,j)∈A′xij+∑i∈V′:(j,i)∈A′xji=∑i∈V′:(i,j)∈A′xij+1≤δj(G′).Then the coefficient of yjcan be reduced to let the right hand side reach this maximum, and (7) is replaced by∑i∈V′:(i,j)∈A′xij≤1+(δj(G′)−2)yj∀j<n′.In the case j = n′ the constraint remains∑i∈V′:(i,n′)∈A′xij≤2+(δn′(G′)−2)yn′.However, since the preprocessing phase will remove some edges from graph G′ to produce the reduced graph G and will fix some edges in the tree, we must take this into account to obtain the final version of these constraints:∑i∈V:(i,j)∈Axij+δjp(T)≤1+(δj(G)+δjp(T)−2)yj∀j<n,∑i∈V:(i,j)∈Axin+δnp(T)≤2+(δn(G)+δnp(T)−2)yn,whereδjp(T)is the number of arcs added to T in the preprocessing phase that is incident to j.Some bridges can have been identified in the preprocessing phases that are still in G. When {i, j} is a bridge in G, the procedure we have followed to identify it will give us the orientation of the arc bridge. The arc must be in the arborescence, and thenxij=1∀(i,j)arcbridgeinGwill also be added to the formulation.In this section we develop several valid inequalities for the problem. The first set of inequalities has already been used (see, for example, Akgün & Tansel, 2010). It is given by(9)xij+xji≤1∀{i,j}∈E.The preprocessing phase provides us with a set of 2-cocircuitsC={{(i1,j1),(i1′,j1′)},…,{(ig,jg),(ig′,jg′)}}.At least one arc from each cocircuit must be in the arborescence. Valid inequalities(10)xikjk+xik′jk′≥1∀{(ik,jk),(ik′,jk′)}∈C,are then generated. Some of them, those associated to nodes of degree 2 in G′, will already be in the formulation, while several others will not.The previous inequalities can be used in any spanning tree optimization problem, since they only make use of the x-variables. Moreover, the amount of inequalities in families (8), (9) and (10) is relatively small, and all of them will be incorporated to the formulation. We have also developed a family of valid inequalities which do depend on the y-variables (i.e., they are specifically oriented to the MBV), whose size is larger:(11)xaj+xbj≤1+yj∀j<n,∀(a,j),(b,j)∈A:a<b.Here, since there will be a third arc pointing from j (note that j ≠ n), if two arcs pointing node j are in the arborescence, then j will be a branch vertex and yjmust take value one. This is a disaggregated version of constraints (7).The outline of the exact method we use to solve MBV is given in Fig. 9. First the graph is reduced and an upper bound obtained as seen in previous sections, carrying out the search 100 times per instance. Bridges and cocircuits found in step 2 are used to build constraints (21) and (19), respectively. In order to build constraints (14), lengths djare obtained in step 4. Then the formulation to be used, putting together all improvements made on (L), is given by(12)(MBV)min∑j∈V′′yjs.t.∑j∈V:(j,n)∈Azjn=n−1,(13)∑i∈V:(j,i)∈Azji=∑i∈V:(i,j)∈Azij+1∀j<n,(14)zij≤(n−1−dj)xij∀(i,j)∈A,(15)∑i∈V:(j,i)∈Axji=1∀j∈V,j<n,(16)∑i∈V:(i,j)∈Axij+δjp(T)≤1+(δj(G)+δjp(T)−2)yj∀j∈V′′,j<n,(17)∑i∈V:(i,n)∈Axin+δnp(T)≤2+(δn(G)+δnp(T)−2)ynifn∈V′′,(18)xij+xji≤1∀{i,j}∈E,(19)xikjk+xik′jk′≥1∀{(ik,jk),(ik′,jk′)}∈C,(20)zkj≤(n−3)xkj+xjn∀j∈NG(n),n≠k∈NG(j),(21)xij=1∀(i,j)arcbridge,(22)xij∈{0,1}∀(i,j)∈A,(23)yj∈{0,1}∀j∈V′′,(24)zij≥0∀(i,j)∈A.Note that the node set V is used to configure the tree but only those nodes in V′′ have their corresponding y-variable. Although the number of valid inequalities (11) is polynomial, adding all of them to the formulation makes it unnecessarily large and worsens the computational results. Therefore, (11) are separated and added to the formulation inside a branch-and-cut procedure by explicitly checking all of them. A maximum of 1000 violated inequalities is added to the formulation when solving a given instance. There are several possibilities with the upper bound. If ub = 0, then there exists a Hamiltonian path in the graph (a spanning tree without any branch). In such a case, the procedure stops without additional search, since this solution must be optimal. When the upper bound is positive (and integer), whether the linear relaxation of the formulation gives a value greater than ub-1, it is guaranteed that the optimal solution will take value ub and the search is also stopped. Otherwise, the IP search must be used to find better bounds.All the results of the experiment were obtained using an Intel Core 2 Quad CPU Q9300, 2.50 gigahertz × 4, with 3 gigabytes of RAM memory, running linux Ubuntu 12.04. The heuristic was coded in pascal using Free Pascal Compiler, version 2.4.4–3.1, without additional parameters. The branch-and-cut algorithm was programmed in Xpress mosel 32-bit v3.4.3, with the default parameters (except those oriented to stop the search when the optimality is guaranteed).Several instances from the literature were used, mainly to compare the results of our method with the results obtained with the latest (and best) approaches in the literature. Note that dense graphs use to contain a Hamiltonian path. To produce more interesting instances, Carrabs et al. (2013) generated sparse graphs with n between 20 and 500 and different densities. They solved (L) by applying CPLEX, with a maximum running time of 1 hour. Some instances with 250 nodes and most of the instances with n ≥ 400 could not be solved in this time (solving instances with more than 500 nodes was not tried, but we also use instances with up to 1000 nodes generated by them). Different relaxations and heuristic methods were used to produce bounds for all instances. These data are available on the website of the first author of Carrabs et al. (2013) and are the first group of instances we used in the computational study (detailed results of their study are also available there). The instances use to contain many bridges, most of them producing isolated nodes, and our preprocessing phase benefited from this. We call these medium instances (when n ≤ 500) or large instances (when n ≥ 600).Silva et al. (2014) use more difficult instances, which do not contain bridges and cannot be reduced in the preprocessing phase. We have incorporated several of these instances into our study, grouped in three classes, with all of them available following the links in Silva et al. (2014). Graphs called dimacs have 450 nodes and between 5714 and 17 425 edges. The edge-swap heuristic these authors use to obtain solutions gave from 0 to 8 branches per graph, and requires several minutes. Compared to the previous algorithms of Cerulli et al. (2009) (re-programmed in Silva et al., 2014), with upper bounds between 1 and 10, the method can be considered satisfactory. Other instances we take from that paper are hcp (four instances with 1000 to 4000 nodes) and stein (five instances with 1000 nodes and 5000 edges). In all cases the results in Silva et al. (2014) seem to be much better than those obtained by the same authors using the method from Cerulli et al. (2009).Results for medium instances are reported in Table 1. We have averaged the results by number of nodes. Each line represents 25 different graphs. Times are in seconds. (L) refers to the results obtained in Carrabs et al. (2013) using formulation (L) to optimally solve the instances. (L)time only takes into account the instances that could be optimally solved in 3600 seconds (the actual times can be much larger). The best upper bound (L)ub they could produce is shown in the table. The rest of columns refer to our method. The total computational time needed by the heuristic procedure (100 runs on each of the 400 instances) was 239 seconds, i.e., 0.6 seconds per instance and 0.006 seconds per run in average (not considered in the table). C is the number of isolated nodes removed in the preprocessing phase plus the nonisolated nodes which are removed from V to produce V′′, i.e., the constant to be added to the objective value got using formulation (MBV) on graph G. The lower bound produced by the linear relaxation of (MBV) is given in column lb, and column ub reports the upper bound produced by our heuristic algorithm. Both are very tight. The number of nodes of the branch-and-bound algorithm (Xpress) is bbn, and the number of separated valid inequalities in family (11) is cuts. The number of bridges (of all types) and cocycles used in the solution method are also reported. Column time shows the averaged computational times needed to solve the instances optimally. The results are self-explanatory, since all instances could be optimally solved in extremely short times, much shorter than those previously needed to produce approximate solutions.Similar results are obtained for large instances (Table 2). The total computational time needed by the heuristic procedure (100 runs on each of the 125 instances) was 264 seconds, i.e., 2.1 seconds per instance. In this case, each entry of the table averages five instances of the same size (n and m). Relative deviation of the lower and upper bound with respect to the optimal value is also shown (lb percent and ub percent, respectively). Again due to the tightness of the bounds, all instances could be optimally solved in minutes of CPU time. Ten minutes of CPU time is the average for the most difficult and largest instances.Columns ES and EStime of Table 3show, respectively, the best upper bounds and the computational times (100 runs) of the Edge-Swap heuristic developed in Silva et al. (2014) when applied to the dimacs instances. After several minutes, six instances were optimally solved (with optimal value 0), but up to 8 branches were needed in the best solution of one of the instances. Our heuristic method found an optimal value equal to 0 in 1.7 seconds (average time), most of the times in step 1 of Fig. 5.No optimal solutions could be obtained in 1 hour of CPU time for any of the instances in the other two groups (Table 4). In this case an average time of 1362 seconds (although very different from one instance to another) was needed to produce upper bounds one order of magnitude better than the bounds previously produced in the literature in about 32,500 seconds. All lower bounds take value 0, which means that all these instances are probably Hamiltonian but the search procedure cannot find the optimal solution.We have also considered an extended version of the model where the branches can have different costs depending on the node where they are located, and the edges of the graph are weighted. Let fj> 0 be the fixed cost associated to node j ∈ V′, to be paid when j is a branch and let cij> 0 be the fixed cost (weight) associated to edge {i, j} if it is in the tree. We call this version MBV Location Problem, MBVL.Obviously during the preprocessing phase we must add to the constant of the objective function the cost of nodes not in V′′ and the costs of the removed bridges.The heuristic procedure has to be completely re-designed. Since the number of branches is now secondary, and it is their cost that should be reduced when exchanging edges from outside and inside the tree, the procedure becomes a little simpler. It is outlined in Fig. 10. In step 1, the weights we use to dynamically adapt Prim’s algorithm depend now on the costs of the model:cijδj(G′)ifδi(τ)≥3,cijδj(G′)+αfiδi(G′)ifδi(τ)=1,cij+fiotherwise,where again i is the marked extreme of {i, j}. The improvement phase IMP is repeated until not possible and then the procedure stops. IMP works by iteratively considering edges not in the tree {i, j}, identifying edges in the tree that close a cycle with {i, j} and replacing one of the edges in the cycle by {i, j} if the cost of the tree is reduced (taking into account the costs of both edges and the possible changes in the set of branches of the tree).After calculating the constant to be added, only a simple change in the objective function of (MBV) suffices to get a valid formulation for MBVL:(MBVL)min∑j∈V′′fjyj+∑(i,j)∈Acijxijs.t.(12)−(24).We considered the same instances as in Section 8. Since none of them comes with fixed costs, for easy reproducibility we tookfj:=2n′+Round(j/10)∀j∈V′.Instances stein come with their own weights. For the rest of the instances, trying to compensate both costs and to produce optimal solutions with several branches, we tookcij:=2n′−i−j∀{i,j}∈E(and consequently both arcs with the same cost in (MBV)).Again all medium and large instances could be optimally solved in a short time (Tables 5 and 6). Now the total computational time needed by the heuristic procedure was 187 (resp. 217) seconds for the medium (resp. large) graphs, i.e., 0.5 (resp. 1.7) seconds per instance in average. Bounds were again really tight. We have included a column in the table with the number of branching vertices of the optimal solution found by the procedure (bv). The times and size of the search tree were slightly greater than the times of MBV, and the number of added cuts was similar.The rest of the instances were heuristically solved, needing a total time of 822 seconds. The upper bounds produced by the algorithm are shown in Table 7.

@&#CONCLUSIONS@&#
Tightening several constraints, adding or separating valid inequalities and preprocessing the graphs when possible, instances of the Minimum Number of Branches Problem previously considered too difficult have been optimally solved, and good approximate solutions have been generated by a new heuristic method and give better solutions than the best previously known. Also a new problem (which can be considered as a discrete location problem) has been introduced and solved with a modification of the method. Solution methods for many other spanning tree problems in the literature can benefit from some of the ideas presented in the paper.