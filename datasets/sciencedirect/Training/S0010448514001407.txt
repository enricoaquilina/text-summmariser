@&#MAIN-TITLE@&#
Layered shape grammars

@&#HIGHLIGHTS@&#
We propose a computer-aided conceptual design system to assist modelling in the early phases of design.Our system enhances shape grammars with layers and logic predicates.Layers improve time performance and structuring of shape grammars, and predicates control the application of shape grammars.We have applied these new techniques to examples taken from the architectural and video games domains.

@&#KEYPHRASES@&#
Computational design,Computer-aided conceptual design,Shape grammars,Architecture,Video games,

@&#ABSTRACT@&#
In this article we propose a computer-aided conceptual design system to assist modelling at the early stages of design. More precisely, we address the problem of providing the designer with design alternatives that can be used as starting points of the design process. To guide the generation of such alternatives according to a given set of design requirements, the designer can express both visual knowledge in the form of basic geometric transformation rules, and also logic constraints that guide the modelling process. Our approach is based on the formalism of shape grammars, and supplements the basic algorithms with procedures that integrate logic design constraints and goals. Additionally, we introduce a layered scheme for shape grammars that can greatly reduce the computational cost of shape generation. Shape grammars, constraints, goals and layers can be handled through a graphic environment. We illustrate the functionalities of ShaDe through two use cases taken from the architectural design and video games domains, and also evaluate the performance of the system.

@&#INTRODUCTION@&#
Computer-aided design tools traditionally help designers in many tasks, such as description, documentation and visualization of their projects. However, these tools can also play a more active role in creative aspects of the design process. Some approaches automatically produce highly polished visualizations of designs to be used in movies, video games or computer graphics applications  [1–3]. Others offer support in the early, conceptual stages of design, when the involved shapes and ideas are still malleable. These last assistants are usually called computer-aided conceptual design (CACD) tools  [4–6]. Assistant systems that evaluate, propose and allow exploration of different conceptual design alternatives can be of great help in the early stages of the design process  [7–9].A number of CACD tools have been developed to date. They share the need for some kind of expert knowledge specification, in the form of design requirements and performance criteria, that can be used to evaluate solutions or to guide generation/exploration processes. Approaches range from visual methods, like shape grammars  [10], to more explicit techniques such as semantic models  [11] or object-oriented relations  [12].In this paper we present two main contributions. In the first place, we propose a CACD system to help in modelling at the early stages of design. The system provides the designer with design alternatives that aid to overcome the blank page syndrome. This condition appears when facing a new design project and the absence of starting points entails a lack of inspiration. The alternatives provided can be used as starting points to be further completed and polished by the human designer. To guide the generation of such alternatives according to a given set of design requirements, the designer can express both visual knowledge in the form of basic geometric transformation rules, and also by logic requirements. This combination takes advantage of the fact that some requirements are better described using logic predicates (in the form of constraints or goals) that are evaluated during the generation process, in the form or constraints or goals. As far as we know, this combined specification procedure is a novel approach to CACD. Our approach is based on the formalism of shape grammars, supplementing the basic algorithms with procedures that integrate logic predicates.In the second place, we propose to decompose shape grammars into layers. This reduces the computational cost of algorithms for grammar interpretation, and can greatly speed up grammar execution. Moreover, layers can be used to better organize the process, arranging design elements in groups that can be later visualized separately.These formalisms and algorithms to represent and process rules, constraints, goals and layers, have been implemented and integrated in ShaDe, a new CACD tool built on the commercial CAD software SketchUp. ShaDe provides a general editor and interpreter of 2D shape rules, logic predicates (constraints and goals), and layers. Rules are expressed in 2D, but height information can be associated to each layer, allowing to visualize the final drawings in three dimensions. We illustrate the modelling process with ShaDe through an example taken from the architectural field.The rest of the paper is structured as follows: in Section  2 we provide the necessary background on shape grammars and discuss briefly some related prior work on CACD tools; then, in Section  3 we present the new concepts and algorithms that allow the representation and handling of layers and constraints in a grammar. In Section  4 we describe ShaDe, the software tool that we have developed based on the aforementioned ideas. To illustrate the capabilities of the method and the tool, in Sections  5 and 6 we develop two examples in the field of architectural design and the area of strategy/simulation video games. Section  7 presents a quantitative evaluation. Finally, in Section  8 some conclusions are drawn and future continuations of this research are outlined.A shape grammar is a production system in which shapes are generated by means of replacement rules. The concepts of shape rule and shape grammar were introduced by Stiny and Gips  [10]. In this section we gather some necessary definitions  [13], and explain the role that shape grammars have played in computational design over the last decades.A shape grammar is a 4-tuple〈S,L,R,I〉where:•Sis a finite set of shapesLis a finite set of symbolsRis a finite set of rulesα→β, whereαis a non-empty labelled shape andβis a labelled shapeIis a non-empty labelled shape, called initial shape or axiom.A shape is defined by a finite set of distinct lines that cannot be combined to form another line, that is, they are maximal. The representation of a shape is thus unique. A labelled shape consists of two parts: a shape and a set of labelled points. A labelled point(p,A)is a pointpwith a symbolA. A labelled shapeσis an ordered pairσ=〈s,P〉wheresis a shape andPis a finite set of labelled points. A segment or linel,l={p1,p2}is defined by any pair of distinct pointsp1andp2, the so-called end points of the line.A ruleα→βapplies to a shapeγwhen there is a transformationτsuch thatτ(α)is a sub-shape ofγ, that is,τ(α)≤γ(a labelled shapes1is sub-shape of another labelled shapes2if and only if every line and every labelled point ofs1is ins2).τcan be any general geometric transformation. In particular, we will use translations, rotations and regular scales. The sub-shape recognition process needs at least three distinguished points (that can be labels or intersections between segments) in the left side of every rule, as well as in the current design, in order to properly determineτ.The labelled shape produced by the application of a ruleα→βto a labelled shapeγunder transformationτis given by the expressionγ−τ(α)+τ(β). This labelled shape is obtained by substituting the appearance ofτ(α)insideγwithτ(β). In Fig. 1we can see a rule and one derivation, that is, a sequence of shapes generated by successive applications of the rule.Shape grammars have been used for numerous recreation and generation tasks related to decorative arts, paintings, architectural plans and engineering design  [14]. This wide usage relies on the power of shape grammars to capture and recreate heterogeneous design styles. Indeed, many authors have pointed out the advantages of shape grammars as a visual design framework. For example, Stiny showed that they have the potential of producing any possible shape  [15]. They are also a compact method because few rules can yield such complex and unexpected shapes  [16]. More specifically, from the point of view of generative CAD tools, it has been noticed  [17] that grammar-based systems can easily automate design and thus allow a great deal of exploration. Shape grammars have been suggested as a geometric design framework due to some desirable properties  [18], such as their parametric (instead of symbolic) nature and their maximal unique shape representation.In this section we provide an overview of several CACD tools. Some of these tools have provided support from an evaluative perspective. Kraft and Nagl  [8] developed prototype software providing a visual knowledge specification language for conceptual design. Graph-based domain ontologies define concepts and relations between them, as well as design rules. The designer can use the concepts and relations of this ontology in order to manually instantiate sketches of conceptual buildings (in the context of this work, a sketch is not a shape, but a graph of semantic objects that formalizes the different features of the design idea). The created sketch can be checked against the rule base specified inside the ontology. Pauwels et al. use Semantic Web technologies in order to formalize rules about building performance  [11]. The process of defining a design concept would be similar to the one in the work of Kraft and Nagl, using semantic web technologies instead of graph-based techniques. In both works, design concepts are not geometric objects, but explicit, symbolic descriptions about their features. Grabska et al.  [19] have developed prototype software to support architectural conceptual design that extracts symbolic information from graphical sketches drawn by the designer. It provides a form of visual requirement specification by means of arrows that relate rooms of different floors. The extracted symbolic information can be used to define logic rules that will check the validity of the sketches drawn by the designer.Other CACD tools have focused on generation capabilities. A considerable part of the corpus of generative CACD tools are shape grammar interpreters. Chau et al.  [14] compared 21 implementations up to 2004. More recently, McKay et al.  [9] gathered some of the most relevant interpreters up to 2011. In this last review, the systems are evaluated according to a set of requirements for shape grammar implementations derived from the works of Gips  [20] and Chau et al.  [14]. Most of the evaluated tools are generic in the sense that they are not aimed at a particular field of design, and provide graphic means to deal with shape rules. To the best of our knowledge, the most recent contributions in this area are the works of Li et al.  [21], Hoisl and Shea  [22] and Trescak et al.  [23]. The first one provides means to create, edit and visualize shapes and rules in AutoCAD. The one of Hoisl and Shea focuses on facilitating user interaction, providing interactive and visual means to deal with parametric rules. The second also aims to provide a friendly interface, as well as to improve the traditional algorithm for recognizing subshapes.There exist some generative approaches that rely on different techniques. For example, SEED  [12] is an object-oriented generative tool for the initial phases of architectural design that represents design requirements symbolically by means of specification units, which are objects that represent some part of a building (for example, the dining room inside a house). With the help of these objects, the user can establish different relationships among the elements to make up the input for a layout problem   [24], that will generate a valid solution. Shea et al. proposed efiForm, a tool based on the so-called shape annealing optimization method  [7]. The optimization system is integrated into a CAD tool by means of XML models. Designs are represented both in XML and natively in the CAD and optimization systems. Another generative approach is the one of Mora et al.  [25], who developed a CAD tool for the early phases of architectural design. They also use an object-oriented model to specify entities and relations among them. A set of ad-hoc algorithms are used to generate the geometry of every element represented by the entities, taking into account the established design conditions. Krish proposed a generic, generative tool for conceptual design  [26] based on evolutionary algorithms that make an initial population of shapes evolve to better solutions. Recently, Ruiz-Montiel et al. have developed a system based on shape grammars and machine learning techniques, that learns how to apply rules to generate a great variety of schematic architectural designs based on a housing program  [27–29]. In particular, policies obtained by reinforcement learning can be used to choose the best rule and transformation to be applied at every step of a grammar derivation in order to generate feasible designs.Other generative approaches, not related to CACD, automatically produce highly polished visualizations of designs to be used in movies, video games or computer graphics applications. For example, Müller et al.  [1] use shape grammars to create building mass models. Merrell et al.  [2] use simulated annealing to produce floor plans according to a housing program automatically inferred by training a Bayesian network with numerous plan examples. Then they use ad-hoc algorithms to automatically generate 3D models from the produced plans. Yu et al.  [3] also use simulated annealing to determine the furniture arrangement of a room according to a set of relationships extracted from positive examples. Our work is related to some of these approaches, however it focuses on supporting the early stages of design. In particular, our approach to CACD focuses on automatically offering numerous, feasible starting points to be refined by the human designer. To guide the generation process, our tool provides the designer with different means to specify design requirements. These techniques are detailed in the next section.Layers are a common structuring device in practical CAD tools. From a theoretical point of view, experts acknowledge the need of using partial descriptions of a design. Partial descriptions of designs have to be superimposed in order to make up the whole picture. A design is composed of several partial descriptions that have no meaning in themselves, that is, they are fragments of the design. They have to interact and overlap in order to form the whole meaning. Kotsopoulos, starting from the theoretical background of product shape algebras   [30], introduced this notion as a thinking-graphic device when working with shape grammars  [31]. Stiny also introduced the concept of multiple tuples (or channels, as Yue and Krishnamurti explain in a recent work  [32]) in shape grammars as a technique to deal with the difficulty of distinguishing segments embedded in the maximal lines  [15].We have exploited this concept in order to lighten the complexity of the algorithms involved in shape grammar interpretation; more concretely, we might have several simple shapes separated in distinct layers instead of a complex one inside a single layer, thus decreasing the time requirements of the sub-shape recognition algorithm.Formally, we define a layered shape grammar as a 5-tuple〈S,L,R,I,La〉where:•Sis a finite set of shapesLis a finite set of symbolsRis a finite set of rulesα→β, whereαis a non-empty layered shape andβis a layered shapeIis a non-empty layered shape, called initial shape or axiomLais a finite set ofnlayer names,(La0,La1,…,La(n−1)).A layered shape is a set ofnlabelled shapes(σLa0,σLa1,…,σLa(n−1)). That is, there is a labelled shape defined for each layer. In Fig. 2we can see an example of a layered shape (the bottom-left cross represents the origin of coordinates).A rule applies to a layered shapeγwhen there is a transformationτsuch thatτ(αLai)is a sub-shape ofγLai, that is,τ(αLai)≤γLai, for every layerLai. Note that the applied transformationτmust be the same in every layer. The rest of the arithmetic for labelled shapes is naturally extended to layered labelled shapes in a similar way, applying the operators in parallel to the shapes of every layer.In Fig. 3we can see a layered shape grammar with the content of each layer shown separately. The grammar is composed of three rules that are divided into three layers.While defining and understanding a layered shape rule is apparently more complicated than in the case of a standard shape rule, this shortcoming can be circumvented by integrating the layered shape grammar interpreter into a CAD tool with layer facilities. These kind of tools usually allow viewing different layers separately, as well as any combination of them at once. As explained in Section  4, we have built our interpreter on a commercial tool that offers such layer capabilities.Shape grammar interpreters spend most of their time solving the so-called subshape detection problem: given two shapesαandγ, find all transformationstsuch thatt(α)≤γ. A reference algorithm for this problem was proposed by Krishnamurti  [33]. We have extended this algorithm to the layered case.Let us start describing the original algorithm. It works with a fixed set of three points inα. This set, calledDPα, is mapped to every plausible combination of three points (a so-called triplet) insideγ, and if both sets form similar triangles, then the six points are used to calculate a transformationt. Ift(α)≤γ, thentis added to the solution set. The setDPαmust be carefully chosen, because the number of triplets insideγdepends on the type of points involved inDPα. For example, consider the shapesαandγin Fig. 4(a) and (b), respectively (in this work, labels are represented by means of circles). In 4(b) we can find 22 intersection points and 4 white labels. If the setDPαis composed of three intersection points (namely, three corners of the square in Fig. 4(a)), then the number of triplets inγis 22×21×20. On the other hand, ifDPαis composed of two intersection points (two corners) and the white label, then the number reduces to 22×21×4, so the most efficientDPαis the second one.If we have a shapeγwithnlayers(La0,La1,…,La(n−1)), our algorithm computes all theDPsforαLai,0≤i≤(n−1). We can compute the number of triplets for every three-point set, and run the original algorithm only in the layer that requires less combinations; as the subshape relation must hold in every layer simultaneously, we can stick to one layer in order to compute all the possible transformations. Table 1shows the pseudo code for this algorithm. The method getTransformations (α,β,DP) in our algorithm performs the original Krishnamurti’s algorithm  [33] for subshape detection. The inputs for this original algorithm are shapes with presumably less points and segments than the complete shape resulting from the union of every layer, making the computation faster. Section  7 provides a more detailed evaluation of performance.Shape Grammars with Constraints and Goals consider logic predicates during their execution in order to produce designs according to a set of design requirements. Logic predicates are Boolean-valued functions. They return true or false depending on whether the statement they represent is satisfied or not. We consider two kinds of logic predicates:1.Constraints: predicates that must be satisfied at every step of any rule derivation.Goals: predicates that must be satisfied at the end of any rule derivation. They control termination. The design is considered satisfactory as soon as goals are attained. In such case, the derivation sequence can terminate.The space of all shapes that can be generated through the repeated application of rules to an initial shape has a tree-shaped structure, with shapes at its nodes, and as many branches from each node as possible pairs (rule, transformation) are applicable to the corresponding shape (see Fig. 5). The process of generating a shape that complies with a given set of predicates can thus be formulated as a depth-first search over this tree. There are two kinds of nodes:•Goal nodes: nodes representing a shape that fulfils all the goals, without violating any constraint.Terminal nodes: nodes representing a shape that either does not allow more rule applications (due to its geometry) or violates some of the current constraints.Table 2shows the pseudo code for a recursive algorithm that performs depth-first search. The search starts at the root node of the tree, checking if it is already a goal node (with the method isGoalNode) or a terminal one (with the method isTerminalNode). Otherwise it will explore the tree, exploring as deep as possible along each branch before backtracking, until it finds a goal node. In case that no goal nodes are found, the algorithm will return failure. The method getChildren computes all the possible shapes that can be obtained from a given shapes, applying the rules of the shape grammar. The method takeChild takes a node of a given list and removes it from the collection. If the result of the recursive call is a shape, then the algorithm has found a solution. Otherwise, the result is failure and there does not exist any solution in that branch.Note that constraints prune the search tree, effectively reducing the space that needs to be explored.Let us illustrate the use of logic predicates with a simple example over the tree sketched in Fig. 5. Suppose that we need to produce shapes with the rule in Fig. 1(a) satisfying two design requirements:1.The shape must not contain segments larger than one metre.The shape must contain at least ten squares.The user/designer has to formalize each requirement as a constraint or goal. Let us formalize the first one as a constraint and the second one as a goal. With these premises, a possible path the algorithm may follow through the tree is depicted in Fig. 6. In the first level, the axiom (which is a square with one metre side) does not violate the constraints but does not meet the goal, so the algorithm goes deeper. The same happens in the second level. In the third level, the algorithm now finds two nodes with shapes that violate the constraint, and are marked as terminal. The third shape in this level does not violate the constraints but still does not attain the goal, so the algorithm explores this node, finding a solution in the fourth level.As we have seen in this example, some requirements are specified in terms of exact metric (it is the case of the constraint, stating that the shape must not contain segments larger than one metre). Although shape grammars involve dimensionless rules in the sense that the size of the pattern to be found (that is, the left part of the rule) does not matter, these rules apply to real shapes that can in fact have dimensions, as is the case of the axiom in the previous example. Since the requirements always refer to measurable shapes, there is no conflict in establishing predicates involving exact metric.Constraints need to be defined with care. When a constraint is violated, the depth-first search algorithm prunes all the paths that could be followed from the offending node. If there were a valid solution inside some of those paths, the algorithm would never reach it. This could happen, for example, in the example depicted in Fig. 6, if the grammar had an additional rule that removed squares. As a general guideline, a predicate can be formulated as a constraint when we are sure that once it is violated, there is no possible derivation that will satisfy it again. Otherwise, it is better to define the predicate as a goal. For example, if the grammar contains rules that remove shapes, we cannot ensure this property.ShaDe11ShaDe can be downloaded from http://www.lcc.uma.es/~perez/ntidapa/.is a generative CACD tool that relies on layered constrained shape grammars in order to propose design solutions: it handles layered shapes that are intended to represent a design that meets a set of logic constraints and goals.In this section we focus in the architecture of ShaDe and some relevant aspects of its interface. A more detailed description can be found in the user’s guide and technical Refs.  [34,35].ShaDe is built on Trimble SketchUp, a popular, freely-available 3D modelling software that can be extended with Ruby  [36] plugins. ShaDe has been implemented as one of these plugins.22For efficiency reasons, the shape grammar algorithms are not executed within the Ruby interpreter that comes along with SketchUp, but by an external Ruby command.This approach presents several advantages:1.Providing a generative CACD tool integrated with a commercial CAD tool can help to overcome the alleged confinement of design generative software to the academic world  [37].Hoisl and Shea  [22] note that design practitioners tend to think visually. ShaDe incorporates the sophisticated tool set of Sketchup in the graphic interface of its grammar interpreter, avoiding the need to explicitly program shape rules.Dynamically supported Ruby scripts provide support for the logic predicates used to control shape grammar application.In Fig. 7we can see the architecture of ShaDe. There are four ShaDe-specific modules: (1) Layered Shape Grammar Interpreter module, (2) Design Generation Module, (3) ShaDe Interface and (4) Predicate Generation Module. These are covered in the next sections.The Layered Shape Grammar Interpreter (LSGI) module relies on our layered subshape detection algorithm, as well as in the arithmetic algorithms developed by Krishnamurti  [38], in order to implement the application of shape grammars. As the SketchUp representation of shapes is not maximal in general, ShaDe implements a translation method that receives the SketchUp entities that constitute a shape and returns the maximal representation for the same shape. This method is invoked every time a new shape is created or edited inside the graphical interface. When a layered shape needs to be painted, the LSGI module communicates with the Ruby API in order to create the corresponding SketchUp geometric entities.Layered shape grammars are implemented by means of the entities that SketchUp provides for dealing with layers. We use the so-called Layer entity of SketchUp in order to organize the maximal representation of the shapes; for each layer we keep the structures that store the maximal representation of the corresponding shapes.The Design Generation (DG) module takes into account the design requirements (specified as logic predicates) in order to propose solutions. The solution space to explore, configured as a tree-like structure (see Section  3.2), is generated thanks to the LSGI module.The logic predicates that control the depth-first search described in Section  3.2 are implemented as Ruby scripts that are invoked every time a node is checked. Users can (de)activate both constraints and/or goals at any moment.ShaDe allows the association of a shape grammar with a set of logic predicates. This is done by means of the project entity. Projects can be executed in two different modes: (1) applying a number of rules and (2) applying rules until the design goals are fulfilled. When (1) is chosen as execution mode, the goals of the project are not taken into account, applying a maximum depth search limit.Design scripts can be used to establish sequences of projects. Each project in a script is executed from the shape produced by the previous project. The first project starts from an axiom, i.e., a shape provided by the user. Scripts allow to specify different phases in the generation of a design, as we will illustrate in Sections  5 and 6.The DG module can also use functions of the SketchUp Ruby API in order to implement the behaviour of constraints and goals.The Interface of ShaDe relies partly on the already provided canvas and basic drawing/layer tools of SkethUp. It adds several specific toolbars that gather different commands that deal with ShaDe entities.In Fig. 8we can see a screenshot of the graphical interface of ShaDe. In the following, we describe the user interaction with ShaDe.1.Rule Canvas. Rules appear at the left side of the canvas. All drawing tools can be used to create and edit all rule shapes with a pointing device.Design Canvas. The current shape (or the axiom, when no rules have been applied) appears at the right side of the canvas.Basic SketchUp Toolbar. This toolbar gathers some basic SketchUp commands that can be used to edit shapes and also to change the canvas view (zoom in/out, rotate, etc.).Edition Toolbar. Provides specific commands in order to perform shape grammar editing tasks like adding or removing rules, managing shapes and labels, and also visualizing the design in three dimensions.File Toolbar. This toolbar provides commands that save/load several ShaDe entities (shapes, grammars, projects or scripts).Execution Toolbar. These commands allow the user to execute the shape grammar with some of the following protocols: (a) applying certain rule once, (b) applying random rules a number of times, (c) applying random rules until goals are met, (d) executing a design script.Predicates Toolbar. Provides commands for managing constraints and goals (mainly activate/deactivate them, defining new predicates and checking if goals are met).Layers Window. Allows layer management (choosing the current layer, which layers are displayed, etc.).The Ruby scripts for some logic predicates that we consider of common use are predefined in ShaDe. They are gathered in Table 3. The user can activate these at any time, so that they are taken into account in rule application.However, in many cases the user will probably need additional logic predicates. For this reason, ShaDe offers the possibility of defining personalized constraints and goals. This can be done in two ways:1.Graphically, thanks to a predicate generation module that asks for information about the logic predicate.Directly coding the logic predicate in Ruby, inside a built-in code editor.When the graphic option is chosen, the Predicate Generation (PG) module gathers information about the predicate by means of a set of graphic dialogues, and then automatically generates the corresponding Ruby code. We have tried to develop a general and user-friendly graphic interface, covering a wide range of possibilities by means of dialogues and forms that the designer has to fill in. Basically, the predicates can refer to five different entities:1.Rule IDs. Example: the applied rule is the one with ID 3; or the first applied rule is the one with ID 1.Applied transformations. Example: the applied scale factor is bigger than 2.Segments of the generated shape. Example: the shape must not contain segments larger than one metre.Points of the generated shape. Example: there are more blue labels than yellow ones inside the shape, or there are at least two yellow labels at a distanceof 3.6 m of a blue label.The whole generated shape. Example: the shape is inside a contour, or the shape is a sub-shape of another given one.In Figs. 9 and 10we can see some graphic dialogues for configuring predicates related to the applied transformations and the labels of the generated shape, respectively.In this section we describe a design script used to generate housing unit schemes. This design script is based on some ideas of Rafael Leoz, a Spanish architect whose most productive period fell between 1950 and 1970.The goal of this example is to focus on the conceptual design facet of ShaDe. More precisely, we show that our system can be used to generate many varied solutions that, although low-detailed, meet an essential set of design requirements and thus can be used as starting points for complete design projects. In addition, we describe in detail all the shape grammars, constraints and goals used in the example. A video displaying the most relevant steps of this example is available on the Web.33http://youtu.be/1SwkKOinJ8A.One of the main motivations behind Leoz’s work was the improvement of social housing. Leoz studied how to build affordable houses by means of mass production. The basic idea is to start from a small number of simple shapes that can be easily mass-produced, and aggregate them in order to obtain a vast number of more complex shapes. The most important contribution in this sense is the so-called Hele module or just Leoz module   [39]. Leoz chose this shape because it offers many harmonic combination possibilities, since it does not have symmetries and its perimeter is configured according to the Fibonacci numbers (see Fig. 11).We have used pairs of Hele modules in order to produce samples of single-family housing units. Each Hele module is made up of four cells of 3.60×3.60 m. Two modules can be combined in many different ways. We can see some examples of such combinations in Fig. 12.Leoz usually employed a set of predefined rooms in order to easily configure the interior space of the houses  [40]. Since we are using two Hele modules for each housing unit, we have eight cells available to be filled with a set of rooms. The chosen set of rooms, inspired by those used by Leoz in several projects  [40], is depicted in Fig. 13, with six single-cell rooms and a double one.We developed a design script in Shade to produce several distinct 2D housing units schemes, using pairs of Hele modules and the set of predefined rooms depicted in Fig. 13.Leoz usually worked with grids that divided the plane in a regular manner. From these grids, he extracted simple shapes that were further aggregated in order to produce more complex shapes  [40]. The Hele module comes from a rectangular grid. This grid can be used as axiom for our first production step. The subshape recognition algorithm used by the shape grammar interpreter will recognize the Hele modules inside this grid. We can now establish the layers that will reduce the computational cost of grammar execution. They will also help us to represent designs in three dimensions and to visualize different aspects of the design separately:1.The underlying grid.The Hele modules yielded by the grid.The walls of the rooms.Elements with table-height.Elements with seat-height.Elements with wardrobe-height.Fig. 15 depicts the layers with the help of an example. All the shapes and rules of the grammars need to be defined for the six layers.The Leoz design script comprises three design projects, each one with its own shape grammar, constraints and goals (see Table 4). In the following we describe the aim of each project:•Project 1: First Hele module. The first production step is to add the first Hele module from the axiom (see Fig. 14).Fig. 16displays the single rule for this project. Labels are black in the grid layer, blue in the modules layer and white in the rooms layer. Neither constraints nor goals are needed.Project 2: Second Hele module. Starting from the shape produced by Project 1, Project 2 adds the second Hele module. In Fig. 17we can see the single rule for this project. Labels are black in the grid layer, yellow in the modules layer and white in the rooms layer. A constraint is needed to ensure that both modules are in contact. We have established that two labels of the second Hele module (coloured in yellow) must be at a distance of 3.6 m of a label from the first Hele module (coloured in blue). In Fig. 12 we can see a small set of Hele module combinations. Thanks to the emergence properties of shape grammars, ShaDe is able to automatically generate all the combinations of two Hele modules.Project 3: Rooms. This project adds different predefined rooms that are depicted in Fig. 13 (the pieces of furniture are schematic), starting from the shape produced by Project 2. It has seven rules, one for each kind of room (Fig. 18). Before the application of these rules, labels are white in the rooms layer. When rules are applied, their colours change depending on the room that is added. We need four constraints and one goal for the execution of this project:–Constraint 1: The transformations involved in subshape recognition must not involve scaling, that is, the rooms are to be added in their original size. This constraint comes predefined with ShaDe (see Table 3).Constraint 2: The first rule applied must be the one of the service cell, since it is the one that needs more space.Constraint 3: The rules are applied in order, to make sure that every room is present.Constraint 4: The dining room must be placed near the service room; these two rooms cannot be separated by more than 5 m. This constraint can be configured using the coloured labels that the rules add to the rooms layer.Goal: All the rules of the grammar have been applied. This goal comes predefined in ShaDe (see Table 3).

@&#CONCLUSIONS@&#
