@&#MAIN-TITLE@&#
New results for the Directed Profitable Rural Postman Problem

@&#HIGHLIGHTS@&#
We introduce new valid inequalities for the Directed Profitable Rural Postman Problem.We test a branch and cut algorithm that adds connectivity constraints in a lazy way.We propose efficient and effective heuristic algorithms outperforming known methods.We find optimal solutions for all benchmark instances not solved to optimality yet.

@&#KEYPHRASES@&#
Routing,Directed Profitable Rural Postman Problem,Arc routing with profits,Matheuristics,

@&#ABSTRACT@&#
We study a generalization of the Directed Rural Postman Problem where not all arcs requiring a service have to be visited provided that a penalty cost is paid if a service arc is not crossed. The problem, known as Directed Profitable Rural Postman Problem, looks for a tour visiting the selected set of service arcs while minimizing both traveling and penalty costs. We add different valid inequalities to a known mathematical formulation of the problem and develop a branch-and-cut algorithm that introduces connectivity constraints both in a “lazy” and in a standard way. We also propose a matheuristic followed by an improvement heuristic (final refinement). The matheuristic exploits information provided by a problem relaxation to select promising service arcs used to solve optimally Directed Rural Postman problems. The ex-post refinement tries to improve the solution provided by the matheuristic using a branch-and-cut algorithm. The method gets a quick convergence through the introduction of connectivity cuts that are not guaranteed to be valid inequalities, and thus may exclude integer feasible solutions.All proposed methods have been tested on benchmark instances found in literature and compared to state of the art algorithms. Results show that heuristic methods are extremely effective outperforming existing algorithms. Moreover, our exact method is able to close, in less than one hour, all the 22 benchmark instances that have not been solved to optimality yet.

@&#INTRODUCTION@&#
LetG(V,A)be a directed graph, whereV={0,…,n}is the node set (node 0 represents the depot), andA={(i,j)|i≠j,i,j∈V}is the arc set. LetR⊆Abe a subset of arcs requiring a service (service arcs). A penaltypijis assigned to each arc(i,j)∈Rand a traveling costcijis associated with each arc(i,j)∈A. The penalty represents the cost that has to be paid if the corresponding service arc is not selected. The problem looks for a tour starting and ending at the depot so that total traveling and penalty costs are minimized. Since the objective of minimizing traveling and penalty costs can be reformulated as maximizing the difference between the profit gained by serving required arcs and the traveling costs, the problem is called Directed Profitable Rural Postman Problem (DPRPP). Moreover, the problem is NP-hard generalizing the well-known Directed Rural Postman Problem (DRPP) where all service arcs have to be visited in the tour (see Eiselt, Gendreau, & Laporte (1995) and Dror (2000)).The problem belongs to the class of arc routing problems with profits. Whereas vast literature exists for node routing problems with profits (see Feillet, Dejax, & Gendreau (1981) and Vansteenwegen, Souffriau, & Van Oudheusden (2011)), there are still very few contributions which can be found on their arc routing counterpart (see Corberán & Prins (2010) for a very recent annotated bibliography). As far as we know, Malandraki and Daskin (1993) are the first authors to consider arc profits by introducing a directed version of the prize-collecting arc routing problem. In their problem a prize can be collected from each arc multiple times, and the size of the prize decreases with the number of collections. Feillet, Dejax, and Gendreau (2005) introduce the Profitable Arc Tour Problem (PATP). The objective function of the PATP maximizes the profit located on arcs minus the travel costs using a fleet of unlimited vehicles with no capacity constraint, but an upper bound on the length of each tour. No depot is considered and the profit is available on arcs for a limited number of times. More recently, Aráoz, Fernández, and Zoltan (2006) introduce the Privatized Rural Postman Problem (PRPP). The PRPP looks for a tour starting and ending at the depot while maximizing the difference between the profits gained by serving required edges and the crossing costs. The PRPP can be seen as the undirected version of the DPRPP. The authors study problem polyhedral properties identifying some dominance relations. Later on, Aráoz, Fernández, and Meza (2009) rename the problem Prize-collecting Rural Postman Problem. The authors identify upper bounds by solving iteratively relaxed models with a small number of inequalities and adding violated cuts through exact separation procedures. They also provide lower bounds for the problem generating feasible solutions using the 3T heuristic by Fernández, Meza, Garfinkel, and Ortega (2003). Their problem formulation uses two sets of binary variables indicating when edges are served and when only crossed, respectively. They show that the number of times an edge can be crossed in an optimal solution is never higher than 2, thus generalizing a known result for the Rural Postman Problem (RPP) (see Christofides, Campos, Coberán, & Mota (1981)).Since the work by Aráoz et al. (2006), many other authors have studied different variants of the prize-collecting RPP. Examples are the clustered prize-collecting ARP by Aráoz, Fernández, and Franquesa (2009), and the windy clustered prize-collecting ARP by Corberán, Fernández, Franquesa, and Sanchis (2011). More recently, Black, Eglese, and Wøhlk (2013) study the time-dependent prize-collecting Arc Routing Problem (TD-PARP) inspired to the PRPP but with the addition of real constraints. The graph is directed and traversing costs depend on the time they are crossed. Moreover, the problem allows for more requests between the same two nodes. Finally, in the literature there are problems where profits are placed on nodes and arcs. This is the case of the one-period Bus Touring Problem (BTP) introduced by Deitch and Ladany (2000). In the BTP the profits are non-negative attractiveness values and the objective is to maximize the total attractiveness of the tour by selecting a subset of nodes (sites) to be visited and arcs (scenic routes) to be traveled subject to constraints on touring time, cost and total distance.The problem studied in this paper originates in the domain of the transportation service procurement where companies need to decide which customers to serve directly and which to assign to external operators paying an outsourcing cost. In Guastaroba, Mansini, and Speranza (2009) the problem, introduced under the name of Shipper’s Lane Selection Problem (SLSP), considers a shipper that has to decide which lanes (service arcs) to pick out for a direct service with its own vehicle, and which to assign conveniently to external carriers paying an outsourcing cost (the penalty). Since lanes outsourcing is made through an auction, the problem objective is the minimization of the sum of traveling costs and outsourcing costs plus the fixed cost of the auction set-up. The authors provide a mathematical formulation using binary instead of integer variables, thus allowing a single crossing for each arc. Other works can be found in this application area almost all referring to node instead of arc routing problems. See for instance Chu (2005) who first analyzes the problem of deciding how many private vehicles to employ in truckload mode (and then defining their routing) and how many external carriers to use in less than truckload mode when the customer demand is more than the available vehicle capacity. A slightly different problem formulation is also analyzed by Côté and Potvin (2009) who propose a Tabu Search algorithm to solve it. More recently, the SLSP has been reformulated by Archetti, Guastaroba, and Speranza (2012) who call it Directed Profitable Rural Postman Problem and introduce an effective Tabu Search algorithm with the addition of an ex-post ILP-refinement. They also provide a set of benchmark instances for the problem many of which have not been solved to optimality up to now.This paper provides different contributions. We introduce a tighter problem formulation than the one proposed in Archetti et al. (2012) adding different valid inequalities and use it to develop a branch-and-cut algorithm. We implement the proposed exact method separating the connectivity constraints both using the standard separation based on the solution of max-flow problems at each node of the search tree and excluding subtours only when integer solutions are found (lazy separation). The combination of the new problem formulation with the lazy separation of the connectivity constraints results to be the best performing approach allowing to close all the 22 instances not solved to optimality by Archetti et al. (2012) in less than one hour of computing time. To guarantee a fair comparison with the literature we test our algorithms on a comparable PC than the one exploited in Archetti et al. (2012), and use the same version of MIP solver (CPLEX 10.1) the authors used in the paper. Note that in this CPLEX version no subroutine for lazy constraints is available.The mathematical formulation of the problem has also been used to construct an effective matheuristic and a final improvement method. Matheuristics are hybrid methods that combine heuristics and mathematical programming approaches providing a very promising alternative to meta-heuristics in solving hard combinatorial problems (we refer interested readers to Maniezzo, Stützle, & Voss (2009)). Our matheuristic exploits information provided by a problem relaxation to identify subsets of “promising” service arcs used to solve to optimality Directed Rural Postman problems. Each DRPP is formulated on a restricted graph induced by the selected service arcs (Auxiliary Problem). The matheuristic consists of two main routines, one considering subsets of service arcs of increasing size and the other one of decreasing size. Finally, the improvement heuristic (final refinement) receives as input the best integer solution provided by the matheuristic and tries to improve it exploiting the branch-and-cut framework of a common MILP solver by inserting connectivity cuts that may not be valid inequalities and thus may eliminate feasible solutions. When an integer solution is found, the method looks for larger subtours and eliminates them forcing at least one arc to leave each of them, whereas this may not be the case in an optimal solution. On the contrary, small subtours are excluded through the insertion of standard violated inequalities as in an exact method. A defined parameter establishes when a subtour is considered large. Choosing this parameter, the method looks for the best trade-off between a quick convergence obtained through a massive introduction of connectivity cuts not guaranteed to be valid inequalities (large subtours) and a more substantial selection of violated cuts as in an exact method. In the first case, a higher efficiency is paid in terms of a lower performance, while in the second one better solution values can be obtained at the cost of a larger computing time.The paper is organized as follows. In Section 2 the mathematical formulation of the problem, different valid inequalities and some simple properties are discussed. We also describe the mathematical formulation of the Auxiliary Problem used to solve optimally the DRPP when the subset of service arcs to be visited is given. Section 3 is devoted to solution algorithms description, whereas in Section 4 we test both our exact algorithm and the heuristic approaches on benchmark instances introduced in Archetti et al. (2012) and compare their performance with state of the art algorithms. In Section 5 some conclusions and future developments are drawn.We start by describing the integer linear programming formulation for the DPRPP. The model usesO(|A|)integer variables x to indicate the number of times each arc is crossed andO(|A|)binary variables y to select arcs to serve. Finally,O(|V|)binary variables z are used to formulate connectivity constraints:xij⩾0numberoftimesarc(i,j)iscrossed(i,j)∈A,yij≔1ifarc(i,j)isserved0otherwise;(i,j)∈R,zj≔1ifnodejisvisited0otherwise.j∈V⧹{0}.The problem can be formulated as follows:(1)(DPRPP)min∑(i,j)∈Acijxij+∑(i,j)∈Rpij(1-yij)(2)s.t.:∑i∈V⧹{j}xij=∑i∈V⧹{j}xjij∈V(3)xij⩾yij(i,j)∈R(4)∑i∈V⧹{j}xij⩽(|R|+1)zjj∈V⧹{0}(5)∑i∉P∑j∈Pxij⩾∑j∈Pzj|P|P⊆V⧹{0},P≠∅(6)xij⩾0integer(i,j)∈A(7)yij∈{0,1}(i,j)∈R(8)zj∈{0,1}j∈V⧹{0}.The objective function (1) minimizes the sum of traveling costs and penalties paid. Constraints (2) are the so called in-degree and out-degree constraints and impose the equivalence between the number of arcs entering and leaving each nodej∈V. Constraints (3) imply that arc(i,j)∈Rcan be served (yij=1), if and only if it has been crossed (xij⩾1). Constraints (4) control the values ofzjvariables. If at least one arc is entering node j, then variablezjis forced to 1. Inequalities (5) are connectivity constraints and prevent the generation of isolated cycles. Finally, constraints (6)–(8) define integer and binary conditions. This formulation can be found in Archetti et al. (2012). Note that, as in classical profitable problems, the objective function (1) can be reformulated as the maximization of profits minus costs:max∑(i,j)∈Rpijyij-∑(i,j)∈Acijxij-∑(i,j)∈Rpij.LetR∗⊆Rbe the set of service arcs selected in an optimal solution of the DPRPP andxij∗the optimal value of variablexij,(i,j)∈A. The following proposition is trivially true:Proposition 1In an optimal solution of the DPRPP,xij∗⩽|R∗|if(i,j)∈Randxij∗⩽|R∗|+1otherwise.To understand this simple result one can look at Fig. 1A where a DPRPP instance with three service arcs(1,2),(2,3),(2,5)(drawn in bold lines) is shown. Assuming that penalties and costs are such that all service arcs are selected in an optimal solution, then variablex12will take value|R∗|=|R|=3. Fig. 1B shows the case in which arc(1,2)does not belong to R. In this case, variablex12will take value|R∗|+1, with|R∗|=2.Different valid inequalities can be added to the formulation (1)–(8). These inequalities help to strengthen the continuous relaxation of the problem, and the relaxation obtained by removing connectivity constraints (5) that we use in the solution algorithms. With respect to formulation (1)–(8) we also introduce a binary variablez0associated with the depot.We consider the following sets of valid inequalities:•The first set of inequalities provides a lower bound for the left-hand side of constraints (4). Each constraint forces at least one variablexijentering in node j to become positive whenzjis equal to one:(9)∑i∈V⧹{j}xij⩾zjj∈V.LetI={I0,…,Ik}be a partition of the nodes in V withI0={0}. EachIp∈I⧹I0consists of all nodes j not belonging to previous setsIs,s=0,…,p-1, so that there exists at least one arc(i,j)∈Aor one arc(j,i)∈A, withi∈Ipandj∈Ip+1(for example, Fig. 2shows the resulting partitionI={I0,I1,I2,I3}for an arbitrary graph, withI0={0},I1={1,4,5},I2={2,6},I3={3,7}). The following inequalities hold:(10)∑i∈Ipzi⩾zjj∈Ip+1,p=0,…,k-1,(11)∑i∈Ip,j∈Ip+1xij⩾zss∈Ip+1,p=0,…,k-1,(12)∑i∈Ip,j∈Ip+1xji⩾zss∈Ip+1,p=0,…,k-1,(13)∑i∈Ip,j∈Ip+1xij⩾yqs|{q,s}∩Ip+1|⩾1,(q,s)∈R,p=0,…,k-1,(14)∑i∈Ip,j∈Ip+1xji⩾yqs|{q,s}∩Ip+1|⩾1,(q,s)∈R,p=0,…,k-1.Constraints (10) impose that if a nodej∈Ip+1is visited, then at least one nodei∈Iphas to be visited as well. Constraints (11) and (12) reinforce the same concept of (10), imposing that at least one arc has to enter inIp+1fromIpand at least one arc has to leaveIp+1entering inIpif a nodes∈Ip+1is visited, respectively.Similarly to constraints (11) and (12), inequalities (13) and (14) impose that at least one arc has to enter inIp+1fromIpand at least one arc has to leaveIp+1entering inIpif a service arc(q,s)with at least one endpoint inIp+1is served.Constraints (10)–(14) can be easily generalized by considering any two subsetsIpandIqwithq=p+1,…,k. For instance, inequality (10) can be modified as follows:∑i∈Ipzi⩾zjj∈Iq,p=0,…,k-1,q=p+1,…,k.This set of constraints associates each variableyijwith the variableszh,h∈{i,j}corresponding to its endpoints:(15)yij⩽zh(i,j)∈R,h∈{i,j}.If service arc(i,j)is visited (i.e.yij=1), then both variablesziandzjare forced to 1.According to Proposition 1 and similarly to constraints (15), we can introduce the following upper bounds on variablesxij:(16)xij⩽(|R|+1)zh(i,j)∈A⧹R,h∈{i,j},(17)xij⩽|R|zh(i,j)∈R,h∈{i,j}.Note that all presented valid inequalities are polynomial in number. Moreover, it can be observed that inequalities (13) and (14) are implied by inequalities (11), (12) and (15).Let us consider the DPRPP relaxation obtained by excluding connectivity constraints (5) from formulation (1)–(8) and adding valid inequalities (9)–(12), (10)–(17). From now on, we will refer to such a relaxation as to problem RELAX. We indicate asRRELthe set of service arcs selected by the optimal solution of problem RELAX. We have already definedR∗⊆Ras the set of service arcs selected in an optimal solution of the DPRPP. The following proposition holds:Proposition 2In general,R∗is not included inRREL.Trivially, a service arc(i,j)withpij⩽cijmay not be selected in the optimal solution of problem RELAX. On the contrary, it may be part of the DPRPP optimal solution if it is the most convenient way to ensure connectivity among disconnected sets of service arcs.Nevertheless,RRELusually contains promising service arcs, that is, service arcs that would be likely visited in an optimal solution of the DPRPP. In the following section, we will describe a heuristic algorithm that selects different combinations of service arcs inRRELand then formulates and solves to optimality the resulting DRPP instance using the following formulation.Given a subsetR‾⊆Rof service arcs, letG‾(V‾,A‾)be the complete graph induced byR‾, whereV‾⊆Vis the set of endpoints of arcs inR‾plus the depot (if not already included), andA‾is given by the setR‾plus the lacking arcs between every pair of nodes inV‾. A costc¯ijis assigned to each arc inA‾as follows: if the arc(i,j)∈R‾thenc¯ijis its original traveling costcij, otherwisec¯ijis the cost of the shortest path connecting i to j in the original graph G. The DRPP visiting arcs of setR‾in a tour at minimum cost can be formulated as follows:(18)(AUX)min∑(i,j)∈A‾c¯ijwij(19)s.t.:∑i∈V‾⧹{j}wji=∑i∈V‾⧹{j}wijj∈V‾(20)wij⩾1(i,j)∈R‾(21)∑i∈K∑j∉Kwij⩾1K⊆V‾⧹{0},K≠∅(22)∑j∈V‾⧹{0}w0j⩾1(23)wij⩾0integer(i,j)∈A‾Each variablewijis a non-negative integer and represents the number of times arc(i,j)∈A‾is crossed. Objective function (18) minimizes the sum of traveling costs. Constraints (19) are the classical in-degree and out-degree constraints. Constraints (20) ensure the crossing of arcs inR‾. Constraints (21) are common connectivity constraints which can be used since all nodes in graphG‾have at least one entering or leaving arc belonging toR‾. Constraint (22) guarantees that at least one arc has to leave the depot. Finally, constraints (23) define the nature of variableswij. From now on we will refer to this formulation of the DRPP as to the Auxiliary Problem (AUX).It can be noticed that constraints (22), that force the solution to include the depot, are already implied by constraints (19) and (21). However, we introduce them as they strengthen the problem relaxation obtained by eliminating constraints (21). Such a relaxation is the starting point for the branch-and-cut algorithm we use to solve problem AUX to optimality. The exact method first solves to optimality the subproblem without constraints (21). Then it adds violated constraints from the set (21) in a lazy way, i.e. searching them only when integer solutions are found in the search tree. We will better describe the concept of lazy constraints when introducing our branch-and-cut method for the DPRPP.Finally, alternative formulations of the Rural Postman Problem can be found in Ball and Magazine (1988) and Christofides, Campos, Coberán, and Mota (1986). It is worth observing that, even if we use a formulation for the DRPP on an induced graph where non-service arcs are represented by shortest paths, the variables of the problem (namely variableswij) cannot be set as binary (see also Dror (2000) pages 256–257, where it is said that no small and easy-to-obtain upper bound is known for the variables in the DRPP formulation). We report a simple example showing how the best solution one can obtain by assuming to cross each arc in graphG‾at most once, may not be optimal (see Example 1 below).Example 1Fig. 3shows a graph G consisting of 4 nodes plus a depot and the complete graphG‾induced by the set of service arcsR‾={(1,3),(1,4),(2,3)}. The optimal solution for the DRPP on graph G is the tour0→2→3→1→3→1→4→0with cost equal to 8 obtained solving problem AUX on graphG‾. If we assume that each arc inG‾cannot be crossed more than once then the best solution obtainable becomes0→1→3→2→3→1→4→0with cost equal to 11 which is not optimal for the DRPP.In this section, we describe the heuristic procedures and the branch-and-cut approach proposed for solving the DPRPP.We introduce two solution algorithms. The first approach is a matheuristic where at each iteration a new subset of service arcs in R is selected and a DRPP is solved to optimality. The second procedure works as a final refinement that tries to improve the best solution found by the matheuristic using a branch-and-cut search. The method gets quick convergence forcing connectivity constraints which may exclude integer feasible solutions. It is worth noticing that, although we introduce this method as an improvement procedure, nothing prevents to use it as a stand-alone algorithm.The algorithm solves problem RELAX and uses different combinations of arcs inRRELto construct DRPP instances solved to optimality using problem AUX. A parameterγis introduced to control diversification by enlarging the set of service arcs initially selected by the optimal solution of problem RELAX. We call this algorithm Relaxation Based Heuristic (RBH) and report its pseudo code in Algorithm 1.Algorithm 1Relaxation Based Heuristic (RBH)Require Graph G=(V,A), set R of service arcs.ensure a feasible tourr∗with total costw∗.1: Setr∗≔∅and total costw∗≔∑(i,j)∈Rpij.2: Solve problem RELAX. Let(xREL∗,yREL∗)be its optimal solution and letRREL⊆Rbe the subset of service arcs selected in(xREL∗,yREL∗).3: ifyREL∗=0̲then return (r∗,w∗).4: Setγ=0.5: while (γ⩽γmax) do6:ifγ>0then7: Solve problem RELAX with the addition of constraint∑(i,j)∈Rxij⩾min{|RREL|*(1+γ),|R|}. Let(xREL∗,yREL∗)be its optimal solution andRRELthe resulting set of selected arcs.8:end if9:if(xREL∗,yREL∗)contains a unique cycler¯closed on the depot with total costw¯10: Setr∗≔r¯and total costw∗≔w¯.11:return(r∗,w∗)12:else13:(r′,w′)≔ISA ((xREL∗,yREL∗),RREL).14:ifw′<w∗then setw∗≔w′,r∗≔r′.15:(r′,w′)≔IDA ((xREL∗,yREL∗),RREL).16:ifw′<w∗then setw∗≔w′,r∗≔r′.17:(r′,w′)≔IIA ((xREL∗,yREL∗)).18:ifw′<w∗then setw∗≔w′,r∗≔r′.19:return(r∗,w∗).20:end if21:if (|RREL|=|R|) then22:γ≔γmax+∊.23:else24:γ≔γ+γstep.25:end if26: end whileAt Step 1 the valuesr∗andw∗are initialized to the case where no service arcs are selected: the objective function valuew∗is set equal to the sum of all penalties, whereas tourr∗is void. Then the optimal solution(xREL∗,yREL∗)of problem RELAX is determined andRRELis the set of service arcs visited by such a solution (Step 2). If the optimal solution of problem RELAX does not select any service arcs, then initialization values at Step 1 are optimal for the DPRPP and algorithm stops (Step 3). Then parameterγis initialized to 0 and the while cycle controlled byγis started. In the first iteration, corresponding toγ=0, the algorithm directly checks if the optimal solution of problem RELAX contains a unique tour closed to the depot (Steps 9–12). If this is not the case, the three subroutines ISA, IDA and IIA are called and the best tour foundr∗with total costw∗is returned at the end. From the second iteration of the cycle to the last one, when parameterγbecomes positive, the Step 7 is added allowing to enlarge the set of selected arcs. To this aim problem RELAX is solved with the inclusion of constraint∑(i,j)∈Rxij⩾min{|RREL|*(1+γ),|R|}that forces the selection of a larger number of service arcs than the previous iteration by a defined percentageγ. Note that the right-hand side of this constraint never allows a number of service arcs larger than|R|. When|RREL|=|R|, at Step 22 the parameterγis set to a value larger thanγmaxby a percentage∊and the while cycle is stopped.Algorithm 2Initial Solution Algorithm – ISA ((xREL∗,yREL∗),RREL)1: Solve problem AUX using setRRELas required arcs. Let r be the tour found and w its total cost.2: LetR∼be the set of isolated service arcs selected in(xREL∗,yREL∗).3: ifR∼≠∅then4: Solve problem AUX using setRREL≔RREL⧹R∼. Letr̃be the tour found andw̃its total cost.5:ifw̃<wthen setw≔w̃,r≔r̃.6: end if7: return(r,w).Pseudo code of the Initial Solution Algorithm (ISA) is described in Algorithm 2. At Step 1 this subroutine finds a first feasible solution solving a DRPP using as required arcs the complete setRREL. The optimal solution of problem RELAX can have isolated tours. If an isolated tour contains only one service arc, we call such an arc an isolated service arc. To be selected in an optimal solution of problem RELAX an isolated service arc must have a penalty larger than the traveling cost of the corresponding tour. The selection of isolated service arcs in an optimal solution of the DPRPP depends on how convenient they remain after imposing their connection to the depot tour. While it may happen that an isolated service arc is selected in the optimal solution of the DPRPP, we notice that this is usually not the case. So, we decide to eliminate all isolated service arcs from setRRELand then solve problem AUX on the remaining set (Steps 2–5). Algorithm 2 terminates providing the best solution between the two solutions found.Algorithm 3Improvement by Decreasing Algorithm – IDA ((xREL∗,yREL∗),RREL)1: Setr=∅andw=∑(i,j)∈Rpij.2: Letñbe the number of isolated tours in(xREL∗,yREL∗)with more than 2 service arcs.3: fori=1,…,ñdo4: LetRibe the set of service arcs belonging to tour i. SetRREL′≔RREL⧹Ri.5: Solve problem AUX using setRREL′as required arcs. Letribe its solution andwiits total cost.6:ifwi<wthen setw≔wi,r≔ri.7: end for8: Letr0be the tour passing through the depot in(xREL∗,yREL∗)andw0its total cost.9: ifw0<wthen setw≔w0,r≔r0.10: return (r,w).Routines IDA and IIA represent the two main phases of RBH. Their pseudo codes are illustrated in Algorithms 3 and 4.Isolated subtours are selected in the optimal solution of problem RELAX when the sum of traveling costs is lower than the sum of penalties. Nevertheless, their actual convenience for the optimal solution depends on the cost to connect them to the depot. To evaluate the convenience not to serve an isolated tour found by the problem RELAX optimal solution, Algorithm IDA removes, in turn, the service arcs of each isolated tour from the setRREL. At each iteration of the for cycle (Steps 3–7 of Algorithm 3) a new set of service arcsRiis determined and then eliminated fromRREL. The resulting set of service arcsRREL′is provided as required arcs to construct a new DRPP instance (problem AUX) solved to optimality. If no convenient paths exist to connect isolated tours to the depot, it may happen that the tour passing through the depot in the optimal solution of problem RELAX is already optimal for the original problem (Steps 8–9).Algorithm 4Improvement by Increasing Algorithm – IIA ((xREL∗,yREL∗))1: Setr=∅andw=∑(i,j)∈Rpij.2: Letñbe the # of isolated tours in(xREL∗,yREL∗)with more than 2 service arcs.3: LetR0be the set of service arcs selected by the tour passing through the depot in(xREL∗,yREL∗).4: fori=1,…,ñdo5: LetRibe the set of service arcs selected by tour i. Solve problem AUX using setRi∪R0. Letribe the solution tour andwiits total cost.6:ifwi<wthen setw≔wi,r≔ri.7: end for8: Sort sets{Ri,i=1,…,ñ}in non-decreasing order of solution costs{wi,i=1…ñ}.9: SetR‾≔R1∪R0.10: fori=2toñ-1do11: Solve problem AUX using setR‾≔R‾∪Ri. Letr¯be its solution tour andw¯its total cost.12:ifw¯<wthen setw≔w¯,r≔r¯.13: end for14: return (r,w).Subroutine Improvement by Increasing (IIA) aims at evaluating the convenience to connect each isolated tour with the tour passing through the depot. This represents a measure of the convenience to insert it into the optimal solution. For this aim, during each iteration of the first for cycle (Steps 4–7), the service arcs selected by an isolated tour are added to those (if any) in the tour passing through the depot and used as input to problem AUX. For each setRi∪R0of required arcs defined at Step 5, we keep the objective function value (total cost) of the solution found by the problem AUX and in Step 8 we sort isolated tours in non-decreasing order of such values. Then, following this order, the iterations of the second for cycle starting at Step 10, evaluate the solutions obtained by increasingly including the set of service arcs of each isolated tour, one after the other, to the set of service arcs of the tour passing through the depot. Thus, at each iteration, a new instance of problem AUX is solved receiving as input an increasing set of required arcs represented by the set of service arcs considered in the previous iteration plus the arcs of the isolated tour under consideration.This algorithm uses as input the best solution found by procedure RBH, and exploits a branch-and-cut algorithm to force connectivity cuts which may not be valid inequalities. In particular, when an integer solution is found at a node of the branch-and-bound tree, the procedure identifies isolated subtours. If the cardinality of the set P of nodes taking part of the subtour is larger thanα|A||A||V|the following cut is introduced:(24)∑i∈P∑j∉Pxij⩾1otherwise constraint (5) is added to the formulation.The value of parameterαdefines the separation among large and small subtours. The smaller its value the higher the number of subtours that may be considered large. We decide to separate small from large subtours assuming that large subtours are more promising, since they identify arcs which more likely will belong to the optimal solution. If a subtour is classified as promising, then at least one node in such a tour has to be visited. This is imposed through the introduction of inequality (24) that prevents the creation of a tour by forcing to leave it with at least one arc (right-hand side of the constraint is a constant). Note that in an optimal solution this may not be the case. The method adds an inequality (24) for each of the identified large subtours. Forcing such constraints may cause the exclusion of some problem feasible integer solutions, but allows the method to converge more quickly. The algorithm stops when a time limit is met. We call this procedure Heuristic Cuts Search (HCS).Moreover, to enhance HCS’s performance a heuristic routine is called iteratively in the tree after a predefined number of iterations. The procedure takes the optimal solution of the continuous relaxation at the current node of the search tree, and rounds the possibly fractional value of variablesyijassociated with service arcs to their closest integer. Selected service arcs are then used as input to problem AUX. Note that, given a set of required arcs, the solution of the problem AUX will provide the best way to serve them. This may possibly include the selection of additional service arcs located on the shortest path connecting nodes of the graph on which the problem AUX is formulated. If the solution found by solving the problem AUX is better than the actual incumbent solution, the latter is updated making bounding operations possibly more effective.We introduce a branch-and-cut algorithm that starts by solving to optimality the problem RELAX with all its valid inequalities. Commonly, branch-and-cut approaches for routing problems add violated connectivity constraints (5) at the continuous relaxation of all tree nodes (including the root) through the solution of max-flow problems. This is what is done in Archetti et al. (2012).We implement our exact method separating the connectivity constraints in two different ways. We use the standard separation based on the solution of max-flow problems to identify violated inequalities and, as an alternative, we eliminate subtours only when the LP solution in the current node of the search tree is already integer (lazy separation). In such a case, isolated tours are looked for, and if found, they are prevented by adding the inequalities (5) on the subsets P identified by the isolated cycles. Note that a connectivity cut is inserted for each identified subtour. The search of subtours is computed looking for connected components in the solution graph. A solution becomes feasible when no more isolated tours are found in the integer solution, that is, no more cuts will be discovered on that tree branch. In our implementation we adopt a best bound strategy to select nodes in the backtracking. The selection of the branching variables and the branching direction are determined automatically by CPLEX.The performance of our branch-and-cut method highly depends on the time required to solve problem RELAX with all its valid inequalities and on the time spent for separating connectivity constraints. We decide to test both ways of separating inequalities to compare their effectiveness. Each one of the two methods has pros and cons. In the literature, constraints added to an integer solution are usually considered weak in a polyhedral sense, and generally used in a lazy way by the branch-and-cut algorithm with the purpose of checking the feasibility of the integral solutions found along the tree. However, in our case the lazy constraints do not eliminate only the current infeasible solution, but also exclude all integral solutions that contain the identified subtours. Moreover, the lazy way of introducing inequalities avoids the introduction of the high number of constraints that the standard method has to deal with since the beginning, often causing the algorithm to go out of memory (see results by Archetti et al. (2012)).Finally, we also test a variant of our branch-and-cut where a heuristic routine is iteratively called at nodes of the search tree to solve problem AUX on subsets of service arcs. Without this external routine the method is already efficient: the routine’s introduction seems only to produce an increase in the average computational time. For this reason, we do not report computational results on this variant. Detailed results can be found in the technical report (Colombi & Mansini, 2013).In this section, we present the results obtained testing our algorithms on the set of benchmark instances provided by Archetti et al. (2012) that can be downloaded at the web site http://www.unibs.it/sites/default/files/ricerca/allegati/13004DPRPP.zip. This data set consists of the following five sets of instances.1.DPRPP_∊_δinstances: this set consists of two groups of problems: the DPRPP_∊_δ_valXA that originally come from those by Benavent, Campos, Corberán, and Mota (1992) and instances DPRPP_∊_δ_egl-eY-A and DPRPP_∊_δ_egl-sY-A, originally taken from Li and Eglese (1996). Parameters(∊,δ)define the interval[∊cij,δcij]in which penaltypijfor each arc(i,j)is randomly generated and are set equal to(1.0,2.0),(1.5,2.5)and(2.0,3.0), respectively. The total number of problems is equal to 54 (30 in the first group and 24 in the second one).DPRPP_P instances: 26 problems.DPRPP_D instances: 36 problems.DPRPP_G instances: 36 problems.DPRPP_R instances: 20 problems.Sets 2–5 come from Aráoz et al. (2009), where the original profits of these problems have been used as penalties for the DPRPP. At the website http://www.ing.unibs.it/orgroup/instances.html we provide the new optimal solutions we get for all open instances.All tests have been performed using a Laptop with 1.73gigahertz processor in Windows Seven operating system. Algorithms have been coded in C++ and models implemented in ILOG Concert Technology 2.0 and solved using CPLEX 10.1.In this section, we show the results obtained by different implementation of our exact procedure. We set a computational time limit of 3600seconds after which the branch-and-cut search is stopped and the best feasible solution found as well as its percentage gap with respect to the best lower bound are provided as output.In Table 1, we summarize the average results on each set of instances obtained by the branch-and-cut algorithm when implemented using two different separation methods for the connectivity cuts and two different mathematical formulations. Detailed results for each instance can be found on the webpage http://www.ing.unibs.it/orgroup/Results_DPRPP.zip. In particular, formulation “Basic”applies the problem formulation proposed in Archetti et al. (2012), whereas formulation “New” uses our formulation of the DPRPP that includes the new described valid inequalities. Moreover, both variants are tested with the two ways of adding violated connectivity cuts, that is the lazy way (Lazy separation) and the standard one solving max-flow problems at each node (Standard separation). The first column of the table provides the name of the five sets of instances, whereas column “#” indicates the total number of instances for each set and “# opt” how many instances in each set have been solved to optimality by each branch-and-cut variant. The entry is highlighted in bold style when all instances of the set have been solved to optimality. Columns “Time” and “# cuts” report the average time in seconds required to solve the instances of the set and the average number of connectivity cuts added.Comparing the results of Table 1 with the ones of the branch-and-cut implemented in Archetti et al. (2012) it is evident how competitive the use of lazy constraints and the introduction of our valid inequalities could be. Direct comparison can be done since hardware is comparable and the same version of CPLEX 10.1 has been used. Comparing New and Basic, one can appreciate the advantage of a better problem formulation. It is worth noticing that the combination of the New formulation with the lazy separation is the best performing variant finding the optimal solutions for all the instances and always requiring the lowest average computational time (Basic formulation for DPRPP_∊_δ_egl instances shows a lower average time, but this is due to the fact that the method in most difficult instances goes out of memory very early before the 3600seconds available for the computation). In Table 2, we provide the details on the optimal solution values found by the branch-and-cut with lazy separation for all the 22 open instances not solved to optimality by Archetti et al. (2012). The first column of the table provides the instance name, whereas columns “|V|” and “|R|” indicate the instance size, namely its number of nodes and of service arcs, respectively. Column “Opt.” shows the optimal solution value for the instance. Columns “Time” and “# cuts” report the time in seconds required by each variant to get the optimal solution and the number of connectivity cuts added to prevent isolated tours. Since the variant using Basic formulation does not always terminate within the computational time limit of 3600seconds, in column “Time” we report (into brackets) the best integer solution found and its percentage gap from the best lower bound. When the algorithm goes out of memory, the computing time is put before the brackets.From the analysis of Table 1 it is evident how DPRPP_∊_δ_val instances of Set 1 are very easy. Their solution always requires an average time less than 0.20seconds for all the variants. On the contrary, DPRPP_∊_δ_egl are among the most difficult instances. The variant using formulation New with lazy separation has been able to find the optimal solution for all the 8 open instances (see Table 2), whereas the corresponding variant with Basic formulation goes out of memory 2 times. Formulations New and Basic applied with standard separation do not close respectively two instances (gap from the best bound equal to 0.6% and 4.0%, respectively) and one instance (gap equal to 4.4%). Comparing these results with the ones in Archetti et al. (2012) one can notice how the use of lazy cuts helps problem solution and how the procedure we use to separate violated cuts in the standard way performs better than the one applied in Archetti et al. (2012). If we exclude instances DPRPP_ALBAIDAANoRPP and DPRPP_ALBAIDABNoRPP that are the most difficult problems in the set DPRPP_P, the remaining instances are still quite easy being solved, on average, in less than 0.25second and less than 6seconds for both variants with lazy separation and standard separation, respectively. In all the cases they always require a limited number of cuts. DPRPP_D is a set of instances that shows a large deviation in terms of number of nodes and service arcs. The complexity of such instances increases with their size. Our algorithm finds the optimal solution using any of the four variants for all the instances and has been able to close all the four open instances. In the case with lazy separation, formulation New has a computational time by about 7 times lower than formulation Basic and has halved the number of cuts. When considering standard separation, the time required by formulation Basic is more than 4 times larger than the corresponding formulation with lazy separation, whereas that of formulation New is 20 times larger than the corresponding formulation with lazy constraints.As for DPRPP_D, also for instances DPRPP_G the complexity increases with size. For the lazy separation case, formulation New performs well closing to optimality all the previously open instances. This is not the case for the formulation Basic that in one case goes out of memory with a gap from the best bound larger than 5% and in another one is unable to find the optimal solution and terminates after 1hour with a gap equal to 2.57%. Nevertheless, both formulations with lazy separation outperform the corresponding formulations with standard separation that show, on average, higher computational times and larger numbers of added cuts and are unable to find the optimal solution in 5 instances (formulation Basic) and 3 instances (formulation New), respectively. Finally, the results on instances DPRPP_R show how all variants have been able to find the optimal solution for all the instances, closing to optimality two previously unsolved instances. In conclusion, variant using New formulation with lazy separation of connectivity cuts has been able to solve all the instances to optimality. The second variant that has produced the best results is the variant using Basic formulation with lazy separation that performs slightly better than the variant with New formulation and standard separation. Finally, variant using Basic formulation with standard separation is the worst one. Results show the effectiveness of using lazy constraints and how the introduction of new valid inequalities creates a stronger formulation that significantly helps branch-and-cut solution.In this section, we analyze the performance of our heuristic approaches. After some preliminary tests, we have decided to set both parametersγmaxandγstepfor heuristic RBH equal to0.30. This means that the algorithm executes only 2 iterations of the while cycle. The maximum computing time assigned to heuristic HCS has been set to 50seconds. To limit the number of times the problem AUX is solved, we set a CPLEX condition that calls the corresponding heuristic only if the current iteration is a multiple of 10. A maximum computing time of 10seconds is assigned to the solution of each problem AUX. Moreover, we set to2%the percentage gap between incumbent integer solution and best bound, under which the problem AUX is not solved anymore. Preliminary tests have shown that, on average, it is difficult that a solution of this problem can improve the best incumbent under this gap value.In the following, we compare the performance of the Tabu Search algorithm and the ILP-refinement (indicated as ILP-Ref.in the tables) proposed by Archetti et al. (2012) with our procedures RBH and HCS, the latter tested withα=0andα=0.05, respectively.Tables 3–8have all the same structure. The first column indicates the name of the instance (reduced to the identification number). Each entry of column “Best Known” shows the best known solution value that corresponds to the optimal solution value for all instances. Column “Gap (%)” provides for each heuristic the percentage gap of its solution value (UB) from the best known value (BK) as followsUB-BKUB(computed as in Archetti et al. (2012) in order to guarantee a comparison). Column “Time” indicates the computational time in seconds required by each algorithm. This means that to correctly evaluate the time of the ILP-refinement that receives as input the solution found by the Tabu Search, one has to sum the computational time of the two procedures. Thus, differently from Archetti et al. (2012), the “Time” column of ILP-refinement is the sum of Tabu Search and ILP-refinement computing times. Similarly, the computational time for our heuristic HCS that receives as input the best solution found by procedure RBH is computed as the sum of the times required by the two procedures. Column “Routine” shows which routine of the method RBH has found the best final solution. If the name of the routine has “(γ)” at the end, it means that the best solution has been found by this routine during the second iteration of the while cycle of RBH whenγ=0.30. For algorithm HCS column “# cuts” provides the number of heuristic cuts used and column “# AUX” shows the number of time the problem AUX has been solved and the number of times its solution has improved the best incumbent integer solution (value into brackets).Table 3 presents results for instances DPRPP_∊_δ_valXA of Set 1. Procedure HCS finds the optimal solution for all instances with bothα=0.05andα=0. In particular, almost all the optimal solutions have been found by routine ISA. Algorithm RBH always requires less than 1 s and finds an average error almost null, whereas Tabu Search and ILP-refinement show a performance slightly worse with an average computational time of about 13 and 16seconds, respectively. Note that these instances are so easy that HCS never calls the routine to solve problem AUX. Table 4 shows heuristic results on instances DPRPP_∊_δ_egl-eY-A and DPRPP_∊_δ_egl-sY-A of Set 1. On these instances Tabu Search performs very well providing an average gap equal to 0.29%, whereas ILP-refinement has no effect at all only producing an increase in the computational time. Our algorithm RBH performs very well but in few instances that increase average error to 0.53%. Such an error is however strongly reduced by HCS. It is worth noticing that HCS (α=0.05) behaves better than HCS (α=0) where all subtours (also the smallest) are forced to be visited. This seems to confirm our idea that smallest subtours selected by problem RELAX are more unlikely to belong to the optimal solution. To conclude, on this set of instances, the performance of RBH–HCS and that of Tabu Search–ILP-refinement are comparable. On instances of the Set 2 (see Table 5) our algorithm HCS with bothα=0andα=0.05outperform state of the art algorithms. Forα=0.05the average computational time and the average gap are equal to 4.05seconds and 0.06%, respectively, whereas the corresponding values increase to 19.84seconds and to 0.38% for ILP-refinement by Archetti et al. (2012). In Table 6, heuristic results on instances of the Set 3 are presented. Also in this set the combination of our algorithms outperforms state of the art algorithms. HCS withα=0.05requires, on average, 33seconds and gets an average gap equal to 0.28%, whereas ILP-refinement shows an average gap equal to 0.71% and requires about 40seconds. In Set 4 (see Table 7) the average time of our HCS withα=0.05is higher by about 9seconds than the one of ILP-refinement, however its percentage gap is 0.06% instead of 0.18%. It is worth noticing that, for these instances, HCS is able, on average, to strongly improve results obtained by RBH in less than 3seconds. Finally, better results can be found on Set 5 in Table 8, where both RBH and HCS get a better average gap than Tabu Search and ILP-refinement and require computational times significantly lower. The average computing time of our HCS is lower than 1second with an average gap equal to 0.25% against the 40seconds required by the ILP-refinement getting an average gap of 0.46%.In Table 9, we report a summary comparing all results for Tabu Search–ILP-refinement and RBH–HCS. The first column indicates the set of instances, then for each algorithm we provide the average (Avg.) and the maximum (Max) gap and the average and the maximum time computed out of all instances in each set. On all solved instances our algorithms provide a better average performance in terms of time and percentage gap.To better analyze the performance of our algorithms, in Table 10we illustrate the number of times each routine in RBH obtains the best solution provided as output. For each routine (i.e. for each row of the table) we show the number of times it gets the best value (final solution) for algorithm RBH (first column) and the number of times this value is not improved by the refinement HCS (second column), respectively. For instance, routine ISA gets the best solution value provided by RBH in 69 instances out of the 172 available, whereas for HCS this happens 56 times, that is in 13 out of 69 times HCS is able to improve the best result obtained by ISA. Note that the last line of the table refers to HCS and indicates the number of times (that is 86) where HCS gets the best final results improving the results obtained by RBH.Finally, in Table 11, we provide the number of times each algorithm finds the best solution value in each set of instances, and show into brackets the number of times such values coincide with the best know solution values. If the best known value is reached by more than one algorithm we count it for all of them. For instance, the first row of DPRPP_∊_δ_val results shows that Tabu Search and ILP-refinement get 21 best heuristic solutions that coincide with the best known values, whereas RBH and HCS find 28 and 30 best solutions corresponding to best known values, respectively. To conclude, HCS performance is very good and RBH is an easy and fast matheuristic able to find promising solutions in some sets of instances even better than the ones obtained by more complicated meta-heuristic algorithms as the Tabu Search used as benchmark.

@&#CONCLUSIONS@&#
In this paper, we analyze a generalization of the Directed Rural Postman Problem where not all arcs requiring a service have to be visited provided that a penalty is paid for the ones not served. This generalization is called Directed Profitable Rural Postman Problem.We introduce different valid inequalities for the problem and propose a branch-and-cut algorithm and two heuristic methods. We implement different variants of the exact algorithm which use the problem formulation with and without the new valid inequalities and insert connectivity cuts either in a standard way or in a lazy way. The standard way solves the max-flow separation problem at each node of the search tree, whereas the lazy way excludes subtours only when an integer solution is found. The best variant combining a new problem formulation with the lazy separation of the connectivity constraints results to be extremely efficient closing all open benchmark problems available in the literature in less than one hour. Heuristics behave very well outperforming state of the art algorithms in several sets of instances. The core of the first procedure is the solution of Directed Rural Postman problems constructed on subsets of service arcs previously selected by the optimal solution of a problem relaxation. The second heuristic procedure is a quite general method based on a branch-and-cut structure where inserted connectivity cuts may not be valid inequalities. We believe that the main ideas behind these two heuristic algorithms deserve to be further analyzed and possibly extended to other arc routing problems. This will be the objective of our future research.