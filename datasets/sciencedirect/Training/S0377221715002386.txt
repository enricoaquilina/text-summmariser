@&#MAIN-TITLE@&#
On the representation of the search region in multi-objective optimization

@&#HIGHLIGHTS@&#
We describe the search region in multi-objective optimization by local upper bounds.The complexity of the description directly translates to generic solution methods.We enhance an earlier algorithm to compute this representation.We develop structural properties of this representation.From these we propose a new algorithm avoiding the filtering step of the former.

@&#KEYPHRASES@&#
Multiple objective programming,Search region,Local upper bounds,Generic solution approaches,

@&#ABSTRACT@&#
Given a finite set N of feasible points of a multi-objective optimization (MOO) problem, the search region corresponds to the part of the objective space containing all the points that are not dominated by any point of N, i.e. the part of the objective space which may contain further nondominated points. In this paper, we consider a representation of the search region by a set of tight local upper bounds (in the minimization case) that can be derived from the points of N. Local upper bounds play an important role in methods for generating or approximating the nondominated set of an MOO problem, yet few works in the field of MOO address their efficient incremental determination. We relate this issue to the state of the art in computational geometry and provide several equivalent definitions of local upper bounds that are meaningful in MOO. We discuss the complexity of this representation in arbitrary dimension, which yields an improved upper bound on the number of solver calls in epsilon-constraint-like methods to generate the nondominated set of a discrete MOO problem. We analyze and enhance a first incremental approach which operates by eliminating redundancies among local upper bounds. We also study some properties of local upper bounds, especially concerning the issue of redundant local upper bounds, that give rise to a new incremental approach which avoids such redundancies. Finally, the complexities of the incremental approaches are compared from the theoretical and empirical points of view.

@&#INTRODUCTION@&#
Most solution approaches in multi-objective optimization (MOO) aimed at outputting a set of “good” solutions iteratively generate candidate solutions. Generally, a pool of solutions is maintained and updated when new solutions arrive. The pool provides information which is used to decide whether a new solution should be inserted and whether old solutions should be removed. It can also be used to guide the search process within the objective space. In particular, from the images in the objective space of the pool solutions, we can define the part of the objective space containing all points that none of these images dominate, which we refer to as the search region.The concept itself is well known in the field. Especially in the two dimensional or bi-objective case, it is a key tool of the two-phase and branch and bound methods. In the two-phase method (see Ulungu & Teghem, 1995), adjacent extreme nondominated points computed in the first phase define triangles which delimit zones where all other nondominated points lie. The so-called local nadir points corresponding to the right angles of these triangles act as local upper bounds that together define the search region, assuming that the objectives are to be minimized. This upper bounding part is also one of the foundations of multi-objective branch and bound (see Sourd & Spanjaard, 2008). Actually, the representation of the search region through local upper bounds makes it possible to test the existence of the intersection between the search region and a convex lower bound on the feasible points associated to a search node and to decide whether to fathom the search node or not.Given a discrete set of pointsQ⊂Rp,Kaplan, Rubin, Sharir, and Verbin (2008) consider maximal empty orthants with respect to Q, which contain no point of Q and are maximal for this property under inclusion. Assuming that the points of Q are feasible points of an MOO problem, the union of all maximal empty orthants corresponds to the search region associated to Q and their apexes correspond to local upper bounds in the context of MOO. Kaplan et al. (2008) give an algorithm for the generation of all maximal empty orthants, and hence for the computation of all local upper bounds of the search region. However it requires that the input points are given in a nondecreasing order of some component and in this sense does not directly imply an incremental approach.Przybylski, Gandibleux, and Ehrgott (2010) consider local upper bounds in arbitrary dimension for a generalization of the two-phase method to problems with arbitrarily many objectives. They propose an online algorithm to carry out the update of the local upper bounds as soon as new feasible points are discovered, but they do not consider the complexity of this operation.Several solution methods to generate the nondominated set iteratively solve linear programs parameterized by local upper bounds (see Sylva & Crema, 2007), possibly including redundancies (see Kirlik & Sayın, 2014; Lokman & Köksalan, 2013). In Sylva and Crema (2007) each local upper bound is determined by solving an integer linear program.Also, Dächert and Klamroth (2015) propose to compute boxes for three dimensional MOO problems that are defined by a common lower bound and several upper bounds and decompose the search region. They develop an efficient incremental algorithm, that avoids redundancies, to update the decomposition each time a nondominated point is found, through e.g. the optimization of a pseudo-distance function parameterized by the defining points of the box. In particular, they show that, in the three dimensional case, the search region can be described by 2n + 1 boxes if the number of known feasible points is n.The paper is organized as follows. Section 2 sets some notations, formally defines the concepts of search region and upper bound set, then motivates their use in MOO. Section 3 shows the existence and uniqueness of local upper bounds through a first algorithm for which we discuss some enhancements. Section 4 investigates some properties of the elements of upper bound sets that yield another approach to compute an upper bound set. Section 5 is devoted to the complexity aspects related to the representation of the search region by a set of local upper bounds and the comparison of the two approaches from both theoretical and empirical points of view. Finally, Section 6 provides conclusions and perspectives.We consider MOO problems(1)minf(x)=(f1(x),…,fp(x))s.t.x∈Xwith feasible set X ≠ ∅ and with p ≥ 2 objective functionsfj:X→R,j ∈ {1, …, p}. Let Y = f(X) denote the set of all feasible points in the objective space. For all j ∈ {1, …, p} and x ∈ X, we assume, for any instance of an MOO problem, that m < fj(x) < M for somem,M∈R,or that such values m and M exist that bound the area of interest for the decision maker. We will refer to Z = (m, M)pas the p-dimensional search interval, a set that contains all feasible or at least all relevant points. We denote byZ^=[m,M]pthe closure of Z.The Pareto concept of optimality for MOO problems is based on the componentwise orderings ofRpdefined forz1,z2∈Rpbyz1≦z2(z1weaklydominatesz2)⇔zj1≤zj2,j∈{1,⋯,p},z1≤z2(z1dominatesz2)⇔z1≦z2andz1≠z2,z1<z2(z1strictlydominatesz2)⇔zj1<zj2,j=1,⋯,p.A pointz2∈Rpis called dominated byz1∈Rpif z1 ≤ z2. If, moreover, z1 < z2 then z2 is called strictly dominated by z1. A subset N of Z is stable for the dominance relation ≤ or simply stable if for any z1, z2 ∈ N,z1¬≤z2. For any subset Q ofRp,Qnd is the set of all nondominated points of Q, i.e.Qnd={z∈Q:thereexistsnoz¯∈Qwithz¯≤z}. We refer to Ynd as the nondominated set of (1), and every point z ∈ Ynd is called nondominated.Note that M must therefore be strictly greater than the component values of the nadir point, defined as the componentwise maximum of the nondominated points, i.e. (max {zj: z ∈ Ynd})j ∈ {1, …, p}.We define some general notations. We denote byMthe p-dimensional vector (M, …, M) and analogously the p-dimensional vectorm= (m, …, m) and the p-dimensional all-ones vector 1. For anyz∈Rp,we let z−jbe the (p − 1)-dimensional vector of all components of z excluding component j, for a given j ∈ {1, …, p}. Finally, for anyz,a∈Rpand any j ∈ {1, …, p}, (zj, a−j) denotes the vector (a1, …, aj − 1, zj, aj + 1, …, ap). Such a vector will be referred to as the jth projection of vector z on vector a.In the following definition, we formalize the concept of search region which we presented in the introduction.Definition 2.1Let N be a finite and stable set of feasible points. The search region for Ynd∖N, denoted by S(N), contains all the points in Z that could be nondominated given N, or alternatively, excludes all the points in Z that are dominated by at least one point in N, that is:(2)S(N)={z∈Z:∀z¯∈N,z¯¬≦z}=Z∖{z∈Z:∃z¯∈Nwithz¯≦z}Note that the search region S(N) excludes the points in N, since they are already known, that is, S(N) ∩ N = ∅.In some cases, N is a subset of Ynd obtained by some scalarizing function. More generally, N may contain any feasible point, no matter how it is obtained, e.g. by any heuristic procedure. It could even be any stable set of not necessarily feasible points from Z, provided none of its points dominate any point of the nondominated set Ynd.Regarding the stability condition on N, it can be easily seen that the set S(N) is not affected if a point dominated by another point of N is added. In other words:Remark 2.2For any set of points Q, we have S(Q) = S(Qnd), i.e., both sets induce the same search region.Consequently, the assumption that the set N is stable can be made without loss of generality.Our purpose is to find an explicit and concise characterization of S(N) using a finite set U(N) of minimal local upper bounds, which could also be referred to as local nadir points or maximal points (for the dominance relation). We will refer to U(N) as an upper bound set for the search region S(N) in the following.Every local upper bound u ∈ U(N) defines a search zone C(u) ⊂ Z asC(u)={z∈Z:z<u},and the search region S(N) is covered by the union of these search zones. In order to possibly include any point of Z in a given search zone C(u), the possible values for u should include the boundary of Z. So in general U(N) is a subset ofZ^,the closure of the search interval Z.In the following, we give three alternative definitions for upper bound sets and show their equivalence.Definition 2.3Let N ⊂ Z be a finite and stable set of points. A setU(N)⊂Z^is called an upper bound set with respect to N if and only if(1)S(N)=⋃u∈U(N)C(u)and∀u1,u2∈U(N),C(u1)¬⊂C(u2).While condition (1) in Definition 2.3 guarantees that the search region S(N) is exactly represented by the search zones induced by U(N), condition (2) ensures minimality of the set U(N) in the sense that no redundant search zones are contained in the representation. Observe that this definition can be seen as a natural extension of the concept of upper bound in the one-dimensional case. If p = 1, a stable set may either be empty (N = ∅), or it may consist of exactly one point (N={z¯}). The corresponding search region is then uniquely represented by one point, namelyu¯=Min the first case andu¯=z¯in the latter case.As an example, we describe the situation in the two-dimensional case.Example 1LetN={(z11,z21),…,(z1n,z2n)}be a stable set of two-dimensional points (with n ≥ 1). In the bi-objective case, the points in any stable set N can be ordered such that the objective values are strictly increasing in the first objective and strictly decreasing in the second objective. Hence we can assume thatz11<⋯<z1nandz21>⋯>z2n. The search region consists of the union of search zones defined by pairs of consecutive points in N. Thus the upper bound set associated to N isU(N)={(z11,M),(z12,z21),(z13,z22),⋯,(z1n,z2n−1),(M,z2n)}We illustrate this example in Fig. 1.The conditions of Definition 2.3 can immediately be reformulated in terms of pairwise comparisons between points in S(N) and U(N).Proposition 2.4Let N ⊂ Z be a finite and stable set of points. ThenU(N)⊂Z^is an upper bound set with respect to N if and only if(1a’)∀z ∈ S(N) ∃u ∈ U(N) : z < u,∀z∈Z∖S(N)∀u∈U(N):z¬<u,and∀u1,u2∈U(N):u1¬≤u2.Conditions (1a’) and (1b’) together are equivalent to condition (1) in Definition 2.3, and condition (2’) is equivalent to condition (2) in Definition 2.3.□In the case where the search interval is restricted to integer-valued vectors, i.e.Z⊂Zp,conditions (1a’) and (1b’) of Proposition 2.4 can be further specified since for allz,z′∈Zpsuch that z < z′, we have z ≦ z′ − 1. We briefly restate them in the following remark.Remark 2.5AssumeZ⊂ZpandM∈Zp. Under the same hypothesis of Proposition 2.4, we have for the upper bound setU(N)⊂Z^:(1a”)∀z ∈ S(N) ∃u ∈ U(N) : z ≦ u − 1 and∀z∈Z∖S(N)∀u∈U(N):z¬≦u−1This is particularly useful in the context of the two-phase and branch and bound algorithms which we discuss at the end of this section.A yet alternative characterization of local upper bounds that will turn out useful for their efficient determination is given in Proposition 2.6. In particular, local upper bounds are exactly those points that (i) are not strictly dominated by any of the points in N, and (ii) are maximal with this property.Proposition 2.6Let N ⊂ Z be a finite and stable set of points. ThenU(N)⊂Z^is an upper bound set with respect to N if and only if U(N) consists of all pointsu∈Z^that satisfy the following two conditions:(i)no point of N strictly dominates u andfor anyu¯∈Z^such thatu¯≥u,there existsz¯∈Nsuch thatz¯<u¯,i.e., u is a maximal point with property (i).Let U(N) denote the upper bound set with respect to N, and let U′(N) denote the set of all points satisfying (i) and (ii) above.Claim 1: U(N) ⊂ U′(N). Let u ∈ U(N). We show that u satisfies (i) and (ii).(i)Assume that there exists a pointz¯∈Nsuch thatz¯<u. Then by condition (1) of Definition 2.3,z¯∈C(u)⊂S(N),which contradicts S(N) ∩ N = ∅.Letu¯≥uand henceC(u)⊂C(u¯). Since u ∈ U(N), by condition (2) of Definition 2.3, we getu¯∉U(N). Thus, there exists a pointz′∈C(u¯)such that z′ ∈ Z∖S(N). Since z′ ∈ Z∖S(N), there exists a pointz¯∈Nwithz¯≦z′and hencez¯<u¯.Claim 2: U′(N) = U(N), i.e., we show that U′(N) satisfies (1) and (2).First observe that for any u′ ∈ U′(N), we have C(u′) ⊂ S(N). Indeed, if there exists z′ ∈ C(u′)∖S(N), then there exists z ∈ N such that z ≦ z′. Since z′ < u′, we get z < u′ contradicting condition (i).(1)Let u′ ∈ U′(N). Then we have C(u′) ⊂ S(N) and hence⋃u′∈U′(N)C(u′)⊂S(N). From Claim 1 above, we haveS(N)=⋃u∈U(N)C(u)⊂⋃u′∈U′(N)C(u′),and thus⋃u′∈U′(N)C(u′)=S(N),which proves (1).Now let u1, u2 ∈ U′(N). Then we have C(u1) ⊂ S(N) and C(u2) ⊂ S(N). If C(u1) ⊂ C(u2), then (ii) would be violated. This proves (2).□In computational geometry, Kaplan et al. (2008) define maximal empty orthants with respect to a discrete set of pointsQ⊂Rpas partially bounded hyperrectangles of the form∏j=1p(−∞,aj)⊂Rp,for somea∈Rp(apex), which contain no point of Q and are maximal for this property under inclusion. It is clear that such points a satisfy the conditions of Proposition 2.6 and are therefore local upper bounds for the search region S(Q).For their generalization of the two-phase method to MOO problems with more than two objectives, Przybylski et al. (2010) are interested in characterizing the part of the objective space where remaining nondominated points have to be searched after phase one. To this end, they define a concept similar to our search region, the search area. The search area S′(N) is defined as the closure of the complement set of{z∈Rp:∃z′∈N,z′≦z},i.e.,S′(N)=cl({z∈Rp:∃z′∈N,z′≦z}C).N is defined in Przybylski et al. (2010) as an upper bound set for the nondominated set in the sense of Ehrgott and Gandibleux (2007), and can also be any stable set of feasible points. Note that we omit from their definition a lower bounding part, which is not relevant for our purpose.In fact, the search area S′(N) corresponds to the closure of the search region S(N) defined according to Eq. (2) in Definition 2.3. This difference implies that the search area S′(N) includes N and even points of the objective space that are weakly dominated by some points of N.Przybylski et al. (2010) and Dächert and Klamroth (2015) also describe the search area by a set of corner points or upper bounds which are the same as the local upper bounds we consider in this paper. The former rely on a definition for these points which corresponds to Proposition 2.6.The concepts and properties developed in Sections 2.2 and 2.3 apply to MOO in general. For continuous and mixed discrete-continuous problems, they are useful in approaches aimed at generating discrete representations of the nondominated set. In the case of discrete problems, such as multi-objective combinatorial optimization (MOCO) problems, they play an important role in the generation of the nondominated set as well. In this section, we focus on the latter issue and mention two widely applied methods to show how the computation of local upper bounds can be integrated into an overall solution strategy.The representation of the search region as a set of search zones makes it possible to derive a simple algorithm to enumerate all nondominated points of a MOCO problem. This can be done by iteratively exploring the search zones that define the search region and updating the search region whenever new points are found. The exploration of a search zone C(u) has to determine whether C(u) contains feasible points, and if so output one such point. In order to limit the number of search zones that are considered, the exploration routine should return only nondominated points. Such an exploration can be achieved by solving, for example, the following mathematical program associated to a search zone C(u):P(u):min{g(f(x)):x∈X,f(x)<u}where g is any strongly increasing aggregation function of the fj’s (e.g.g:z↦∑j=1pzj). Note that the strict dominance in the definition of P(u) can be transformed into non-strict inequalities by slightly decreasing u since X is a discrete set, or, when possible, by taking advantage of Remark 2.5. Problem P(u) can be seen as a variant of the ε-constraint method (see e.g. Chankong & Haimes, 1983) and was proposed in Chalmet, Lemonidis, and Elzinga (1986) using a weighted sum function with positive weights as function g.The generic method is presented in Algorithm 1. From property (2) of Definition 2.3, there is no redundant constrained program among the programs associated to the search zones of the current search region.Now we count the number of constrained programs that have to be solved in Algorithm 1. Note that each local upper bound that is considered at Step 3 will either lead to a nondominated point or be part of the final upper bound set U(Ynd) (if the associated P(u) has no feasible solution). Therefore the number of calls to the exploration routine is exactly |U(Ynd)| + |Ynd|. This, together with the tight upper bound on |U(Ynd)| provided in Section 5.1, amounts toO(|Ynd|⌊p2⌋)solver calls for p ≥ 2.Many papers in the literature propose overall strategies, based on solving budget constrained programs, that generate the nondominated set: Chalmet et al. (1986), Laumanns, Thiele, and Zitzler (2006), Sylva and Crema (2008), Özlen and Azizoglu (2009), Lokman and Köksalan (2013), Kirlik and Sayın (2014), and Dächert and Klamroth (2015). To our knowledge, only approaches specialized to the bi- and tri-objective cases provide a non-trivial upper bound on the number of solver calls. Good upper bounds are known, however, for p = 2 and p = 3. Chalmet et al. (1986) propose an approach for the case p = 2, similar to Algorithm 1, where exactly 2|Ynd| + 1 solver calls are required. In the more complex case p = 3, Dächert and Klamroth (2015) suggest a closely related method and show that at most 3|Ynd| − 2 solver calls are needed in this case.In multi-objective branch and bound (MOBB), a bounding step is performed at each node of a search tree. Assume we consider the current node whose set of feasible solutions is X′ ⊂ X. In general, computing either X′ or Y′ = f(X′) would be expensive. However, given a set of, say m weight vectors λ1, …, λmofRpsuch that for any i ∈ {1, …, m}, λi≥ 0, we may approximateYnd′by computingαi=min{∑j=1pλjizj:z∈Y′},especially if the single objective version of the underlying problem is solvable in polynomial time. Denoting by Q the set{z∈Z:∑j=1pλjizj≥αi,i=1,…,m},we have Y′ ⊂ Q, thusYnd′⊂Q. Therefore, if Q ∩ S(N) = ∅ then the current node can be pruned since it cannot yield any new nondominated point.Consider also the two-phase method, and especially the version where a ranking algorithm is used to obtain, in phase two, nondominated non-extreme points. A set of weight vectors λ1, …, λmthat satisfy the same conditions as above is obtained in phase one. At some time during phase two, we are given m valuesα1,…,αm∈Rsuch that for each i ∈ {1, …, m}, all feasible points whose weighted sum value according to the weight vector λiis less than or equal to αihave been computed. Considering N as the set of all these feasible points, excluding the dominated ones, we can test whether the setQ={z∈Z:∑j=1pλjizj≥αi,i=1,…,m}intersects the search region S(N).Now we explain how local upper bounds help to determine whether such a polytope Q intersects the search region. For anyλ∈Rpsuch that λ ≥ 0 and for anyz,z′∈Rpsuch that z < z′, we have∑j=1pλjizj<∑j=1pλjizj′. Therefore, together with conditions (1a’) and (1b’) of Proposition 2.4, we obtain:Q∩S(N)=∅if,forallu∈U(N),thereexistsi∈{1,…,m}suchthat∑j=1pλjiuj≤αi(Rule``R"")If the feasible points are integral, that is we restrict ourselves to integer vectors in both S(N) and Q, the above condition for Q ∩ S(N) = ∅ can be strengthened using Remark 2.5. In this case, we rely on the following implication: if z and z′ are two vectors such that z ≦ z′, then∑j=1pλjizj≤∑j=1pλjizj′. Then in this case, we have:Q∩S(N)=∅if,forallu∈U(N),thereexistsi∈{1,…,m}suchthat∑j=1pλjiuj<αi−∑j=1pλji(Rule``Z"")These rules are used by Sourd and Spanjaard (2008) in the context of MOBB to find all nondominated points of the bi-objective minimum spanning tree problem. Przybylski, Gandibleux, and Ehrgott (2008) also use them in a two-phase method based on the use of a ranking algorithm to find all nondominated points of the bi-objective assignment problem. Przybylski et al. (2010) consider their application again in a two-phase method not limited to the bi-objective case. The rules they propose for the general multi-objective case are related to their definition of the search area we presented in Section 2.4, which implies that the rule for the integral case is a little weaker than Rule “Z”.The initial search region consists of the whole search interval Z. Therefore, it can be described by the following upper bound set:U(∅)={M}.Actually, this defines the unique search zone C(M) = Z, which is consistent with Definition 2.3.Starting with this in the case N = ∅, a simple incremental algorithm can be formulated that iteratively introduces points to the set N and updates the upper bound set U(N) accordingly. It was first proposed by Przybylski et al. (2010) with a slight difference in the filtering step to which we shall return later. Given a finite and stable set N ⊂ Z, a corresponding upper bound set U(N), and a pointz¯∈Zthat is nondominated with respect to N, Algorithm 2describes the updating procedure to obtain the upper bound setU(N∪{z¯}).Basically, Algorithm 2 updates each search zone C(u) in which the new pointz¯lies by removing from C(u) the part of Z which is dominated byz¯(includingz¯). This is achieved by replacing C(u) by p subzones as done in Step 6 of Algorithm 2. Some of these newly generated subzones may be redundant, and are thus removed in Step 7. More formally, we state the following result, which justifies Algorithm 2.Proposition 3.1Let N ⊂ Z be a non-empty finite and stable set of points. ApplyingAlgorithm 2iteratively on the points of N, starting with an initial upper bound set U(∅) = {M}, returns the correct upper bound set U(N).We show that Algorithm 2 correctly computes the setU(N∪{z¯}),given any finite and stable set N ⊂ Z of points, the correct upper bound set U(N), and a new pointz¯∈Zthat is nondominated with respect to N. The result then follows by induction.Considering the new pointz¯,the search regionS(N∪{z¯})must be updated from S(N) by removing all points in Z such thatz¯≦z.In Step 1 of Algorithm 2 the search zones C(u), u ∈ A, containingz¯are identified. All other search zones C(u), u ∈ U(N)∖A, are not affected by the new pointz¯and thus need not be modified.Thus, we just need to remove the set of points{z∈S(N):z¯≦z}from the search zones C(u), u ∈ A, to ensure that condition (1) of Definition 2.3 is satisfied. Steps 4–6 are justified by the fact that for any u ∈ A we haveC(u)∖{z∈S(N):z¯≦z}=⋃j=1pC(z¯j,u−j).Among the candidate local upper bounds of P, as defined after all iterations of Step 6, there may be some redundant local upper bounds in the sense that they induce search zones that are included in a search zone associated to some (candidate) local upper bounds of P ∪ (U(N)∖A). Let(z¯j,u−j)∈P,with u ∈ A, be a redundant local upper bound, i.e. there exists u′ ∈ P ∪ (U(N)∖A) such thatz¯≤(z¯j,u−j)≤u′. Ifz¯<u′,then P contains the candidate local upper bound(z¯j,u−j′),otherwise we have u′ ∈ B. Therefore, Step 7 correctly filters the set P, which leads to satisfying condition (2) of Definition 2.3.□In Przybylski et al. (2010), the filtering step is formulated with respect to the set U(N), i.e.P←{(z¯j,u−j)∈P:(z¯j,u−j)¬≤(u′),∀u′∈U(N)}.This is correct, but involves unnecessary dominance tests compared to Algorithm 2, since one only needs to filter with respect to P ∪ B instead of U(N).It is even possible to further refine the filtering step of Algorithm 2. To this end, we prove the following proposition.Proposition 3.2Let(z¯j,u−j)be a candidate local upper bound in P. Then:(1)(z¯j,u−j)≤(z¯k,u−k′)for some(z¯k,u−k′)∈Pwith k ≠ j implies(z¯j,u−j)≤(z¯j,u−j′);(z¯j,u−j)≤u′for some u′ ∈ B impliesz¯j=uj′andz¯−j<u−j′.(1)Sincez¯<u′,we have(z¯k,u−k′)≤u′,which, together with(z¯j,u−j)≤(z¯k,u−k′),leads to(z¯j,u−j)≤u′,and thus(z¯j,u−j)≤(z¯j,u−j′).Sincez¯<uand(z¯j,u−j)≤u′we havez¯−j<u−j≤u−j′. Moreover, with u′ ∈ B, we obtainz¯j=uj′.□According to property (1) of Proposition 3.2, the filtering step 7 of Algorithm 2 can be replaced by the following step:P←{(z¯j,u−j)∈P:(z¯j,u−j)¬≤(z¯j,u−j′),∀(z¯j,u−j′)∈Pand(z¯j,u−j)¬≤u′,∀u′∈B}which is equivalent to the following formulation:P←{(z¯j,u−j)∈P:(z¯j,u−j)¬≤u′,∀u′∈(A∪B)∖{u}}From property (2) of Proposition 3.2, it is also possible to do fewer dominance tests against the local upper bounds of B.Overall, Proposition 3.2 shows that it is only required to perform dominance tests between vectors that differ in all but one component. We present these enhancements in Algorithm 3, where we split the sets B and P into p disjoint sets, respectively B1, …, Bpand P1, …, Pp, to stress the by-component filtering step.While Algorithm 3 allows the correct computation of upper bound sets, it requires the iterative filtering for a possibly large number of candidate local upper bounds, which may be computationally expensive. In the next section, we establish structural properties of local upper bounds which yield necessary and sufficient conditions for a candidate local upper bound to become actually a (non-redundant) local upper bound. Then a new approach to the incremental computation of an upper bound set, which avoids the filtering step, is derived.In this section, we study some theoretical properties of local upper bounds that yield another approach which, in comparison to the algorithms presented in Section 3, avoids the filtering step (namely Steps 8 and 9 in Algorithm 3).The properties are first presented under a simplifying assumption that no two distinct points, among the points of Z to be considered, share the same value in any dimension. This assumption, denoted “SA” in the remainder, corresponds to what is referred to as a general position assumption in computational geometry. It is, however, not realistic for many instances of MOCO problems, that is why we extend the properties under the general case according to which identical component values among distinct points are allowed.We first illustrate the properties on small examples (Section 4.1). Then we detail the properties and derive the new approach (Section 4.2).In this section, we give a geometric intuition to the properties that are detailed in the next sections through two example instances in the tri-objective case. First we present an example instance in the SA case (Example 2). Then we discuss the consequences of feasible points having identical component values (Example 3).Example 2Under SAWe consider a three-dimensional simple instance of our problem which consists of two feasible points: z1 = (3, 5, 7) and z2 = (6, 2, 4). Let us apply the incremental algorithm presented in Section 3 first on U(∅) = {M} andz¯=z1then on U({z1}) andz¯=z2. At the first iteration, z1 yields three local upper bounds, namely u1 = (3, M, M), u2 = (M, 5, M), and u3 = (M, M, 7) so that U({z1}) = {u1, u2, u3}. Then at the second iteration we consider the three projections of z2 on the local upper bounds whose associated search zones contain z2 which are u2 and u3. We get u21 = (6, 5, M), u22 = (M, 2, M), and u23 = (M, 5, 4) for u2, and u31 = (6, M, 7), u32 = (M, 2, 7), and u33 = (M, M, 4) for u3. Projections u23 and u32 being redundant since u33 ≥ u23 and u22 ≥ u32, we have U({z1, z2}) = {u1, u21, u22, u31, u33}.We represent the situation in Fig. 2. The feasible points z1, z2 are depicted together with their Pareto dominance cones {z ∈ Z : zi≦ z}, i ∈ {1, 2}, in gray as well as the local upper bounds. The scene is represented in perspective from pointmto pointMso that the search zones go towards us.Now we look at a particular local upper bound, sayu21=(z12,u−12). Consider any pointz¯that belongs to the search zone defined by u21. The jth projection ofz¯on u21 amounts to sliding u21 along the half-line[u21,(mj,u−j21)). From Fig. 2, we can see that if a projection ofz¯on u21 lies outside any of the three black line segments that start from u21, then it will be redundant since it belongs to the closure of another search zone. We can see that these line segments are edges of the union of dominance cones associated to the points of N, plus three dummy pointsz^1=(M,m,m),z^2=(m,M,m)andz^3=(m,m,M). With these dummy points, even local upper bounds located on the boundary ofZ^lie at the intersection of three dominance cones. We can now avoid the filtering step (Steps 8 and 9) of Algorithm 3 if, for each local upper bound u, the p edges of the union which are incident to u are known. In the rest of this section, we consider facets of the union of the dominance cones associated to the points of N and to the dummy pointsz^1,z^2,z^3.We can see that the facets incident to u21 are composed of two facets incident to u2 that are shrunk after the first projection of z2 and one facet which is a subset of a facet of the dominance cone associated to z2. So, in order to compute the edges incident to u21, we only have to keep track of the three points that lower bound the facets, namely z2, z1, andz^3. This holds because under SA, a facet is defined by a local upper bound and a single point of N.Consider the three-dimensional instance represented in Fig. 3with three feasible points z1 = (2, 7, 7), z2 = (5, 7, 5) and z3 = (8, 7, 3), which all share the same value on the second coordinate. We look again at facets of the union of all dominance cones associated to the points of N. The local upper bound u = (M, 7, M) is defined byz^1on component 1,z^3on component 3, and z1, z2, and z3 on component 2. We consider the facet of the union incident to u and orthogonal to the f2-axis. Similarly to the SA case, we may want to represent this facet by u and a single point defining a lower bound on the f1 and f3 values. Since this facet is incident to three feasible points we could defineb=(z11,z21=z23,z33)=(2,7,3)(see again Fig. 3).However, this information may not be sufficient to avoid future redundancies. Consider for example the pointz¯=(4,3,7)as depicted in Fig. 3 together with its Pareto dominance cone (in dotted lines). It satisfiesz11<z¯1<z12,z¯2<z21=z22andz¯3=z31.z¯defines among others the local upper boundu′=(z^11,z22,z¯3)=(M,7,7). Unfortunately, one of the edges incident to u′ represented as a dashed line in the figure is limited by an intermediate feasible point, namely z2. Therefore, it will be necessary in the general case to keep track of all feasible and dummy points that belong to a facet incident to a local upper bound. This is what the sets Zj(·) are aimed at in Section 4.2.According to Step 7 of Algorithm 3, all components of a local upper bound u result from previously generated upper bounds for p − 1 components and, for the remaining component, from the currently added pointz¯. The initial local upper boundM, however, is not defined from any point of Z. In order to make no particular case of the component values inherited fromM, we extend any stable set of points from Z with the dummy points we introduced in the previous section. Namely, we define the extension of N as the setN^=N∪{z^j,j=1,…,p},wherez^j=(Mj,m−j),j∈{1,⋯,p}It is not hard to see thatU({z^j,j=1,…,p})={M},i.e. the dummy points yield the initial search zone, which implies that for any finite and stable set N of points from Z, we haveU(N^)=U(N).Using dummy points, we now have that any component value of a local upper bound is defined by a point ofN^.Observe that a dummy pointz^jcan only define the jth component of any local upper bound, which is M. Indeed since no point from Z is lower than or equal to m on any component, m cannot be a component value of a local upper bound. Therefore, and since M is unique in the component values of a dummy point,z^jis the only dummy point that can define component j.The following proposition gives a useful property of those points that define each component of a local upper bound.Proposition 4.1For any local upper bound u ∈ U(N) and j ∈ {1, …, p}, there existsz∈N^such that zj= uj and z−j< u−j.If uj= M, then the dummy pointz^j∈N^satisfies the required conditions.Otherwise and sinceN^is a finite set, there exists an ε > 0 sufficiently small such that no point ofN^has its jth component value in the interval (uj, uj+ ε). Let u′ = (uj+ ε, u−j). According to Proposition 2.6, sinceu′∈Z^and u′ ≥ u, there exists a z ∈ N such that (i) z < u′ and (ii)z¬<u. It follows from (i) that we have z−j< u−j, which imposes zj≥ ujfrom (ii). From the choice of ε, we therefore have zj= uj.□In the following we define two notations for those points that define local upper bounds, for the general case and for the SA case, respectively.Definition 4.2For any local upper bound u ∈ U(N), we denote byZj(u)={z∈N^:zj=ujandz−j<u−j}the set of defining points of u for component j, j ∈ {1, …, p}.In the SA case, the unique defining point of u for component j is denoted zj(u).Using Proposition 4.1, we can now precisely characterize the projections which are kept in the set P after the filtering step of Algorithm 3. We first consider the SA case.Theorem 4.3Simplifying assumptionLetz¯be a point of Z that is nondominated with respect to N and such that the points inN∪{z¯}satisfy SA. Consider a local upper bound u ∈ U(N) such thatz¯<u. Letzjmax(u)=maxk≠j{zjk(u)}.Then, for any j ∈ {1, …, p},(z¯j,u−j)is a local upper bound ofU(N∪{z¯})if and only ifz¯j>zjmax(u).Let u ∈ U(N) andz¯∈Z∖Nbe a point not dominated by any point of N such thatz¯<u.(⇒)Suppose thatu¯=(z¯j,u−j)is a local upper bound inU(N∪{z¯})and letzjmax(u)=zjk(u)for some pointzk(u)∈N^,such thatzkk(u)=uk,k ≠ j. Therefore,zkk(u)=u¯kand, from SA, no other point ofN^equalsu¯kon its kth component. Thus from Proposition 4.1, we havez−kk(u)<u¯−k,which implieszjk(u)=zjmax(u)<u¯j=z¯j.Assume that for a given j ∈ {1, …, p},z¯j>zjmax(u). Suppose, to the contrary, that(z¯j,u−j)is not a local upper bound forN∪{z¯},that is, it dominates a local upper bound ofU(N∪{z¯}). Hence from Proposition 3.2, there exists u′ ∈ U(N) such that(z¯j,u−j)≤(z¯j,u−j′)(note that in the SA case, the set B defined in Algorithm 2 is empty). Then, we haveu−j≤u−j′,which impliesuj>uj′anduk<uk′for some k ≠ j. Letzk(u)∈N^be the point that defines the kth component ukof u. From Proposition 4.1, we havez−kk(u)<u−k. Thus, since k ≠ j, we havez−jk(u)<u−j′but since u′ is a local upper bound, we must havezjk(u)≥uj′(otherwise zk(u) < u′). Hence,zjmax(u)≥zjk(u)≥uj′. Since we have bothz¯j>zjmax(u)andz¯j<uj′,we obtain a contradiction:z¯j<uj′≤zjmax(u)<z¯j.□Let us illustrate this theorem on the first example instance of Section 4.1.Example 2continuedConsider the situation in Fig. 2a with N = {z1}, where z1 = (3, 5, 7). The points that define the local upper bounds of U(N), namely u1 = (3, M, M), u2 = (M, 5, M), and u3 = (M, M, 7), are:z1(u1)=z1z2(u1)=z^2z3(u1)=z^3z1(u2)=z^1z2(u2)=z1z3(u2)=z^3z1(u3)=z^1z2(u3)=z^2z3(u3)=z1and zmax (u1) = (m, 5, 7), zmax (u2) = (3, m, 7), and zmax (u3) = (3, 5, m).The point z2 = (6, 2, 4) strictly dominates u2 and u3 and we have:z12>z1max(u2)z22>z2max(u2)z32≤z3max(u2)z12>z1max(u3)z22≤z2max(u3)z32>z3max(u3)thus we obtain again the four new local upper boundsu21=(z12,u−12),u22=(z22,u−22),u31=(z12,u−13),andu33=(z32,u−33).According to Theorem 4.3, we can avoid the filtering step of Algorithm 3 if we keep track of the p points that define each local upper bound and only generate the projections ofz¯that satisfy the conditions of Theorem 4.3. The corresponding algorithm is detailed in Algorithm 4.Note that each component of the vector zmax (u) for a given local upper bound u will be used at most once in all iterations of Algorithm 4. That is why it is computed only before its use, namely at Step 5. Moreover, this vector is not sufficient to compute the vector zmax (uj) associated to a local upper bound ujdefined from u. Indeed, as the following example shows, it is required to keep track of all points that define the component values of uj, as is done in Steps 8–10.Example 2continuedConsider a new point z3 = (4, 4, 2) and the local upper bound u21 = (6, 5, M) with zmax (u21) = (3, 2, 7), stemming from z1(u21) = z2 = (6, 2, 4), z2(u21) = z1 = (3, 5, 7), andz3(u21)=z^3=(m,m,M).We have z3 < u21 andz23≥z2max(u21),thusu212=(z23,u−221)is a local upper bound of U({z1, z2, z3}). Since z1(u212) = z1(u21), z2(u212) = z3, and z3(u212) = z3(u21), we have zmax (u212) = (4, 2, 4). As we can see, the last component value of zmax (u212), which comes from z1(u212) = z2, cannot be obtained from zmax (u21) or z3.In the general case, Theorem 4.3 is modified as follows:Theorem 4.4Let N be a finite and stable set of points of Z, and letz¯be a point of Z that is nondominated with respect to N. Consider a local upper bound u ∈ U(N) such thatz¯<u. Letzjmax(u)=maxk≠jmin{zj:z∈Zk(u)}.Then, for any j ∈ {1, …, p},(z¯j,u−j)is a local upper bound ofU(N∪{z¯})if and only ifz¯j>zjmax(u).Let u ∈ U(N) andz¯∈Z∖Nbe a point not dominated by any point of N such thatz¯<u.(⇒)Suppose thatu¯=(z¯j,u−j)is a local upper bound inU(N∪{z¯})and to the contraryz¯j≤zjmax(u). Then, there is k ≠ j such thatz¯j≤zjfor all z ∈ Zk(u). Sinceu¯≤uandu¯k=uk,it holds thatZk(u¯)⊂Zk(u)but for any z ∈ Zk(u),zj¬<z¯j=u¯j. Hence,Zk(u¯)=∅which contradicts Proposition 4.1.Assume that for a given j ∈ {1, …, p},z¯j>zjmax(u). Suppose, to the contrary, that(z¯j,u−j)is not a local upper bound forN∪{z¯},that is, it dominates a local upper bound ofU(N∪{z¯}). Hence from Proposition 3.2, there exists u′ ∈ U(N),(z¯j,u−j)≤(z¯j,u−j′)(possibly withz¯j=uj′).Then we haveu−j≤u−j′which impliesuj>uj′anduk<uk′for some k ≠ j. From Proposition 4.1, the set Zk(u) is non-empty. For any z ∈ Zk(u), we have z−k< u−kand thus, since k ≠ j,z−j<u−j′but since u′ is a local upper bound, we must havezj≥uj′(otherwise z < u′). Hence, there is z ∈ Zk(u) such thatzjmax(u)≥zj≥uj′. Since we have bothz¯j>zjmax(u)andz¯j≤uj′,we obtain a contradiction:z¯j≤uj′≤zjmax(u)<z¯j.□We illustrate the general case on the second example instance of Section 4.1.Example 3continuedIn Fig. 3, we consider the situation with N = {z1, z2, z3} where z1 = (2, 7, 7), z2 = (5, 7, 5) and z3 = (8, 7, 3). We only look at the local upper bound u = (M, 7, M). We haveZ1(u)={z^1},Z2(u) = {z1, z2, z3}, andZ3(u)={z^3}. Thus zmax (u) = (2, m, 3). The projections of a pointz¯that strictly dominates u will be kept as non-redundant local upper bounds depending on the comparisons between the component values ofz¯and zmax (u) only.Algorithm 5 presents the update procedure in the general case. The initialization is done with U(∅) = {M} andZj(M)={z^j},j ∈ {1, …, p}.In Sections 3 and 4, we described two incremental approaches for the update of an upper bound set. In Section 3, the approach is based on redundancy elimination (RE) among local upper bounds, while in Section 4 it is based on redundancy avoidance (RA) with respect to local upper bounds.We first report upper bounds on the total number of local upper bounds associated to a discrete set of points N. Then we study the complexities of the RE and RA approaches. Finally, we present some computational experiments that compare these approaches.None of the incremental algorithms proposed in the literature, even in the SA case, make it possible to directly derive a non-trivial upper bound on the size of any upper bound set U(N) for p ≥ 4.For p = 2, the number of local upper bounds is clearly |N| + 1 (see Example 1). For p = 3 we recall that Dächert and Klamroth (2014) showed that it is upper bounded by 2|N| + 1 and is exactly 2|N| + 1 in the SA case.For an arbitrary p ≥ 2, Kaplan et al. (2008) provide a tight upper bound on the size of U(N). Following Boissonnat, Sharir, Tagansky, and Yvinec (1998) who study the complexity of a union of axis-parallel hypercubes, they show that the number of maximal empty orthants with respect to a stable set N isO(|N|⌊p2⌋). They also provide an instance for which this number isΩ(|N|⌊p2⌋). Therefore, and recalling that maximal empty orthants are in one-to-one correspondence with local upper bounds,O(|N|⌊p2⌋)is a tight upper bound on the total number of local upper bounds associated to a stable set N.In this section, we analyze the worst case behavior of the two approaches. We consider the dimension p of the problem as a fixed parameter. The reference algorithm for the RE approach will be Algorithm 3 while the reference algorithm for the RA approach will be Algorithm 4 in the SA case, and Algorithm 5 in the general case.In the SA case, both approaches first compute the set A of local upper bounds whose associated search zones containz¯. This amounts to |U(N)| dominance tests if U(N) is stored as a simple linked list. If A is small compared to U(N), it is possible to reduce the complexity of these operations. Actually, since the elements of A are those local upper bounds located in the hyperrectangle∏j=1p(z¯j,M),they can be obtained by an orthogonal range query on the set U(N) (see de Berg, Cheong, van Kreveld, & Overmars, 2008, Chapter 5). In the case p = 2, U(N) can be efficiently stored in a simple balanced binary search tree. For p ≥ 3, as in the case of the algorithm of Kaplan et al. (2008), U(N) can be stored in a dynamic p-dimensional range tree (see e.g. Willard & Lueker, 1985), which allows insertions and deletions in O(logp|U(N)|) time and orthogonal range queries in O(logp|U(N)| + |A|) time. We note that augmented dynamic range trees (Mehlhorn & Näher, 1990, Theorem 8) lower the “log” factors to logp − 1|U(N)|log log |U(N)|.We assume that p ≥ 3 since it can be easily seen that both approaches operate identically in the case p = 2. Both approaches consider p|A| candidate local upper bounds.We first consider the SA case. We focus on the operations on which Algorithm 3 (RE approach) and Algorithm 4 (RA approach) differ. They correspond to Steps 5–9 (Algorithm 3) and Steps 3–10 (Algorithm 4), and respectively involve sets Pj, j ∈ {1, …, p}, and P.Proposition 5.1The worst-case complexity of Steps 5–9 inAlgorithm 3is bounded by O(|A|2).The complexity of these steps is dominated by the filtering (Steps 8 and 9) of each Pj, j ∈ {1, …, p}, where |Pj| = |A|, therefore the total time is O(|A|2).□This can be reduced to O(|A|log |A|) in the case p ∈ {2, 3} (Kung, Luccio, & Preparata, 1975) and O(|A|logp − 3|A|log log |A|) in the case p ≥ 4 (Gabow, Bentley, & Tarjan, 1984) using some specialized algorithms.Proposition 5.2The worst-case complexity of Steps 3–10 inAlgorithm 4is bounded by O(|A|).In Algorithm 4, no additional dominance test is performed with the local upper bounds of P, but the valueszjmax(u)need to be computed just before they are needed, each of which takes constant time. Also the references to the p points that define each local upper bound have to be updated which takes constant time for each new upper bound. The total time of these operations is thus O(|A|).□In the general case, the number of local upper bounds against which candidate local upper bounds have to be checked for dominance in the RE approach just grows by an additional |B|. In the RA approach adapted to the general case, namely Algorithm 5, it is possible that |N| points have to be considered in a set Zk(u) at Step 12. This leads to an upper bound on the complexity of O(|N||A|) in Algorithm 5.In practice, however, the size of the sets Zk(u) is rather small depending on how many points in N share the same component values. Note that according to Boissonnat et al. (1998), an alternative approach would be to slightly shift those points in N that do not satisfy SA such that the resulting set satisfies SA. Then Algorithm 4 can be applied, yielding a complexity of O(|A|). Similarly, ties in the comparisons of any jth component values for points zkand zlcould be resolved by a lexicographic comparison “<lex” wherezjk<lexzjlifzjk<zjlor ifzjk=zjland k < l, which would replace the natural comparison “<” between reals (and similarly for “>”) in Algorithm 4. However these approaches yield redundant search zones that, in the context of Algorithm 1, induce redundant solver calls.In this section we investigate the behavior of the RE and RA approaches on random instances.We implemented Algorithm 3 for the RE approach and Algorithm 5 for the RA approach. Both algorithms were implemented in C. The experiments were run on a workstation equipped with an Intel Core i7-3840QM CPU at 2.80 gigahertz with 8 megabytes cache and 32 gigabytes RAM. For both algorithms, we considered the version that does not require SA, since the assumption cannot be made in most applications.As test instances, we generated random stable sets of points N. In order to obtain a new point in the random stable set being generated, we uniformly draw from the integer set [1, K]pand reject the points that are dominated by or dominate any of the previous points. We draw without or with replacement in [1, K], respectively, to obtain points satisfying SA or not. In the general case, the parameter K controls to what extent objective values are shared among feasible points. In the SA case, K is just set to a very large integer. Since in both cases the distribution of each point is conditioned by the requirement that it is neither dominated by nor dominates any previously generated point, the generated points are eventually randomly reordered.We considered instances for p ∈ {3, 4, 5, 6} having 100, 000, 50, 000, 25, 000, and 5000 points, respectively. We generated instances under SA and also with possible identical component values. In the general case, we set K so as to obtain|N|K∈{5,10}. The plots we made in the SA case were obtained by recording intermediate results every 500 points for p ∈ {3, 4, 5} and every 100 points for p = 6. We also considered a pathological instance type in the general case having many duplicated component values among points, with p = 6, |N| = 10, 000 and K = 10.We have drawn 10 instances of each type and the output results were averaged over the 10 runs carried out for each instance type.We provided above a theoretical tight upper bound on the number of local upper bounds in SA instances. Now we consider the empirical number of local upper bounds observed in our test instances for p ∈ {4, 5, 6} (since this number is known exactly for p = 3). The results, which can be obtained by any of the two approaches, are reported on Fig. 4. According to Fig. 4, it seems that on such random instances, the number of local upper bounds grows approximately linearly in the number of points. Kaplan et al. (2008) show that the number of maximal empty axis-parallel boxes in a set of n points drawn uniformly and independently from [0, 1]pis O(nlogp − 1n), therefore the growth observed in our experiments may be superlinear. However, the distribution of our points is not the same since we discard points that dominate or are dominated by previously drawn points and the bound of Kaplan et al. (2008) does not count only maximal empty orthants.Observing from Fig. 4 the apparently linear relation between |N| and |U(N)|, we performed a simple linear regression. We obtained the following slopes for the fitted lines: 6.524 for p = 4, 31.86 for p = 5, and 165.9 for p = 6. This gives an insight on the increase in the number of local upper bounds induced by the consideration of a new point in the search region, i.e. the average|U(N∪{z¯})|−|U(N)|.We also computed the average number of search zones that contain the current point (namely |A|) between two observations. Since these values do not vary much on the tested instance, we provide the averages over all instances of all sizes: 3.999 for p = 3, 21.56 for p = 4, 141.67 for p = 5, and 735.9 for p = 6.From the average|U(N∪{z¯})|−|U(N)|and |A|, we compute the ratio|U(N∪{z¯})|−|U(N)||A|. We obtain 0.5001 for p = 3, 0.3025 for p = 4, 0.2249 for p = 5, and 0.2255 for p = 6. This indicates that the number of additional search zones induced by each search zone that contains the current feasible point remains small.We first provide raw computation times in Table 1, showing the performance of the RE and RA approaches on SA and on general instances.Since the computation times of the algorithms we consider to generateU(N∪{z¯})are both Ω(|U(N)|), we also present normalized computation times. Fig. 5shows running times divided by |U(N)|.According to these results, the RE approach remains the best one in terms of computation time for p ∈ {3, 4, 5}, the values being rather close in the case p = 5. The RA approach however outperforms the RE approach for p = 6. These observations hold for SA and general case instances but the gaps between the relative efficiency of the approaches are larger on SA instances. Besides, additional computational experiments on SA instances with p ∈ {7, 8} showed that the RA approach performs even better above p = 6. Namely, we obtained the following average computation times (RE time in seconds, RA time in seconds): (161.69, 5.046) for p = 7, n = 500, (1 240.11, 27.458) for p = 7, n = 1 000, (24.06, 0.348) for p = 8, n = 125, (423.15, 2.330) for p = 8, n = 250.We also observed in our experiments that, even starting from p ≥ 3, a little fewer component comparisons are made in the RA approach than in the RE approach. Finally, we ran the implementations under Cachegrind, a CPU caches profiling tool. We observed for the RA approach a larger use of the slowest caches, L2 and L3, than for the RE approach. This, together with the smaller average |A| observed on low dimensional instances, explains why the implementation of the RA approach performs worse than the one of the RE approach for p ≤ 5.To observe the effect of highly duplicated component values among distinct points, we also tested the approaches on the pathological instances (p = 6, |N| = 10, 000, and K = 10). The average |U(N)| and |A| are much smaller than in the SA case, being respectively 14 228.4 and 33.44. Due to the fact that many points share the same component values, the sets Zk(u) in Algorithm 5 can grow significantly, reaching the maximum value of 1 109.7, averaged on the test instances. Therefore, the computation time of the RA approach is a little longer than the one of the RE approach (1.95 against 1.51 seconds).

@&#CONCLUSIONS@&#
We addressed in this paper the problem of representing the search region in MOO. The concept itself is used in numerous approaches to compute the nondominated set. We provided several equivalent definitions of the search region. Local upper bounds induce a decomposition of the search region into search zones. We reviewed possible uses of this decomposition to enumerate all nondominated points of an MOCO problem. We presented two incremental approaches to compute the local upper bounds that represent a search region, respectively based on “redundancy elimination (RE)” and “redundancy avoidance (RA)”. The first encompasses an already known algorithm for which we proposed some enhancements to its filtering step. The second is derived from theoretical properties of local upper bounds we studied and avoids the filtering step of the former. Finally, we considered the complexity of the representation of the search region by local upper bounds and gave some insights into the theoretical complexities and the practical efficiencies of the two incremental approaches. In particular, we showed that the RA approach developed in this paper performs better than the RE approach starting from dimension 6 on instances where the objective ranges are not too small.The future work directions are numerous. Although the RA approach is practically less efficient than the RE approach in low dimensions, it maintains, contrary to the latter, a relation between feasible points and local upper bounds. This makes it possible to define a neighborhood between local upper bounds, as in Dächert and Klamroth (2015) in the case p = 3, that can be exploited in order to update the search region more efficiently when a search zone containing the new feasible point is known. Derivatives of the concept of search region defined in this paper could also be considered. Actually, we made no assumption on the feasible points that define the search region, apart from the requirement that they constitute a stable set of points. If e.g. the feasible points are optimal with respect to one objective function, some search zones may be discarded. Note also that the search zones that are defined in this paper are bounded below by the same pointm. It may be interesting to bound below each search zone using some local lower bounds such that the union of the corresponding restricted search zones still contains all unknown nondominated points.