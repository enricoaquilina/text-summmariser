@&#MAIN-TITLE@&#
Message-oriented middleware for smart grids

@&#HIGHLIGHTS@&#
We provide a taxonomy of current standards and architectures for smart grids.We find out requirements for a messaging systems for a smart grid architecture.We provide a taxonomy of current messaging systems.We evaluate three representatives systems against the requirements.

@&#KEYPHRASES@&#
AMQP,RabbitMQ,DDS,XMPP,Publish–subscribe,

@&#ABSTRACT@&#
In order to increase the efficiency in the use of energy resources, the electrical grid is slowly evolving into a smart(er) grid that allows users' production and storage of energy, automatic and remote control of appliances, energy exchange between users, and in general optimizations over how the energy is managed and consumed. One of the main innovations of the smart grid is its organization over an energy plane that involves the actual exchange of energy, and a data plane that regards the Information and Communication Technology (ICT) infrastructure used for the management of the grid's data.In the particular case of the data plane, the exchange of large quantities of data can be facilitated by a middleware based on a messaging bus. Existing messaging buses follow different data management paradigms (e.g.: request/response, publish/subscribe, data-oriented messaging) and thus satisfy smart grids' communication requirements at different extents.This work contributes to the state of the art by identifying, in existing standards and architectures, common requirements that impact in the messaging system of a data plane for the smart grid. The paper analyzes existing messaging bus paradigms that can be used as a basis for the ICT infrastructure of a smart grid and discusses how these can satisfy smart grids' requirements.

@&#INTRODUCTION@&#
The energy grid has evolved from a unidirectional production/transmission/distribution/consumption pipeline to a complex system where every level of the pipeline comprises multiple actors that can produce energy, as well as store it and exchange it with many other actors. Different architectural solutions have been proposed, with the goal of facilitating the operational control of such increasingly complex system. The energy grid can now interact with the final user to control his energy consumption, by either direct control on some of his appliances (for example, the washing machine) or indirect control, by providing fine grain resolution on the cost of the energy at a given day and time, such that the final user tunes up his own schedule for the energy consumption. The grid can also promote cooperation among different prosumers (both producers and consumers of energy) to enable more efficient energy usage, particularly in what concerns consuming on the spot for renewable energies.Traditional techniques cannot cope with the design of energy grids, since these are characterized by a large number of actors and mechanisms, controlled by many different entities, which are kept together by a plethora of connections to exchange energy and data. Thus, the paradigm of the “smart grid” has emerged, in which the interaction between the involved actors is articulated into an energy plane and a data plane, where the latter provides the required information used to orchestrate the efficient allocation of energy to different energy-consuming actors as well as to different storage units.This smart grid paradigm led to the emergence of a plethora of systems and architectures, with many common points as well as many differences. One of the common points is related to the size and complexity of smart grid systems. In fact, an energy grid usually serves a large number of users by providing them the energy they consume. This characteristic, together with the fact that each actor is controlled by an independent entity, leads to organize smart grids using loosely-connected, service-oriented, scalable architectures, communicating via standard protocols [1] and the introduction of a messaging bus [2] can limit the complexity of the system.The smart grid can and must adhere to standards to pursue the three goals [3] of: i) improving interoperability between neighboring systems; ii) limiting the complexity of the system when it scales to a large user base; and iii) opening new markets to technology providers and utilities companies. Currently there are (too) many standards that address the smart grid area, focusing on different components or layers of the grid and providing different views on the system, but the latest standardization activities are leading different approaches to convergence on a common semantics.While adhering to standards is useful to normalize “what” is communicated in the system, the introduction of a messaging bus takes care of normalizing “how” the data is exchanged. The communication functionalities of the messaging bus, and the services supporting it, can be entrusted to a middleware located over the communication stacks but under the business logic of the applications. The middleware abstractions facilitate the interaction between different components, and also between the “mechanisms” elements and the “politics” elements of the smart grid, which are the traditional categories used to divide the system components into two sets performing different functions. The mechanisms collect data from the surrounding environment, and actuate on the physical world. The politics contain logic to perform computations based on the information received by the underlying mechanisms. After retrieving data from mechanisms, and processing the data, the politics send commands back to the mechanisms, to perform energy-efficient and business-efficient actions. Fig. 1highlights the duality between politics and mechanism components.In the most common type of smart grid, the sensors and actuators are too limited in computational power to be able to support a complex protocol, like the ones used in the middleware. The topology is centered on a gateway installed in the users' houses (e.g. the Energy Service Interface (ESI) in the National Institute of Standards and Technology (NIST) vision [4], which will be described in Subsection 2). The gateway manages a subset of the sensors and actuators deployed in the house, and it is connected to the internet to interact with energy services via a data plane. This topology carries the name of Home Area Network (HAN), and in the rest of this work the gateway installed in the user's HAN will be called HAN Gateway, or HAN GW.As far as current smart grids are concerned, a user's house usually hosts a number of HANs, one per each vendor of technology, e.g. one for the solar panels and one for controlling the Heating, Ventilation and Air Conditioning (HVAC) system. In this case, the middleware would extend itself only up to the HAN Gateway; the latter would decode the protocol used in the middleware, and then interact with the sensors and actuators associated with it. The middleware supports multiple event processing agents that exchange information between event producers, event consumers, and other agents.In this paper, we focus on the approaches for supporting the data plane dimension of the smart grid, and in particular the deployment of message-oriented middleware. The remainder of the paper is organized as follows. Section 2 analyzes current standardization efforts and technical initiatives for smart grids and collects the architectural and technological requirements. Section 3 presents messaging bus paradigms and architectures that can potentially satisfy these requirements. Section 4 then provides some use cases, while Section 5 discusses how to select the middleware to be employed to support the functionalities of a particular standard. Section 6 draws some conclusions and wraps up the paper.In the past few years a number of companies, research centers and standardization bodies worked toward facilitating the design and implementation of smart grids. A number of legacy and closed technologies have created parallel subsystems in the HANs of final users, and then have been refined into standards. Afterwards standardization activities had the goal of organizing existing standards and produce best practices to select the right approach to be used in a given smart grid design.This work is centered on ICT middleware that can support the smart grid's data plane, and thus the analysis of the smart grid use case was instrumental for eliciting the requirements for middleware for the smart grid. Not to be lost in systems' details, the internals of existing approaches were disregarded, and instead the focus has been on intended scenarios and requirements of the smart grid.An analysis of existing standards for smart grids can be driven, at top level, by the vision of system engineering, which considers building systems by first providing system architecture, and then refining it into a system design by adding details such as data encoding, and protocols. We consider that existing standards on smart grids can be categorized in three sets, depending on the level of detail they provide such as:Meta-architectures expand the architectural analysis toward embracing different architectures, with the goal of proposing an abstract model which can be mapped onto a family of architectures. A particular architecture is identified as an instance of the family.Architectures limit the content of the standards to the proposed smart grid architecture and to the functionalities that must be supported.Design standards go deep into low-level details, like data encoding and protocols to be employed in the smart grid.Two examples of meta-architectures are the NIST Canonical Data Model (CDM), which proposed a reference model in “NIST Framework and Roadmap for Smart Grid Interoperability Standards, Release 2.0” [4], and the joint effort of CEN (European Committee for Standardization), CENELEC (European Committee for Electrotechnical Standardization) and ETSI (European Telecommunications Standards Institute), which led to a meta-model called Smart Grid Architecture Models (SGAM) [5]. Meta-architectures are too general to draw clear requirements for the ICT middleware that can support it. Anyway, the meta-architectures agree regarding the large scale of the proposed deployments, which leads to the requirement of scalability. Moreover, the actors in the scenario must be able to associate different levels of urgency to their messages, thus the requirement of providing prioritization in the underlying messaging bus.Two important design standards are the Common Information Model (CIM) [6] [7] by the International Electrotechnical Commission (IEC), and the Smart Energy Profile version 2.0 (SEP) [8], which is a profile of the ZigBee protocol suite. Both design standards were developed in order to allow effective data exchange among different information systems, and they mainly specify the interfaces between components of an energy grid, therefore establishing a common language and protocol for interoperability between software modules, potentially from different vendors. As an example, SEP has been developed to map directly to the Common Information Model (CIM), and it adheres to the NIST framework, and thus SEP inherits CIM characteristics. The approach considers that some messages require Quality of Service (QoS), both in terms of message prioritization and of delivery semantics (e.g. delivery guarantees). Finally, the solution must support a scalable and dynamic scenario, since the design standards explicitly consider systems where the interacting applications can be switched on or off while the system is already up and running, the inclusion of new applications and their online update, also very important is the provision of fault tolerance features.Most other standards are part of the “architectures” category. Examples from this group are ETSI M2M (Machine to Machine), defined in ETSI Technical Report TR 102691 [9], and Device Language Message Specification/COmpanion Specification for Energy Metering (DLMS/COSEM). These are similar in scope, since both address data exchange for meter reading, tariff and load control. Their scenarios comprise energy meters empowered with real-time transmission of data regarding energy consumption, which is then used by the customer to tune up its energy usage and by the electricity company to manage the electricity distribution. The scenario supported by ETSI M2M is thus more limited and self-contained than the typical smart grid. The requirements are thus limited to scalability, while the constraint of being based on REST [10] bestows limitations on the flexibility that can be harnessed.The OSGP (Open Smart Grid Protocol) [11] is another design standard published by ETSI. It is intended to support communication between large deployments of smart grid devices and utility companies for billing purposes, but also to control user's consumption in case of energy shortage, and to provide usage information to the user. From the analysis of its scenario, it is evinced that the requirements for supporting middleware are rich delivery semantics to protect sensitive communications, which can be impacted by attackers and network failures. Other requirements derived by the provided description are scalability and dynamicity.Microsoft Smart Energy Reference Architecture (SERA) [12] is an architectural standard that positions itself as complementary to the NIST initiative. The SERA intends to concoct a bridge from NIST standards to related Microsoft products and technologies, by positioning the products in the meta-architecture of NIST. Requirements for a middleware supporting SERA are scalability, rich delivery semantics, and the capability to assign different priority levels (prioritization) to independent information flows.The discussion above highlights a trend in current smart grid systems. When analyzed at the same granularity, all of them are subject to the same requirements: meta-architectures will provide requirements on the scalability of the system and on support for information flows having different priority (prioritization); more details on the concrete architecture lead to considering the changes in the topology (dynamicity), and details on the protocol highlight the importance of rich delivery semantics to protect individual communication flows.The functional requirements described above can be related to the underlying network, leading to the derived requirements on message latency, jitter (also known as time predictability) and Data Bandwidth. Latency is the travel time of a message from its source to its destination, and must be under a given threshold to ensure the scalability and dynamicity of the system. The jitter is the measure of the variability of the message latency over time, and it must be under control to ensure correct delivery semantics. Data bandwidth is the total throughput between sender and receiver, and it must be sufficiently large for scalability and prioritization. Table 1summarizes the requirements presented in this subsection.The requirements are instrumental in selecting the right messaging system, which is the single software component that has the largest impact on the system performance, but some requirements can profit from other characteristics of the platform. Examples are:i)Scalability can leverage on distributed and cloud computing to harvest computational power to serve more actors;Dynamicity can exploit a component-based architecture to hide the changes of one subsystem to the rest of the smart grid and hence to ease the integration of new components and the application of updates while the system is executing;Prioritization can benefit from operating systems and networks that can enforce QoS, or at least to prioritize some of the services and/or processes. Any guarantee to prioritization depends on the capabilities of the operating systems and networks;Delivery Semantics are helped out by a combination of low and high level protocols that offer good reliability to the communication.A smart grid is a complex system where many actors interact, on both the data plane and the energy plane. The resulting complexity precludes the development of monolithic applications, since the software would be overcome by a huge quantity of “housekeeping” details (managing networking, data storage, interaction with electrical hardware, etc.), and the plethora of device drivers that such application should include to be able to interact with the electrical hardware, since vendors have developed many custom protocols for their devices. A middleware has the function of providing abstraction to allow the developer to focus on the business logic of the application (the intelligence behind the choices made by the application). The final effect is a lower time-to-market for applications, and a reduction in the number of bugs in the released software, since the mechanisms of the middleware are implicitly debugged by all the application developers that are using the middleware's functionalities in their projects.Among the functionalities that can be provided by a middleware layer, communication is probably the most prominent. In a smart grid, timely information can improve the efficiency, reliability and security of energy management. Better efficiency comes from the overall monitoring of the electricity network, and from the capability of acting upon loads in order to better adapt to overall and local energy production from traditional and renewable sources, since renewable sources are affected by fluctuating weather factors. The increase in reliability and security arises from the capacity of real-time monitoring and actuation over the network.A middleware layer must satisfy at least two different needs of the smart grid as follows:i)Communication for decision-making: some of the decisions that must be taken in the smart grid depend on information that is not produced locally. For example, utility companies can decide the energy price at a given time of the day just some hours in advance. Saving money by consuming energy when it is cheaper can be done only if energy prices are received from the utility companies in a timely manner.Cooperation between the smart houses: some level of interaction is needed to orchestrate the operations of the energy consumers, for example to switch on/off the appliances of houses at different times. In fact, should every house switch on/off the appliances using a deterministic algorithm based on global parameters only, like the price of energy, every house would switch on its appliances at the same time, thus creating a hot spot that can result in black-outs for the excess of energy consumption.Communication middleware can be categorized as Remote Procedure Call (RPC) oriented Middleware, Transaction-Oriented Middleware (TOM), Object-Oriented/Component middleware (OOCM) and Message-Oriented Middleware (MOM). Fig. 2displays these categories.A Remote Procedure Call (RPC) middleware provides functionalities and infrastructure to call procedures on remote systems, without worrying about the communication details. Any API call that involves RPC interface is synchronous to the user, since it waits until the server returns a response; even if it is possible to encapsulate the API call in a multi-threaded workflow to asynchronies it, the resulting system would be not scalable and with a low fault-tolerance capability [13].A Transaction-Oriented Middleware (TOM) is used to ensure the correctness of transaction operations in a distributed environment. It is primarily used in architectures built around database applications [14]. TOM supports synchronous and asynchronous communication among heterogeneous hosts, and it eases integration between servers and database management systems.An Object-Oriented/Component Middleware (OOCM) is based on object-oriented programming models and supports distributed object request. OOCM is an extension of Remote Procedure Calls (RPC), and it adds several features that emerge from object-oriented programming languages, such as object references, inheritance and exceptions. These added features make OOCM flexible, and add to its expressivity [15].A Message-Oriented Middleware (MOM) allows message passing across applications on distributed systems. A MOM provides several features such as: i) asynchronous and synchronous communication mechanisms; ii) data format transformation (i.e. a MOM can change the format of the data contained in the messages to fit the receiving application [16]); iii) loose coupling among applications; iv) parallel processing of messages; v) support for several levels of priority.Considering the paradigms introduced above, and the requirements of the smart grid, it is possible to argue their suitability in middleware for smart grids. The RPC model is focused on distributed systems based on client–server model, while it is not a preferred choice for event-oriented applications, since its interactions are inherently synchronous hence limiting its scalability to large volumes of data. Transactional middleware aims at providing safe interactions with one or at most a small number of databases, it enriches the data with controls and redundancies for data safety, and it results in low scalability in both the data volume that can be handled, and in the number of interacting actors; moreover, according to [17] the QoS guarantees they provide are often unnecessary or undesirable for most applications. Object-oriented middleware has synchronous requests as its default form of interaction, however many systems include support for asynchronous communications. Not being designed for concurrent event management, these usually do not attain the same level of performance as systems explicitly designed for the event-based interaction paradigm [18]. Since data of smart grids are collected and exchanged as the result of events, the interaction paradigm of choice appears to be the Message-Oriented Middleware (MOM) [19].Delving more deeply into MOMs, it appears that they come in different “flavors” and they can support one or more communication paradigms, which can be broadly categorized as:i) Message Passing, which involves direct communication between applications. The interacting parties are defined explicitly, and the main communication abstraction is the channel between two applications. In message passing MOM, the middleware has the role of facilitating the setup of the channel, for example by resolving “names” of the applications to their network addresses, but it does not mask the identity of the interacting parties;ii) Message Queuing, where the communication is performed via message queues. The middleware hosts facilities to create and access message queues, which are named entities that receive messages from different applications and dispatch them to all interacting parties that have subscribed to the queue, in a First In First Out (FIFO) manner. A special cases of message queuing is Publish/Subscribe, where messages are actually events that are “published” to peers that “subscribed” to them. In particular, Publish/Subscribe systems can be:a)Topic-oriented, if subscribers receive all messages published to the topics they subscribed to. In this interaction paradigm the topic takes the place of the message queue;Content-oriented, if messages are delivered to subscribers based on conditions that filter the events. This can be built using “topic-oriented” systems by considering the pipeline that delivers the message to the subscriber, and inserting into it a filtering application that performs deep inspection of the messages.Data-oriented interaction, where parties share data structures, and every change to the data is “published” to the other parties. Usually, a limited set of peers can change the data, and the rest can only receive data changes. If a new peer gets into the system: instead of sending him all the messages regarding the topics it is interested into, the middleware can send him just the final status of the data it subscribed to.A Publish Subscribe Message-Oriented Middleware (PSMOM) encapsulates the communication primitives related to that interaction paradigm, and provides asynchronous and highly scalable many-to-many communication model [20]. In this scheme, senders and receivers of messages interact through an intermediary, the PSMOM. The sender of the message, called publisher, is not aware of the identity of recipients (subscribers), and it publishes its messages to the PSMOM. Subscribers are enabled to receive the messages from the PSMOM by performing subscriptions of the information they are interested in.The publish/subscribe scheme concurs to creating systems decoupled in terms of space, time and synchronization. Space decoupling means that publisher and subscriber do not need to be aware of each other's location or identities. Time decoupling means that publisher and subscriber do not need to be online and actively collaborating in the interaction at the same time. Synchronization decoupling allows asynchronous notification of subscribers by using event services callbacks.Fig. 3depicts an example of topic-oriented PSMOM where four applications connect to a MOM broker. The Publisher application sends messages to Topic 1 and Topic 2. The topics operate as relaying systems, forwarding related messages only to interested subscribers. In the case at hand, Subscriber A subscribes to Topic 1, Subscriber B subscribes to Topic 1 and Topic 2, and Subscriber C subscribes to Topic 2, and all receive messages according to their subscriptions.The rest of this section will discuss examples of MOMs. In particular, Extensible Messaging and Presence Protocol (XMPP) [21] will be the placeholder for message passing systems, AMQP [22] will be the representative for message queuing and PSMOMs, and Data Distribution Service (DDS) [23] will be used as the data-oriented interaction system of choice. We will not report any content-oriented message queue system, since they choose the message recipient by performing deep packet inspection; this latter characteristic leads to high computational complexity and causes severe limitations on their performance and scalability, thus impeding their market acceptance.The Extensible Messaging and Presence Protocol (XMPP) is an open eXtensible Markup Language (XML) protocol specified by the Internet Engineering Task Force (IETF) for near-real-time messaging, presence, and request–response services [21]. This protocol is of the message passing kind, since applications do not abstract from the identity of their peers. Still, its main applications are based on extensions to the basic XMPP protocol, and are:-The creation of multi-user chat rooms, similar to Internet Relay Chat systems [24]Application-layer publish/subscribe systems, where the clients are the interacting parties and the server is the router of the messages [25]In fact, XMPP was originally developed for instant messaging applications in the project Jabber, and it has characterized by the large number of protocol extension it received. For example, XMPP has been extended to support voice and video communications. The main implementation of the protocol aims at scalability, having the goal of delivering data from a large number of connected devices to many user applications. The built-in functionalities of XMPP include XML streaming, encryption using Transport Layer Security (TLS), authentication, Unicode support, and information about publishers' and subscribers' presence in the network.XMPP was introduced to get past the limitations of the traditional architecture of the internet, which is based on cumbersome HTTP-like protocols and request/response paradigm. XMPP introduces stateful communication that can keep track of sessions between the server and the clients. XMPP is based on the client/server paradigm, and Fig. 4shows its general overview. Two applications, identified by a unique identifier called Jabber Identification (JID), can communicate by connecting to a XMPP server and exchanging XMPP messages, which are routed through the servers down to the message's destination.XMPP specifies that communication happens via three different kinds of communication snippets called XML stanzas: Message, Presence, and IQ (info/query). The Message stanza is sent from one entity to another, adhering to the “push” paradigm, and among its uses there is instant messaging. The Presence stanza is used to publish messages to all involved subscribers, and it usually manages notifications regarding the applications that are active in the XMPP network. The IQ stanza is used to send a message that must be followed by a response, like in REST, and it is used to set up connections for streaming of either XML, or out-of-band binary data. In fact, while all in-band messages are encoded using the XML format, out-of-band messages can be used to transport binary data for efficiency reasons.This subsection discusses the Advance Messaging Queue Protocol (AMQP) protocol [22], which is our representative for the topic-oriented message queue paradigm. The well-known publish/subscribe bus RabbitMQ [26] is an open source messaging broker, and the most popular implementation of the AMQP protocol.AMQP defines the full protocol specification, comprising both the message encoding, and the semantic actions that correspond to the messages. Applications can communicate by sending messages to a server of the AMQP overlay, which acts as message broker. As shown in Fig. 5, the application can subscribe to a given channel, and can send messages to a channel, which will be delivered to all the applications that subscribed to the channel. AMQP divides the brokering task between exchanges and message queues, where the first is a router that accepts incoming messages and decides which queues to route the messages to, and the message queue stores messages and sends them to message consumers.The message queue abstraction inherently supports the chain of responsibility design pattern [27], which pipelines a complex task into smaller steps. Each application in the pipeline acts on the message along the way, adding to the message and/or modifying its form, and finally rejecting it or passing it to the following application via another message queue.A feature of AMQP is the option to define a message as “persistent”. This implies that the message is stored on the AMQP server and, whenever a new application gets into the system, it will receive all the persistent messages, to be put on-track regarding the current status of the distributed system. This mechanism provides an automatic boot-up mechanism for applications, since they will be informed regarding the current status of the system, stored into the persistent messages, and the applications will be able to act like applications that have been in the system for some time. On the other hand, if too many messages are stored, their delivery to new applications will create much traffic and introduce unpredictable delays into the new applications' boot-up.The Data Distribution Service for Real-Time Systems (DDS) [23] standard has been defined by the Object Management Group (OMG) organization, to create a data-oriented messaging system. DDS has been designed with an emphasis on high-performance and predictability, where the former is ensured by a lightweight architecture, and predictability is ensured by its capabilities to reserve resources by enforcing prioritization on the communications [28].DDS is based on the Data Centric Publish–Subscribe (DCPS) model, which models a distributed global data space (represented in Fig. 6). This distributed shared memory is reachable by participating nodes via a set of interconnected servers. Publishers are applications that write information to the distributed data space, while consumers are applications that are able to read on the distributed data space. Consumers are registered onto the DDS middleware, thus when data is created or modified by the publishers, DDS takes care of propagating the related changes to the data to all subscribers.DDS uses a data model based on structures, which are identified by a topic and a type. The topic provides a unique identifier to the structure within the global data space. The type provides structural information, needed to inform the middleware on how to manipulate the data and to provide type safety. When updating a data structure, a client uses the type information to perform a preliminary check on the correctness of the update, and thereafter uses the topic to deliver the update request to the correct DDS server. The DDS middleware will be in charge of performing sanity checks on the update at hand, apply it on the data structure, and contact all subscribed clients.DDS provides data structural persistence, meaning that an application receives at boot time the current state of the data it subscribed to. This is more efficient than the mechanisms of message queue systems, since the latter ones would deliver a message for each change that has been made to the data structure.Apart from its data model, DDS is characterized by its set of QoS policies for guaranteed data delivery, real-time performance, bandwidth reservation, redundancy, and data persistence. DDS was standardized to let multiple companies develop their own DDS stack, and the standard addresses the whole stack, comprising middleware architecture, the Application Programming Interface (API) to access its services, and the message formats used in the protocols. The goal of this standardization process is to provide interoperability between DDS stack produced by different vendors.The three approaches that were discussed are not in contrast with each other, and can actually be seen as mutual refinements.It is possible to assemble a message queue system from a message passing system by creating an ad-hoc application having a globally known name, like it is done in the case of RabbitMQ solution [26]. The application will act as a broker and it will take care of managing subscriptions of queues, with the queue name contained in the payload of the messages. Similarly, the broker application will receive data messages that contain a queue name, and it will relay the messages to all the applications that “subscribed” to that queue name.Similarly, it is possible to assemble a data-oriented messaging system from a message queue system by simulating the shared memory space via two queues per data structure, one for updating the data structure and one to receive notifications regarding data structure changes. The queues will communicate with an application that manages the data structure, receiving changes and providing updates to the subscribers of the data structure.It is possible to refine every system under consideration by adding complexity into the architecture, for example by adding more connected server applications for redundancy and high performance. A custom message queue system built on top of other paradigms can present a better performance than COTS message queue systems, since custom systems are focused on solving the technical problems of a particular application, while COTS systems are more generic. Obviously, this kind of development would take time and programming and testing efforts. This is a natural trade-off between the performance of the final system, and the time-to-market of the application. There is no one-take-all solution, but every applicative scenario needs its own technical and economic analysis.In order to allow for a better understanding of the different nature and applicability context of these messaging systems, this section provides some examples on middleware designed to support the smart grid data plane.The example discussed in this section is part of the Arrowhead project [29], which addresses the energy and competitiveness challenges by studying new dynamic interactions between energy producers and energy consumers, machines, people and systems. Arrowhead bases its architecture on a Service-Oriented Architecture, which is regarded as a suitable paradigm for collaborative automation in an open-network environment connecting large quantities of embedded devices [30].Among the different pilots of Arrowhead, its virtual market of energy builds upon the smart grid to implement the flex-offer concept. Fig. 7depicts one of the interconnection solutions that can be used in an Arrowhead-compliant system using the virtual market of energy.Flex-offers are a type of Demand/Response (DR), in which an energy consumer (a device) is capable of expressing its consumption flexibilities, in terms of time and power. A Flex-Offer Agent (FOA) is responsible for transmitting flex-offers to an Aggregator, which is then capable of joining flex-offers from several FOAs and places a larger flex-offer on an energy market. If the offer is accepted by the market, the Aggregator replies to the FOA that controls the device.In this architecture the communication between the Aggregator and the FOAs is implemented using XMPP, and exploits the Arrowhead Framework services to establish the most adequate connections and to control the connection status.The FOA was designed to be executed as a software module, which can run on multiple devices; in the case of Fig. 7 it is executed on the HAN Gateway. The architecture is based on two hierarchical levels. The first level connects the HAN Gateways with the devices using XMPP extensions for the Internet of Things (XEP-0323) [31]. XMPP is particularly suitable for this scenario due to its capability to support the Publish/Subscribe communication paradigm, which provides an asynchronous and highly scalable many-to-many communication model.Communications between FOAs and Aggregators are performed on an independent XMPP bus (in Fig. 7 named XMPP1), which integrates the Arrowhead Framework modules for system discovery, orchestration and authorization. The main advantage of this architecture relies on its capabilities of interoperability and on the decoupling between Publishers and Subscribers, in time, space and synchronization, which simplifies the implementation of FOAs and of the Arrowhead Framework modules.Several types of Aggregators might exist, and some Aggregators can be more specialized on certain types of devices. Choosing the most adequate Aggregator also depends on the geographical area, thus to obtain the address of a proper Aggregator, a FOA uses the Service Registry module, to register itself, and the Orchestration module (to obtain an Aggregator that matches its criteria). The Orchestration module contains information about connection rules and system configuration. Security services are provided through the Authorization module, which implements authentication supported on combination of Public key Infrastructure (PKI) and X.509 certificates. All communications can be encrypted by using XMPP [21] over Transport Layer Security (TLS).The coexistence of different services on the messaging bus, together with the different paradigms of interaction used (publish/subscribe vs request/response) and to the potential extension in the direction of adding more services in the system, leads to choosing a more general messaging bus, based on message passing (XMPP). Moreover, XMPP allows the system to be extended by the application of XEPs.Most importantly, XMPP is also in a process of being standardized as a protocol for the control of Demand Response applications for OpenADR [32] and on the ISO/IEC/IEEE 21451-1-4 [33] standards.The ENCOURAGE project [3] aims at developing user-side smart grid technologies, for the seamless interaction of existing devices by different vendors, fine-grained remote control of user's appliances, and energy brokerage between neighbors.The ENCOURAGE platform [3] considers the world divided into macrocells, which are sets of residential and commercial buildings which are co-located in the same area, share the same environmental condition (weather), are connected and can exchange energy. The macrocell is further divided into cells, which are residential/commercial space that pertains to the same user economically. The ENCOURAGE architecture, depicted in Fig. 8, is articulated into 4 modules as follows:-Energy Brokerage and Business Intelligence module, which considers energy usage of the whole macrocell, optimizes energy exchanges and consumption schedule, and provides off-line report.Supervisory Control module, which works at the level of the cell and computes strategies to allocate the energy available through the EB&BI module in the most efficient way, and sends commands to actuators and appliances installed in user's homes.Middleware module, which takes care of connecting the other modules, encoding data in XML format (CIM based), and delivers data efficiently by means of communication through a AMQP-based messaging bus.In particular, the middleware module comprises a Virtual Device (VD) that takes the roles of-Cache, by keeping the current status of each sensor and actuator in the system, to provide the datum to querying components without contacting devices in user homesDatabase handler, by interacting with a database to keep a historical entry for each message that passes through the middlewareRouter, by relating the unique id of a device to the gateway that must be reached to contact the deviceENCOURAGE provided a fully defined and stable architecture, being clearly aligned with the publish/subscribe interaction paradigm, and where performance was a key driver. Due to this, the choice was made for a messaging bus specialized for topic-oriented message queuing communication, which provides better system performance for messages exchanged via publish/subscribe, and faster time-to-market.This section describes an alternative design for the ENCOURAGE middleware for smart grids. The usage of DDS as the messaging bus underlying data exchange can provide easier implementation of data dissemination and outsources its efficiency to the mechanisms provided by DDS, while not impacting much over the functioning pertaining to the request/response paradigm. Still, the system designer has to relinquish the control over to the messaging bus; even the large configuration space of DDS cannot compete with providing one own's implementation on the application layer. Thus, the optimal solution to this trade-off depends on how much the stress is on the fine grain control on data communication and on the side effects to be performed together with communication.Let us consider the design presented in the previous subsection and let us remap it over a DDS-based middleware, starting the analysis from the communication between the components, as represented in Fig. 9.Basically, every exchange is substituted by a distributed namespace having the same name of the exchange, and the routing keys are mapped on the hierarchical data contained in the namespace.In the case of the data flow from the Virtual Device module up and vice versa, the system requires data communication and a notification system for when communication has happened, and these actions are covered by the DDS messaging bus.Communication of data from the HAN to the VD can be done through basic DDS distributed data sharing, but the other way around (controls sent from VD to the HAN) must provide an acknowledge mechanism for robustness sake; the latter can be implemented by another distributed data structure used just for acknowledgment notification.The responsibilities of VD are as follows: router to relate device name (id) to the correct HAN, register for online devices, caching of current values, interaction with DB for storage of data historicals. While the caching of current value can be done directly by the messaging bus, storing historical data directly in the distributed data space can lead to low performance since the distributed data space would become very large; thus, there is still the need for an application to store data on a DB. Registry and routing functionalities can be implemented through a distributed namespace, even though the logic for the wiring of the connections (choosing the correct elements in the distributed namespace) would have to be moved to each component; the other option is to have the logic kept into a specific component. Thus, the VD cannot be substituted directly by the messaging bus, at least for sake of performance. Should performance not be an issue, VD could be completely disregarded, by moving its logic into the middleware library used by the components to implement their interaction with the messaging bus.The design presented in this case study was based on an analysis that showed that not only it was possible to limit the interaction paradigm to publish/subscribe, like in the previous case study, but also that some functionalities of the system could be simulated directly by a specialized messaging bus. While in the comparison between message passing (XMPP) and topic-oriented message queuing (AMQP) the trade-off was flexibility vs performance and time-to-market, this time a more specialized data-oriented message queuing messaging bus led to less code to be developed, and thus faster time-to-market and better maintainability, since some functional requirements were already satisfied by the underlying messaging system and needed no component; on the other hand, data-oriented message queuing buses such as DDS do not allow fine grained control on the actions to be performed after each event, thus impeding optimization of the system and potentially causing performance loss.The particular requirements of smart grids impact on the definitions of the layers supporting them. The capabilities of a message oriented-middleware (MOM) play a critical role in the overall system performance especially with the increasing demand from applications that require soft real-time publish/subscribe services. Thus, the data plane of a smart grid needs to grant correctness and time predictability to the information it transports.In the discussion that follows, we elaborate on the analysis of Section 4, which provides a set of requirements for middleware supporting a smart grid (Table 1), by analyzing the MOMs described in Section 5 in relation to: prioritization, delivery semantics, scalability, latency, time predictability (low jitter), dynamicity, and data bandwidth.Expressing and implementing politics regarding Prioritization is important in time-critical distributed systems. The requirement of message priority mechanisms impacts on the broker decisions on ordering and dropping messages. Publishers assign relative priorities to their messages, to control the broker's queues; subscribers allocate the relative priorities among their subscriptions.In XMPP, Resource Application Priority extension protocol (XEP-0168) [34] allows a client to specify the priority of an application, over other applications of the same client, with the purpose of assigning more (network) resources to more important applications. The XMPP “application” definition is deliberately loose and defined by examples (possible applications are messaging, voice chat, collaborative editing, etc.). XMPP has not a mechanism to prioritize routing in multi-hop paths, hence the priority involves the first “hop” only, and after a message is sent, the rest of the delivery mechanism is plain TCP/IP.In systems built over AMQP, a publisher prioritizes messages by assigning a value from 0 to 9 to each message, to specify that the message must be transferred between queues before lower priority messages. This mechanism in not related to a single client, and it is instead imposed on a global level, hence all the elements of the distributed system must agree on common values for the same levels of priority.DDS provides QoS policies for the definition of message transport priority. The transport priority QoS policies allow a DDS application to deliver messages with different priorities. DDS has got the advantage of proposing different means to cope with message priorities and ordering, while XMPP and AMQP propose basic approaches to prioritize messages. The flexibility of DDS can be interesting for a variety of applications but, in the case of smart grids, prioritized message delivery is required only for fast and time predictable delivery of commands to appliances, and to specify looser time constraints for historical data transfers. Thus, AMQP and DDS are the best mechanisms as far as this metric is concerned, since XMPP only prioritizes the first “hop” from the source to the destination.Delivery semantics involves mechanisms to protect communication from message losses, duplicated messages, and messages re-ordering. By bestowing the responsibilities on Delivery Semantics on basic network mechanisms, like the IP layer, as it happens with UDP, best effort delivery semantics is prone to all the problems related to best effort communications, which means that there is no reliability guarantee and messages can be duplicated and re-ordered. While direct communication can easily implement delivery semantics by for example using TCP mechanisms, publish–subscribe communication must use more refined techniques for message re-transmission. In the case of smart grids, Delivery Semantics allow the subscriber to maintain a logical order over changes made by multiple publishers to the virtual representation of a smart grid element, combined with using timestamps on produced messages to take care of re-ordering.In XMPP, the Advanced Message Processing (AMP) (XEP-0079) [35] protocol allows publisher and subscriber to define additional delivery semantics for advanced processing of XMPP message stanzas, including reliable data transport. Anyway, concurrent changes to common data structures can impact the correctness of distributed applications, since the final states of semantically identical applications can be different.AMQP uses queues with guaranteed delivery to a single recipient. Since messages have to get through bottlenecks represented by queues, concurrent changes to a resource are implicitly serialized. AMQP ensures content ordering by exploiting the TCP/IP transport layer. Messages are delivered in the order in which they are sent.DDS provides a QoS policy for reliability that specifies two different data delivery guarantee modes, named “Reliable” and “Best Effort”. Reliable guarantees mean that all messages in a “Data Writer” history will be delivered to the correspondent “Data Reader”. Best effort indicates that a message is only sent once, and should the transmission fail, the message will be lost. Moreover, DDS provides QoS policies to control the order of received messages.XMPP appears worse off with respect of this metric, while AMQP and DDS are both capable of expressing Delivery Semantics that are rich enough for smart grid application.The functional requirement of Scalability and the network behavior in terms of network Latency and time predictability (low jitter) differ from the case of usual internet communication. In fact, smart grid communications are many-to-some for data collection from the Home Area Networks of the users toward the service centers, and one-to-one to deliver the commands from the service centers to the HANs. These requirements favor systems that provide an abstraction over the identity of the subscribers, like message queues and data-oriented systems, since it disencumbers clients from maintaining a list of the peers that subscribed to their data. Except for the discussion on the programmability of scalable systems, the efficiency of the systems reduces to three views, the network point of view, the publisher point of view, and the subscriber point of view.As far as network is concerned, latency relates to the time that the message takes to be transported over the network. From the publisher side, the delivery time of the messages can be critical since some messages, such as control messages (e.g. to take care of potential outages), are useful only within a bounded amount of time. Important aspects related to publish/subscribe systems' latency are the topology of the system, the routing protocol, and the broker's workload. In fact, the topology gives an assessment of how many brokers exist in the path between publisher and subscriber, and what is the impact of the MOM layers in this delay. The routing protocol influences the latency since the travel time among different hops can vary, depending on how the overlay network routes messages among nodes [36]. Finally, part of the latency is not caused by network transmission, but instead it is the time a message spends in each broker waiting to be processed, and it depends on the broker's load.The XMPP protocol is basically a best effort protocol with an Extension Protocol (XEP) that supports QoS functionalities. XEP-0203 [37] provides timestamp information regarding stored messages, which can be useful in case of late delivery, so that if a message is delayed, the original send time can be determined.Beside time-stamping messages to measure latency, AMQP uses a method called “pre-fetch” to determine how many messages will be sent before the customer acknowledges a message. The objective is to send message data in advance, to reduce latency [22].The DDS protocol aims at low message latency and jitter by using fewer layers in comparison with other middleware technologies. DDS supports a number of QoS policies, providing guarantees on the maximum latency for data delivery, latency budget, reliability of data delivery, priority of data delivery, and deadline policy; if used in the correct way, this set of QoS policies can reduce latency and jitter significantly. The latency-budget policy defines the maximum acceptable delay from the time the data is sent until the data is received by a subscriber application. The deadline policy specifies the maximum inter-arrival time between messages, and it defines the maximum duration that a “Data Reader” expects to elapse between the change of a value, and the update of the values contained in each subscriber's instance.XMPP does not have active control on latency and jitter. AMQP has mechanisms to improve (minimize) latency. On the other hand, DDS goes one step further by making efforts to cope with time predictability by enforcing reliability in the communication, at the cost of a more complex programming of the system.Supporting Dynamicity implies that the system is able to perform fast reconfiguration as the smart grid participants change over time. Apart from the limits of the underlying network, which are related to the available bandwidth, the requirement of Dynamicity copes with fast adding and removal of elements in the network, and with fast recovery of the shared state of the distributed system into the new element of the network.XMPP does not have the concept of distributed state. Interactions are performed by means of remote procedure calls, and a new peer must contact explicitly other elements to retrieve data regarding current distribute state. This implies a burden on the programming, and the need to implement primitives that are native in other communication paradigms.AMQP uses different delivery modes for different kinds of data, to specify if a message needs persistence. “Persistent” messages are provided to new peers by saving them in a log file, and sending them to each application that associates to the middleware in the future. If the system selects persistency for many messages, every time that a new client associates to the system a large amount of traffic is generated to deliver every persistent message to the new client. An alternative is to save only a few messages into the persistent log file to fast reboot some important data structures, and act like XMPP for the rest of the distributed state.DDS is data-oriented, hence it keeps trace of the current state of shared data structures. The internals of DDS keep trace of shared structures, and provide persistency to them instead of the messages related to data changes. The result is that a much lower traffic is generated for each persistent data structure.With respect to this metric, DDS is a clear winner. Anyway, if the system maintains virtual representations of smart grid devices, there are probably applications updating the state of the devices, and these applications could use databases or log files to save their state, hence implementing a data-oriented persistence, limited to data actually requiring it.The overall Data Bandwidth of the system depends on the throughput of the broker and the size of each message. In this case publishers can identify the upper and lower bounds for the output stream and a subscriber can limit the maximum bandwidth used for receiving the messages. The different paradigms we considered in the last sections are not focused on maximizing Data Bandwidth, still it is interesting to analyze the mechanisms and functionalities available. These are representative of the communication paradigms and hence they can provide insights regarding what can be done to improve Data Bandwidth while still abiding to the rules of a communication paradigm.The protocol defined by XMPP XEP-0138 [38] defines an extension standard for negotiating compression of XML streams that supports a wide range of compression algorithms, and early measurements showed that it can reduce bandwidth usage up to 90% [21]. The protocol Jingle RTP Sessions (XEP-0167) [39] enables applications to communicate through negotiated sessions that use the Real-time Transport Protocol (RTP) to exchange voice or video data, which has the drawbacks of best effort protocols, but it is lightweight, minimizing delay and maximizing data bandwidth.The RabbitMQ implementation of AQMP provides facilities to multiplex several connections into one TCP/IP channel, making efficient use of the network ports, and allowing the available bandwidth to be shared among concurrent activities at the application layer.DDS controls network bandwidth by using the “time-based-filter” policy, which defines the minimum inter-arrival time between messages. Also, DDS uses the “resource-limit” policy to control the amount of message buffering in the queues. These policies concur to save network bandwidth, and potentially can provide high throughputs [40]. Moreover, the time-based-filter policy allows handling different production and consumption rates without overflowing consumers. All of the discussed systems are good candidates for smart grids with respect to this metric.Table 2summarizes the discussion of this section regarding the relative merits of the different messaging buses.

@&#CONCLUSIONS@&#
Ensuring high performance and advanced communication capabilities for bidirectional data flows in the middleware layer is a key requirement for systems requiring high scalability, such as smart grids. In this paper, we described the main features of different categories of middleware, and identified reasons to prefer Message-Oriented Middleware (MOM) over the other categories. To effectively take advantage of distributed communication through a MOM, a large-scale data infrastructure must employ a scalable data middleware. The selection of the most adequate MOM technologies for Smart Grid middleware is not a trivial task since the choice depends on the grid requirements and the features they need, such as scalability, reliability, flexibility, security and real-time data.This paper surveys paradigms and technologies that support the MOM communication paradigm. Our analysis led us to the conclusion that XMPP has not been developed in order to support real-time constraints, and it mostly targets best-effort applications. The applicability of XMPP to smart grid scenario depends on the usage of extensions to the protocol, which bring this simple protocol to the level of the more complex AMQP and DDS. AMQP is used for high performance distributed system applications, and it is an open cloud messaging platform for real-time on a global scale. On the other hand, AMQP's focus is mostly on high performance and not on predictability. DDS targets distributed real-time systems [41] and therefore it is capable of addressing complex distributed applications, where prioritization requirements have to be guaranteed.In the case of smart grid applications, message queues and data-oriented middleware are both viable approaches. The data-oriented middleware we considered (DDS) is much more complex but it provides many QoS policies to be used for improved reliability of the middleware, which are not required in the case of smart grid applications. On the other hand, in the scenarios at hand, data-oriented approaches support more dynamic scenarios, and message queues should be enriched by applications maintaining shared data structures to fill the gap and be at the same level of data-oriented middleware.Apart for message queues needing to maintain shared data structures, topic-based message queuing appears to be as good as data-oriented middleware. Having ruled out basic XMPP that does not employ XEP extensions, the choice between DDS and AMQP has to be solved by using different criteria, like monetary cost for using the middleware as codebase of a system, and the current expertise of the developer with the messaging paradigms. When XEP extensions are taken back into the picture, XMPP takes the form of many different protocols, depending of which XEP are in use, and it must be analyzed as a different protocol for each XEP configuration in use, while losing its most appealing characteristic, which is its extensive use, even across application domains.