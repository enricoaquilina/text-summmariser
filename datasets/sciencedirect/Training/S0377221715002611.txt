@&#MAIN-TITLE@&#
A branch-cut-and-price algorithm for the piecewise linear transportation problem

@&#HIGHLIGHTS@&#
We consider a transportation problem with a piecewise linear cost structure.Two new formulations are proposed based on a Dantzig–Wolfe reformulation.One reformulation is extended to an exact solution method.The proposed method is much faster than standard optimization software.

@&#KEYPHRASES@&#
Transportation problem,Piecewise linear,Branch-cut-and-price,

@&#ABSTRACT@&#
In this paper we present an exact solution method for the transportation problem with piecewise linear costs. This problem is fundamental within supply chain management and is a straightforward extension of the fixed-charge transportation problem. We consider two Dantzig–Wolfe reformulations and investigate their relative strength with respect to the linear programming (LP) relaxation, both theoretical and practical, through tests on a number of instances. Based on one of the proposed formulations we derive an exact method by branching and adding generalized upper bound constraints from violated cover inequalities. The proposed solution method is tested on a set of randomly generated instances and compares favorably to solving the model using a standard formulation solved by a state-of-the-art commercial solver.

@&#INTRODUCTION@&#
In this paper we consider the problem of finding a minimum cost flow in a bipartite graph between a set of suppliers and a set of customers. The cost of sending goods on an arc follows a piecewise linear structure (see Section 2) and the problem is thereby a natural generalization of the Fixed-Charge Transportation Problem. This problem is termed the Piecewise Linear Transportation Problem (PLTP), and is a versatile problem that is fundamental within supply chain network design and arises in a number of applications. The general form of the cost functions allows for modeling of different transportation modes such as small packages, less-than-truckloads, truckloads, and air freight (see e.g. Croxton, Gendron, & Magnanti, 2003b; Lapierre, Ruiz, & Soriano, 2004). Additionally, the cost function can be used to model price discounts such as all-unit or incremental discounts, often found in procurement theory (see Davenport & Kalagnanam, 2001; Kameshwaran & Narahari, 2009) or to linearize an otherwise nonlinear cost function.Kim and Pardalos (2000) present a heuristic for the PLTP based on a linearization of the cost function and subsequent solution of a (standard) transportation problem. In Croxton, Gendron, and Magnanti (2003a) the authors show that the linear programming relaxations of three textbook formulations of a piecewise linear function are equivalent. One of them is the Multiple-Choice Model (MCM) used in Section 2.1. Other studies (e.g. Keha, de Farias, & Nemhauser, 2004; Vielma, Ahmed, & Nemhauser, 2008, 2010) have extended this result to include a number of other formulations and they also perform tests to find the best formulation in terms of solving the problem to optimality by a standard solver. The most recent of these studies suggests that when the number of different transportation modes is relatively small (as in our tests), the MCM, presented in Section 2.1, is preferable. As the linear programming relaxation of the standard models is often very poor, we propose two stronger formulations for the problem, both based on a Dantzig–Wolfe reformulation of the problem.In Section 2 we give a formal definition of the problem using the standard multiple-choice formulation and two new formulations. The two new stronger formulations rely on a Dantzig–Wolfe reformulation of the original problem and column generation is required to solve the LP relaxation. The strength of the linear programming relaxation of the formulations is investigated in Section 3, along with the computational experience on a test bed of instances. Based on these results we propose an exact solution method based on one of the formulations, in which we add valid inequalities described in Section 4 and by applying the branching rule described in Section 5. In Section 6 we test the solution method on a number of randomly generated instances and compare the method to solving the MCM by a standard commercial solver. Section 7 summarizes our findings and concludes this paper.In this section we first define the PLTP and introduce notation. Then we introduce a standard formulation and two new formulations of the PLTP.Let the set of supply nodes (suppliers) be denoted by the set I = {1, …, n}. The total capacity of each supplier i is denoted by Si. The demand nodes (customers) are denoted by the set J = {1, …, m}, where customer j has demand dj. The cost of transporting goods from supplier i ∈ I to customer j ∈ J follows a piecewise linear cost structure with κijline segments on the arc between supplier i and customer j, which is also known as the modes. For notational convenience we will assume that κij= κ for all (i, j) and we denote the set of modes by Q. Each mode q ∈ Q from i to j is characterized by a fixed cost for using the mode, gijqand a variable cost (the slope of the mode), cijq. Additionally, the flow using mode q on the arc (i, j) is restricted to a minimum of Lij, q − 1 and a maximum of Lijq(see Fig. 1), where Lij0 = 0. We assume that Lijκ≤ min {Si, dj}, i.e. that the maximum flow between supplier i and customer j does not exceed neither the capacity Sinor the demand dj, respectively. Note that the maximum capacity on an arc might be restrictive, i.e. the inequality might be strict. Hence, formally we consider a separable, lower-semicontinuous, piecewise linear function with κ line segments defined on the interval from 0 to Lijκ(see Vielma et al., 2010 for more on other kinds of piecewise linear functions).One standard way of representing a discontinuous, piecewise linear function is by the so-called Multiple-Choice Model. Using this formulation, the problem can be stated as(1)(MCM)min∑i∈I∑j∈J∑q∈Q(cijqxijq+gijqvijq),(2)s.t.∑i∈I∑q∈Qxijq=dj,∀j∈J,(3)∑q∈Qvijq≤1,∀(i,j),i∈I,j∈J(4)∑j∈J∑q∈Qxijq≤Si,∀i∈I,(5)xijq≤Lijqvijq,∀(i,j,q),i∈I,j∈J,q∈Q(6)xijq≥Lij,q−1vijq,∀(i,j,q),i∈I,j∈J,q∈Q(7)xijq≥0,∀(i,j,q),i∈I,j∈J,q∈Q(8)vijq∈{0,1},∀(i,j,q),i∈I,j∈J,q∈Q.The objective, (1), is to minimize the total costs of supplying the customers. Each customer has to receive an amount equal to its demand by (2). Constraints (3) enforce that at most one mode is used between each combination of supplier and customer. Constraints (4) state that the solution has to obey the capacity at each supplier. Constraints (5) and (6) bound the flow within the associated upper and lower bounds for mode q between the supplier i and customer j, respectively. Variable xijqrepresents the flow between i and j on the mode q and the associated binary variable vijqis 1 if this mode is used, 0 otherwise. The linear programming relaxation of the MCM is equivalent to replacing the objective function by its lower convex envelope (see e.g. Croxton et al., 2003a). We denote by MCM-LP the relaxed problem defined by the program (1)–(8), where (8) is replaced by the constraints 0 ≤ vijq≤ 1, ∀(i, j, q), i ∈ I, j ∈ J, q ∈ Q.The two new formulations are based on the introduction of variables for each feasible flow-vector from either each supplier to all the customers, or from all suppliers to each customer (see Fig. 2). These models are denoted the Supplier-Based Model (SBM) and the Customer-Based Model (CBM), respectively. Both formulations are obtained by applying a Dantzig–Wolfe reformulation of the MCM, while keeping either the demand constraints (2) (for the SBM) or the supply constraints (4) (for the CBM) in the master problem.Let χidenote the set of all feasible flows from supplier i to the m customers with an accumulated flow less than or equal to Siand the flow on each arc (i, j) less than or equal to Lijκ, i.e. χi:= (xij)j ∈ J: 0 ≤ xij≤ Lijκ, ∀ j ∈ J and ∑j ∈ Jxij≤ Si} and Tidenote the set of indices of elements of χi. That is,xit∈χi,for t ∈ Ti, is a vector with m entries and each entryxijtrepresents the flow on the arc (i, j). For each flow index t ∈ Ti, we define the associated costs of the flow byCitand a binary variableβit,which is equal to one if the flow characterized by the vector t is used and zero otherwise. Now, the PLTP can be formulated as(9)(SBM)min∑i∈I∑t∈TiβitCit,(10)s.t.∑t∈Tiβit=1,∀i∈I,(11)∑i∈I∑t∈Tiβitxijt=dj,∀j∈J,(12)βit∈{0,1},∀i∈I,∀t∈Ti,The objective is to minimize the total cost as defined in Eq. (9). Constraints (10) state that for each supplier, exactly one flow in Timust be chosen, assuming that the all-zero flow belongs to Ti. The demand of each customer must be satisfied by constraints (11). Finally, all variablesβitmust be binary.We denote by Tjthe set of indices of elements belonging to the set χjdefined as the set of feasible flows from all suppliers to customer j ∈ J where the total flow is at least dj, while respecting all arc capacities, i.e. χj= {(xij)i ∈ I: 0 ≤ xij≤ Lijκ, ∀ i and ∑i ∈ Ixij= dj}. We still denote byxijtthe flow from i to j for the index t ∈ Tjand letCjtdenote the total cost of flow vector(xijt)i∈I. Using these variables the PLTP can be stated as(13)(CBM)min∑j∈J∑t∈TjβjtCjt,(14)s.t.∑t∈Tjβjt=1,∀j∈J,(15)∑j∈J∑t∈Tjβjtxijt≤Si,∀i∈I,(16)βjt∈{0,1},∀j∈J,∀t∈Tj.The objective is to minimize the total cost as defined in Eq. (13). For each customer one flow that satisfies its demand must be chosen, enforced by constraints (14). By (Eq. 15) the capacity at the suppliers must be obeyed. All variablesβitare binary.The two new formulations, the SBM and the CBM, are both equivalent to the MCM in the sense that a feasible solution to either of them can be translated into a solution for the MCM. This procedure is straightforward and is a matter of looking at a variableβjt=1,for j ∈ J and t ∈ Tj, with a flow ofxijtand setting the corresponding xijland vijlvariables to match this flow in the MCM. Conversely, a solution to the MCM naturally decomposes into a set of flows feasible to the SBM (resp. CBM).However, the way we generate new variables in the two new formulations, which is described in the next section, we only obtain variables with integer values ofxijt. This potentially leads to a suboptimal solution of the two new formulations if the optimal solution to the MCM has a non-integral xijl-value. It is possibly to relax this assumption, but this has two main disadvantages. Firstly, the number of variables in the programs (CBM) and (SBM) will increase which is likely to increase the computational complexity of solving these programs. Secondly, the subroutine used for solving the so-called pricing problems, described in Section 2.5, would have to be modified to handle non-integrality which potentially also increases the computational complexity.One way to avoid this suboptimal solution would be to ensure that an integer-valued optimal solution in terms of the (x, v)-variables exists. This can be achieved by restricting all the Lijq’s, dj’s and Si’s to integer numbers, which is often an acceptable assumption given that rational data can always be transformed appropriately.Another approach would be to relax the binary requirement ofβjt’s. The drawback is that additional measures has to be employed to avoid a solution where a convex combination of different modes is used, i.e. one could obtain fractional values in terms of the vijl-variables. For the SBM one example would be a solution withβ11=β12=0.5,but the flow vectors of the variables represent a flow to customer j using v1j1 = 1 and v1j3 = 1, respectively. This can be avoided by using a branching rule as described in Section 5. A solution to the SBM might exist which has two or more variables strictly positive, provided that they represent the exact same modes used between each customer and supplier. This would correspond to a convex combination of the continuous variables xijlusing the integer-valued (in our case)xijt’s. Besides our branching rule, our test instances possess the property that an optimal solution with integer-values exists. For more on the delicate task of ensuring integrality in column generation we refer to such papers as Lübbecke and Desrosiers (2005) and (Vanderbeck & Wolsey, 2010, Chap. 13).The two formulations SBM and CBM contain a very large number of variables, namely a variable for each feasible integer flow from a supplier or to a customer. We use a column generation scheme to solve their LP relaxations denoted by SBM-LP and CBM-LP due to the large number of variables. Column generation is a general technique which solves iteratively the LP-relaxation by considering only a subset of all the variables (this problem is often called the restricted master problem). New variables are, traditionally, only added when they are candidates to enter a basis of the linear programming relaxation, e.g. has a negative reduced cost for a minimization problem. The problem of identifying the variable with the most negative (or most positive for maximization problems) reduced cost is known as the pricing problem. This process of solving the restricted master problem and finding new variables to add to it is referred to as an iteration. Since variables are often added (and some might be removed) to the restricted master problem, one often refers to the restricted master problem of the current iteration. For a general introduction to column generation we refer the reader to such articles as Barnhart, Johnson, Nemhauser, Savelsbergh, and Vance (1994), Lübbecke and Desrosiers (2005), (Vanderbeck & Wolsey, 2010, Chap. 13), and Desrosiers and Lübbecke (2010). For more on specialized topics, such as new developments within stabilization methods we refer to e.g. Benchimol, Desaulniers, and Desrosiers (2012), Gondzio, Gonzalez-Brevis, and Munari (2013). Another very important aspect of column generation is the ability to efficiently solve the pricing problem(s). In the following we investigate the pricing problems for the SBM-LP and the CBM-LP. We find that the pricing problems have the same structure and can be solved by the same method.Let ωiand ηjdenote the optimal dual solutions associated with the constraints (10) and (11), respectively, in the current iteration of the restricted master problem. A variableβitprices out ifCit−ωi−∑j∈Jηjxijt<0,The problem of identifying the variable with most negative reduced cost can thus be found by solving the following problem for each supplier i ∈ I.(PricingPiSBM−LP)−ωi+min∑j∈J∑q∈Q((cijq−ηj)xijq+gijqvijq),s.t.∑j∈J∑q∈Qxijq≤Si,∑q∈Qvijq≤1,∀j∈J,xijq≤Lijqvijq,∀(j,q),j∈J,q∈Qxijq≥Lij,q−1vijq,∀(j,q),j∈J,q∈Qxijq≥0,∀(j,q),j∈J,q∈Qvijq∈{0,1},∀(j,q),j∈J,q∈QBy adding a dummy customer this problem is readily recognized as a Single-Sink, Fixed-Charge, Multiple-Choice Transportation Problem (SSFCMCTP) for which an efficient algorithm based on dynamic programming is available from Christensen, Andersen, and Klose (2012) and known to beNP-Hard. Note, that only modes for which(cijq−ηj)Lij,q−1+gijq<0,will be considered in an optimal solution for the pricing problem, since a flow of all zeros is feasible. If an optimal solution,(xijq*)j∈J,to (Pricing PiSBM−LP) has a negative objective function value, then this solution represents a flow-vector associated to a new variable that will be added to the restricted master problem of the current iteration. That is, we introduce, in the restricted master problem of the current iteration, a new variableβitwherexijt=xijq*,for those j ∈ J wherexijq*>0andxijt=0otherwise.Let πjand λi≤ 0 denote the optimal dual variables associated now with the constraints (14) and (15). A variableβjtprices out ifCjt−πj−∑i∈Iλixijt<0For each customer j the problem of finding the most negative reduced cost can then be formulated, as(17)(PricingPjCBM)−πj+min∑i∈I∑q∈Q((cijq−λi)xijq+gijqvijq),s.t.∑i∈I∑q∈Qxijq=dj,∑q∈Qvijq≤1,∀i∈I,xijq≤Lijqvijq,∀(i,q),i∈I,q∈Qxijq≥Lij,q−1vijq,∀(i,q),i∈I,q∈Qxijq≥0,∀(i,q),i∈I,q∈Qvijq∈{0,1},∀(i,q),i∈I,q∈Q.This problem is also a SSFCMCTP, which we solve by the algorithm of Christensen et al. (2012). An optimal solution with a negative objective function value will be used to introduce a new variable in the same manner as for the SBM-LP.In this section we investigate the theoretical strength of the new models compared to MCM which corresponds to a standard textbook way of representing piecewise linear cost functions. In addition we investigate the computational effectiveness of the models by presenting their actual strength on a subset of the instances used in Section 6.The theoretical strength is easy to establish. The LP relaxations of the CBM and SBM are at least as strong as that of the MCM, as these two models are Dantzig–Wolfe reformulations of the latter (see e.g. Geoffrion, 1974; Nemhauser & Wolsey, 1999).The theoretical strength does not directly prove that the new models will provide a strictly better bound than the LP relaxation on any instance. To investigate this a number of tests were run to show that it is very often the case on our test bed and next we provide some small examples of the relationship between the different models of linear programming relaxation bound. Note that there is no inclusion relation between the SBM and the CBM as the following examples show.Example 1An Example where z(SBM-LP) > z(CBM-LP) > z(MCM-LP)Consider the following example with two suppliers and two customers. The supplier capacities are S1 = 3 and S2 = 4 and the customer’s demands are d1 = 3 and d2 = 4. The cost functions are specified in Fig. 3and assumed to be the same for either customer. Note that L22k= L221 < min {S2, d2} = 4. The optimal solution to the z(SBM-LP) isForsupplier1:Setthevariableβ11=1withtheflow(03)andcostsC11=4.Forsupplier2:Setthevariableβ21=1withtheflow(31)andcostsC21=8.Thus, z(SBM-LP) = 12 which is the optimal (integer) value. For the z(CBM-LP) the optimal solution isForcustomer1:Setthevariableβ11=1/3withflow(30)andcostsC11=4,andthevariableβ12=2/3withflow(03)andcostsC12=5.Forcustomer2:Setthevariableβ21=1withflow(22)andcostsC21=6.Hence, z(CBM-LP) = 10 + 2/3, which is strictly less than z(SBM-LP). By comparison the LP relaxation of the MCM leads to the solution wherev111=1,v121=1/2,v211=1/3,v221=1x111=2,x121=1,x211=1,x221=3.This solution has a cost of z(MCM-LP) = 9 + 2/3. However, the CBM might provide a better LP relaxation than the SBM as illustrated in the following example.Consider the same setting as in Example 1, but modify the capacities and demands by setting S1 = S2 = 4, d1 = 2, and d2 = 3. One can verify that the optimal solution to the z(SBM-LP) is given byForsupplier1:Setthevariableβ11=1withflow(22)andcostsC11=4.Forsupplier2:Setthevariableβ21=1/3withflow(03)andcostsC21=5,andthevariableβ22=2/3withflow(00)andcostsC22=0,and thereby the total costs are z(SBM-LP) = 5 + 2/3. It can be verified that this solution is also the optimal solution to the z(MCM-LP). For CBM-LP we obtain the solutionForcustomer1:Setthevariableβ11=1withflow(20)andcostsC11=2.Forcustomer2:Setthevariableβ21=1/3withflow(03)andcostsC21=5,andvariableβ22=2/3withflow(30)andcostsC22=4,which means that z(CBM-LP)=6+1/3, which is strictly higher than z(SBM-LP).To test the strength of each of the models, MCM, SBM and CBM, we measure the gap between the value of their LP relaxations and of the optimal solution of MCM. The gap is defined as 100 · (OPT − z( · ))/OPT and the results are presented in Table 1. We confine these tests to the instances from Section 6 with 5 modes. Note that the time to solve the LP relaxations for the MCM and the CBM on all instances was less than 1 CPU second. For the SBM it took significantly longer to solve the LP relaxation and in some cases over 100 CPU seconds, as many more variables were generated compared to the CBM. These results indicate that the CBM outperforms the SBM by far and also the MCM with respect to closing the gap in the root node. As shown in Example 1 this relation does, however, not hold in general. In this paper we consider few-suppliers-many-customer instances, i.e. n ≤ m, since this is the case for most real-world distribution systems. Therefore, the number of constraints kept in the master problem is higher for the SBM than for the CBM, which might favor the CBM. Encouraged by these results we choose to develop our exact solution method by solving the CBM. The following two sections will explain how we add valid inequalities to the LP relaxation of CBM and the type of branching scheme we apply.Though the solution to the current LP relaxation of the program (13)–(16) satisfies the capacity constraints, thexijtvalues of the columns used in this solution might not. To strengthen the formulation, we add cover inequalities, which are valid inequalities based on the knapsack structure of inequalities (15). For more information on cover inequalities see e.g. Nemhauser and Vance (1994), Gu, Nemhauser, and Savelsbergh (1998, 1999), and Wolsey (1998).Let us define a vector A = (aj)j ∈ Jwhere aj≥ 0, ∀j. We say that A characterizes a cover if∑{j:aj≤dj}aj>Si,for some i ∈ I, where djand Sistill denote the demand of customer j and capacity of supplier i, respectively. If A characterizes a cover, then the so-called cover inequality is valid for the CBM∑{(j,t):xijt=aj}βjt≤C(A)−1,where C(A) = |{aj: aj≤ dj}|. Further, the following strengthen inequality, called the extended cover inequality, is also valid for the CBM∑{(j,t):xijt≥aj}βjt≤C(A)−1.Consider, again, the following optimal LP solution to the CBMForcustomer1:Setthevariableβ11=1/3withflow(30)andcostsC11=4,andthevariableβ12=2/3withflow(03)andcostsC12=5.Forcustomer2:Setthevariableβ21=1withflow(22)andcostsC21=6.The vector (3 2)Tcharacterizes a cover since3+2=a1+a2>S2=4.The corresponding extended cover inequality implied is∑{t∈T1:x21t≥3}β1t+∑{t∈T2:x22t≥2}β2t≤1.Note that the addition of this valid inequality will cut off the optimal LP solution.Given a solution(β˜jt)j∈J,t∈Tjto the current LP, an extended cover inequality characterized by some vector A is violated if∑j∈J(1−∑t:xijt≥ajβ˜jt)<1,since C(A) will be at most m. Then, consider variables y(αj) taking value one if the jth coordinate of vector A, aj, is equal to an integer αjranging from 0 to djand zero otherwise. Finding a vector A characterizing an inequality which is most violated by a current solution(β˜jt)j∈J,t∈Tjcan thus be formulated as follows.min∑j∈J∑αj=0dj(1−∑t:xijt≥αjβ˜jt)y(αj),s.t.∑j∈J∑αj=0djαjy(αj)≥Si+1,∑αj=0djy(αj)≤1,∀j∈J,y(αj)∈{0,1},∀j∈J,∀αj=0,⋯,dj.Further, notice that it is only necessary to consider values αjsuch that, in the current solution, there is a positive column whose flowxijt=αj(since otherwise they will only add to the right hand side, specifically to C(A), but not to the left hand side of the extended cover inequality). In other words, if we defineA˜j={xijt:β˜jt>0,t∈Tj}for j ∈ J, the separation problem is(18)(ECiSep.)min∑j∈J∑αj∈A˜j(1−∑t:xijt≥αjβ˜jt)y(αj),s.t.∑j∈J∑αj∈A˜jαjy(αj)≥Si+1,(19)∑αj∈A˜jy(αj)≤1,∀j∈J,y(αj)∈{0,1},∀j∈J,∀αj∈A˜j.This program (ECiSep.) is a Multiple-Choice Knapsack Problem (MCKP) for which a specialized algorithm is available, see Pisinger (1995).We initialize the current LP with CBM-LP. Then, given a solution(β˜jt)j∈J,t∈Tjto the current LP, we identify violated extended cover inequalities, add them to this current LP and solve it again. The added inequalities can be handled very efficiently in our subproblem as explained in the following subsection.Gu et al. (1998) present a way of strengthening the extended cover inequalities by lifting. This technique can also be modified to the proposed method, but tests on a subset of the test instances used showed that this was not an efficient enhancement.When using column generation the addition of valid inequalities is a delicate task (see e.g. Desaulniers, Desrosiers, & Spoorendonk, 2011; Desrosiers & Lübbecke, 2010). It is crucial that the added inequalities do not destroy the structure of the pricing problem. Fortunately, a cover inequality is easy to incorporate into the pricing problem for the CBM. LetAidenote the set of vectors characterizing the extended cover inequalities that were derived from the capacity constraint (15) for supplier i and currently added to the (restricted) master problem, i.e.(20)∑{(j,t):xijt≥aj}βjt≤C(A)−1,∀A∈Ai,∀i∈I.Thus, the restricted master problem to be solved is min{(13) s.t. (14), (15), (20),βjt≥0,∀j∈J,∀t∈Tj}.If we denote by ζAthe non-positive dual variable associated to the extended cover inequality characterized by A, a variableβjtnow prices out ifCjt−πj−∑i∈Iλixijt−∑i∈I∑A∈Ai:xijt≥ajζA<0.Hence, for each customer j, the objective function defined by Eq. (17) of problem (Pricing PjCBM) must be replaced by−πj+min∑i∈I(∑q∈Q((cijq−λj)xijq+gijqvijq)−∑A∈Ai:xijt≥ajζA).This modified pricing problem can still be seen as a Single-Sink, Fixed-Charge, Multiple-Choice Transportation Problem and can thus be solved using the algorithm of Christensen et al. (2012) if additional breakpoints (or modes) are inserted and fixed and variable costs are adapted as follows.First, for each arc (i, j), we add a breakpoint to the cost function (i.e. splitting an existing mode into two modes) for each different value aj− 1. LetQijnewrepresent the set of indices of the added breakpoints for arc (i, j). We denote any breakpoint by Lijq, but if q ∈ Q, it is an original breakpoint and ifq∈Qijnew,then it is a new breakpoint, in which case it is equal to some value aj− 1.Then, if q ∈ Q, its variable cost cijqis unchanged and its fixed cost is replaced bygijq−∑A:aj−1≤LijqζA.Finally, ifq∈Qijnew,let q′ ∈ Q be the index of the breakpointLijq′such thatLij,q′−1<Lijq≤Lijq′. The variable cost corresponding to this breakpoint Lijqis set equal togij,q′−1and its variable cost togij,q′−1−∑A:aj≤LijqζA.The interpretation of this addition of breakpoints and cost adaptation is the following. When pricing out a new variable which has a flow greater than or equal to some aj, then the variable appears in the corresponding Eq. (20) and the dual variable ζjshould be subtracted when calculating its reduced cost. This is implemented by stating that for each element A inAj,we introduce a new mode at aj− 1 which has the same variable cost and upper capacity limit as the original mode, but the fixed cost of this and all subsequent modes will be decreased by ζA, i.e. increased by − ζAwhich is non-negative (see Fig. 4).Hence, the subproblem solved will very often contain more modes than the original problem due to added cover inequalities.That is incorporating the valid inequalities defined by constraint (20) from the master problem into the subproblem reduces to manipulating the objective function of the pricing problem by adding a number of new variables.Any solution,β˜j,to the CBM corresponds to a solution for the MCM, given byv˜ijq=∑t:vijqt=1β˜jtandx˜ijq=∑t:vijqt=1xijqtβ˜jt.A solution is integer if and only if nov˜ijqis fractional (as discussed in Section 2.4). This insight is crucial in developing branching rules for the CBM. In preliminary tests a number of different approaches were tested and based on these results we employ the following branching rule. Given the current LP solution, calculate the cost on every arc asC˜ij=∑q∈Qx˜ijqcijq+v˜ijqgijq.Then calculate the difference betweenC˜ijand the real cost of a flow of∑q∈Qx˜ijqunits on the arc. Branching is done by selecting the arc with the largest difference and the mode that corresponds to this flow. When a variable to branch on, sayv˜ijq¯,has been chosen, the branching is done as follows. On the to-zero branch we require that∑q=q¯κvij¯q=0and on the to-one branch that∑q=q¯κvij¯q=1.This has a nice result of either limiting the flow on an arc to at most Lij, q − 1 (on the to-zero branch) or forcing it to be at least Lij, q − 1 (on the to-one branch), which is depicted in Fig. 5. This kind of restriction is easy to handle in the pricing problem. This is known as branching on a Special Ordered Set 1, a term from Beale and Tomlin (1970). To select the next node to be processed a hybrid estimateselection scheme was used (see Achterberg, 2009). This node selection strategy tries to select nodes with both strong lower bounds, as well as a reasonable chance of obtaining a good primal solution (as measured by a pseudocost, for more see also Linderoth & Savelsbergh, 1997).In this section we describe how a number of test instances were generated and how the proposed method compares to the standard solver CPLEX (version 12.4).We generate a number of test instances in the following way. First of all we consider instances having n ∈ {5, 10, 15} suppliers and m ∈ {15, 30, 50, 100} customers, while the number of modes is from q ∈ {3, 5, 7}. Let U[x, y] denote the uniform distribution from x to y and UI the discretized version. The customer demand is then drawn from UI[20, 100] with expected value 60. The supplier capacity is drawn from UI[0.8 · h, 1.2 · h], where h = 60m/n, hence h is the average demand per supplier. The increase in capacity on an arc is distributed as UI[0.8 · q, 1.2 · q] for each mode, while the fixed cost increase is drawn from UI[2, 10]. The variable cost for mode (i, j, q) is calculated as U[0, (gijq− gij, q − 1)/(Lijq− Lij, q − 1)] and rounded to two decimals. In this way there is a relationship between the fixed cost for using a mode and the capacity of the mode. These instances will have discontinuous, non-decreasing costs as well as integral capacities and demands. Furthermore, the total capacity on an arc is evenly spread among the modes.In Vielma et al. (2010) a number of instances with 10 suppliers, 10 customers and different numbers of modes were presented, and they were also used in Keha, de Farias, and Nemhauser (2006) and Vielma et al. (2008). We also test the proposed solution method on the 100 instances with 4 modes as these are the only instances with integral mode capacities from that test bed. The remaining instances have highly fractional mode capacities, which make a transformation into instances with integral mode capacities nontrivial. Furthermore, these instances might have decreasing costs, which means that the pricing algorithm of Christensen et al. (2012), which assumes a non-decreasing cost structure, cannot be applied as a subroutine. On these instances, we use a straightforward, naive dynamic programming algorithm to solve the pricing problems instead.In order to test the proposed method, we compare it on a number of test instances to the MCM passed to the general solver CPLEX (version 12.4). The tests were conducted on a laptop with a 2.4 gigahertz Intel Core 2 Duo CPU and 4 gigabyte of RAM, running Linux and using the gcc compiler. The proposed method was implemented using the branch-cut-and-price framework SCIP (version 2.1.1, see Achterberg, 2009; SCIP, 2010). We used the concert technology interface for CPLEX and all parameters were set to default except that only one core was used, since SCIP does not currently support multiple cores. The MCM was implemented in a straightforward way using the CPLEX API, but the built-in function to model piecewise linear functions, IloPiecewiseLinear, was also considered. However, the built-in function was clearly dominated by the MCM-implementation and therefore is not shown in the results, e.g. it could not solve any of the smallest test instances within the given time limit. The different choices of suppliers, n, customers, m, and modes, κ, are detailed above and for each configuration 5 instances were generated. In Tables 2–4, for each configuration we present the average time used to solve the 5 instances, the average number of nodes in the branching tree, and the optimality gap in the root node. The latter is presented both with and without the cuts presented in Section 4 for the CBM and for CPLEX with and without the different default cuts. We enforce a time limit of 3 hours of CPU time (10.800 seconds). A number in parenthesis after the runtime indicates the number of instances that could not be solved to optimality within the time limit and a number in brackets indicates the number of instances for which the algorithm ran out of memory. In either case the instance was not included in the statistics. The number in bold indicates the fastest average run time.In general the small instances of Table 2 can be solved rather fast by both methods, with the CBM being the fastest on all instances.In Table 3 we see that CPLEX is consistently slightly faster than the CBM when there are only 3 modes. The CBM exhibits a slightly unexpected behavior when looking at the run-times from 5 to 7 modes. On these instances the run times often decrease, which is counterintuitive. This might be explained by the simultaneous decrease in the optimality gap. The instances from Vielma et al. (2010) seem to be comparable in terms of the runtime for both solution methods. The expected decrease in performance for the CBM due to the naive dynamic programming algorithm being used for pricing is hardly noticeable, probably because of the relatively small instance size.In Table 4 we again see that the CBM is slower than CPLEX when there are only 3 modes. On the largest set of instances CPLEX fails to solve all instances, except one. The CBM solves all the instances and much faster.In Figs. 6,–8 we plot the logarithm to the total solution time for each configuration of both the CBM and CPLEX for the values κ = 3, κ = 5, and κ = 7, respectively, to facilitate comparison. For κ = 3 there is little difference between using CPLEX and the CBM, but the CBM becomes highly favorable as κ increases. We only include the instances that could be solved within the imposed time limit and do not include the unsolved instances, which explain why the total solution time for CPLEX seems to be decreasing on the two largest instances in Fig. 8. However, for the largest set of instances, CPLEX can only solve one of the 5 instances and even uses more time than the CBM does for solving all instances. As regards the second largest set of instances CPLEX fails to solve two out of the 5 instances. If we were to penalize the unsolved instances in Fig. 8, the observed downwards trend for the biggest instances would be changed to a dramatic increase instead.When we inspect the optimality gap for the reported instances, we find a noticeable pattern that warrants a few comments. To display this pattern we plot the gap between the optimal LP value and the optimal integer solution for the MCM and the CBM, without adding any cuts, against the ratio m/n. We take a simple average over the gaps in the two cases where the ratio of m/n could refer to two different configurations as e.g. the instances with 5 suppliers and 15 customers and those with 10 suppliers and 30 customers, both have a ratio of m/n = 3. We restrict our comparison to the instances where κ = 3, but the results are similar for the other settings of κ. There seems to be a trend of the gap decreasing when the m/n-ratio increases. For the MCM this decline is roughly linear while it seems to be roughly exponential for the CBM. Here we summarize a few observations from these computational tests:•When there are more than 3 modes, the CBM is always faster and on large instances it is significantly faster.The CBM results in much fewer nodes and a smaller optimality gap than the MCM.While CPLEX is very effective in adding cuts, the gap of the CBM is always tighter after addition of the valid inequalities.There seems to be a relationship between the optimality gap and the ratio m/n (see Fig. 9).

@&#CONCLUSIONS@&#
