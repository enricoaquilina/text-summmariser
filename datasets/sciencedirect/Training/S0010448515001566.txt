@&#MAIN-TITLE@&#
Frame field smoothness-based approach for hex-dominant meshing

@&#HIGHLIGHTS@&#
A frame field smoothness-based algorithm for bulk point insertion is proposed.An iterative procedure for smoothing the frame field is proposed.The impact of geometric singularities on the final mesh is reduced.Volumic ratio of hexahedra is increased up to twenty percents.

@&#KEYPHRASES@&#
Hexahedral meshing,Mixed hexahedral meshes,Tetrahedra recombination,

@&#ABSTRACT@&#
An indirect approach for building hex-dominant meshes is proposed: a tetrahedral mesh is constructed at first and is recombined to create a maximum amount of hexahedra. The efficiency of the recombination process is known to significantly depend on the quality of the sampling of the vertices. A good vertex sampling depends itself on the quality of the underlying frame field that has been used to locate the vertices. An iterative procedure to obtain a high quality three-dimensional frame field is presented. Then, a new point insertion algorithm based on a frame field smoothness is developed. Points are inserted in priority in smooth frame field regions. The new approach is tested and compared with simpler strategies on various geometries. The new method leads to hex-dominant meshes exhibiting either an equivalent or a larger volume ratio of hexahedra (up to 20%) compared to the frontal point insertion approach.

@&#INTRODUCTION@&#
Hexahedral meshes are commonly preferred to tetrahedral meshes in engineering analysis. One of their main advantage resides in the fact that a lower number of elements are required for the same amount of vertices, compared to tetrahedra. In computational fluid dynamics, hexahedral meshes offer for instance good results along boundary layers. Indeed, the anisotropic refinement of tetrahedra is known to produce poor quality elements  [1], while this operation does not affect the quality of hexahedra. In the field of computational solid mechanics, tetrahedra may also lead to some issues such as inaccuracy or locking problems  [2]. Understanding precisely why an element type is better than another in some situations may still be open for debate. Nonetheless, even though the generation of tetrahedral meshes can be considered as a well known problem, the automatic generation of conforming all-hexahedra meshes is still an open issue.Mesh generation has always been considered as a time-consuming process in engineering analysis. The generation of tetrahedral meshes may now be considered merely automatic. The generation of all-hex and hex-dominant meshes often requires time consuming user interactions. Our purpose here is to develop a fully automated procedure for generating non uniform hex-dominant meshes that contain a maximum amount of hexahedra, both in volume and number.The main idea of the current approach is to decompose the meshing procedure, as proposed in  [3], in two different stages: first, bulk points are created inside the domain and are subsequently tetrahedralized; then, tetrahedra are recombined to create a mixed mesh containing a maximum amount of high-quality hexahedra. The way points are distributed in the domain is of paramount importance for obtaining a mesh that is truly hex-dominant. The point insertion algorithm that we have proposed in  [3] was based on a first in first out approach: points of the boundary of the domain were inserted in a queue and each of those was generating 6 potential neighbors along pre-defined directions. Each potential point was then inserted in the queue if it was not too close to an existing point.The approach of  [3] allowed us to generate high quality hex-dominant meshes with sometimes more than 90% of hexes in volume. Yet, this simple fifo approach is clearly perfectible. This is the objective of this paper.In this work, we start by developing a smoothness indicator that allows to identify the geometric singularities of the domain as well as regions where the geometry is smooth. A new point insertion procedure is then proposed in which the points are prioritarily inserted in smooth regions where the probability of generating large chunks of structured hexes is high.The global algorithm for hybrid mesh generation uses two intermediate meshes and can be summarized as follows: a first usual tetrahedral (or triangular in two dimensions) mesh, called background mesh, is created. On this first mesh, the frame field is computed: the frame field computation in two dimensions is identical to [3] and is presented in 3.1; in 3.3 are presented some improvements concerning the three-dimensional frame field computation.Then, new points are inserted to create a second “unusual” tetrahedral (triangular in two dimensions) mesh, i.e. suitable for efficient recombination. The previous frontal algorithm [3] for point insertion is presented in 3.2, as well as the new points insertion algorithm depending of the frame field smoothness.Finally, the recombination algorithm of tetrahedra into hexahedra can be applied: this recombination is strictly identical to the one presented in [3] and is briefly presented in 2. Note that the two-dimensional recombination algorithm of triangles into fully quadrangular meshes, presented in [4], is totally different from the tetrahedra recombination.Resulting meshes on several geometries are eventually presented in Section  4, with computational times and algorithms comparison.One single hexahedron can be decomposed into 5, 6, or 7 tetrahedra, according to the Yamakawa–Shimada algorithm [5]. Fig. 1shows 2 of the possible patterns. The problem of finding all the possible recombination patterns in a tetrahedral mesh may seem intractable but it is not. Two tetrahedral elements that do not share any vertex cannot be recombined into one hexahedron. Thus, searching all potential hexahedra in a tet mesh is the sum of local problems: each tetrahedronTof the mesh is associated to a cavity that contains all tetrahedra that share vertices withT. Then, patterns are searched into that small subset of the mesh. This procedure yields an extensive set of topologically correct potential hexahedra. Note that there is no intermediate prisms or pyramids involved in the procedure.If two of the potential hexahedra share one ore more tetrahedra, they are obviously mutually exclusive. These compatibility issues between neighboring hexahedra will be taken care of later, as the final hexahedral elements will be picked out of the potential hexahedra set. More subtle incompatibilities have to be taken into account like hexahedra that would share 3 points on one of their face or that would share one face diagonal. This final treatment to deal with possible remaining conformity issues uses the Owen–Canann–Saigal algorithm [6]. Similar final recombinations can be used to create prisms [5] and pyramids. The reader is referred to [3] for a more detailed description of the recombination process.Consider the set of all potential hexahedraH={H1,…,HNh}. Here,Nhis typically of the order ofNtifNtis the number of tetrahedra in the mesh (see Table 1). We build the following undirected graphG: each nodeiofG​corresponds to a potential hexahedron and edgeijexists ifHiandHjare compatible i.e. if those two hexahedra can exist simultaneously in a finite element mesh. A subsetS={Hi1,…,Him}ofmhexahedra that are all compatible with each other forms a clique i.e. a subgraph ofGsuch that any pair of nodes are connected nodes. To maximize the number of hexahedra in the final mesh, we thus need to find the largest clique possible.In this specific problem, we must remind that two potential hexahedra that share no vertices are always compatible. This implies that, asymptotically, nearly all hexahedra are compatible with each other which means that the number of edges inGis close toNhNh, which is huge (a very standard mesh can haveNh=106hexahedra). Consider now the dual ofGi.e. a graphG′with the same nodes but where an edge exists betweenHiandHjif and only if it was not present inG. This graph connects hexahedra that are incompatible. Compatible elements being clustered, the number of edges inG′is of orderO(Nh). Note that finding the maximal clique ofGis equivalent to finding the maximal independent set of the dual graphG′.The maximal independent set can be defined as the larger subgraphS, i.e. the independent set with the highestm. Weightswjcan also be defined on the nodes of the graph and the maximum independent set can be defined as the one that maximizes∑j=1mwj.Unfortunately, the general problem of the maximum clique/independent set is known to be NP-hard. Finding all the maximum cliques, in the worst-case, follows anO(3n/3)complexity fornnodes, since3n/3is the maximal number of maximal cliques in a graph withnnodes as shown by Moon and Moser  [7].In the algorithm proposed in  [8], all the maximum cliques are found with a worst-case running time complexity ofO(3n/3). At some point, the decision criteria to choose a node is a functionf, equal tonc, the number of compatible adjacent nodes. Of course, one could change this function to be maximized and make it depend on other criteria. For instance, one could choose a weighted sum including the element quality and the boundary proximity to create this function to maximize.In Fig. 2, the algorithm from  [8] has been used to find the maximum clique (depicted in Fig. 2(b)) on a very simple cubic domain. The optimal solution made of 8 hexahedra is found. The corresponding incompatibility graphs of potential hexahedra are shown, with highlighted independent sets in gray in Fig. 2. We observe that the number of potential hexahedra in the graph isNh=12and the average degree of a node (average number of connections in the graphG′) isC(G′)≈3. In Table 1 are summarized some statistics for larger graphs on the cube and the dome geometry from Fig. 8(a).However, since such a clique algorithm presents a high computational cost, we use hereafter a simple greedy algorithm for meshes involving a large amount of elements, while keeping the idea of the function to maximize. The greedy algorithm consists in sorting all the potential hexahedra, according to this weighted function, and choosing in priority the ones with the higher values. Note that if the greedy algorithm provided the maximum clique solution in the case of the 8 hexahedra cube, it is clearly not a general result: the maximum clique solution is in general different from the greedy algorithm solution.Let us finally mention that, depending on the kind of graph involved in this mesh generation problem, one might consider using appropriate heuristics for these graphs. Maybe such heuristics might allow one to use faster algorithms for solving the maximum clique (or approximate maximum) problem. Algorithms based on sequential decision-making techniques [9] could also be considered.In two dimensions, we have shown in [4] that any mesh composed of an even number of triangles could be converted into a quad mesh using edge swaps and recombinations. The quality of the final quad mesh benefits of course from an appropriate point insertion scheme  [10] but there is a guarantee of finding a mesh composed of quadrangles only. In 3D, things are very different: the recombination algorithm that we have proposed here-above does not guarantee that every tetrahedra will be converted into an hexahedra. In 3D, the percentage of hexahedra in the final mesh strongly depends on the point insertion scheme. This sensitivity is illustrated in Fig. 3where a dome is meshed using a standard Delaunay refinement approach and using our new approach. Here, we do not consider any post-smoothing of the points positions (as, for instance, in [11,12]) to improve the mesh quality, but we propose a pre-computation to directly obtain appropriate point locations. This a priori approach is based on two main ingredients: a frame field that will guide point insertion and the point insertion scheme itself i.e. the way points are prioritized in the insertion queue.Let us first briefly recall the main idea for computing the two-dimensional frame field, since it will be used to compute the three-dimensional frame field.A frame field is a set of two orthonormal tangent vector fields that vary smoothly on the2Dmanifold. Frame fields may be forced to be aligned with the boundary of the domain or to the principal directions of curvature of a surface. Frame fields are mathematical objects that have nasty symmetries: in 2D, any rotation ofkπ/4,k∈Zmakes the frame field invariant. In 3D, there are 24 symmetries.In 2D, computing frame fields is straightforward, using e.g. finite elements. Letθbe the local angle between the frame field and a reference basis at a given point. The frame field at any point of the surface is found by solving an elliptic PDE on the surfaceΩwith boundary conditions that enforceθon the domain boundary∂Ω:∇2a(θ)=0onΩ,a(θ)=āon∂Ω(1)∇2b(θ)=0onΩ,b(θ)=b̄on∂Ωwitha(θ)=cos(4θ),b(θ)=sin(4θ), andā,b̄the boundary conditions set in such a way that the frame field is aligned on the outgoing normal vector to the domain. The frame field is eventually given byθ=14atan2(b,a).Details about frame field computation can be found in  [10,3]. In Fig. 4is depicted an example of 2D frame field.The aim of a point insertion algorithm is to build a set of points in the domain that are aligned with the frame field and that have a density that is predetermined. Our approach is based on a priority queue. All the points of the boundary of the domain are initially inserted in the queue. Then, the point at the tail of the queue is removed from the queue and 6 potential points in 3D or 4 potential points in 2D are created along the local directions of the frame field (see Fig. 4). Those potential points are inserted in the queue provided that they are not too close to existing points of the set of points and that they lie in the domain. In  [3], the priority queue was a fifo queue i.e. the priority was “first in, first out”. This queueing system implies that new points are inserted layer by layer, starting from the boundaries and moving towards the inside of the domain. This first approach looks very much like a frontal approach: fronts are colliding at some point, typically close to the medial axis of the domain. This behavior is visible on the left image of Fig. 5. In this same picture, it is clear that in those regions where the frame field is smooth, the point insertion scheme produces very good results. On the other hand, when fronts are reaching non smooth regions or are close to singularities, it becomes less easy to produce optimal point locations. Fig. 4 shows frame field smoothness for that particular domain. Singularities are localized in the blue spots: we observe large variation of the frame field around these points. The idea here is to change the way the queue is prioritized: points should first be inserted where the frame field is smoother. Points close to singularities will be inserted at the end, leaving the algorithm fill up large parts of the domain bulk where frame fields are smooth. This is achieved by inserting the points in an ordered set, with the order depending on the frame field smoothness, instead of a fifo queue.Two issues must be addressed at this point. First, the definition of smoothness itself. Then, as we will observe in Section  4, the fact that a good point insertion algorithm may be quite useless if based on a poor 3D frame field: it must be smoothed as well.Similarly to the two-dimensional meshing procedure, we start with a tetrahedral background mesh to extend the frame field and mesh size field from the boundaries to the volume. But unlike the two-dimensional case, describing a frame requires three degrees of freedom instead of one. It is indeed not possible to formulate the smoothing of a 3D frame field as an elliptic PDE problem. Here, we choose to consider a local smoothing method where a single frame is aligned with its mesh-neighbors.First, let us consider only two frames. There are 24 possible rotations to apply a frame on another (some of these are depicted in Fig. 6), each rotation being characterized by an angleαi≥0and an axisai. We compute these rotations and choose to consider the one with the smaller angleα, other transformations are discarded.Then, let us consider a noden0surrounded byNneighborsni,i=1…N. We have chosenNrotations applying the frame ofn0on the frame of eachni, i.e.Ncouples(ai,αi). Smoothing is done by applying the following rotation of axisaand angleαto the frame ofn0:(2)a∗=∑i=1Naiαi,α=‖a∗‖,a=a∗α.Note that forN≥2, several iterations may be required to obtain convergence of the frame ofn0. In the computations of Section  4, we considered that convergence is reached when the angular differenceΔα<5×10−3rad≈0.29°. In practice, when the whole global frame field is not converged, we observed an average of 2.1 local iterations, while this number gets closer to 1 as the global frame field converges.We apply this local transformation to the frame field at each node of the 3D background mesh. Then, we compute the infinity normN∞=max(α)as the maximum angle of rotation used to align a frame on its neighbors, and iterate until convergence of this norm. In the computations of Section  4, we considered that convergence is reached whenN∞<3×10−2rad, i.e. when the larger rotation angle encountered in the whole domain is smaller than about 1.7°.These iterations eventually correspond to some pseudo-diffusion operator. We imposed a Dirichlet boundary condition, which is the 2D frame field computed using the PDE (1). For the initial condition of the iterative smoothing, the frame field is given the value of its nearest frame on the boundary. We observed that initial condition is of huge importance. Indeed, using for instance a totally random frame field as initial condition leads to a totally different converged field. This iterative smoothing does not erase geometric singularities and does not create new ones either: this is why it is mandatory to initiate the frame field with a good first guess.Nodes are sorted with respect to their angular difference between two iterations. This is done to improve the convergence. The less converged nodes are treated last like in a Gauss–Seidel method. Finally, computational costs are strongly reduced by stating that if the frames of a node and its neighbors were not modified during the previous iteration (i.e. the criterionΔαmentioned above was directly satisfied), computation is unnecessary for that node.While the frame field is smoothed, we also evaluate its smoothnesssat each node, simply defined as(3)s=1−4πN∑i=1Nαi.The smoothness is thus simply a measure of the average angleαto apply the frame of noden0on each neighbor, with a scaling to obtain a lower bound of approximately 0 and a maximum value of 1 for perfectly aligned frames.Fig. 7depicts the frame field  smoothness in the center of the dome: in Fig. 7(a), the frame field is not smoothed, but is equal to the frame field of the nearest neighbor on the boundary, while in Fig. 7(b) is depicted the result of the iterative procedure described above. However, the result in 7(b) does not seem sufficient to really improve the ratio of hexahedra. We also would like to reduce the impact of the singularities on their direct neighborhood, and therefore extend the regions presenting a smooth frame field.To achieve this, we slightly modify the rotation (2) and introduce different weightscidepending on the local smoothnesssi:(4)a∗=∑i=1Nci(si)aiαi,α=‖a∗‖,a=a∗α,using the relationship(5)c(s)={1ifs≥0.8510−3ifs<0.85.The iterative smoothing procedure then becomes similar to a diffusion operator with a variable diffusivity, depending on local smoothness. Simply put, information strongly propagates from smooth to non smooth regions, but does not propagate much in the opposite direction.In Fig. 7(c) is depicted the resulting frame field smoothness: the impact of the singularities on the frame field is clearly diminished, leading to wide regions filled with smooth frame field.This section is devoted to comparing the point insertion algorithms and the frame field computations described in Section  3 on the geometries depicted in Fig. 8.We will compare the final meshes, in particular the ratio of hexahedra in number and volume, as the computational time required by the different approaches. In Tables 2 and 3are summarized the results for every geometry and method: we compare the two point insertion algorithms (frontal queue and smoothness-based ordered set) and the two frame fields (smoothed or simply based on its nearest boundary neighbor), which leads to four computations on each geometry.As in previous figures, hexahedra are colored in gray while the colors yellow, red and green correspond to tetrahedra, prisms and pyramids respectively. As previously mentioned, when the frame field is build using the smoothing algorithm, the threshold relationship (5) is used and the frame field is initiated to its nearest neighbor value on the boundary.The first two geometries are the dome (Fig. 8(a)) and the Stanford bunny (Fig. 8(b)). In Figs. 9 and 10are depicted cut views of the 3D mesh for the frontal approach and the frame field-based approach. We observe a large improvement using the new approach: the half-sphere of the dome is filled with hexahedra, while the bunny presents large blocs of aligned hexahedra.This is confirmed by the hexahedra ratios in Table 2. The new frame-field based approach is particularly efficient on these two geometries for the same reason: they present a large volume for a small amount of boundaries. However, the difference between the two is that the faces of the dome are straight while the boundaries of the bunny are more chaotic.Indeed, for the dome, using the new (smoothness-based) point insertion only leads to 1% improvement in volume ratio and the frame field smoothing alone leads to 2.5% improvement. On the contrary, for the bunny, the new insertion leads to 8% improvement and the frame smoothing only to 6%. This is mostly due to the fact that the frontal algorithm does a better job on geometries with straight faces, while the non-smoothed initial frame field is worse with geometries presenting concavities as the dome. When combining the smoothing with the new insertion algorithm, we obtain a huge improvement of 7%–18% in volume ratio.Concerning the computational times, all computations show that the smoothness-based insertion is a bit slower. This was predictable since inserting elements in a ordered set has a larger cost than simply inserting at the end of a queue. But we also observe that, if the smoothing and insertion take more time, the tetrahedra recombination time usually strongly decreases. This is due to the fact that a better alignment of the points leads to a lower total number of elements, decreasing the amount of possible recombinations.Geometry 8(c) is a hollow turbine blade, which involves a lot of thin parts (tends to benefit to the frontal algorithm) and presents concavities (decreasing the quality of the initial non-smoothed frame field). The consequence is that on the one hand, using the new insertion with a poor frame field does not yield much improvement, and on the other hand, the frontal algorithm does not benefit much of a smoothed frame field either. But again, combining the two leads to a volume ratio 5% larger. Cut views are depicted in Fig. 11.Geometry 8(d) is a mechanical piece involving straight faces and different parts not as thin as the blade. Therefore, this is a typical geometry where the simple frontal algorithm does a good job, the final improvement does not exceed about 2% for a computational time approximately 20% higher.Geometry 8(e) consists in an aircraft fuselage with its tail. If boundaries are quite straight, it presents a large central volume to mesh: the new approach again leads to an improvement of 8% for a time increased by 70% (Table 3). On cut views of Fig. 12, we see that, obviously, the frontal algorithm gives a nicer hexahedral mesh close to the fuselage straight boundary, but has issues when getting closer to the center.Finally, geometry 8(f) is a simply extruded naca profile: the two approaches give approximately the same result (about 93% with less than 1% difference, which becomes non significant). We observed that, by imposing an even smaller required mesh size, both methods reached a volume ratio of 97%, which confirms that the simple frontal algorithm gives good results for such simple geometries.Note finally that the memory footprint did never exceed 800 Mb on the larger geometries.

@&#CONCLUSIONS@&#
A first iterative method has been proposed to obtain a smoother three-dimensional frame field. A second method was proposed to insert new points preferentially away from the geometric singularities.This new frame field-based approach has revealed either as efficient or much more efficient than the previous frontal indirect approach, depending on the geometries, for a reasonable additional computational cost ranging from 0% to 70%. If each isolated method only leads to minor improvements, we observed that combining the two methods leads to large benefits in terms of hexahedra ratio. The larger improvements, up to 20%, have been observed on geometries presenting a large volume compared to their surface.