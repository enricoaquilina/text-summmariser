@&#MAIN-TITLE@&#
Bidirectional transformation between BPMN and BPEL with graph grammar

@&#HIGHLIGHTS@&#
We propose a new context-sensitive graph grammar formalism called E-EGG in short.E-EGG introduces new mechanisms to tackle bidirectional transformation between BPMN and BPEL.Steps to achieve transformation and check correctness of BPMN structure are presented.Corresponding algorithms are further designed and analyzed.A case study on transformation from BPMN to BPEL is discussed.

@&#KEYPHRASES@&#
Graph grammar,EGG,BPMN,BPEL,Parsing algorithm,

@&#ABSTRACT@&#
A graph grammar is a formal tool for providing rigorous but intuitive ways to define visual languages. Based on an existing graph grammar, this paper proposes new context-sensitive graph grammar formalism called the Extension of Edge-based Graph Grammar, or E-EGG. The E-EGG introduces new mechanisms into grammatical specifications, productions, operations and so on in order to conveniently treat the bidirectional transformation between the Business Process Modeling Notation (BPMN) and the Business Process Execution Language (BPEL). Besides formal definitions of the E-EGG are provided, steps and algorithms to achieve the bidirectional transformation and to check the correctness of BPMN models’ structure are presented. Finally, a case study on transformation from BPMN models to BPEL codes is provided to show how the parsing algorithm of the E-EGG works.

@&#INTRODUCTION@&#
Modeling of business processes and workflows is an important area in software engineering. The Business Process Modeling Notation (BPMN) is a standard set of graphical notations, and it essentially provides notations for business process modeling with an emphasis on control flow [1]. Since they are graphic notations, the models of BPMN are easy to understand for managers and business analysts. At present, many there appear some software tools for supporting BPMN specification. While the Business Process Execution Language (BPEL) [2] is a XML-based language for specifying business processes as services and describing Web service composition. The use of BPEL to model can be achieved within an enterprise application integration [3]. Since BPEL is non-graphical, managers and business analysts have problems understanding BPEL codes.In practical applications, there are many demands for transformation between BPMN models and BPEL codes. Transformation from BPMN to BPEL was proposed in [4] at first time, then a lot of techniques were proposed to solve problems in transformation.White [4] informally sketched a transformation from BPMN to BPEL and used an example of a travel booking process to present the problems and discuss some issues of the transformation. However, this transformation is limited, e.g. it excludes diagrams with arbitrary topologies. Also, several steps in White's transformation require human input to identify patterns in the source model. Gao [5] presented a tool to transform BPMN into these tools are only able to export BPEL codes for restricted classes of BPMN models, which focused on how the go to structure in BPMN models can be transformed into BPEL codes.Ouyang et al. [6] defined an abstract syntax and formal semantics for BPMN and systematically proposed an algorithm to transform models captured in a core subset of BPMN into BPEL. The authors mainly used Petri nets to define formal semantics for the core subset of BPMN, which has greatly theoretical basis. Unfortunately, the transformation is still incomplete, in which there are problems resulting from the possible usage of arbitrary cycles. Thus only a subset of the language constructs is allowed in order to be able to transform a BPMN models into BPEL codes completely. Lassen and Aalst [7] presented a tool automatically mapping a graphical workflow model expressed in terms of Workflow Nets (WF-nets) onto BPEL. Puhkaev et al. [8] presented an approach of a conversion of graphical BPMN and its extension BPNE into execution BPEL, and proposed a structure of the software which implements the proposed method. However, this work doesn't provide mapping BPEL onto BPMN.Since unstructured processing diagrams cannot be transformed into equivalent structured ones [9], an approach to overcome some of these limitations for processes without parallelism is sketched in [10]. However, the transformation from BPMN to BPEL is not well solved. The reason is mainly that BPMN is a graph-oriented modeling language and BPEL is a block-structured one [11], so mapping BPMN onto BPEL becomes a very challenge.Meanwhile, many techniques have been proposed to analyze formal semantics for BPEL and transform it into other easily understandable languages or models. WofBPEL[12] used a detail mapping from BPEL to Petri nets and unlike many other approaches this mapping is feature complete, i.e., control links, joins conditions, event handing, etc. are taking into account in this transformation. WofBPEL analyzed Petri nets with a Petri-net-based tool dedicated to the analysis of workflow processes. WSAT (Web Service Analysis Tool) [13] is a formal specification, verification, and analysis tool for web service compositions, which was developed at the University of California at Santa Barbara. In this tool, BPEL-based specifications are transformed into guarded automata. However, the above approaches don't aim at the mapping of models onto BPEL, i.e., they all map BPEL onto some other languages (e.g., Petri nets). In addition, though Petri nets has very theoretical basis, the formal method of it is difficult for end users.In fact, with the increasing use of graphical languages such as the BPMN [14], entity-relationship diagrams, and data or program flowcharts, etc., a framework for formally defining and analyzing graphical languages is becoming more and more important. For the specification and analysis of graphs composed of nodes and edges, graph grammar [15] is ideally a formal but intuitive tool. In view of the role played by a string grammar to string languages, it is not an exaggeration to say that a graph grammar forms the theoretical basis of visual languages [16].Currently, there are a number of graph grammars and their applications appear in literature. In 1997, Rekers and Schürr [17] proposed a graph grammar formalism called Layered Graph Grammar (LGG) for specifying visual languages. Different from most previous graph grammars, the LGG is context-sensitive and can intuitively specify and parse a wide range of graphical visual languages [18]. Productions in the LGG differ widely from others by introducing some context nodes that will not be replaced in a reduction or derivation operation. However, the context nodes make the productions difficult to design and its parsing algorithm complicated with exponential time complexity.To overcome the weaknesses of the LGG, Zhang et al. [19] proposed another context-sensitive grammar called Reserved Graph Grammar (RGG), which is founded on the basis of the LGG, but offers an improvement over it. The RGG introduces a marking mechanism to tackle the embedding problem, in which a unique label is used to identify all of the context elements. In addition, with the introduction of selection-free productions to graph grammars, a Selection-Free Parsing Algorithm (SFPA) is put forward for a confluent RGG, which only needs to consider one parsing path and thus can efficiently parse graphs with a polynomial time complexity [19]. Due to the RGG's characteristics, its application is more extensive in solving some new issues, such as Visual XML Schemas [20] and Generic Visual Language Generation Environments [21], etc. Next, the RGG is extended by introducing some spatial notations and mechanisms. The new spatial specifications of the extended RGG, called Spatial Graph Grammar (SGG) [22], can qualitatively express the spatial relationships of objects and may reduce the parsing complexity.In 2008, Zeng et al. [23] proposed another a context-sensitive graph grammar formalism called Edge-based Graph Grammar (EGG), which overcomes some of the shortcomings of the LGG and RGG without the loss of expressive power. The main advantage of the EGG over the LGG is its simplified context expression by using an edge instead of a node, and that over the RGG is its simplified node structure which only has one level instead of two. Based on the EGG, a new attempt of transformation from BPMN to BPEL [24] was provided, which presented mapping steps and a parsing algorithm. However, this approach does not aim at the mapping of BPEL onto BPMN.Obviously, a graph grammar has advantages in dealing with graph structure, which is a formal tool for providing rigorous but intuitive ways to define visual languages. So, we still extend the existing graph grammar, and make it more convenient to bidirectionally transform between BPMN and BPEL. This paper proposes a new context-sensitive graph grammar formalism called the Extension of Edge-based Graph Grammar or E-EGG in short, and achieves the transformation between BPMN and BPEL by means of the E-EGG, which prevents problems caused by using Petri net methods such as the complexity of mapping BPMN onto Petri net, more experience of this mapping, and the difficulty of ensuring mapping's correctness. Steps of the bidirectional transformation are provided, and corresponding algorithms are further designed and analyzed. Meanwhile, we can verify the correctness of BPMN models using the graph grammars’ superiority in the transformation from BPMN to BPEL. This verification is difficult for other methods. In addition, a new algorithm is designed to deal with complicated structures in BPMN, which avoids a complicatedly formal method. So, it is more simple and practical. Finally, a case study on transformation from BPMN to BPEL is discussed to explain how the transformation algorithm from BPMN to BPEL works.The rest of the paper is organized as follows. Section 2 introduces some basic definitions and operations of the EGG as the preliminaries to Section 3, which presents the formal definitions of the E-EGG with the introduction of new mechanisms, such as an attribute set, new operations on graphs, etc. Based on the E-EGG, Section 4 provides steps and algorithms to realize the bidirectional transformation between BPMN and BPEL, analyzes the complexity of algorithms, and explains a case study on transformation from BPMN to BPEL. Finally, Section 5 concludes the whole paper.Different from other graph grammars, the EGG introduces some new concepts, such as the dangling edge, core graph and so on, to deal with the embedding problem. In the EGG, dangling edges with unique marks are allowed in both sides of a production to indicate the context. Then, the embedding problem could be solved in grammatical operations by avoiding ambiguity. Below are some formal definitions of the EGG, which are fundamental to the discussion of bidirectional transformation between BPMN and BPEL in the next section.Definition 2.1GΔ=(N,E,s,t,l)is a graph on a given label set L, where•N is a set of nodes, which can be expressed asN=NT∪NN, where NT represents a set of terminal nodes and NN represents a set of non-terminal nodes;E is a set of edges;s: E→N is a mapping from edge E to N, indicating the source node of an edge;t: E→N is a mapping from edge E to N, indicating the target node of an edge;l: N∪E→L is a mapping from N and E to L, and L can be expressed asL=Ln∪Le.Ln=T∪T¯is a set of node labels, where T represents a label set of NT andT¯represents a label set of NN; Le is a set of edge labels.In order to represent different nodes in this paper, each node needs to be given a unique identifier called id. A node with an id is denoted as nidor ni(id=i=0,1,2,…). It should be noted that a node's id is not part of the above definition, and is just used to indicate the node. If the label of node niis A, this label can be denoted as ni.A. Obviously, in a graph there may be several nodes which have the same label.To deal with a business process by the EGG, it should be firstly mapped onto a corresponding graph of the EGG, also called an EGG graph. In this paper, the business processes of BPMN include three types of nodes, then the following labels of nodes in corresponding EGG graphs are given. The label “xor” of a node represents an exclusive gateway; the label “and” of a node represents a parallel gateway; the label “x” of a node represents an atomic activity.If a graph G of the EGG is directed, the notation din(n) is used to represent the numbers of edges in which target nodes are n, and the notation dout(n) is used to represent the numbers of edges in which source nodes are n. For expression convenience, notations like G.N, G.E, G.L, G.l, and so on are used to represent the corresponding parts of G in the following definitions.Definition 2.2G¯Δ=(N,E^,M,l,s¯,t¯,m)is a graph with dangling edges on a given label set L, where•N,  L, and l are the same as that inDefinition 2.1;E^is a set of edges, which can be expressed asE^=E∪E¯, where E is the same as that inDefinition 2.1andE¯=E→∪E←is a set of dangling edges.E→represents a set of edges which only have source nodes, whileE←represents a set of edges which only have target nodes;Mis a unique marks’ set ofE¯, also called marks;s¯:(E∪E→)→Nis a mapping for source nodes of an edge;t¯:(E∪E←)→Nis a mapping for target nodes of an edge;m:E¯→Mis an injective mapping fromE¯to M, indicating the mark of a dangling edge.Usually, there are two typical grammatical operations that have reverse functions. One is called L-application (deduction) and the other is called R-application (reduction). More detailed information about the content of the EGG is available in the literature [23].A new attribute of nodes called BCode is introduced to save the corresponding BPEL codes. While a new attribute set of edges is also introduced to represent the conditions or information of a flow in BPMN models. These definitions are as follows.Definition 3.1nΔ=(lab,BCode)is a node on a label set Ln, where•Ln is the same as that defined inDefinition 2.1;lab ∈ Ln, representing the label of n;BCode is an attribute owned by node n, representing the BPEL codes of n.Definition 3.2eΔ=(lab,ns,nt,Eatts)is an edge on a label set Le, where•Le is the same as that defined inDefinition 2.1;lab ∈ Le, representing the label of e;ns is a node defined inDefinition 3.1, representing the source node of e;nt is a node defined inDefinition 3.1, representing the target node of e;Eatts is a set of attributes owned by edge e, whileEatts=Eka∪Eka¯with Eka being a set of attributes which must have finite values, called key attributes of e, andEka¯being a set of attributes which could have finite or infinite values, called non-key attributes of e.In the above definition, a set Lehas multiple elements and every element indicates one of edge types in a graph. This makes edges strong expressive power. For simplicity, the business processes in this paper only contain a control flow of BPMN models, so there is only one edge type in models. In corresponding E-EGG graphs, the label of this edge type could be “controlflow”. That is to say,Le={controlflow}. In the E-EGG, similar to representation of a node, a unique identifier is also provided for an edge, denoted as ei(i=0,1,2,…), to distinguish different edges. If there is an edge ei, an attribute att in the set Eka of the edge can be denoted as ei.Eka.att, or ei.Eatts.att, while the notation ei.lab represents the label of it.Definition 3.3BAGΔ=(N,E,l,s,t)is a BPMN-attributed graph on a given label set L, where•N is a set of nodes defined inDefinition 3.1, andN=NT∪NNlike that inDefinition 2.1;E is a set of edges defined inDefinition 3.2;L, l, s, and t are the same as those defined inDefinition 2.1.In the following, unless otherwise specified, graphs mean BPMN-attributed graphs.Definition 3.4BAG¯Δ=(N,E^,M,l,s¯,t¯,m)is a BPMN-attributed graph with dangling edges on a given label set L, where•N, L, and l are the same as those defined inDefinition 3.3;E^is a set of edges defined inDefinition 3.2, and it can be expressed asE^=E∪E¯, which is the same as that defined inDefinition 2.2;•M,s¯,t¯,and m are the same as those defined inDefinition 2.2.Definition 3.5Two BPMN-attributed graphs with dangling edgesBAG¯1andBAG¯2are isomorphic, denoted asBAG¯1≈BAG¯2, if and only if there exist two bijective mappings∃fN:BAG¯1.N↔BAG¯2.Nand∃fE:BAG¯1.E↔BAG¯2.E, and the following conditions are satisfied:∀n((n∈BAG¯1.N)→(n.lab=(fN(n)).lab));∀e∀att((e∈BAG¯1.E^)→(e.lab=(fE(e)).lab)∧(BAG¯2.s¯(fE(e))=fN(BAG¯1.s¯(e)))∧(BAG¯2.t¯(fE(e))=fN(BAG¯1.t¯(e)))∧((att∈e.Eka)→(e.Eka.att=(fE(e)).Eka.att))).In order to check the structure correctness of BPMN models and generate corresponding BPEL codes of models, there is a new definition of a production in the E-EGG as follows, and two elements Con and Fun are added into a production.Definition 3.6A production p is defined as a quadruple, denoted as(BAGL¯,BAGR¯,Con,Fun), which consists of a left graphBAGL¯, right graphBAGR¯, condition Con and function set Fun, where•BAGL¯andBAGR¯are the same as that defined inDefinition 3.4;(BAGL¯.M=BAGR¯.M)∧(M⊂{0,1,2,…});Con is condition which must be satisfied for the use of this production;Fun is a group of functions which are executed once this production is used.In the above definition, Con is used to determine whether a production is needed to use, while Fun is used to calculate and modify the values of attributes in a production. Generally speaking, the attributes of nodes or edges in left and right graphs of a production could be changed by Fun functions. As for the example of business processes, productions are given in Fig. 1, which consist of not only the left and right graphs, but also Con and Fun.Definition 3.7A graph BAW is the sub-graph of a graph BAG if and only if the following conditions are satisfied:•(BAW.N⊆BAG.N)∧(BAW.L⊆BAG.L);∀n∀e((n∈BAW.N∧(s(e)=n∨t(e)=n)∧e∈BAG.E)→e∈BAW.E^).Definition 3.8If a graph BAW is the sub-graph of a graph BAG, and BAQ is a BPMN-attributed graph with dangling edges, BAW is a redex of BAG with respect to BAQ, donated as BAW ∈ Redex(BAG, BAQ), if and only if there exists a bijective mapping fN: BAW.N↔BAQ.N, and the following conditions are satisfied:•BAW ≈ BAQ;∀n((n∈BAW.N)→(din(n)=din(fN(n)))∧(dout(n)=dout(fN(n))));if BAQ is the left or right graph of a production, the condition Con in this production should also be satisfied.Definition 3.9If a graph BAW is the sub-graph of a graph BAG, BAQ is a BPMN-attributed graph with dangling edges, andBAW∈Redex(BAG,BAQ), then a function Assign(BAW → BAQ) is defined as the following assignment operation:•∀nj∃fN((nj∈BAQ.N∧(fN:BAQ.N↔BAW.N))→(nj.BCode:=(fN(nj)).BCode)).Since a node in a graph of the E-EGG has an attribute of BPEL code, function Assign(BAW → BAQ) can assign attributes’ values of a node in BAW to ones of a node in BAQ.Definition 3.10A R-application to a graph BAG using a production (L, R, Con, Fun) is defined as the following processes:•If BAW is a redex, namely BAW ∈ Redex(BAG, R), then Assign(BAW → R) is executed;All functions in Fun of the production are executed;Replace BAW in BAG with L to generate a graph BAG″, denoted asBAG′′Δ=Tr(BAG,BAW:R,L).The above processes are denoted as BAG↦pBAG″.Definition 3.11An E-EGG is a quadruple (λ, Ln, Le, P), where:•λ is an initial graph;Ln and Le are the same as that defined inDefinition 2.1;P is a set of productions, and each production p ∈ P should satisfy the following constraints, which are called productions’ constraints:p is the same as that defined inDefinition 3.6;The right graph of p is nonempty;LetLnLandLnRbe the label sets of the left and right graphs in p, then(LnL⊆Ln)∧(LnR⊆Ln);For any production, the following relationship < between its left graph L and right graph R is necessary:L<R⇔(|L.N|<|R.N|)∨(|L.N|=|R.N|∧|L.NT|<|R.NT|)∨(|L.N|=|R.N|∧|L.NT|=|R.NT|∧|L.E^|<|R.E^|)In the above definition, productions’ constraints ensure the workability and decidability of the E-EGG, and their fourth constraint means that the size of R must be no less than that of L in a production, which makes a host graph parsed in finite steps of R-application [18].Definition 3.12LeteeggΔ=(λ,Ln,Le,P)be an E-EGG, its language Γ(eegg) is a set of graphs which can be defined byΓ(eegg)={G|(λ→*G)∧(G.NN=∅)}.BPMN models provide the freedom of drawing arbitrary business processes, which results in difficult transformation from BPMN to BPEL. In order to deal with BPMN model, structures of the BPMN model should be classified two categories: basic structure and complicated one. Basic structures are components that can be directly mapped onto the five structures in BPEL codes such as sequence structure, flow structure, switch structure, pick structure and while structure. While, the BPMN models may contain components that are not basic structure, e.g. unstructured or crossed cycles, which are called complicated structure. The complicated structure cannot be directly transformed into the corresponding components in BPEL, so the transformation of complicated structure is relatively difficult and also one of the problems mainly discussed in this section.To achieve the transformation from BPMN to BPEL, the following steps should be executed.Step 1, pretreatment. This step mainly analyzes the structure of BPMN models, and transforms models with complicated structure into ones only with basic structure by a new algorithm which is discussed in Section 4.1.2. In this way, the model with basic structure can be treated more conveniently.Step 2, initialization. In this step, BPMN models from Step 1 are initialized to graphs of the E-EGG.Step 3, calling a new parsing algorithm in Section 4.1.3. This algorithm can execute R-applications for a given host graph to check whether the graph is valid or correct or not. If the graph is valid, this algorithm gives corresponding BPEL codes of this graph.Since the direction of a business process in BPMN models can be arbitrary, the models may be unstructured. In the process of transforming from BPMN into BPEL, models should first be mapped onto the structured ones. The following problem we faced is: can a graphical model containing unstructured cycles be mapped onto an equivalent program permitting structured cycles only? The answer was given almost fifty years ago [25]: any concurrent or sequential flow diagram can be mapped onto a functionally equivalent program containing a single while-loop and new conditional statements.In order to facilitate the expression, a BPMN model can be marked as BG, and the set N is represented for all nodes in the BG, denoted as BG.N. While the set E represents all edges in the BG, denoted as BG.E. If there is a directed edge from node nito njin a BPMN model, the notation < ni, nj> indicates this edge. niis called the pre-node of nj, and the edge < ni, nj> is called the pre-edge of nj. If there are many pre-nodes and pre-edges of n, we can denote PreSet(n) to present the set of these pre-nodes and pre-edges. In the realization process, a table with three-dimensional structure can be used to store PreSet(n). The first dimension of this table stores the name of node n, and the second and third dimension are arrays, which store respectively pre-nodes of n and conditions of the corresponding pre-edges. While, in the edge < ni, nj> , njis called the post-node of ni, and the edge < ni, nj> is called the post-edge of ni. Similar to the PreSet(n), if there are many post-nodes and post-edges of n, we can denote PostSet(n) to present the set of these post-nodes and post-edges, and also use a table with three-dimensional structure to store PostSet(n).In addition, if there is a node n and the number m of edges which target or source nodes are n, we also call that the node n has the number m of entrances or exits.Definition 4.1A path from node n1 to njin a BPMN model BG is a series of nodes and edges: n1, e1, n2, e2, ...,nj−1,ej−1, nj, this path can be denoted as (n1, nj), and njis called the arrived node of n1, where•ni∈ BG.N, 1 ≤ i ≤ j;ek=<nk,nk+1>∈BG.E,1 ≤ k < j.Definition 4.2Supposing there is a path (ni, nj) in a BPMN model BG, and nihas two or more entrances and one of these entrances comes from nj. Then this path is called a cycle.If a cycle (n1, nj) consists of a series of nodes and edges n1, e1, n2, e2, ...,nj−1,ej−1, nj, the notation loopNodeSet(ni) can be used to express the set of nodes in this cycle. In fact, the set of nodes in this cycle can be found through searching the PreSet(ni) of a node ni(i = 1,2,..., j). For example, in Fig. 2, there are three equations:PreSet(c)={b,e},PreSet(d)={c},PreSet(e)={d}. We may determine loopNodeSet() of the cycle by searching the PreSet() of the three nodes.If there are two or more cycles in a BPMN model, then we can use notation LoopSet to represent the set of these cycles. In practical realization, we use a two-dimensional structure to store every cycle. In this structure, the first dimension of it is used to store the name of cycles; the second dimension is an array to store every node in the corresponding cycle. Meanwhile, in order to facilitate expression, if there is a cycle numbered as i in the set LoopSet, then we may use notation LoopSet[i] to express this cycle, and use notation LoopSet[i].njto express the node j of this cycle.Definition 4.3A cycle (ns, nt) in a BPMN model BG is structured cycle, if and only if the following condition is satisfied:•∀ni∀n((ni∈ PreSet(n)∧n ∈ loopNodeSet(ns)∧n ≠ ns) → ni∈ loopNodeSet(ns)).Obviously, in Fig. 2, nodes c, d and e form a structure cycle.Definition 4.4A cycle (nu, nv) in a BPMN model BG is unstructured cycle, if and only if one of the following conditions is satisfied:•∃ni∀n(ni∈ PreSet(n)∧n ∈ loopNodeSet(nu)∧n ≠ nu∧ni∉loopNodeSet(nu));∃nj∀n(nj∈ PostSet(n)∧n ∈ loopNodeSet(nu)∧n ≠ nv∧nj∉loopNodeSet(nu)).For example, in Fig. 2, since there is (k ∈ PreSet(h)∧h ∈ loopNodeSet(g)∧h ≠ g∧k∉loopNodeSet(g)), the cycle consisted of node g, h and i is the unstructured cycle. While, the cycle consisted of node h, i, j and k is also the unstructured cycle.If an unstructured cycle (nu, nv) consists of a series of nodesnu1,nu2, ...,num, (nu1=nu,num=nv), the notation unloopNodeSet() can be used to express the set of nodes in this cycle. In order to obtain the set unloopNodeSet(), we may firstly traverse the LoopSet, and search the PostSet() of every node (excluding ending node) in every cycle. If there are nodes in the PostSet() which are not belong to a cycle in the LoopSet, these nodes and other nodes in the cycle should be added into unloopNodeSet(). For example, in Fig. 2 the nodes g, h, and i form a cycle, and the pre-node of h is k, then the node k should be added into the unloopNodeSet() and it becomes {g, h, i, k}.If there are two or more unstructured cycles in a BPMN model, we use the notation UnLoopSet to express the set of these cycles. In the realization process, we construct a two-dimensional structure to store UnLoopSet. Wherein, the first dimension is array storing every node in an unstructured cycle, and the second dimension stores the name of the corresponding cycle.Based on the above discussion, a new algorithm is further provided. It could transform a BPMN model including unstructured cycles into the corresponding model only including structured cycles without changing the semantics of the model. The algorithm is shown in Fig. 3. It has a parameter, namely a BPMN model, to be treated, and the result returned by the function is just the transformed model only with structured cycles.Function IsUnstructured() in line 4 judges whether a BPMN model includes unstructured cycles. The parameter of this function is a BPMN model, and the type of returned value by the function is Boolean. Function FindUnstructure() in line 6 searches unstructured cycles in the BPMN model. Its parameter is also the BPMN model, and the returned value is the set of all unstructured cycles in the model.Function MaptoStructure() in line 9 is the core function of the algorithm. It is mainly to transform one unstructured cycle into structured cycle, its parameter is just one unstructured cycle, and its return is a new path with structured cycle. This function is to treat two situations of an unstructured cycle. The first is among multiple cycles and these cycles contain some same nodes and edges. The second is between a cycle and nodes outside this cycle. To facilitate understanding above two situations, the following Fig. 4(a) and (b) show examples of the first and second situation respectively.Pseudo-codes of function MaptoStructure() are further presented in Fig. 5. Its input is a path including an unstructured cycle and its output is a path excluding an unstructured cycle. The pseudo-codes from line 8 to line 49 are designed to deal with the first situation in the above discussion. Note that every node in a path unstrcy can be denoted as unstrcy[i](i=1,2,…). First, it needs to judge the type of node unstrcy[1] in the path unstrcy. If unstrcy[1] is an activity node, a new judgment node J should be created by the function CreateJudgeNode() in line 17 and set as the first node of the path. So, the first node would be the judgment node. Second, it needs to find the last judgment node in the path unstrcy, which is realized by function FindlastJudgeNode() in line 5 and generate a new edge with some conditions from this node to the first node. Finally, for any other node n in the path unstrcy, if n is the start node of a cycle in the path, a new edge with some conditions from the first node of the path unstrcy to n should be added; if n is the end node of a cycle in the path, a new edge with some conditions from n to the last judgment node of the path unstrcy should be added. This process can be done by pseudo-codes from line 30 to line 46. After the above processes, the unstructured BPMN models in the first situation can be transformed into the structured models. For example, the graph in Fig. 4(a) can be transformed into Fig. 6(a).While, to solve the second situation in the above discussion, pseudo-codes from line 52 to line 68 are executed in Fig. 5. First, it needs to find all nodes outside of the cycle in path unstrcy, which is done by function FindNodeOutCycle() in line 52. Second, it needs to find the first and last judgment nodes of the cycle in path unstrcy by using function FindFirstNodeofCycle() and FindLastNodeofCycle() in line 58 and 64 respectively. Finally, for every node n outside of the cycle, if one of nodes in the PostSet() of n is the node (not the start node) of the cycle in the path, supposing the corresponding edge is poe, a new edge with some conditions from n to the start node should be added, and the edge poe should be deleted; if one of nodes in the PreSet() of n is the node (not the end node) of the cycle in the path, supposing the corresponding edge is pre, a new edge with some conditions from the last judgment node to n should be added and the edge pre should be deleted. So, the unstructured BPMN models in the second situation can be also transformed into the structured models. For example, the graph in Fig. 4(b) can be transformed into Fig. 6(b).In addition, there are some basic but useful functions in MaptoStructure(). In Fig. 5, function AddNodeToPreSet() in line 19, 34, 45, etc. has two parameters, and it adds the first parameter into the second parameter that is the PreSet() of a node. Similarly, function AddNodeToPostSet() in line 18, 39, 44, etc. also has two parameters, and it adds the first parameter into the second parameter that is the PostSet() of a node. Function IsStartofCycle() in line 31 has two parameters. Wherein, the first parameter is a node, and the second one is a cycle. This function judges whether the first parameter is the entrance node of the cycle, and if so, it returns to TRUE, or it returns to FALSE. Similarly, function IsEndofCycle() in line 36 has two parameters, the first parameter is a node, and the second one is a cycle. This function judges whether the first parameter is the exit node of the cycle, and if so, it returns to TRUE, and if not, it returns to FALSE.A BPMN model only with structured cycle can be obtained through the Section 4.1.2. Then, according to Step 2 in Section 4.1.1, that is to map this type model of BPMN onto an E-EGG graph. In this way, we may treat this graph conveniently with the E-EGG by use of a graph parsing algorithm as follows.Graph parsing algorithm determines whether a given host graph can be reduced to the initial graph according to a graph grammar. Then, a reduction is also called R-application. Because of its advantages of processing graph, in this paper a new graph parsing algorithm is designed to transform from graphs of the E-EGG to BPEL codes, which is presented in Fig. 7.In order to better understand this parsing algorithm, some detailed explanations are given with introduction of two stacks GraphStack and RedexStack. They are used to store graphs and corresponding redexes of the graphs respectively. The pseudo-code in line 7 pushes the flag “MARK” into the RedexStack, which is used to separate redexes of different intermediate graphs. For specific graph G in GraphStack, pseudo-codes between line 8 and line 19 search all redexes with all productions of the E-EGG, and push them into the RedexStack for backtracing. It is function FindRedex() in line 10 that searches for all possible redexes. The action in line 30 executes R-application with respect to the redex popped out from the RedexStack using the corresponding production. According to Definition 3.10, R-application could achieve the purpose that the structure of a graph can be deduced by replacing a redex with the left graph of a production, and the attribute BCode of nodes in left graph of a production could be assigned by the Fun of a production. That is to say, when the structure of a graph could be deduced, the BPEL codes of it can also be obtained. Finally, the above pseudo-codes are repeatedly executed until the graph can be transformed into the initial symbol. Section 4.3 will further discuss how the parsing algorithm transforms graphs of the E-EGG into BPEL codes in a case study.The complexity of the parsing algorithm is in need of considering its computational efficiency. In this sub-section, the complexity of the parsing algorithm is analyzed.Theorem 4.1For a given E-EGG, the time complexity of its parsing algorithm isO((psm!)h·(hh·h!)m), where h is the number of nodes in a host graph, ps is the number of productions in the E-EGG, and m is the maximum number of nodes among all productions’ right graphs.ProofSupposing k1 and k2 are time complexity of the function FindRedex() and R-Application() respectively. According to the parsing algorithm, its time complexity σ is determined by the following equation:σ=O(σ1·(σ2·(k1+σ3)+σ4+k2)),where σ1 is the maximal number of iterations in lines 5–31, σ2 is the number of iterations in lines 8–19, σ3 is the number of iterations in lines 13–17, σ4 is the number of iterations in lines 21–27.For the lines 13–17, these codes are to find redexes in the host or intermediate graph with respect to the right of a given production. So, the maximal number of redexes is the all possible node combinationsChm. Thus,σ3≤Chm=O(hm). For σ2, it is the number of productions, that is to say,σ2=ps. Since σ2 · σ3 is the total number of elements pushed into the redex stack and σ4 is the partial number of elements popped from the redex stack, σ4 should be no more than σ2 · σ3, and thus can be ignored.For the lines 5–31, when executing one R-application, it produces no more thanps·Chmredexes for ps productions. According to the size-increasing condition, each R-application would reduce the size of the derived host graph. So, there are at most h R-applications and an R-application will reduce the intermediate graph size by at least 1, the following derivations hold for σ1:σ1≤(ps·Chm)h·ps·Ch−1m·ps·Ch−2m…·ps·Ch−(h−m−1)m·ps·Ch−(h−m)m=ps2h−m·(h!(h−m)!·m!)h·∏u=1h−m−1(u+m)!m!·u!=O((psm!)h·(hh·h!)m)As for k1 and k2, since the maximal possible number of selections of m nodes from h nodes isAhm=h·(h−1)·…·(h−m+1), the worst cases of searching for all redexes of a right graph in a given host graph must bek1=O(hm). Obviously,k2=O(1).Combining all the above discussions, the following equations can be obtained:σ=O((psm!)h·(hh·h!)m)The steps of transformation from BPEL to BPMN are provided as follows.Step 1, pretreatment. Obviously, BPEL codes are conveniently analyzed only if they are standardization in style. So, this step is to standardize BPEL codes.Step 2, calling a new algorithm in Section 4.2.2. This algorithm is to analyze BPEL codes after pretreatment, and to transform it into an E-EGG graph by use of productions and graph operations.Step 3, mapping E-EGG graphs onto BPMN models. The E-EGG graph obtained in Step 2 is very similar to the BPMN model, so further mapping is relatively easy.It can be seen from Fig. 8that this algorithm has two parameters. Wherein, a parameter bpelcode represents BPEL codes to be transformed, and the other parameter ps represents a production group in the E-EGG.Function Initialize() in line 1 is mainly to pretreat BPEL codes and assign them as a whole to the attribute of an initial symbol in the E-EGG. While, function L-Application() in line 2, 9, 10, 11, and 12 has three parameters, which is used to find a redex in the host graph (the first parameter) that is isomorphic to the left graph of a production (the second parameter), to replace the redex with this production's right graph, and to assign the BPEL codes (the third parameter) to the attribute of corresponding nodes. Function FindFirstofBPEL() in line 3 and 14 is to analyze the structure of the first statement in BPEL codes, and this structure may be sequence, flow, switch and while structure, etc. On the contrary, function FindRemainderofBPEL() in line 4 and 15 is to analyze the structure of the remainder statement in BPEL codes. There is function IsAllTerminalNode(Graph g) in line 5 with the return value being Boolean. It is to judge whether the graph g is only composed of terminal nodes and edges or not. If yes, the return value of this function is TRUE, and if no, the return value of this function is FALSE. In addition, function TypeofStructure() in line 7 is to judge what type of the BPEL structure that is, such as sequence, flow, switch and while structure.Similar to Section 4.1.4, the complexity of the above algorithm is also analyzed.Theorem 4.2For a given E-EGG and BPEL codes, the time complexity of the transformation algorithm from BPEL to BPMN isO(n · ps), where n is the number of structures in BPEL codes, and ps is the number of productions in the E-EGG.ProofSupposing r1, r2, r3, r4, and r5 are time complexity of function Initialize(), L-Application(), FindFirstofBPEL(), FindRemainderofBPEL(), and TypeofStructure() respectively. According to the algorithm, its time complexity ω is determined by the following equation:ω=O(r1+r2+r3+r4+ω1·(r5+r2+r3+r4)),where ω1 is the maximal number of iterations in lines 5–16.For the lines 5–16, these pseudo-codes transform the initial symbol of the E-EGG into a graph only with terminal nodes and edges. Obviously, its maximal number of iterations is n. Thus,ω1≤n=O(n). While, the time complexity of function Initialize() is related to the number of structures in BPEL codes, that is to say, r1 ≤ O(n). In fact,r2=r3=r4=O(1). To achieve the function TypeofStructure(), productions should be searched to judge the type of the BPEL code. So,r5=O(ps).Combining all the above discussions, the following equations can be obtained:ω=O(n·ps)This subsection provides a case of a business process modeled by BPMN to show how the BPMN model can be transformed into BPEL codes using the steps presented in Section 4.1.1.Fig. 9shows a business process described by BPMN notations. In this business process, there are eleven activity nodes and ten gateway nodes. Wherein, if an edge has conditions, then conditions should be labeled beside the edge in this BPMN model, such as cond-1, etc. In addition, this model includes unstructured cycles, namely the cycle d->e->f and h->i->k. Then, how to transform this BPMN model into BPEL code?First, executing the first and second steps in Section 4.1.1, namely pretreatment and initialization. We may obtain the host graph of the E-EGG in the top of Fig. 10, which only has structured cycles. Meanwhile, some of the empty condition operations are added into the generated E-EGG graph in order to facilitate the analysis.Next, executing the third step in Section 4.1.1, namely calling a parsing algorithm. To analyze the business process given in the top of Fig. 10, the executions of the parsing algorithm in Fig. 7 are discussed in more detail as follows. In Fig. 10, each redex is identified, which is namedCijwhere j presents the number of an intermediate graph including this redex and i specifies the order of this redex. We use this notation to refer to the corresponding objects in the following transformation.1st Transformation. The parsing algorithm first tries to search all redexes with the productions given in Fig. 1. Obviously, the production 2 are satisfied and R-applications are then executed. In Fig. 10, the redexC11consisting of the activity a can be placed by the non-terminal node labeled S. Hence,C11is folded into a node labeled S with the BPEL transformation sketched as:<invoke name=”a”...>The similar operations are also applicable to other redexesC21,C31, …,C111.2nd Transformation. The parsing algorithm continues to find new redexes. As a result, the redexC12is selected and replaced by R-application with the production 3. It is a sequence structure and is folded into the non-terminal node labeled S with the BPEL transformation sketched as:<sequence><invoke name=”b”...> <invoke name=”c”…></sequence>In the same way, the redexC22is selected and replaced by R-application with the production 5. It is a switch structureand is folded into the non-terminal node labeled S with the BPEL transformation sketched as:<switch><case condition=”cond-2”> <invoke name=”d”...></case><case condition=”cond-3”> NULL</case></ switch >The similar operations are also applicable to other redexesC32,C42, …,C62.Similarly, according to the above processes, the BPMN models in Fig. 9 can be transformed into the corresponding BPEL codes step by step.

@&#CONCLUSIONS@&#
Based on the existing graph grammar EGG, this paper introduces some new mechanisms which include the attributes of each node and each edge in graphs, new productions, the Assign function and parsing algorithm, etc. Besides the formal definition of the E-EGG, steps and algorithms of bidirectional transformation between BPMN models and BPEL codes are given. According to a set of properly designed productions, the proposed method is able to not only check the structural correctness of host graphs but also perform transformations between the correspondences of BPMN and BPEL. Finally, a case study is provided to illustrate how the transformation from BPMN to BPEL works.Our future research includes the applications of the E-EGG to more BPMN related problems and the development of more effective parsing algorithm.