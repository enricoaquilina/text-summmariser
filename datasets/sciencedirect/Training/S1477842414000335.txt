@&#MAIN-TITLE@&#
AmbientTalk: programming responsive mobile peer-to-peer applications with actors

@&#HIGHLIGHTS@&#
We discuss the challenges of developing responsive mobile peer-to-peer applications.We introduce AmbientTalk, an actor-based distributed programming language designed to develop such applications.We compare an AmbientTalk application to an equivalent one in Java RMI.We define a small-step operational semantics for a subset of AmbientTalk.We establish data race and deadlock freedom of the concurrency model.

@&#KEYPHRASES@&#
Actors,Event loops,Futures,Mobile networks,Peer-to-peer,Service discovery,Leasing,

@&#ABSTRACT@&#
The rise of mobile computing platforms has given rise to a new class of applications: mobile applications that interact with peer applications running on neighbouring phones. Developing such applications is challenging because of problems inherent to concurrent and distributed programming, and because of problems inherent to mobile networks, such as the fact that wireless network connectivity is often intermittent, and the lack of centralized infrastructure to coordinate the peers.We present AmbientTalk, a distributed programming language designed specifically to develop mobile peer-to-peer applications. AmbientTalk aims to make it easy to develop mobile applications that are resilient to network failures by design. We describe the language׳s concurrency and distribution model in detail, as it lies at the heart of AmbientTalk׳s support for responsive, resilient application development. The model is based on communicating event loops, itself a descendant of the actor model. We contribute a small-step operational semantics for this model and use it to establish data race and deadlock freedom.

@&#INTRODUCTION@&#
Throughout the past decade, we have seen the rise of mobile platforms such as J2ME, iOS and Android. These platforms, in turn, enable a new class of applications: mobile peer-to-peer (P2P) applications. What is characteristic of such applications is that they are often used on the move, and that they sporadically interact with peer applications running on neighbouring phones (often communicating via a wireless ad hoc network [1]).Developing such applications is a challenge not just because of the inherent difficulty of developing distributed applications. Connectivity between phones is often intermittent (connections drop and are restored as people move about) and applications may not always rely on fixed infrastructure or a reachable central server to support the coordination.In this paper we present AmbientTalk, a distributed programming language designed specifically to develop mobile P2P applications. AmbientTalk is the first distributed object-oriented language that specifically targets applications deployed on mobile phones interconnected via an ad hoc wireless network. On the surface, the language is similar to other OO scripting languages such as JavaScript, Ruby or Python. However, contrary to these languages, it offers built-in support for concurrent and distributed programming. Its concurrency model is founded on actors [2]: loosely coupled, asynchronously communicating components.We show how AmbientTalk facilitates the development of mobile P2P applications that are resilient to intermittent network failures by default, and how this compares to mainstream distributed object-oriented middleware such as Java RMI (Section 7).Novelty: This paper complements previous expositions of AmbientTalk [3–5] with a precise operational semantics (Section 8). To the best of our knowledge, this is the first formal account of an actor-based language based on communicating event loops with non-blocking futures. We use the operational semantics to establish data race and deadlock freedom.Availability: AmbientTalk currently runs as an interpreter on top of the JVM and specifically targets Android-powered smartphones. It is open sourced under an MIT license and available at ambienttalk.googlecode.com. The Android version is published on the Google Play Store (http://bit.ly/HM7Kzv).AmbientTalk׳s concurrency and distribution features are tailored specifically to mobile ad hoc networks. We briefly describe the features characteristic of mobile ad hoc networks and why they present a challenge.There are two discriminating properties of mobile networks, which clearly set them apart from traditional, fixed computer networks: applications are deployed on mobile devices connected by wireless communication links with a limited communication range. Such networks exhibit two phenomena which are rare in their fixed counterparts:•Volatile connections: Mobile phones equipped with wireless media possess only a limited communication range, such that two communicating phones may move out of earshot unannounced. The resulting disconnections are not always permanent: the phones may meet again, requiring their connection to be re-established. Often, such transient network partitions should not affect an application, allowing it to continue its collaboration transparently upon reconnection. Partial failure handling is not a new ingredient of distributed systems, but these more frequent transient disconnections do expose applications to a much higher rate of partial failure than that which most distributed languages or middleware have been designed for. In mobile networks, disconnections become so omnipresent that they should be considered the rule, rather than an exceptional case.Zero infrastructure: In a mobile network, phones (and thus the applications they host) may spontaneously join or leave the network. Moreover, a mobile ad hoc network is often not administered by a single party. As a result, in contrast to stationary networks where applications usually know where to find collaborating services via URLs or similar designators, applications in mobile networks have to discover partner applications while roaming. Services must be discovered on proximate phones, possibly without the help of shared infrastructure. This lack of infrastructure requires a peer-to-peer communication model, where services can be directly advertised to and discovered on proximate phones.Any application designed for mobile networks has to deal with these phenomena. It is therefore worth investigating models or frameworks that ease the development of mobile P2P applications. Because the effects engendered by partial failures or the absence of remote services often pervade the entire application, it is difficult to apply traditional library or framework abstractions. Therefore, support for distributed programming is often dealt with in dedicated middleware (e.g. Java RMI [6], Jini [7]) or programming languages (e.g. Erlang [8], Emerald [9], Argus [10]). In the spirit of such systems, we designed AmbientTalk as a new distributed programming language.We briefly describe the foundations of AmbientTalk: Where did its features originate?Object model:AmbientTalk is a dynamically typed, object-oriented language. It was heavily inspired by Self [11] and Smalltalk [12]. Like Ruby, however, AmbientTalk is text-based (not image-based). Inspired by Scheme [13] and E [14], it places an additional emphasis on lexical nesting of objects and lexical scoping.AmbientTalk embraces actor-based concurrency [2]. In particular, it embraces a particular flavor of actor-based concurrency known as communicating event loops, pioneered by the E programming language [14], whose distinguishing features are (a) the treatment of an actor as a coarse-grained component that contains potentially many regular objects, and (b) the complete absence of blocking synchronization primitives. All interaction among actors is purely asynchronous.The event loop model maps well onto the inherently event-driven nature of mobile P2P applications. Phones may join or leave the network and messages can be received from remote applications at any point in time. All of these events are represented as messages sent to objects, orderly processed by actors. The use of event loops avoids low-level data races that are inherent in the shared-memory multithreading paradigm [15,16].AmbientTalk avoids traditional RPC-style synchronous distributed interactions, and provides only asynchronous message passing. This was a deliberate design choice to deal with the latency of wireless connections and the intermittent connectivity of devices due to transient network partitions.Inspired by the queued RPC mechanism of the Rover toolkit [17], remote references in AmbientTalk automatically buffer outgoing messages for which the recipient is currently unavailable. This allows the communication subsystem to automatically mask temporary network failures, which is especially useful in the face of intermittent wireless connectivity.AmbientTalk uses leasing to deal with partial failures, inspired by Jini [7].Following ABCL [18], Eiffel// [19], E [14] and Argus [20], AmbientTalk features futures (aka promises) to enable return values for asynchronous method calls. This mitigates part of the inversion of control that is characteristic of asynchronous, event-driven code.AmbientTalk makes use of the publish/subscribe paradigm [21] to express discovery among objects: services publish themselves in the network, while clients subscribe to these service announcements. In this light, AmbientTalk is a close cousin of Jini [7], albeit tailored to peer-to-peer networks: AmbientTalk programs need not rely on third-party lookup service infrastructure, but can discover one another directly.AmbientTalk was also inspired by M2MI [22], a lightweight extension to Java enabling asynchronous anycast communication in wireless networks.AmbientTalk is meant to serve as a research language to explore the language design space for mobile P2P applications. To support this role, it features an extensive set of reflective APIs to be able to extend the language from within itself. AmbientTalk supports a reflective architecture based on mirrors [23] and a variety of hooks into the actor system׳s message processing and transmission protocols, inspired by early work on reflection in concurrent object-oriented languages [24,25].Before explaining the concurrent and distributed features of AmbientTalk, we give a brief overview of its more conventional sequential building blocks.Objects: AmbientTalk is a dynamically typed, object-oriented language. It is prototype-based rather than class-based, meaning that objects are not instantiated from class declarations, but rather can be created as anonymous singleton objects (using an object literal declaration) or by cloning existing objects.In the example below, a top-level function named makePoint is defined. Its return value is a fresh object with three slots: x, y and distanceToOrigin. The x and y slots are initialized with the arguments to the function. The distanceToOrigin slot contains a method. Methods are implicitly parameterized with a self pseudo-variable, which they can use to access the receiver object׳s slots. Note that x and y are instance variables (slots) of the point object, while the variables t1 and t2 are local variables of the distanceToOrigin method. Numbers are objects in AmbientTalk, and sqrt is a method defined on such number objects:Blocks: While AmbientTalk is predominantly object-oriented, it has a distinctly functional flavor, through the use of blocks. Blocks (the terminology stems from Smalltalk) are objects that represent anonymous closures, i.e. functions that may refer to lexically enclosing variables. Blocks are constructed by means of the syntax{|args|body}, where the|args|part can be omitted if the block takes no arguments. For example:Like Smalltalk and Self, AmbientTalk often uses blocks to represent delayed computations, such as the branches of an if:then:else: control structure, or as listeners or callbacks to await an event, as will be shown later. For instance:The abs function calculates the absolute value of a number x. The if-test is not a built-in statement. Instead, the body of this function consists of a call to the function if:then:else:, which expects a boolean and two blocks. If the boolean is true, the first block is called (with no arguments), otherwise the second block is called.A unique feature of AmbientTalk is that functions or methods can be defined or called using both traditional C-style syntax as well as Smalltalk-style keyword message syntax. In general, keyword message syntax is used to express control structures (such as the if:then:else: function) while the C-style syntax is used to express application-level functions or methods (e.g. a function call like sum(1,2) or method invocation like p.distanceToOrigin()).Blocks are often used as arguments to higher-order functions, e.g. to map a function over an array. In the following example, a block is mapped over an array of points, producing an array of only the x-coordinates:The keyword message syntax in combination with syntactically lightweight blocks enables AmbientTalk programmers to easily define their own control structures. We have found this to be extremely helpful in a language that makes heavy use of asynchronous APIs and an event-driven programming style.Type tags: Since AmbientTalk is dynamically typed, it cannot use a static type system to categorize objects. Instead, the language provides annotations called type tags. Type tags can be used to annotate whole objects or individual methods or messages. They are also used for service discovery, as described shortly. An example:Apple is defined as a subtype of the Fruit type tag. The empty object a is then annotated with this tag. Type tags are analogous to empty “marker” interfaces in Java (such as java.lang.Cloneable and java.io.Serializable): these interfaces serve no purpose other than to classify objects, without making any claims as to the objects׳ supported methods (since these interfaces are empty).JVM interoperability: AmbientTalk provides built-in support to interoperate with the underlying JVM. This interoperability is similar to that of other dynamic languages implemented on top of the JVM such as Groovy, Jython and JRuby. Concretely, AmbientTalk programs can access Java classes or objects as if they were AmbientTalk objects. This allows AmbientTalk programs to reuse Java libraries. For example, the Java AWT GUI library can be used from AmbientTalk as follows:This code creates an AWT Button and registers a callback object to be notified when the button is clicked. Contrary to most JVM scripting languages, our interoperability layer takes special care to uphold AmbientTalk׳s actor-based concurrency model. Concretely, in the above example, when the Java GUI thread invokes actionPerformed on the AmbientTalk callback object, the interoperability layer will convert this method call into a message, and post this message to the AmbientTalk actor׳s event queue, such that the method body will be executed by the actor, not by the Java thread. This avoids race conditions on the object׳s state, since otherwise both an AmbientTalk actor and a Java thread might concurrently modify it. Our interoperability mechanism is described in full detail elsewhere [26].Other features: The above only scratches the surface of AmbientTalk׳s features. Two other features worth mentioning are:•Reflection: AmbientTalk features an extensive reflection API based on mirrors [23]. This allows objects to be inspected and modified at runtime. AmbientTalk also supports reflection at the actor-level, allowing for instance access on an actor׳s incoming message queue. AmbientTalk׳s reflective architecture is described in full detail elsewhere [27].Object composition: AmbientTalk features inheritance among objects (as in Self). It also supports traits [28], a more robust alternative to multiple inheritance. AmbientTalk traits are described in full detail elsewhere [29].As mentioned previously, AmbientTalk׳s concurrency model is based on actors [2]. A single AmbientTalk virtual machine can host multiple actors that may run in parallel.AmbientTalk combines objects with actors based on the communicating event loops model of the E programming language [14]. What sets this model apart from most other actor languages (such as Act1 [30], ABCL [18], Actalk [31], Salsa [32], Erlang [8], Kilim [33], ProActive [34] or Scala actors [35]), is that:•Each actor is not itself represented as a single object (a so-called “active object”), but rather as a vat containing an entire heap of regular objects. These objects may be stateful. Any object created by an actor is said to be owned by that actor, and forever remains contained in that actor. Objects owned by one actor may hold references to individual objects owned by other actors (i.e. objects contained by an actor may be referenced from outside of the actor, they are not necessarily private).There is no blocking synchronization primitive: Both the sending and receiving of messages between actors happen asynchronously. Contrary to e.g. Erlang or Scala actors, there is no direct equivalent to the receive statement that suspends an actor until a matching message arrives. Instead, message reception happens implicitly by invoking a method on an object.Thus, actors are not represented as individual objects, but rather as a collection of objects that all share a single event loop which executes their code. That event loop has a single message queue, containing messages to be delivered to one of its owned objects. The event loop perpetually takes the first message from the message queue and invokes the corresponding method of the object denoted as the receiver of the message. This method is then run to completion, without interleaving any other events (we discuss how method results are handled in Section 5.4). Consider the following example:By default, there is a single “main” AmbientTalk actor that executes all top-level code. In this example, the main actor creates (and thus owns) two account objects b1 and b2. Any external requests to withdraw or deposit from these accounts will be synchronized (i.e. the method bodies executed without interleaving).The process of dequeuing a message (such as withdraw or deposit) from the actor׳s queue and executing the corresponding method to completion is called a turn. In between turns, the runtime stack of an actor is always empty. Turns are the basic unit of “event interleaving” in AmbientTalk: while executing a turn, no other events can affect the actor׳s heap. In event-loop frameworks, this is sometimes called run-to-completion semantics, since every event is fully processed before processing the next. This avoids data races on the mutable state of objects owned by an actor.Only an object׳s owning actor may directly execute its methods. Objects owned by the same actor may communicate using ordinary, sequential method invocation or using asynchronous message passing. AmbientTalk borrows from the E language the syntactic distinction between sequential method invocation (expressed as o.m()) and asynchronous message sending (expressed as o<-m()).For example, since the main actor owns both b1 and b2, it may atomically transfer funds from one account to the other by executing:It may also decide to send these messages asynchronously:This enqueues the requests to withdraw and deposit in the main actor׳s own message queue. However, the programmer should now be aware that other messages may happen to arrive after withdraw but before deposit was scheduled. In other words, the transfer is no longer atomic, which may or may not be a problem, depending on the application requirements.It is possible for objects owned by one actor to hold references to individual objects owned by other actors. Such references that span different actors are named far references (the terminology stems from E [14]) and only allow asynchronous access to the referenced object. This ensures by design that all communication between actors is asynchronous. Trying to perform a sequential method invocation on a far reference provokes a runtime exception.Fig. 1illustrates AmbientTalk actors as communicating event loops. The dotted lines represent the event loop activity of each actor which perpetually takes the next message from its message queue and executes the corresponding method on one of its owned objects.To illustrate far references, consider the following example. Our main actor spawns a new actor and decides to share its account objects with this new actor:The expression actor: {...} spawns a new actor. The new actor immediately creates a new object, as if by evaluating object: {...}. This object, call it o, acts as the actor׳s public interface. The actor: expression immediately evaluates to a far reference to o, which is stored in the helper variable.The main actor then sends the transfer message via a far reference to o. Messages sent via a far reference to an object are enqueued in the message queue of the object׳s owner for later processing. Hence, the transfer message will later be dequeued and executed by the new actor, not by the main actor.When sending an asynchronous message to an object that is owned by the same actor, the message׳s parameters are passed by reference, exactly as is the case with regular sequential method invocations. When sending a message across a far reference to another actor, objects are instead parameter-passed by far reference: the parameters of the invoked method are bound to far references to the original objects.Take another look at the previous example. The main actor passes b1 and b2 as arguments to an asynchronous transfer message. When the helper actor executes the transfer method, from and to will be bound to far references to b1 and b2 respectively. Note that the helper actor must use asynchronous message passing (via<−) to perform the withdraw and deposit operations. Since it does not own the account objects, it cannot directly invoke their methods.There is one exception to the above parameter-passing rules: objects declared as isolates (via the expression isolate:{...} as opposed to object:{...}) are passed by (deep) copy rather than by far reference. Objects can only be declared as isolates if all of their methods are closed (i.e., do not contain references to lexically free variables). This ensures that such objects are isolated from their scope of definition (hence their name), allowing their methods to be safely executed in other actors. This restriction also ensures that isolates can be serialized without having to transitively serialize the value of any lexically captured variables. The benefit of isolates is that the recipient actor will receive its own local copy of the isolate, avoiding the need for further remote communication.By default, asynchronous message sends do not return a meaningful value (to be more precise, they return null). Often, an object that makes an asynchronous request is interested in a subsequent reply. For instance, in our previous example, what if the main actor wants to know when the transfer performed by the helper actor was completed? This can be accomplished as follows:Any AmbientTalk message may be annotated with the TwoWay type tag to indicate that sending the message should return a future. A future is a placeholder for the later return value, which may not yet be available. Initially, the future is said to be unresolved.The future gives us a handle on the return value, but is not itself the return value. One can register a callback with a future, which is executed when the future becomes resolved, and is passed as the actual return value of the message:The when:becomes:catch: function takes a future and two blocks (a callback and an errback) as arguments, and registers these blocks with the future, as if they were listener objects. If the asynchronously invoked method returns a value, the future is resolved, and the callback is called with the return value (in the above example, the transfer method just returns null, so ack will be null as well, serving only as an acknowledgement). If the method instead raises an exception, the corresponding future becomes ruined and the errback is called with the exception. The errback is analogous to a catch-clause in a regular sequential try-catch statement.Even if when:becomes:catch: is called on a future that is already resolved, the callback or errback is never immediately invoked, but instead always scheduled for eventual execution in the message queue of the actor that created the block. This ensures that the callback or errback is always executed in its own separate turn, and that the execution is properly serialized w.r.t. other messages processed by the actor.Returning to our example, we still have not quite successfully synchronized on the actual transfer of the money: when future resolves, all we actually know is that the transfer method was executed. But since the transfer method itself performs asynchronous requests, completion of the transfer method does not imply completion of the withdraw and deposit messages. This type of transitive asynchronous dependencies comes up sufficiently often that AmbientTalk futures provide support for it. It is possible to resolve a future f1 with another future f2, establishing a dataflow dependency among them: if f2 later becomes resolved with a non-future value v, then eventually f1 will also become resolved with v. Returning to our example, we need to change the transfer method as follows:The transfer method now returns a future f2, rather than null. The outer future will be resolved with this future f2. The callback will be triggered only when the deposit message, sent while executing the transfer method, has itself returned.While this particular example is correct, the code for transfer in general is not: our synchronization only works because we know from and to refer to account objects owned by the same actor. Since AmbientTalk actors enqueue messages in FIFO order, we know that if the deposit method was executed on to, the withdraw method was also executed on from, since it was enqueued earlier in the same actor. In the general case where from and to may refer to objects in different actors, we can no longer make that assumption.AmbientTalk has a number of auxiliary functions that operate on futures. One such function is group:. This function expects an array of futures [f1,f2,...] and returns a new “composite” future f. f is resolved with the array [v1,v2,...] when and only when f1,f2,... have all resolved to values v1,v2,.... If any of the argument futures is ruined with an exception, f becomes ruined with that same exception. If one thinks of futures as boolean with states resolved and ruined, then group: is the equivalent of the logical AND operator. Armed with group: we can apply the proper synchronization:The callback is now triggered only after both f1 and f2 have resolved.Futures as far references: AmbientTalk futures are also far references to their eventual value: one can send asynchronous messages to the future, and these are automatically forwarded to their value. As long as the future is unresolved, the messages are accumulated at the future. When the future is resolved, these accumulated messages are forwarded to the resolved value. If the future is ruined, any futures associated with accumulated messages are ruined with the same exception. This is the asynchronous equivalent of an exception propagating up the call stack.Conditional synchronization: So far, the only way to obtain a future has been to send an asynchronous message annotated as @TwoWay. In addition, these futures are automatically resolved with the return value of the corresponding method. Sometimes, this rigid pattern of using futures is insufficient: it may be that the resolved value of a future depends on run-time conditions known only at a later stage in the program. For instance, consider a bounded buffer with get() and put(v) methods. When the buffer is empty, it may want its get() method to return an unresolved future, to be resolved later when a producer sends a put(v) message.To facilitate such “conditional synchronization” [36] patterns, it is possible to explicitly create and resolve futures:The call to makeFuture returns two values: a fresh, unresolved future object, and a fresh corresponding resolver object. The creator can then share a reference to the future object, while retaining a reference to the resolver object. At a later time, when the value of the future is known, the creator can invoke resolver.resolve(value) to resolve the paired future. This will cause any callbacks registered on the future by means of the when:becomes:catch: function to be called in later event loop turns.The key concurrency properties provided by communicating event loops are:No data races:Since every object is owned by exactly one actor, and since actors process incoming messages for their owned objects sequentially, data races on the state of objects are avoided: there is at most one concurrent activity that can read or write their fields.If all message processing turns are finite, messages will never get stuck in actors’ message queues. Processing a message in finite time is helped by the fact that an actor can never block and wait for a message in the middle of a turn. It can only receive messages between turns, and has no mechanism to selectively block certain messages from being processed. In addition, AmbientTalk futures are fully non-blocking. Contrary to most future abstractions in other languages, they do not support a blocking get() method to await the future׳s value synchronously. One can only await a future׳s value asynchronously, via a callback registered using the when:becomes:catch: function.We should note that even in the absence of low-level data races and deadlocks, AmbientTalk programs can still exhibit higher-level safety and liveness issues. For example, while low-level data races are prevented, race conditions at the level of messages are still possible. For example, in the bank account example, if an object sends a withdraw() followed by a deposit() message, a third message sent by a different actor may interleave and be processed in between those two messages. The programmer is thus still responsible for synchronizing updates that are executed over multiple turns.With respect to liveness, while messages do not get stuck in actors׳ message queues indefinitely, other forms of lost progress bugs are still possible. In particular, messages or notifications may still get stuck indefinitely in the message queues of futures. For example, one actor may register a callback on a future using when:becomes:catch:, but if this future is never resolved, the callback will never be executed. There is also a known issue with futures known as data lock, which occurs when a future gets resolved with itself (either directly or indirectly, via a cycle of futures depending on each other) [14]. However, contrary to deadlocks in a multithreaded program, these lost progress bugs are mostly deterministic and are thus easier to reproduce and debug.We revisit these safety and liveness properties in more detail in Section 8.4.We now turn to AmbientTalk׳s features specifically geared towards distributed programming in mobile ad hoc networks.Actors are AmbientTalk׳s unit of concurrent and distributed execution. A single AmbientTalk virtual machine (VM) may host multiple actors. A network may in turn connect multiple AmbientTalk VMs. When an object a acquires a far reference to an object b in another actor, we call b a remote object (from a׳s point of view). Whether two actors are running inside the same VM or not is not visible at the language level. The programmer should always consider two actors to be distributed, and prepare for possible failures, even if the actors may reside on the same VM.Failure model: The VM is AmbientTalk׳s unit of failure: if a device running an AmbientTalk VM crashes, all the actors on that device crash. AmbientTalk provides no built-in abstractions to recover from device failures (e.g. actors have no persistent state). The network that connects multiple AmbientTalk VMs may also be subject to failures. At the implementation level, we assume a fully asynchronous network model where there is no upper bound on message delivery and individual network messages may be lost, duplicated and reordered. However, as we will explain in the following sections, at the programming language level, AmbientTalk makes the network reliable. Messages sent between remote actors will eventually be delivered, without duplicates and in FIFO order, as long as the network eventually heals and the VMs hosting the actors do not crash. Our message delivery protocol assumes cooperating VMs, we do not attempt to overcome Byzantine failures [37].We have previously shown that objects can acquire a new far reference to a remote object by simply passing an object as a parameter into or as a return value from a message sent via an existing far reference. However, this requires some initial far reference to an object in the remote actor. How is this process bootstrapped?AmbientTalk uses a publish/subscribe service discovery protocol.33The current implementation uses a custom peer-to-peer service discovery protocol based on UDP and IP multicasting and is designed primarily for ad hoc WiFi networks. An AmbientTalk version that uses Bluetooth is also available.A publication corresponds to an object advertising itself by means of a type tag. The type tag serves as a topic known to both publishers and subscribers [21]. A subscription is made by registering a callback block on a type tag. The callback will be triggered whenever an object advertised with that tag is detected in the network.An object that advertises itself is said to be exported. Once exported, an object becomes a globally accessible entry-point. In most distributed systems, exported objects are identified by means of a URL and a UUID, or similar such global identifiers. However, URLs rely on infrastructure (name servers), which cannot always be relied upon in a mobile ad hoc network. In addition, in mobile P2P applications, one application is often interested in any other application with which it can partner, not necessarily a specific application. Thus, mobile P2P applications are more interested in a type of service than a particular unique instance of a service.We use type tags to provide a description of what kinds of services an object provides to remote objects. We make the explicit assumption that all devices in the network attribute the same meaning to each type tag, i.e. we assume that they use a common classification scheme.Assume a mobile P2P application named MatchMaker that wants to pair up with other applications of the same type. This application exchanges user profiles and alerts the user when a matching profile is found. The MatchMaker application exports an object serving as its publicly accessible entry-point, as shown below.Once the myEndPoint object is exported, it can be discovered by other actors. The export:as: function returns an object pub that can be used to take the exported object offline again, by invoking pub.cancel().To discover remote endpoints of peer applications, a MatchMaker application can subscribe a callback to be notified whenever a matching endpoint is discovered in the network:The whenever:discovered: function takes as arguments a type tag and a block that serves as a callback. Every time an object with a matching type tag is discovered by the language runtime, an invocation of this callback is enqueued in the actor owning the block. The remoteEndPoint argument to the block is bound to a far reference pointing to the myEndPoint object of a peer MatchMaker application. The whenever:discovered: function returns an object sub whose cancel() method can be used to cancel the registration of the callback.Because objects residing on different devices are necessarily owned by different actors, far references are the only kind of object reference that can span across different devices. By design, this ensures that all distributed communication is asynchronous. This strict adherence to asynchronous distributed communication has two advantages in wireless networks:•First, latency in wireless networks is still more significant than in wired networks. Asynchronous communication helps to hide latency, enabling applications to perform useful work, or remain responsive, even while sending and receiving messages.Second, as noted previously, connections among roaming mobile devices are often volatile. Asynchronous communication facilitates communication along such intermittent connections via buffering. When sender and receiver are disconnected, outgoing messages can be buffered and retransmitted when the connection is restored. This is like sending e-mail while working offline.AmbientTalk׳s far references make use of such buffering to be resilient to network disconnections by default. Returning to our example, when a MatchMaker application discovers a peer, it obtains a far reference remoteEndPoint to communicate further. Should the peer application disconnect at that point, the exchange message will be buffered within the reference. When the network partition is eventually restored, the far reference automatically retransmits the message. Hence, messages sent to far references are never lost, regardless of the internal connection state of the reference.Of course, not all network partitions are transient. Some will be permanent, or sufficiently long-lasting to require application-level failure handling. To this end, AmbientTalk makes use of leasing [38]. Objects can be exported with a lease such that any far reference that points to it provides access for only a limited period of time (the lease period). For example, the MatchMaker application can export the myEndPoint as a leased object instead of directly exporting the object itself:The function lease:for: expects an object and a duration (here, 2min) and returns a leased proxy for the object. When the proxy is passed to a client in another actor, a leased far reference (also called a leased reference) is created to the leased object which remains valid for at most 2min. The client accesses the myEndPoint object transparently via a leased reference until the lease time elapses. At the discretion of the creator of the lease, the lease can be renewed, prolonging access to the object. By default, the lease is renewed every time a message arrives at the leased object.Fig. 2summarizes the different states a far reference can be in. When the far reference is connected and the lease has not yet expired, it forwards messages to the remote object. While disconnected, messages are accumulated in the reference, as previously explained. When the lease expires, access to the remote object is permanently revoked and the far reference itself becomes expired. Any message sent to an expired reference is discarded (not buffered), and any future associated with this message is ruined with an appropriate exception. Far references to non-leased objects are like leased references whose lease period is infinite.Both endpoints of a leased reference can register callbacks to be invoked upon expiration, e.g. to schedule clean-up actions. Once all far references to an object have expired, the object is taken offline, becoming subject to garbage collection if it is no longer locally referenced. Leased references facilitate distributed garbage collection: without leasing, a single disconnected far reference could keep an object online forever.AmbientTalk also integrates leasing into asynchronous message passing to allow developers to specify an upper bound on how long to wait for the return value of a message. An asynchronous message may be annotated with the Due type tag. Like TwoWay, this indicates that the message send will return a future. The Due type tag expects a duration, which indicates an upper bound on how long this future will remain unresolved. We can use the Due type tag in the exchange message send to denote the time the application is willing to wait for the exchange of profiles as follows:The Due tag makes the exchange message send immediately return a future (stored in the variable leasedFuture). This future is passed by leased reference to the remoteEndPoint object initialized with a lease of 2min. If the leasedFuture is resolved before its lease time has elapsed, the becomes: block triggers as usual. Otherwise, when the lease time elapses, the future is automatically ruined with a TimeoutException exception, and the catch: block is triggered. If the associated message is still buffered locally, it is removed from the buffer and discarded.So far, we have shown how the language can be used to develop a small mobile peer-to-peer application. Over the past few years, we have employed AmbientTalk to build a variety of mobile peer-to-peer applications ranging from a drawing application44A demo of the drawing application called weScribble is available at http://goo.gl/GUbJsDto various multiplayer games including an “urban game” called Flikken[39].In this section, we describe a mobile music player application which we employ to compare AmbientTalk with Java RMI [6]. Java RMI can still be considered a state-of-the-art middleware for distributed object-oriented computing, forming the basis for mobile computing middelware such as Jini (cf. Section 9).Consider a music player running on mobile devices. The music player contains a library of songs. When two people using the music player enter one another׳s personal area network, the music players set up an ad hoc network and exchange their music library׳s song index (not necessarily the songs themselves). After the exchange, the music players calculate the percentage of songs both users have in common. If this percentage exceeds a certain threshold, the music players can e.g. inform the user that someone with a similar taste in music is nearby.Fig. 3gives a graphical overview of the music library exchange protocol modelled in an asynchronous distributed object-oriented system. The figure depicts the protocol from the point of view of device A. This protocol is executed simultaneously on both devices. Once both devices discover each other, the music player running on A sends the openSession message to the remote peer B to start a session to exchange its library index. In response to it, the remote peer B returns a new session object which implements methods that allow the remote music player to send song information (uploadSong) and to signal the end of the library exchange (endExchange).When implementing the music library exchange protocol, it is important to take the effects of volatile connections into account. First, the application should remain responsive in the face of intermittent failures, e.g., the application may want to inform the end-user that the transmission of songs is temporarily suspended. In addition, the application must also cope with permanent failures. Otherwise, if a peer disconnects in the middle of the library exchange, the session may never terminate, and the application will consume unnecessary resources, e.g., a partially uploaded library.We now compare AmbientTalk with Java RMI based on implementing the same music player application in both platforms and subsequently, we evaluate both implementations quantitatively based on an analysis of their lines of code. We refer the reader to [40] for details regarding both the AmbientTalk and Java RMI implementations.The AmbientTalk implementation (90 LoC) is significantly shorter than the corresponding Java RMI implementation (462 LoC). This difference can be partly attributed to the different syntactic nature of AmbientTalk and Java, so by itself these numbers do not mean much. However, what we can compare is the relative amount of code spent on non-functional concerns related to concurrency and distribution.Fig. 4a lists a breakdown of the total number of lines of code according to four different concerns: (1) memory management: includes the code to set up leases and reclaim resources upon lease expiration, (2) concurrency control: includes support for asynchronous communication and buffering during transient disconnections, (3) failure handling: managing timeouts and (4) application-specific code.Fig. 4b shows the relative percentage of these lines of code compared to the total application size. Note the relatively small percentage of AmbientTalk LoC spent on the non-functional concerns. The main causes for the relative blow-up in non-functional code in Java RMI is that it does not feature buffered, asynchronous communication, and its support for leasing is very tightly coupled to the distributed garbage collection module. We should note that we deliberately left out any comparison regarding service discovery, as Java RMI has no support for this.The only conclusion that we want to draw from this comparison is that AmbientTalk seems to succeed at reducing the impact of non-functional concerns that arise when developing fault-tolerant mobile P2P applications.Our exposition of AmbientTalk so far was largely informal. The rest of the paper aims to provide a precise description of AmbientTalk׳s concurrency and distribution model. To this end, we present a small step operational semantics of a subset of AmbientTalk named Featherweight AmbientTalk oratffor short. Our semantics is based primarily on that of JCobox [41], but adapted for a dynamically typed, classless language, and modified to precisely reflect AmbientTalk׳s communicating event loops model with non-blocking futures.Theatfsubset contains actors, objects, isolates (pass-by-copy objects), blocks (functions), non-blocking futures and asynchronous message sending. In Section 8.5 we extendatfwith service discovery, enabling objects in different actors to discover one another. In Section 8.6, we introduce the notion of disconnected actors and fault-tolerant messaging between actors.atfdoes not model AmbientTalk׳s object inheritance using prototype-based delegation, its support for trait-based composition (which is formalized elsewhere [29]), reflection, exceptions, leasing and JVM interoperability.A machine-executable implementation of theatfsemantics in PLT Redex [42] is available online.55http://soft.vub.ac.be/~cfscholl/index.php?page=at_semantics.atffeatures both functional and imperative object-oriented elements (Fig. 5). The functional elements descend directly from the λ-calculus (using an eager evaluation strategy). Anonymous functions are denoted byλx.eand correspond to AmbientTalk blocks. Variable lookup inatfis lexically scoped. Local variables can be introduced vialetx=eine.The imperative object-oriented elements stem from object-based (i.e. classless) calculi [43].atffeatures object {...} and isolate {...} literal expressions to define fresh, anonymous objects. These literals consist of a sequence of field and method declarations. Fields may be accessed and updated. Methods may be invoked either synchronously viae.m(e¯)or asynchronously viae←m(e¯).In the scope of a method body, the pseudovariable self refers to the enclosing object literal. self cannot be used as a parameter name in methods or redefined using let.New actors can be spawned using the actor {...} literal expression. This creates a new object with the given fields and methods in a fresh actor that executes in parallel. Actor and isolate literals may not refer to lexically enclosing variables, apart from the self-pseudovariable. That is, for all field initializer and method body expressions e in such literals, the set of free variablesFV(e)⊆{self}. Isolates and actors are thus literally “isolated” from their surrounding lexical scope, allowing their subexpressions to be evaluated independent of the lexical scope in which they were defined.Futures can be created using the expressionletxf,xr=futureine. This expression brings two variables in scope within the subexpression e: xfwill be bound to a fresh future value and xrwill be bound to a corresponding resolver object. Thisatfexpression corresponds to the built-in makeFuture() function from AmbientTalk (cf. Section 5.4).The resolver object can be used to assign a value to its corresponding future, using the expressionresolvexre. This resolves the future corresponding to xrwith the value of e. Theresolveexpression fromatfcorresponds to invoking the built-in resolver.resolve(v) method in AmbientTalk (cf. Section 5.4).The value of a future xfcan be awaited using the expressionwhen(xf→x){e}. When the future becomes resolved with a value v, the expression e is evaluated with x bound to v. Thisatfexpression corresponds to the when:becomes:catch: function in AmbientTalk (cf. Section 5.4).atfsupports two forms of asynchronous message passing. Expressions of the forme←m(e¯)denote one-way asynchronous message sends that do not return a useful value. If a return value is expected, the expressione←fm(e¯)denotes a two-way asynchronous message send that immediately returns a future for the result of invoking the method m. This is the equivalent of messages annotated with the @TwoWay tag in AmbientTalk (cf. Section 5.4).A number ofatfexpressions can be defined in terms of a desugaring (local transformation), as shown in Fig. 6.It is well-known that functions can be expressed in terms of objects and vice versa.atffunctions (like AmbientTalk blocks) are defined as objects with a single method called apply. The substitution[xself/self]eis necessary to ensure that within function bodies nested inside object methods, the self-pseudovariable remains bound to the object enclosing the function, and not to the object representing the function. Function applicatione(e¯)is desugared into invoking an object׳s apply method.A two-way message sende←fm(e¯)is syntactic sugar for a simple one-way message send that carries a fresh resolver object xr, added as a hidden last argument. The message m is marked mf, serving as a signal for the recipient actor that it needs to pass the result of the method invocation to xr. The value of a two-way message send expression is the future xfcorresponding to the passed resolver xr.The desugaring of “when” and “resolve” make use of special messages namedresolveμandregisterμ. The μ (for “meta”) suffix identifies these messages as special meta-level messages that should be interpreted differently by actors. A regularatfprogram cannot fabricate these messages other than by using the “when” and “resolve” expressions.The expressionwhen(e→x){e′}is used to await the value of a future. It is syntactic sugar for registering a callback function xcwith the future. The expression as a whole returns a dependent future xfthat will become resolved with the expressione′when the future denoted by e eventually resolves.The expressionresolveee′is used to resolve a future with a value, where e must reduce to a resolver ande′to any value. Ife′reduces to a non-future value, the callback function xcwill be called with its x argument bound to the value ofe′. Ife′reduces to a future value, the callback function will be called later, with its x argument bound to the resolved value of the future. Thus, this definition ensures that futures can only be truly resolved with non-future values.atfsemantic entities are shown in Fig. 7. Script letters likeFandMare used as “constructors” to distinguish the different semantic entities syntactically. Regular uppercase letters like F and M denote sets or sequences. Actors, futures, resolvers and objects each have a distinct address or identity, denotedιa,ιf,ιrandιorespectively.The state of anatfprogram is represented by a configuration K, which is a set of concurrently executing actors. Each actor is an event loop consisting of an identityιa, a heap O denoting the set of objects, futures and resolvers owned by the actor, a queue Q containing a sequence of messages to be processed, and the expression e that the actor is currently executing.Objects consist of an identityιo, a tag t and a set of fields F and methods M. The tag t is used to distinguish objects from isolates, witht=odenoting an object andt=Idenoting an isolate. Isolates are parameter-passed by-copy rather than by-reference in remote message sends, but otherwise behave the same as regular objects.Anatffuture is a first-class placeholder for an asynchronously awaited value. Futures consist of an identityιf, a queue of pending messages Q and a resolved value v. A future is initially unresolved, in which case its resolved value v is set to a unique empty value ϵ. While the future is unresolved, any messages sent to the future are queued up in Q. When the future becomes resolved, all messages in Q are forwarded to the resolved value v and the queue is emptied. We do not model AmbientTalk׳s support for ruined futures and asynchronous propagation of exceptions.A resolver object denotes the right to assign a value to its unique paired future. Resolvers consist of an identityιrand the identity of their paired futureιf. The resolver is the only means through which a future can be resolved with a value.Messages are triplets consisting of a receiver value v, a method name m and a sequence of argument valuesv¯. They denote asynchronous messages that are enqueued in the message queue of actors or futures.All object references consist of a global componentιathat identifies the actor owning the referenced value, and a local componentιo,ιforιr. The local component indicates that the reference refers to either an object, a resolver or a future. We defineFutureIdandResolverIdto be a subset ofObjectIdsuch that a reference to a future or a resolver is also a valid object reference. As such,ιa.ιocan refer to either an object, a resolver or a future, butιa.ιfcan refer only to a future.Our reduction rules operate on “runtime expressions”, which are simply all expressions e including references r, as a subexpression may reduce to a reference before being reduced further.We use evaluation contexts [44] to indicate what subexpressions of an expression should be fully reduced before the compound expression itself can be further reduced:e□::=□∣letx=e□ine∣e□.f∣e□.f:=e∣v.f:=e□∣e□.m(e¯)∣v.m(v¯,e□,e¯)∣e□←m(e¯)∣v←m(v¯,e□,e¯)e□denotes an expression with a “hole”. Each appearance ofe□indicates a subexpression with a possible hole. The intent is for the hole to identify the next subexpression to reduce in a compound expression. The notatione□[e]indicates that the expression e is part of a compound expressione□, and should be reduced first before the compound expression can be reduced further.Actor heaps O are sets of objects, resolvers and futures. To lookup and extract values from a set O, we use the notationO=O′{o}. This splits the set O into a singleton set containing the desired object o and the disjoint setO′=O\{o}. The notationQ=Q′·mdeconstructs a sequence Q into a subsequenceQ′and the last elementm. We represent queues as sequences of messages that are processed right-to-left, meaning that the last message in the sequence is the first to be processed. We denote both the empty set and the empty sequence as ∅.Our semantics is defined in terms of a relation on configurations,K→K′. The rules defining the relation are split into two parts: actor-local rulesa→aa′and global rulesK→kK′. This makes it explicit which steps can be executed in isolation within a single actor a, and which require interaction between different actors in a configuration K.Anatfprogram is an expression e that is reduced in an initial configuration containing a single “main” actorKinit={A〈ιa,∅,∅,[null/self]e〉}. The actor׳s heap and queue are initially empty, and the self-pseudovariable is bound to null at top-level.Both actor-local and global rules can be applied non-deterministically, which gives rise to concurrency. We do not yet consider actors distributed across different devices, connected by a network, until Section 8.6. For now, we consider all actors to remain permanently connected with each other.Actor-local reductions: Actors operate by perpetually taking the next message from their message queue, transforming the message into an appropriate expression to evaluate, and then evaluate (reduce) this expression to a value. When the expression is fully reduced, the next message is processed. As discussed previously, the process of reducing such a single expression to a value is called a turn. It is not possible to suspend a turn and start processing another message in the middle of a reduction.The only valid state in which an actor cannot be further reduced is when its message queue is empty, and its current expression is fully reduced to a value. The actor then sits idle until it receives a new message. If an actor is reducing a compound expression, and finds no applicable actor-local reduction rule to reduce it further, the actor is stuck. This signifies an error in the program.We now summarize the actor-local reduction rules in Fig. 9:•let: a “let”-expression simply substitutes the value of x for v in e according to the substitution rules outlined in Fig. 8.new-object, new-isolate: These rules are identical except for the tag of the fresh object, which is set to o for objects and i for isolates. Evaluating an object or literal expression adds a new object to the actor׳s heap. The new object׳s fields are initialized to null. The literal expression reduces to a sequence of field update expressions. The self pseudovariable within these field update expressions refers to the new object. The last expression in the reduced sequence is a reference r to the new object.invoke: A method invocation looks up the method m in the receiver objectιa.ιoand reduces the method body expression e with appropriate values for the parametersx¯and the pseudovariable self. It is only possible to invoke a method on a local object. The receiver reference׳s global componentιamust match the identity of the current actor.field-access, field-update: A field update modifies the actor׳s heap such that it contains an object with the same address but with an updated set of fields. Again, field access and field update apply only to objects local to the executing actor.make-future: A new future–resolver pair is created such that the future has an empty queue and is unresolved (its value is ϵ), and the resolver contains the future׳s identityιf. The subexpression e is further reduced with xfand xrbound to references to the new future and resolver respectively.local-asynchronous-send: An asynchronous message sent to a local object (i.e. an object owned by the actor executing the message send) adds a new message to the end of the actor׳s own message queue. The message send immediately reduces to null.process-message: This rule describes the processing of incoming asynchronous messages directed at local objects or resolvers (but not futures). A new message can be processed only if two conditions are satisfied: the actor׳s queue Q is not empty, and its current expression cannot be reduced any further (the expression is a value v). The auxiliary function process (see Fig. 10) distinguishes between:-A regular message m (or the meta-level messageresolveμ), which is processed by invoking the corresponding method on the receiver object.A two-way message mf, as generated by the desugaring ofe←fm(e¯). Such a message is processed by invoking the corresponding method on the receiver object, and by sending the result of the invocation to the “hidden” last parameter r which denotes a resolver object.A meta-level messageregisterμ, which indicates the registration of a callback function v, to be applied to the value of a resolved future. Since process is only applicable on non-future valuesιa.ιo, the callback function v can be triggered immediately, by asynchronously applying it toιa.ιo. This ensures that v is applied later in its own turn.process-msg-to-future: This rule describes the processing of incoming asynchronous messages directed at local futures. The processing of the message depends on the state of the future, as determined by the auxiliary function store. This function returns a tuple(m,e)where m denotes either a message or the empty sequence, and e denotes either an asynchronous message send or null. The message m is appended to the future׳s queue, and the actor continues reducing the expression e. The store function determines whether to store or forward the message m, depending on the state of the future and the type of message:-If the future is unresolved (i.e. its value is still ϵ), the message is enqueued and must not be forwarded yet (e is null).If the future is resolved and the message name m is notregisterμ, the message need not be enqueued (m is ∅), but is rather immediately forwarded to the resolved value v.If the future is resolved and the message isregisterμ, which indicates a request to register a callback functionιa.ιowith the future, the function is asynchronously applied to the resolved value v. This request need not be enqueued (m is ∅).resolve: This rule describes the reduction of the meta-level messageresolveμ, as used in the desugaring of the “when” and “resolve” expressions. This message can only be reduced when directed at a resolver objectιrwhose paired futureιfis still unresolved (i.e. its value is still ϵ). The paired future is updated such that it is resolved with the value v, which must be a non-future value (i.e.v≠ιa′.ιf′). At the same time, the future׳s queueQ′is emptied. The messages previously stored inQ′are forwarded as a sequence of message sends, as described by the auxiliary functionfwd:-If the queue is empty, no more messages need to be forwarded and the expression reduces to null.If the queue contains a message m or the meta-level messageresolveμ, that message is forwarded to v.If the queue contains the messageregisterμ, this indicates a request to notify the callback functionιa.ιowhen the future becomes resolved. The function is thus asynchronously applied to the future׳s resolved value v.Actor-global reductions: We summarize the actor-global reduction rules in Fig. 11:•new-actor: When an actorιareduces an actor literal expression, a new actorιa′is added to the configuration. The new actor׳s heap consists of a single new objectιowhose fields and methods are described by the literal expression. As in the rule for new-object, the object׳s fields are initialized to null. The new actor has an empty queue and will, as its first action, initialize the fields of its only object. The actor literal expression itself reduces to a far reference to the new object, allowing the creator actor to communicate further with the new actor.far-asynchronous-send: This rule describes the reduction of an asynchronous message send directed at a far reference, i.e. a reference whose global componentιa′differs from that of the current actorιa. A new message is appended to the queue of the recipient actorιa′. The argumentsv¯of the message send expression are parameter-passed as described by the auxiliary function pass (see Fig. 10). This function prescribes the setO″of copied isolate objects to be added to the recipient׳s heap and a sequence of valuesv′¯with updated addresses referring to the copied isolates, if any. As in the local-asynchronous-send rule, the message send expression evaluates to null.congruence: This rule merely relates the local and global reduction rules.The auxiliary functionpass(ιa,O,v¯,ιa′)(see Fig. 12) describes the rules for parameter-passing the valuesv¯from actorιato actorιa′, where O is the heap of the sender actorιa.The parameter-passing rules foratfvalues are simple: objects are passed by far reference, isolates are passed by copy, and null is passed by value. When an isolate is passed by copy, all of its constituent field values are recursively parameter-passed as well.The auxiliary functionreach(O,v¯)returns the set of all isolate objects reachable via other isolates in O, starting from the root valuesv¯. The first two cases define the stop conditions of this traversal. In the third case, an isolate object o is encountered and added to the result. All of o׳s field values are added to the set of roots, and o itself is removed from the set of objects to consider, so that it is never visited twice. The fourth rule skips all other values and applies when v is null, a far referenceιa′.ιo′, an object that was already visited (v=ιa.ιo,ιo∉O) or a non-isolate object (v=ιa.ιo,O〈ιo,o,F,M〉∈O).The mapping σ prescribes fresh identities for each isolate inO′. The function pass prescribes the set of isolatesOσ′which is simply the setO′with all isolates renamed according to σ. The function σvreplaces references to parameter-passed isolates with reference to the fresh copies, and is the identity function for all other values.In Section 5.5 we argued that AmbientTalk׳s event loop concurrency model avoids low-level data races and deadlocks by design. Having introduced an operational semantics foratf, we can state these properties more formally.A data race would occur when two or more actors would simultaneously try to access the field of an object, and at least one of the field accesses is a field update. In the operational semantics, there are no true simultaneous accesses as the “concurrent” actors are reduced one step at a time. However, a simultaneous field access would occur if there are at least two actors in a configuration that would have a field access as the next expression to evaluate, and both actors could proceed. Formally:Definition 1Field accessA configuration K has a field access on a reference r in actora∈K, denotedfieldaccess(K,a,r)iffa=A〈ιa,O,Q,e□[e]〉withe≡r.fore≡r.f:=v, andK→kK″, withK″=K‴a′anda′=A〈ιιa,O,Q,e□[v]〉.A configuration K has a simultaneous field access on a reference r iffK=K′aa′andfieldaccess(K,a,r)andfieldaccess(K,a′,r).Let K be a configuration. K is free of data races as there can be no simultaneous field accesses in K.We show that if there is more than one actor in a configuration trying to access the same field of the same object, then at most one of these actors can make a step. Let r be a reference to the object that is being simultaneously accessed. LetK′⊆Kbe the set of actors performing a field access of the forme□[r.f]ore□[r.f:=v]. Then at most one of these field accesses can be reduced to a value v, all other actors will be stuck.The only rules that allow such field accesses to be further reduced are (field-access) and (field-update). These rules can only be triggered if r is of the formιa.ιo. If r is any value other than a reference to an object, e.g.nullorιa.ιf, the actor will get stuck.Ifr=ιa.ιoboth rules require that the actor executing the expression has a corresponding identifierιa. As actor identifiers are unique within a configuration (cf. rule(new−actor)), there can be at most one actor with identifierιa. Thus there can be at most one actor wheree□[r.f]ore□[r.f:=v]can be reduced to a value. All other actors executing these expressions must have different identifiers, and thus the (field-access) and (field-update) rules are not applicable, causing these actors to get stuck, thus preventing a simultaneous field access.□We show that, given two reasonable assumptions, any message sent from one actor to another must eventually be processed. That is, messages cannot get stuck indefinitely in the message queues of actors, i.e. message passing inatfis deadlock-free. This result, however, depends on two assumptions:Totality: We assume that the individual message processing turns of all actors are total, i.e. processing a message does not diverge or get stuck, but always eventually reduces to a value. This assumption certainly does not hold for allatfprograms. It only holds for correct programs that do not provoke runtime errors (which would lead to stuck states) and that do not diverge (i.e. go into an infinite loop).Axiom 1TotalityA total actor configuration K is one where each actora∈Kthat is evaluating a compound expression e will eventually reduce this expression to a value v. That is,∀a∈K,a=A〈ιa,O,Q,e〉,e≠v∃K′:Ka→k⁎K′∪A〈ιa,O′,Q′,v〉.Here,→k⁎is the reflexive transitive closure of→k.Fairness: Actor configurations K can be reduced in a non-deterministic manner when multiple reduction rules are applicable, as we do not specify a particular order in which the rules apply. However, we will assume a fair scheduling strategy among actors (i.e. every actor that can make progress eventually does make progress). An unfair scheduler could prevent an actor from making progress by always choosing reduction rules that advance only other actors. Fairness can be enforced by the rewrite system (foratf) or the VM (for AmbientTalk).Axiom 2FairnessWe requireatfcomputations to be fair. A computation is fair if each reduction ruleK→kK′that is enabled (i.e. is applicable) is either eventually chosen or becomes permanently disabled (i.e. inapplicable).Our definition of fairness is based on Agha et al.׳s foundational work [45]. We refer to their work for a more formal and detailed treatment of fairness.Given these assumptions, it can be guaranteed that messages never get stuck in the message queues of actors, i.e. all messages are eventually processed. Our proof depends on the following two lemmas:Lemma 1Message sending is non-blockingSending an asynchronous message never blocks the sending actor:∀Ka,a=A〈ιa,O,Q,e□[ιa′.ιo′←m(v¯)]〉∃K′:Ka→kK′A〈ιa,O,Q′,e□[null]〉.Ifιa′=ιathen the message send is local, and the (local-asynchronous-send) rule in combination with the (congruence) rule is directly applicable.Otherwise,ιa′≠ιasuch that the only rule that is applicable is (far-asynchronous-send). This rule is applicable regardless of what particular expressione′the recipient actorιa′is executing. The recipient actor does not need to be in any particular state to accept new incoming messages.□If an actor is ready to process a message and its message queue is non-empty, it must always process the next message. It cannot skip or delay the processing of certain messages. That is∀Ka,a=A〈ιa,O,Q··M〈v,m,v¯〉,v′〉∃K′:Ka→kK′A〈ιa,O′,Q,e〉.By case analysis on the form of v, the receiver of the message. A value v can either be a reference r or the valuesnullor ϵ. The latter two can never be a valid receiver value: the only rules that ever enqueue messages in an actor׳s queue are (local-asynchronous-send), where the value must be a local reference, and (far-asynchronous-send), where the value must be a far reference. It follows that v must be a reference, more specifically, a referenceιa.ιodenoting an object, future or resolver owned by a.If v is a reference to an object or resolver, i.e.v=ιa.ιowithιo∉FutureId, then the rule (process-message) is applicable. Apart from requiring that the actor׳s expression has been fully reduced to a value v and that the message is first in the queue, there are no particular restrictions on the contents of the message. If v is a reference to a future, i.e.v=ιa.ιf, then rule (process-msg-to-future) is applicable, regardless of whether the future is resolved or unresolved.□All messages sent between actors are eventually processed. That is, messages cannot get stuck indefinitely in actors׳ message queues.By Lemma 1, when an actor a1 is ready to send a message m it can always proceed independent of the state of the recipient actor a2. By Axiom 2, the rule (far-asynchronous-send) will eventually be applied. The message is now in the incoming message queue Q of a2.We now show that the message m is eventually processed by a2. First, assumeQ=Q′·m(i.e. m is the first message in the queue). If a2 is idle (i.e. it has fully reduced its expression to a value v), Lemma 2 is applicable and a2 can eventually process m (Axiom 2). Otherwise, a2 is still processing an earlier message. By Axiom 1, message processing is total such that the actor eventually becomes idle, reducing the problem to the previous case.If Q contains more than one message, i.e.Q=Q′·m′, the above reasoning similarly applies andm′will eventually be processed, shortening a2׳s queue toQ′. As messages are processed in strict FIFO order, m must eventually become the first message in the queue and will eventually be processed.□In Fig. 13, we extendatfwith primitives for service discovery, allowing objects in different actors to discover one another as described in Section 6.1.atfactors are extended with a set of exported objects X and a set of import callbacks I. Values are extended to include type tags τ. Objects can be exported, and callbacks can be registered, under various type tags. When the tags match, the callback is fired. Theatfsyntax is extended with tag literals and expressions to export objects, to register callbacks for discovery and the syntactic sugarwhenDiscovered(e→x){e′}to resemble the AmbientTalk when:discovered: function.Fig. 14lists the additional reduction rules for service discovery:•publish: To reduce an export expression, the first argument must be reduced to a type tag τ and the second argument must be reduced to a reference (which may be a far reference). The effect of reducing an export expression is that the actor׳s set of exported objects X is extended to include the exported object and tag. An exported object is parameter-passed as if it were included in an inter-actor message. Hence, if the object is an isolate, a copy of the isolate is made at the time it is exported.subscribe: To reduce a discover expression, the first argument must be reduced to a type tag τ and the second argument must be reduced to an object reference. The effect of reducing a discover expression is that the actor׳s set of import callbacks I is extended to include a reference to the local callback object, and the tag.match: This rule is applicable when a configuration of actors contains both an actorιa′that exports an object under a type tag τ, and a different actorιathat has registered a callback under the same tag τ. The effect of service discovery is that an asynchronous apply message will be sent to the callback object inιa. The callback is simultaneously removed from the import set of its actor so that it can be notified at most once. The exported object v is parameter-passed again, this time to copy it from the publication actorιa′to the subscription actorιa.Note that when exporting an isolate object, the isolate will be copied at least twice: once when initially exported, and once again whenever it is matched against a subscription. The initial copy upon export is necessary such that the exported object becomes self-contained, and can no longer be modified by the exporting actor. The (match) rule can be triggered while the exporting actor is in the middle of evaluating an expressione′. If we were to make the initial copy of the exported object in the (match) rule, a data race could be possible where the actorιa′was in the middle of updating the isolate׳s fields.So far, we have assumed thatatfactors are always permanently connected to all other actors. In practice, actors may reside on distributed devices and only occasionally connect to deliver messages. In Fig. 15, we extendatfactors with networks. Networks partition actors such that communication between actors is only possible if they are in the same network. A network is represented as a unique identifier.The use of networks allows us to more faithfully describe AmbientTalk׳s remote message passing semantics with buffering of messages sent to far references (see Section 6.2). Asynchronous message sends are now split into two parts: message creation and message transmission. Whenever an actor reduces the←operator, a message is created and stored in a message outbox (called Qout), to be transmitted when the recipient is connected. This is called time-decoupled communication[21], as actors do not require an active network connection at the time they send a message to each other.We represent an actor׳s outbox Qoutas a function that, for each remote actorιa, stores all outgoing messages addressed to objects owned byιa. The outgoing messagesQout(ιa)are represented as an ordered sequence of envelopesl¯. An envelope is simply a messagemtogether with the set of isolate objectsOmpassed as arguments to that message. These objects have to be passed together with the message upon transmission.In the reduction rules, the original rule for far-asynchronous-send is replaced by new rules for message creation (create-message) and message transmission (transmit-message). Fig. 16lists the additional reduction rules for time-decoupled message transmission:•create-message: This rule creates a new envelope and appends it toQout(ιa′), i.e. the list of outgoing messages addressed at actorιa′. This rule is actor-local, so it is applicable regardless of whether the recipient actor is currently in the same network.transmit-message: This rule is applicable whenever an actor is in the same network as an actor for which it has undelivered messages. If this is the case, the last (i.e. eldest) of these undelivered messages is removed from the sender actor׳s outbox and appended to the destination actor׳s inbound message queue.mobility: This rule describes that actors can switch between different networks. Application of this rule is entirely involuntary, i.e. actors do not themselves choose to move, they are moved around (non-deterministically) by the system or environment.The extensions toatffor service discovery and robust time-decoupled message sends do not break the results established in Section 8.4 pertaining to data race and deadlock freedom, with one exception: to uphold deadlock-freedom, time-decoupled message sends introduce the additional assumption that the sender and receiver actor must eventually join the same network. Otherwise, the message cannot be delivered and will remain stuck in the sender׳s outgoing message queue.Whileatfonly models the essential core language of AmbientTalk, the race and deadlock freedom results ought to be transferrable to the full language, as we have faithfully modelled all communication primitives present in the full language. None of the AmbientTalk׳s libraries or built-in functions introduce additional ways for two actors to directly share state or to communicate other than by asynchronous message passing.

@&#CONCLUSIONS@&#
