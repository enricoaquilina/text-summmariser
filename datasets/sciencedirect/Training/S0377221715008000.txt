@&#MAIN-TITLE@&#
An approach using SAT solvers for the RCPSP with logical constraints

@&#HIGHLIGHTS@&#
A new methodology is presented to add logical constraints in project scheduling problems.Network transformations are used to solve the problem efficiently.A boolean satisfiable solver guarantees that logical conflicts do not occur.

@&#KEYPHRASES@&#
Project scheduling,RCPSP,AND/OR/BI constraints,SAT,

@&#ABSTRACT@&#
This paper presents a new solution approach to solve the resource-constrained project scheduling problem in the presence of three types of logical constraints. Apart from the traditional AND constraints with minimal time-lags, these precedences are extended to OR constraints and bidirectional (BI) relations. These logical constraints extend the set of relations between pairs of activities and make the RCPSP definition somewhat different from the traditional RCPSP research topics in literature. It is known that the RCPSP with AND constraints, and hence its extension to OR and BI constraints, is NP-hard.The new algorithm consists of a set of network transformation rules that removes the OR and BI logical constraints to transform them into AND constraints and hereby extends the set of activities to maintain the original logic. A satisfiability (SAT) solver is used to guarantee the original precedence logic and is embedded in a metaheuristic search to resource feasible schedules that respect both the limited renewable resource availability as well as the precedence logic.Computational results on two well-known datasets from literature show that the algorithm can compete with the multi-mode algorithms from literature when no logical constraints are taken into account. When the logical constraints are taken into account, the algorithm can report major reductions in the project makespan for most of the instances within a reasonable time.

@&#INTRODUCTION@&#
Resource-constrained project scheduling is a widely discussed project management topic which has roots in and relevance for both academic and practical oriented environments. Due to its inherent problem complexity, it has been the subject of numerous research projects leading to a wide and diverse set of procedures and algorithms to construct resource feasible project schedules. Thanks to its practical value, many of the research results have found their way to practical project management projects. From the initial attempts to construct project schedules using a quantitative scheduling approach, as proposed by the PERT/CPM methods, many extensions have been proposed to make the constructed project schedules more realistic.The presence of renewable resource constraints with limited availability has led to the so-called resource-constrained project scheduling problem (RCPSP) which is one of the most investigated scheduling problems in the project management literature. Resource-constrained project scheduling is the process of constructing a project schedule within the limited amount of resources available. It requires the examination of the possible unbalanced use of resources over time to resolve over-allocations (the so-called resource conflicts) when more resources are required than available. The critical path based scheduling methods will often schedule certain activities simultaneously, but when more resources such as machines or people are needed than there are available, these activities will have to be rescheduled concurrently or even sequentially to resolve the resource constraints. Resource-constrained project scheduling is the process of resolving these resource conflicts such that the total project makespan is minimized.In this paper, the well-known RCPSP is extended with two classes of logical constraints to model new relations between pairs of activities. Furthermore, a solution approach, based on the principles used by Coelho and Vanhoucke (2011, 2014) is proposed to solve this new problem to near-optimality in reasonable time. The paper is organized as follows. In Section 2, a time-indexed formulation for the well-known RCPSP is given and the AND precedence relations are extended to OR and bidirectional (BI) constraints. Section 3 reports on the new solution procedure to solve the problem heuristically in reasonable time, and includes the network transformation rules, the use of the satisfiability (SAT) solver and the metaheuristic search for resource feasible solutions. In Section 4, the design for a new public dataset is described and computational results for all the experiments are reported. In Section 5, general conclusions are drawn and paths for future research are briefly discussed.The RCPSP can be stated as follows. A set of activities N, numbered from a dummy start node 0 to a dummy end node n + 1, is to be scheduled without pre-emption on a set R of renewable resource types. Each renewable resource k ∈ R has a constant availability akper period. Each nondummy activity i ∈ N has a deterministic duration diand requires ri, kunits of resource type k ∈ R. The start and end dummy activities representing the start and completion of the project have a duration and a renewable resource requirement equal to zero. A project network is represented by a topological ordered activity-on-the-node (AoN) format where A is the set of pairs of activities between which a finish-start precedence relationship with time lag 0 exists. We assume graph G(N, A) to be acyclic. A schedule S is defined by a vector of activity start times and is said to be feasible if all precedence and renewable resource constraints are satisfied. The objective of the problem type is to find a feasible schedule within the lowest possible project makespan, and hence, the problem type can be represented as m, 1T|cpm|Cmax using the classification scheme of Herroelen, Demeulemeester, and De Reyck (1999) or as PS|prec|Cmax following the classification scheme of Brucker, Drexl, Möhring, Neumann, and Pesch (1999).A time-indexed formulation of the RCPSP using the binary variable xitthat is equal to 1 if activity i is started at time instance t, and 0 otherwise, can be stated as follows (Pritsker, Watters, & Wolfe, 1969):(1)Minimize∑t=esn+1lsn+1txn+1,tsubject to(2)∑t=esilsi(t+di)xi,t≤∑t=esjlsjtxj,t∀(i,j)∈A(3)∑t=esilsixi,t=1∀i∈N(4)∑i=1nri,k∑s=max(t−di,esi)min(t−1,lsi)xi,s≤ak∀k∈Randt=1,…,T(5)xi,t∈{0,1}∀i∈N;t=1,…,Twhere esiand lsiare used to denote the earliest and latest start for activity i given the project upper bound T using traditional forward and backward critical path calculations. Eq. (1) minimizes the total project makespan. Eq. (2) takes the finish-start precedence relations with a time-lag of zero into account. Eq. (3) guarantees that each activity can only start once at a certain time t. The renewable resource constraints are satisfied thanks to Eq. (4). Eq. (5) forces the decision variables to be binary values.While most of the resource-constrained project scheduling algorithms focus on the traditional AND constraint, different types of logical constraints have been defined in literature. In this paper, three types of precedence relations between activities will be used to construct a resource feasible schedule. To that purpose, the set of precedence relations A will be split up into three disjoint sets Aand, Aor and Abi to define these types of activity precedences. In the following subsections, Eq. (2) will be replaced by five new equations to model these three precedence classes.Most algorithms to solve the RCPSP make use of an activity network with precedence relations with minimal and/or maximal time-lags that force an activity to start/finish no earlier than the start/finish of all its predecessor activities. Ever since the research on improved algorithms to solve resource-constrained project scheduling problem has started, a wide variety of problem formulations have been proposed in literature. For an overview of the research on the RCPSP, the reader is referred to the surveys of Herroelen, De Reyck, and Demeulemeester (1998), Icmeli, Erengüç, and Zappe (1993), Kolisch and Hartmann (2006), Özdamar and Ulusoy (1995) and Hartmann and Briskorn (2010), the classifications schemes of Brucker et al. (1999) and Herroelen et al. (1999) and the overview handbooks written by Demeulemeester and Herroelen (2002) and Vanhoucke (2012).The traditional so-called AND constraints used in almost all problem formulations have been modelled in Eq. (2) as finish-to-start relations with a minimal time-lag of zero. In this paper, the set of AND constraints is denoted by the symbol Aand and hence, Eq. (2) can now be formulated as follows:(6)∑t=esilsi(t+di)xi,t≤∑t=esjlsjtxj,t∀(i,j)∈AandThe OR precedence relations differ from the traditional AND constraints discussed in the previous section that they only require one predecessor to finish before the successor activity can start. Consequently, for an activity with multiple predecessors, a choice has to be made which predecessor will be the dominant one to force the activity not to start earlier. Unlike the AND constraints, all other predecessors can have an overlap with the activity. Scheduling tasks with and/or constraints are discussed in Belhe and Kusiak (1995), Gillies and Liu (1995), Adelson-Velsky and Levner (2002) and Möhring, Skutella, and Stork (2004). In order to define the set of OR constraints Aor, Möhring et al. (2004) have defined a set of waiting activities Nw⊂N consisting of activities j ∈ Nwfor which all pairs(Pjor,j)∈Aorimply that activity j can only start after the finish of at least one activityi∈Pjor. The setPjor(indexl=1,…,|Pjor|) is defined as the set of predecessor activities of waiting activity j linked by an OR constraint. A new binary decision variable yjlis defined for each OR relation for each waiting activity j that is used in a big M constraint to model this new precedence relation, as follows:(7)∑t=esilsi(t+di)xi,t≤∑t=esjlsjtxj,t+Myjl∀(Pjor,j)∈Aor;l=1,…,|Pjor|(8)∑k=1|Pj|oryjl≤|Pjor|−1∀j∈NwEq. (7) models the precedence relations with an additional big M to force OR relation between two activities. Only whenyjl=0,the constraint forces activity j to start after the finish of its predecessor i. Eq. (8) assures that for each waiting activity j at least one yjlis equal to zero according to the definition of the OR constraint.A second extension of the traditional AND precedence relations is the presence of bidirectional precedence constraints that simple stipulate that pairs of activities cannot be executed in parallel, i.e. either the first one has to be executed in order to start the second one, or vice versa. A typical example where the precedence between activities is defined by a bidirectional precedence relation is where both activities make use of the same resource. Often, a (sequence-dependent) changeover time between the two activities accompanies this constraint, as a result of transferring the resource to another place where the execution of the successor activity takes place. This changeover time γijis defined as the minimal time needed between the finish of activity i and the start of activity j to transfer and possibly set up the resource to be used by activity j. To that purpose, a new binary variable zijis defined to model that two activities cannot be executed in parallel, but should be scheduled in a sequence, with at least a minimal time interval to include the changeover times. Sequence-dependent changeover times have been mentioned in papers by Drexl, Nissen, Patterson, and Salewski (2000) and Herroelen, Demeulemeester, and De Reyck (2001).(9)∑t=esilsi(t+di+γij)xi,t≤∑t=esjlsjtxj,t+Mzij∀(i,j)∈Abi(10)∑t=esjlsj(t+dj+γji)xj,t≤∑t=esilsitxi,t+M(1−zij)∀(i,j)∈AbiEq. (9) models the precedence relation between activities i and j and is only relevant in case the zijis equal to zero. Otherwise, ifzij=1,this equation becomes redundant and Eq. (10) then forces activity i to start after the finish of activity j.Fig. 1 displays an example project network in an activity-on-the-node format with 8 nondummy activities and one renewable resource with a limited availability of 3 units. The durations of all activities are displayed above each node while the resource demand is given below each node. All arcs are traditional AND relations with a minimal time-lag of zero, unless otherwise indicated. More precisely, activity D has a set of OR relations with its predecessors as indicated by the dotted arcs. A bi-directional relation between activities E and F exists, as indicated by the bi-directional dotted arc, and it is without loss of generality assumed that the changeover times are equal to zero, i.e.γEF=γFE=0.The schedule displayed on the top shows the optimal schedule in which all relations are traditional AND relations, leading to a makespan of 11 units. The schedule displayed at the bottom respects the OR relations of activity D and the bi-directional relationship between activities E and F. Its makespan is also 11 time units, but activity D starts before the finish of activity C, but after A and B. Moreover, E and F do not overlap, but instead F is scheduled after E. In the computational experiment section, the impact of adding OR and BI relations on the project makespan will be investigated under various settings and for various values of the changeover times.While most of the projects make use of the traditional AND constraints, the use and relevance of logical constraints have been mentioned and illustrated in the literature using various project examples. In Hartmann and Briskorn (2010), examples are given for “exclusive OR” (XOR) relations, which can be seen as a special case of OR constraints, for an R&D project in which only one activity must be executed, either activity “modify prototype” or “start production” after the execution of the predecessor activity “test prototype” and the choice of the activity depends on the outcome of this predecessor activity. Other examples appear in literature, such as Kuster and Jannach (2006) who refers to the use of logical constraints to model mutual exclusion and inclusion relationships between activities, Belhe and Kusiak (1995) who make use of hierarchically structured design activity network with AND, OR and XOR relations, as well as the book by Berthaut (2011) who shows that overlapping modes can be generalized to precedence modes in order to describe all precedence relationships between activities.A straightforward practical application of OR constraints is given in the first example project network displayed on the left of Fig. 2that shows three activities A, B and C that each make use of a different resource type (denoted as ResType x with x equal to 1, 2 or 3). However, activity D is a merging activity that can only be started once one of its predecessors is finished, and should therefore be modelled by OR constraints between activity D and its predecessors. The reason is that activity D can be executed by each of the resource types used by the previous activities, and its start depends on the earliest release of one of the resource types 1, 2 or 3.BI constraints are more intuitive to understand since they mainly involve activities that make use of the same set of resources and can therefore not be executed in parallel. While this can be easily modelled with traditional renewable resource constraints, the presence of sequence-dependent changeover times makes it an ideal problem to be modelled with BI constraints. In the second example on the right of Fig. 2, activities A, B and C make use of the same resource type 1, and changeover times are assumed to be sequence-dependent, i.e. γAB ≠ γBA, γAC ≠ γCA and γBC ≠ γCB. These activities should therefore be scheduled in a sequence which clearly depends on the values of these changeover times and the start and finish times of other activities in the network. The changeover times in the example can be best seen as setup times for resources when switching between activities. The literature on setup times has been reviewed and summarized in the paper by Hartmann and Briskorn (2010).Logical SAT constraints have been successfully used to solve the multi-mode resource-constrained project scheduling problem (MRCPSP) by Coelho and Vanhoucke (2011, 2014). In these papers, each activity is duplicated in multiple activities according to their number of possible modes. A SAT algorithm is invoked to cope with the selection of modes for activities as well as to take the limited availability of nonrenewable resources into account, while a metaheuristic search procedure to solve the RCPSP aims at constructing a resource feasible schedule. The communication between the activity list of the metaheuristic search and the variable list used in the SAT search can be done by one single list of activities. Additionally, clause learning helps to prevent the occurrence of recurring conflicts in the SAT search and improves the performance of the algorithm, certainly when the stop criterion is set at large values. In the next section, it will be shown that this general approach can be translated to the RCPSP problem with logical constraints and leads to near optimal solutions for problem instances with reasonable size.In order to construct near-optimal schedules for the RCPSP with AND, OR and BI constraints, the activity network will be transformed to an extended network to incorporate the new precedence logic. In doing so, the new network will only contain the traditional AND constraints such that the scheduling problem reduces to a traditional RCPSP which can be efficiently solved by a state-of-the-art (meta)heuristic search method from literature. Moreover, a SAT search will be added on top of this algorithm to guarantee that the logic of the OR and BI precedences is satisfied.The network transformation for the OR constraints is relatively easy and consists of the duplication up of each waiting activity into several activities. More precisely, each waiting activity j that has|Pjor|predecessors with OR constraints is duplicated into|Pjor|activities. These activities are duplicates of the waiting activity j and have the same duration and resource demand. Each of these duplicated activities is linked by exactly one of the predecessors of waiting activity j using an AND constraint and with all successor activities of the waiting activity.Fig. 3shows how OR constraints are translated into an activity network with only AND relations. The waiting activity D has three predecessors with OR constraints, i.e.|PDor|=3,and a set of successor activities modelled by the single set of nodesSD. The activity network with both AND (solid arcs) and OR precedence relations (dotted arcs entering activity D) can be transformed into an activity network with only AND constraints by duplicating activity D into a set of activities that is equal to the number of OR relations entering the activity (i.e.|PDor|). In the example, activity D can only start when either activity A, activity B or activity C is finished, and hence, activity D is duplicated into activities D1, D2 and D3. The OR relation is now shifted to the duplicated activities and requires that only one of the duplicated activities D1, D2 or D3 is the real activity D. The SAT logic of Section 3.2 will guarantee that only one of the duplicated activities D1, D2 or D3 will be selected as the real activity with a duration and resource requirement equal to the values of the original activity D, and the two other activities will then be transformed into dummy activities.The transformation of networks with bidirectional constraints requires the duplication of activities in multiple activities and the addition of extra activities to model the changeover times. More precisely, each set of two activities with bidirectional constraints is duplicated into two times two activities with additional AND relations, and the changeover times are modelled by two extra activities that are put in-between these newly created duplicated activities. The construction of such a subnetwork can be best explained by means of a general example as shown in Fig. 4.This figure illustrates how a bidirectional constraint between activities A and B with changeover times γAB (between A and B) and γBA (between B and A) can be easily transformed into an activity network with only AND relations. Both activities A and B are duplicated in four new activities A1, A2, B1 and B2 to model that B1 can only start after the finish of A1, or alternatively, A2 can only start after the finish of B2. Only one of the two possibilities will occur and the other activities will be set to dummy activities, and this will be guaranteed by logical SAT constraints described in Section 3.2. In between these duplicated activities, a new activity is added with a duration equal to the changeover time γAB and γBA, respectively. Finally, extra AND relations are added to guarantee the logical relations between the original A and B activities with their set of successors (SAandSB) and predecessors (PAandPB).The selection of activities in the transformed network is done using a boolean satisfiability problem (SAT) solver to determine which of the duplicated activities have positive durations and which others are considered to be dummy activities. The activity with the positive duration then inherits the resource requirements of the original activity while the dummy activities do not require resources at all. The boolean satisfiability problem is a well-known decision problem where an expression of boolean variables (referred to as literals) linked by means of the logical operators and, or and not is questioned to be true or false. The problem has been studied extensively in literature (see e.g. the paper by Marques-Silva and Sakallah, 1999, amongst others) and is known to be NP-complete (Cook, 1971). In this section, the literal ziis defined as a 0/1 variable of activity i to denote whether this activity will have a positive duration (1) or not (0).OR constraints: The selection of exactly one duplicated activity to satisfy the OR constraint of Fig. 3 can be modelled by the following constraint:Selectonlyoneactivity:zD1+zD2+zD3=1This constraint can be easily translated into the conjunctive normal form (CNF) traditionally used in SAT research that is a conjunction of clauses linked by the “and” operator, as follows:Selectatleastoneactivity:(zD1∨zD2∨zD3)Selectatmostoneactivity:(zD1¯∨zD2¯)∧(zD1¯∨zD3¯)∧(zD2¯∨zD3¯)The second clause should consist of all pairs of activities, or in general, a constraintz1+z2+⋯+zk=1can be represented in the CNF as(z1∨z2∨⋯∨zk)∧(z1¯∨z2¯)∧⋯∧(z1¯∨zn¯)∧(z2¯∨z3¯)∧⋯∧(zk−1¯∨zk¯).Since the “select at most one activity” expressions might consist of quite a large number of clauses just for one activity, a special so-called k clause can replace this CNF equation by using only two clauses that can be generally modelled as follows:(z1¯+z2¯+⋯+zk¯)≥k−1resulting in exactly two clauses in total for each activity with OR constraints. The term “k clause” is used to refer to a special type of clause that requires k literals to be satisfied instead of 1 literal as is the case for normal clauses (Coelho & Vanhoucke, 2011).BI constraints: The selection of pairs of activities to satisfy the BI constraints of Fig. 4 can be modelled using the following constraints:Selectonlyonestartactivity:zA1+zB2=1SelectB1ifA1isstartactivity:zA1−zB1=0SelectγABifA1isstartactivity:zA1−zγAB=0SelectA2ifB2isstartactivity:zA2−zB2=0SelectγBAifB2isstartactivity:zB2−zγBA=0The translation of this set of clauses into CNF is done as follows:Selectonlyonestartactivity:(zA1∨zB2)∧(zA1¯∨zB2¯)SelectB1ifA1isstartactivity:(zA1∨zB1¯)∧(zA1¯∨zB1)SelectγABifA1isstartactivity:(zA1∨zγAB¯)∧(zA1¯∨zγAB)SelectA2ifB2isstartactivity:(zA2∨zB2¯)∧(zA2¯∨zB2)SelectγBAifB2isstartactivity:(zγBA∨zB2¯)∧(zγBA¯∨zB2)While the first clause is similar to the clauses used for the AND constraints, the other clauses are new and can be generally modelled aszi=zjconstraints that can be represented in the CNF as(zi∨zj¯)∧(zi¯∨zj).The pseudocode to transform activity networks with OR constraints into activity networks with only AND constraints (see Section 3.1) as well as the incorporation of SAT clauses to select the activities that satisfy the logic of all OR constraints (see Section 3.2) is given below.Similarly, the pseudocode for the BI network transformations and the corresponding SAT clauses is given below.Applying these transformation and clause insertion rules to the activity network of Section 2.2 results in the extended network with 14 nondummy activities, as shown in Fig. 5. The OR relations of activity are duplicated into 3 activities, each with a duration and a resource demand equal to the values of activity D. The BI relations between activities E and F are translated into a subnetwork with four nondummy activities E1 and E2 (F1 and F2) with a duration and resource demand equal to the original activity E (F), and two additional changeover activities γEF and γFE with a duration equal to the changeover times (equal to zero in the example) and no resource demand.The metaheuristic search algorithm used to solve the problem instances is based on the algorithm of Coelho and Vanhoucke (2011) that was initially proposed to solve multi-mode resource-constrained project scheduling problem with limited renewable and nonrenewable constraints but without the presence of logical constraints. This search procedure consists of an activity selection algorithm to select activities in networks using a single priority list that can be used to model both the activity list and the mode list, as will be discussed in Section 3.4.2. The search procedure also makes use of an activity scheduling step using a state-of-the-art metaheuristic scheduling algorithm from literature, as will be briefly summarized in Section 3.4.1. In the current paper, this search logic is used to solve two types of resource-constrained project scheduling problems with logical constraints, as follows:•The resource-constrained project scheduling problem with logical constraints as proposed in the model formulation using Eqs. (1)–(4), and further abbreviated as RCPSP-Log.The multi-mode resource-constrained project scheduling problem with logical constraints, further abbreviated as MMRCPSP-Log. This problem extends the RCPSP-Log to the presence of nonrenewable resource constraints as well as the use of multiple modes for each activity.In order to solve these two problem types, the search procedure of Coelho and Vanhoucke (2011) needed some adaptations which will be described in the following sections. Due to the network transformations to cope with logical constraints, the project networks often increase dramatically in size, and hence, a first adaptation was made to heuristically cope with these large-sized project networks. The extension to multiple modes in the MMRCPSP-Log increases the project network size even further, which has led to an activity selection procedure that operates under a truncated search process followed with a greedy search step. Moreover, the incorporation of nonrenewable resource constraints for the multi-mode problem has also led to an additional improvement step to solve infeasible solutions when the nonrenewable resource constraints are not met. Fig. 6shows a graphical representation of the algorithm to solve the problem. The flow chart consists of two parts, i.e. an activity selection flow to make the selection of activities using a SAT solver to satisfy all the constraints and a scheduling algorithm that aims at scheduling the nondummy (i.e. selected) activities to near-optimality. The algorithm starts with the random generation of a population of activity lists which are first added to the activity selection step to satisfy all constraint, and returns back to the activity scheduling step as a restricted feasible list that enters the initial population of solutions. This process is repeated until the required number of restricted activity lists is in the population set. Then, the algorithm passes to the activity scheduling step which aims at improving the current solutions in the population, using crossover operators and local search processes. Each time the activity scheduling step evaluates a newly constructed solution, a call to the activity selection step is made to check for constraints feasibility. Hence, the algorithm in Fig. 6 sequentially generates new solutions (activity scheduling) and checks constraints feasibilities (activity selection) in order to return a near-optimal solution after a predefined stop criterion. The details of each step are outlined in Sections 3.4.1 and 3.4.2 and example calculations on the extended network of Fig. 5 are shown in Appendix A.The right part of Fig. 6 graphically displays the adapted SAT search, further referred to as the GSAT heuristic (Selman, Levesque, & Mitchell, 1992), to obtain a feasible selection of activities from the transformed and extended project networks that satisfy all the logical constraints, and, when relevant, the limited amount of nonrenewable constraints. Although not explained in this paper, the presence of limited nonrenewable resources when solving multi-mode project scheduling problems, as will be done in parts of our computational tests, also results in nonrenewable resource constraints clauses which also must be satisfied in a similar way as the clauses for the logical constraints defined in Section 3.2. The construction of the constraint clauses for the nonrenewable resource constraints is based on a simple yet efficient enumeration scheme proposed by Coelho and Vanhoucke (2011).Fig. 6 starts with a population of activity lists that will be used for both the activity selection and activity scheduling steps, which size is equal to the number of activities in the extended project network after transformations. An activity selection mechanism, displayed at the right of the figure, selects from each activity list only a subset of activities to incorporate the logic of the three types of precedences (for problems RCPSP-Log and MMRCPSP-Log) as well as the limited nonrenewable resource constraints (for problem MMRCPSP-Log) (see the computational experiments of Section 4).The selection of these activities is done by incorporating a set of SAT clauses as explained in Section 3.3. While in Coelho and Vanhoucke (2011) an optimal SAT solver using the DPLL algorithm of Davis, Logemann, and Loveland (1962) is used which always returns a feasible set of activities from the extended activity list, this approach could no longer be followed for the current paper due to the large size of the projects after the network transformations. Therefore, an alternative approach, referred to as GSAT, is used that works as follows:•Backtrack limits: The DPLL algorithm assigns values (true/false) to activities and backtracks when infeasibilities occur but this intensive search process is truncated after a predefined number of backtracking limits. Computational experience has shown that this backtracking limit is best set at low values and has been set to 20 in all our experiments.Set remaining values: The set of values that have been set by the truncated DPLL are kept fixed, and the remaining values for the variables are assigned in a greedy way to obtain an activity list for which each variable has a value true or false. More precisely, for each unassigned set of variables representing activities in the extended network, exactly one variable is set to true. This resulting SAT solution possibly leads to an infeasible activity list assignment when nonrenewable resources are taken into account (only for problem MMRCPSP-Log) since a number of these clauses might be violated (#violations in Fig. 6).Improvement step (only for problem MMRCPSP-Log): The number of violations in the clauses is reduced by sequentially repeating a greedy search algorithm that swaps the values between activities in the extended network which corresponds to flipping the value of the literature from true/false to false/true. For every swap, the impact on the number of violations is measured, which might lead to an increasing number of clauses with violations (deteriorations are displayed by downward arcs) or a decreasing number of clauses with violations (improvements are represented by upward arcs). After swapping each activity, the swap that has resulted in the best improvement is kept and this process is repeated several times until a stop criterion is met. In our computational experiments, the best value of the stop criterion is set at a repetition of maximum 4 times. Obviously, when no further violations occur, this process is truncated earlier.This search approach might result in an activity selection which is feasible towards all logical constraints and nonrenewable resource limits, and this remaining activity list with the activities equal to true as the real activity list (all remaining activities become dummy activities) now enters the scheduling step to obtain a feasible and near-optimal solution. In case the remaining activity list still contains a number of violations, a penalty is added to the resulting project makespan which is a function of the number of violations and the algorithm also continues with the activity scheduling step.The population of activity lists generated in the previous step contains a list of activities for which some of the activity durations are set to zero (dummy activities) resulting in restricted activity lists. These lists are now input to a traditional resource-constrained project scheduling algorithm to construct a resource-feasible schedule. The way the search process to near-optimal solutions is carried out is based on a collection of principles borrowed from literature that have been proven to perform excellent.The dual population algorithm, consisting of so-called left- and right-justified schedules is based on the recommendations of Valls, Ballestin, and Quintanilla (2005) and selects parents to construct new child solutions as combinations from both groups using a 2-tournament selection. A two-point crossover operator based on a modified version of the peak crossover operator of Valls, Ballestin, and Quintanilla (2008) using the so-called resource utilization ratio that measures the resource utilization at time unit t allows the selection of time intervals for which the resource utilization is high, so-called peaks, and time intervals with low resource utilization. The local search consists of an iterative forward and backward search of Li and Willis (1992) to improve the two separate populations containing left- and right-justified schedules. This process is initiated on the reduced activity list, and is sequentially repeated on only a subpart of the constructed schedule until a stop criterion is met. This decomposition approach is based on the recommendations of Debels and Vanhoucke (2007) who have shown that an intensive search on subparts of schedules leads to improved solutions.This metaheuristic search process for activity scheduling is graphically displayed on the left pane of Fig. 6 and contains no fundamentally new techniques compared to the best known performing techniques from literature. Each time the metaheuristic algorithm produces a new activity list, the objective function of this new solution must be evaluated. Prior to each evaluation, the newly generated activity list is passed to the activity selection algorithm as an unrestricted list (setting the dummy activity durations back to their original values) and a new restricted list that satisfies all the constraints is returned to the activity scheduling step. The objective of this new activity list is evaluated (i.e. the feasible schedule obtained by the restricted list), and possibly enters the population. In the computational results section, it will be shown that the combined activity selection and activity scheduling step leads to promising results on two well-known project datasets using different settings for the logical constraints.Two datasets have been used to validate the performance of our novel algorithm using resource-constrained project scheduling problems with single-mode and multi-mode activities. The single-mode tests are ran on the single-mode instances of the PSPLIB dataset downloaded from www.om-db.wi.tum.de and presented in Kolisch and Sprecher (1996). All multi-mode tests are done on the triple set MMLIB50, MMLIB100 and MMLIB+ downloaded from www.projectmanagement.ugent.be and presented in Van Peteghem and Vanhoucke (2014), as well as on the multi-mode instances of the PSPLIB.Since all instances from these datasets only contain AND relations, both OR and BI constraints have been generated under a controlled design. To that purpose, two metrics κ1 and κ2 are used to transform some of these AND relations to OR and/or BI relations. These two parameters allow us not only to control the amount of AND relations that will be transformed into OR or BI relations, but also guarantee that future researchers can simply replicate this approach leading to exactly the same networks and the location of the AND/OR/BI relations. The parameter κ1 determines the start activity that will be selected while parameter κ2 is used to determine the percentage of activities that will be selected for the transformation from AND to OR constraints. More precisely, activity i will be selected as an activity for which the AND relations with all its predecessor activities will be transformed into OR relations if the following equation(i+κ1)modκ2=0holds. As an example, if κ1 = 3 and κ2 = 10 then the first activity will be i = 7 ((7+3)mod10=0), the second one activity 17, and so on. The selection of bidirectional constraints is done in a similar way. The two parameters κ1 and κ2 are used to select activities, and the BI constraint is added with the immediate predecessor of this activity with the lowest activity number in the network.The following three sections report computational results to evaluate the performance of the algorithm. All algorithms were coded in C++ and run on Intel CoreTM i7-3610QM CPU with 2GB RAM. Each table in the following sections will display the values for the κ1 and κ2, and hence, the percentage of logical constraints can be calculated as specified earlier. In order to easily see this percentage, the rows with label percent Log display this percentage, and ranges between 0 percent (no logical constraints) and 100 percent (all OR or BI constraints). The stop criterion is calculated as the number of generated schedules and is set at 1000, 5000, 50,000 and 500,000 schedules.Section 4.1.1 shows the results for the MRCPSP instances without the use of logical constraints and serves as a benchmark experiment to validate and compare our procedure with the best performing results available in literature. In Section 4.1.2, the single-mode RCPSP instances are solved under various settings of the percentage OR and BI constraints, and these results are compared with the results without logical constraints. Similarly, Section 4.1.3 displays the results for the MRCPSP instances and shows the impact of the network transformations on the size of the project network in case both multiple modes as well as logical constraints are used. In Section 4.1.4, the impact of increasing values for the changeover times used between two activities with BI constraints is discussed. Section 4.1.5 briefly discusses the impact of the random components of the solution approach on the stability of the test results.In order to facilitate comparison for future researchers with the summary results displayed in the tables of the next sections, an MS Excel file has been put available at www.projectmanagement.ugent.be containing all the relevant information for each project instance. The project instances can be easily generated using the κ1 and κ2 parameters as discussed earlier. In the tables of the next sections, the following key parameters will be used to display the quality of the procedures:•#Act: The number of activities in the project network after the network transformations of Section 3.1.CPU: Average runtime of the procedure until the stop criterion is met, expressed in seconds.#Opt: Number of optimal solutions found, expressed as a percentage of the total number of files.#Imp: Number of improvements found compared to the best known solutions reported on the PSPLIB and MMLIB websites reported in June 2014. Since these best known solutions can changeover time, they are also available in the MS Excel file that is available online. This metric is expressed as the number of instances, and not as a percentage.Percent Opt: Percentage deviation from the optimal solutions (only valid for the J10–J20 PSPLIB instances for which optimal solution are found).Percent LB: Percentage deviation from a known lower bound. The lower bounds used for the PSPLIB instances are described in detail on the PSPLIB website, while for the MMLIB instances, the lower bound is equal to the critical path. All bounds are also displayed in the MS Excel file discussed earlier.Percent UB: Percentage deviation from the best known solution (upper bound) as reported on the website of the PSPLIB and MMLIB instances. Similarly, these upper bounds are also given in the MS Excel file for each instance.Note that not all multi-mode instances for the PSPLIB dataset are feasible, and therefore, the percentages calculated using the predefined metrics are always based on the files for which feasible solutions exist. The MMLIB instance set contains only feasible instances, as explained in Van Peteghem and Vanhoucke (2014).Since no results are available for the single-mode and multi-mode version of the RCPSP with logical constraints, we have first tested our algorithm on data instances from literature on multi-mode instances without logical constraints. Only if these results can compete with results from literature, it can be concluded that the algorithm is a good choice for extension to logical constraints. To that purpose, Table 1displays results for the multi-mode instances without logical constraints on the PSPLIB and MMLIB instances, and serves as a intermediate table to validate the performance of our algorithm in comparison with the best known procedures from literature. The table shows that the results are competitive with current state-of-the-art procedures to solve the MRCPSP as reported by Van Peteghem and Vanhoucke (2014) who present a list of all multi-mode procedures available in literature and benchmark each procedure under a stop criterion of 5000, 50,000 and 500,000 schedules using the percent Opt (for J10–J20 instances of the PSPLIB) or percent LB (for the PSPLIB J30 instances and all MMLIB instances).In Van Peteghem and Vanhoucke (2014), it has been shown that the best performing procedure in literature tested on the PSPLIB instances displays an average percent LB equal to 0, 0.32, 13.66 for the J10, J20 and J30 instances respectively for 5000 schedules. The results in Table 1 are slightly worse and therefore on the fourth place on the list of procedures. Increasing the stop criterion to 50,000 schedules obviously leads to improvements but a comparison is no longer possible due to the lack of results available for the PSPLIB instances. Our procedure however shows that the percentage improvement increases more rapidly for increasing levels of the stop criterion compared to the procedures in literature. This has also been observed in the paper written by Coelho and Vanhoucke (2011).For the MMLIB instances, the best values for percent LB are reported to be equal to 23.79 percent, 24.02 percent and 92.76 percent for the 50,000 schedule limits for the MMLIB50, MMLIB100 and MMLIB+ instances respectively (Van Peteghem & Vanhoucke, 2014). The results in Table 1 are slightly worse but show that our procedure is now able to obtain the second best results in literature. Moreover, new solutions have been found for the MMLIB instances compared to the ones reported in Van Peteghem and Vanhoucke (2014), but these numbers are not shown in the table. More precisely, 6 and 41 improved solutions have been found for the MMLIB50 dataset under a stop criterion of 50,000 and 500,000 schedules, 15 and 76 for the MMLIB100 dataset and 295 for the MMLIB+ dataset (only for the 50,000 schedules stop criterion). These improved solutions have been reported on the multi-mode website where the best known solutions without logical constraints are available.A similar reasoning can be made for the other criteria percent UB, #Opt and CPU and show that out procedure is not always able to outperform the best performing algorithm in literature, but can often compete with it or can, as previously mentioned, sometimes find improved solutions. Therefore, we conclude that the procedure presented in this paper is competitive with the multi-mode procedures in literature and although it cannot be considered as the best performing algorithm to solve the MRCPSP in literature, it is certainly a good alternative for extending it with logical constraints for which currently no results exist.Table 2displays results for the single-mode instances of the PSPLIB sets J30, J60, J90 and J120 instances. The results with both the OR and BI constraints must be compared with the reported results without logical constraints (column 3 with κ1 = κ2 = – and percent Log = 0 percent). All tests have been performed with changeover times equal to zero. For each column the positive values for κ1, κ2 (and the resulting value for percent Log) and the number of activities (#Act) are reported as a result of the network transformations discussed in Section 3.1. The results show that even for J120 instances, the maximum number of activities increases to only 256 and 330 for the OR and BI constraints, respectively (under percent Log = 100 percent) which illustrates that the transformations can be used even for large project instances.The rows with labels percent Opt (J30 instances) or percent LB and percent UB (for all other instances) show the makespan decrease when introducing logical constraints. The results show that percentages up to 20 percent and more are not an exception when introducing BI or OR constraints, however, the improvements seem to decrease for larger instances. The number of improvements shows a similar trend. The average runtime of our procedure is still acceptable, even for a stop criterion up to 50,000 schedules.It is believed that Table 2 is the first table presented in literature for single-mode RCPSP instances with logical constraints and provides enough detailed results for comparison for future algorithms that might be presented in literature.Table 3contains similar results as Table 2, but now for the J10–J20 PSPLIB instances summarized in one single run, as well of for the PSPLIB J30 instances. A similar layout is used in Table 4to show the results for the three classes of MMLIB instances. The run on the relatively small J10–J20 PSPLIB multi-mode instances confirms the previously found results and shows that decreased makespans can be obtained by using logical constraints. However, the results also show that the transformed network instances are now much more complex, and in some cases, the procedure cannot find a solution of the same quality when compared with the instances without logical constraints for the same stop criterion. Only when the stop criterion is set to high values, significant improvements could be found. The main reason lies in the increase of the number of activities due to the network transformation, which sometimes leads to projects with up to 1622 activities for the MMLIB+ instances. This huge increase in the project network obviously leads to a much more complex search process of the algorithm, and hence, a decreased performance. Nevertheless, it is believed that this multi-mode table can still be used as best known results for the MRCPSP with logical constraints and serves as a comparison table for future research.In the previous experiments, the values of the changeover times between activities are set equal to zero, i.e.γij=γji=0. However, the previously mentioned MS Excel file that can be downloaded from www.projectmanagement.ugent.be also contains solutions for positive values for the changeover times and the results will be briefly discussed in this section. More precisely, the changeover times have been increased from 0 to 1, 2, 4 and 8, no OR constraints have been added to the tests and the percentage of BI constraints (percent Log) is varied from 10 percent to 20 percent, 50 percent and 100 percent. Tests have been carried out on the single-mode J30–J120 PSPLIB instances and the multi-mode J30 PSPLIB instances with a stop criterion of 50,000 schedules. Each time, the percentage reduction in the makespan is reported as the previously mentioned percent Opt (for the J30 single-mode instances) or percent Opt (for all other instances) and these values are compared with the results with only AND constraints (no OR and no BI constraints). Results are shown in Figs. 7and 8.Fig. 7 displays the results for the single-mode PSPLIB instances J30–J120, and clearly shows that all tests have resulted in a makespan decrease compared to the case where no OR and BI constraints are used. Obviously, the higher the percentage of BI constraints, the more significant the makespan reduction. The graphs also show that increasing values for the changeover times lead to a lower percentage of reductions in the project makespan, but even with changeover times up to 8 and a percentage of BI constraints of only 10 percent, there are still some small improvements compared to the base case.The results for the multi-mode PSPLIB instances as shown in Fig. 8 show similar results, but the improvements are less outspoken. Increasing values of the changeover times result in makespan improvements for changeover time values up to 2. When the changeover times increase even further to 4 or 8, the procedure can no longer report improvements, and on the contrary lead to an increase in the makespan compared to the base case with only AND constraints. Obviously, the reason is that the size of the network has grown significantly, both due to the BI constraints and the multiple modes in the activities, and hence the procedure is no longer able to fully optimize the search towards improved solutions with high values for the changeover times.Since the meta-heuristic approach proposed in this paper is not deterministic, the solutions obtained and reported in the previous sections should be tested against the stability of the procedure. To that purpose, this section reports on results for a limited computational experiment used with random replications. Obviously, using replications on each test instance would increase the computational time prohibitively for the large numerical study of the previous sections, and therefore, the following choices have been made. A new computational experiment has been set up to test the stability of the procedure by selecting the first instance every ten instances. The reason of this choice lies in the fact that the PSPLIB library contains three parameters (coefficient of network complexity CNC, resource factor RF and resource strength RS) that vary every 10 instances. This choice results in a selection of 48 projects for the J30, J60 and J90 instances and 60 projects for the J120 instances. In doing so, it is assured that exactly one instance for each combination of the parameter values is used for the PSPLIB instance generations. Furthermore, the experiments also have been restricted to the single-mode instances with 50 percent OR and 50 percent BI values for the logical constraints using a stop criterion of 50,000 schedules. Each instance is solved 10 times (10 replications) and the results are reported in Table 5. The columns with label “St.Dev.” report the standard deviation of the makespans while the columns labelled with “# St.Dev. = 0” report the number of instances with a zero standard deviation. The row with label “Avg.” reports the average standard deviation for all test instances.The table shows that the average standard deviations are always lower than one time unit, with a lot of instances with a zero standard deviation for all 10 replications. The average standard deviations of 0.46 and 0.25 for the OR 50 percent and BI 50 percent experiments, respectively, illustrate that the makespans vary with only 1.84 time units and 1 time unit with a probability of 95 percent for the 10 replications (based on the calculations of a two standard deviation interval). The worst results have been found for the J120 instances with ID = 46 (for OR 50 percent) and ID = 31 (for BI 50 percent) with a standard deviation of 1.85 and 1.70, respectively (not shown in the table). Since there is currently no other approach available in literature that solves similar problems, a comparison with other procedures cannot be made. However, the selection of instances for the stability results reported in this section can be easily replicated, allowing to benchmark new results both on quality (previous sections) and stability (this section).

@&#CONCLUSIONS@&#
In this paper, the single-mode and multi-mode resource-constrained project scheduling problems from literature are extended with two types of logical constraints. The first type considers the use of OR relations between activities and specifies that only one of the predecessors must be finished before an activity can start. The second type is referred to as the bi-directional (BI) constraints and specifies that two activities cannot be scheduled in parallel, but in-between these activities a changeover time might possibly be incurred. These two new logical constraints extend the classic RCPSP problem and it is solved by a new procedure discussed in this paper.The new procedure makes use of a heuristic RCPSP solver and a SAT solver and relies on network transformations that extend the project network and transforms the OR and BI constraints into traditional AND constraints. In doing so, the project can be solved by any (meta)heuristic project scheduling algorithm without explicitly taking these logical constraints into account. The SAT solver guarantees that logical clauses between activities implicitly take the OR and BI constraints into account.The procedure is tested on two well-known datasets from literature, the PSPLIB (single-mode and multi-mode) and the MMLIB (multi-mode). A first test experiment on MRCPSP instances without logical constraints shows that the procedure is able to compete with the best procedures from literature. A second test on single-mode instances with logical constraints shows promising results as the size of the transformed networks does not increase too much, and promising results that can be used for future research comparison purposes have been generated within a reasonable time. The third experiment has used the MRCPSP instances with logical constraints and a similar table for future comparison purposes has been displayed. These results show that the size and complexity of the networks increase rapidly, and it was therefore not always possible to find improved solutions (compared to the solutions of these instances when the logical constraints are ignored). Future research should therefore focus on the development of dedicated algorithms for these multi-mode instances to find improved solutions in a reasonable time.