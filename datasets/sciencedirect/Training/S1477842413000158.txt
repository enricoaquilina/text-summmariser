@&#MAIN-TITLE@&#
Regular corecursion in Prolog

@&#HIGHLIGHTS@&#
Meta-interpreters are defined to study new features for coinductive Prolog.The proposed new features are finally clauses and coinductive argument selection.Practical examples show that such features enhance expressivity and efficiency.

@&#KEYPHRASES@&#
Logic programming,Coinduction and corecursion,

@&#ABSTRACT@&#
Corecursion is the ability of defining a function that produces some infinite data in terms of the function and the data itself, as supported by lazy evaluation. However, in languages such as Haskell strict operations fail to terminate even on infinite regular data, that is, cyclic data.Regular corecursion is naturally supported by coinductive Prolog, an extension where predicates can be interpreted either inductively or coinductively, that has proved to be useful for formal verification, static analysis and symbolic evaluation of programs.In this paper we use the meta-programming facilities offered by Prolog to propose extensions to coinductive Prolog aiming to make regular corecursion more expressive and easier to program with.First, we propose a new interpreter to solve the problem of non-terminating failure as experienced with the standard semantics of coinduction (as supported, for instance, in SWI-Prolog). Another problem with the standard semantics is that predicates expressed in terms of existential quantification over a regular term cannot directly defined by coinduction; to this aim, we introduce finally clauses, to allow more flexibility in coinductive definitions.Then we investigate the possibility of annotating arguments of coinductive predicates, to restrict coinductive definitions to a subset of the arguments; this allows more efficient definitions, and further enhance the expressive power of coinductive Prolog.We investigate the effectiveness of such features by showing different example programs manipulating several kinds of cyclic values, ranging from automata and context free grammars to graphs and repeating decimals; the examples show how computations on cyclic values can be expressed with concise and relatively simple programs.The semantics defined by these vanilla meta-interpreters are an interesting starting point for a more mature design and implementation of coinductive Prolog.

@&#INTRODUCTION@&#
Corecursion [6] has been used in some contexts to denote the ability, supported by lazy evaluation, of defining a function that produces some infinite data in terms of the function and the data itself.As an example, let us consider the following Haskell code defining the infinite stream!0:1!:2!:…of the factorials of all natural numbers.The stream fact_stream is defined in terms of itself and of the corecursive function gen_fact that takes the stream itself as one of its arguments.An equivalent, but simpler definition is the following one:After having defined fact_stream, one can get the factorial of n by simply selecting the element at position n in fact_stream:Though the stream is infinite, it is possible to access any arbitrary element because the list constructor “:” is non-strict and, hence, the call to function gen_fact is computed lazily. More abstractly, the data returned by gen_fact corresponds to a tree whose depth is infinite, and that is notregular; a regular tree can have infinite depth, but it is only allowed to have a finite set of subtrees. Trivially, finite trees are regular, whereas infinite regular trees can be effectively represented by finite cyclic data structures, without relying on lazily evaluated computations.Now let us try to check whether all elements in the stream are greater than 0, with the predefined functionall.Checking that an arbitrary decidable predicate holds on all the factorials of natural numbers is only semi-decidable: termination is guaranteed only if the predicate does not hold for some element, as inall(â§¹x −>x<100)fact_stream.Let us now consider this other stream declaration:Differently from fact_stream, stream ones is regular: it corresponds to a tree whose set of subterms contains just 1 and the stream itself. Such a stream is defined as a cyclic data structure, and no lazy evaluation is required: it is recursively defined by using just the list constructor.Despite the regularity of ones, in Haskell the evaluation of the expressionall(â§¹x −>x>0)onesdoes not terminate; this happens because the logical conjunction && is strict in its second argument (when the first argument evaluates toTrue), andallis defined in the standard inductive way.Let us now consider the same problem in Prolog.11All Prolog examples shown in the paper have been tested with SWI-Prolog, version 6.0.2.We can easily define predicate all s.t. all(p,l) succeeds iff predicate p is true for all elements of list l.The resolution of the goalOnes=[1|Ones],all(positive,Ones)does not terminate, for the same reason explained for Haskell. Modern Prolog interpreters support regular terms; the unificationOnes=[1|Ones]succeeds, because occur-check is not performed, and Ones is substituted with the regular term corresponding to the cyclic list containing infinite occurrences of 1. For instance, in SWI-Prolog the goal?−Ones=[1|Ones]succeeds with the answerOnes=[1|Ones], that is, Ones is the unique regular tree which is solution of the equationOnes=[1|Ones]. Such a tree can be represented in infinite different ways; for instance, the following goal (where “==” is the built-in predicate corresponding to syntactic equality) succeeds as follows:If predicate all is interpreted in the standard inductive way, then the Prolog interpreter tries to build an infinite derivation for the goal and, thus, the computation does not terminate. The conventional inductive interpretation of a logic program is based on the inductive Herbrand model, that is, the least fixed point of the one-step inference operator defined by the clauses of the program. This can be proved equivalent to the set of all ground atoms for which there exists a finite SLD derivation.Simon et al. [14–16] have proposed coinductive SLD resolution (abbreviated by coSLD) as an operational semantics for logic programs interpreted coinductively: the coinductive Herbrand model is the greatest fixed-point of the one-step inference operator. This can be proved equivalent to the set of all ground atoms for which there exists either a finite or an infinite SLD derivation [16,9].Coinductive logic programming has proved to be useful for formal verification [10,13], static analysis and symbolic evaluation of programs [2–4].CoSLD resolution is not computable in its general form, but it becomes implementable when restricted to the fragment where only regular terms and regular derivations are allowed. In SWI-Prolog the library coinduction has been recently introduced, to allow coinductive interpretation of predicates. For instance, we want predicate all to be interpreted coinductively:Now the resolution of our goal terminates successfully:This happens because the interpreter is able to build an infinite but regular derivation, as depicted in Fig. 1, by unifying the atom all(positive,Ones), that has to be solved, with the ancestor atom that have been already solved.In Haskell a function with the same behavior cannot be implemented so simply; for instance, specific datatypes have to be expressly defined and used [17,7], or physical equality has to be exploited, at the cost of breaking referential transparency, and other nice properties.Regular corecursion is expressly suited for cyclic data structures; among them, the most commonly used are certainly graphs, a kind of data structure that is heavily employed in many application domains; besides considering graphs, the examples of applications of coinductive Prolog that can be found in Sections 3 and 4, involve other typically cyclic entities, such as automata, context free grammars, and repeating decimals. Regular corecursion allows elimination of the boilerplate code needed for manual bookkeeping of inspected data in a cyclic structure, thus making code simpler, and more reliable, and favoring coinductive reasoning; furthermore, programming abstractions for regular corecursion promote code reuse, and optimization; roughly, recursion compares to iteration with a stack, as regular corecursion compares to recursion with a set (that is, a data structure that stores all previous calls to corecursive functions/predicates).In this paper we study new operational semantics and propose new programming abstractions with the aim of (1) overcoming some of the problems exhibited by some currently available coSLD implementations; (2) making regular corecursion more expressive, and easier to program with.In the next section we will present three main different operational semantics of regular corecursion in Prolog, by means of simple vanilla interpreters. Besides the semantics coinciding with the original definition of coSLD [16], two other versions are presented: the former is equivalent to coSLD as supported by the SWI-Prolog library coinduction, whereas the latter is an enhancement which solves the problem of non-terminating failure, and computes more answers for successful goals.In Section 4 we extend our interpreters by adding finally clauses, to enhance the expressivity of regular corecursion; such a feature allows a simpler definition for some coinductive predicates (for instance, those that correspond to existentially quantified properties).In Section 5 we introduce yet another feature aiming to make corecursive definitions more efficient and coinductive programming more expressive: the user can select the arguments that have to be considered in the coinductive definition of a predicate. Also in this case, some meaningful examples show the usefulness of such an extension.Section 6 is devoted to the related work, and, finally, Section 7 draws conclusions, and outlines further interesting research directions.This section elaborates previous results [14] by defining two different versions of a vanilla meta-interpreter (where vanilla means based on built-in unification and predicateclause/2) supporting coSLD. Even though vanilla meta-interpreters are not efficient to be suitable for practical uses, the meta-programming facilities offered by Prolog are an ideal tool to experiment with new semantics and programming abstractions: vanilla meta-interpreters are concise and abstract enough to serve as a formal semantics, yet they provide prototype implementations to test new language features.We first define a basic meta-interpreter, and then extend it to allow resolution of built-in and library predicates, mixing of coinductive and inductive predicates, and elimination of repeated answers. Such an interpreter is based on the work by Simon [14] and implements the “old style” semantics for coinduction as supported by the U.T. Dallas meta-interpreter (see Section 6).The basic meta-interpreter corresponding to the original formulation of the coSLD operational semantics [14] is a straightforward extension of the conventional vanilla interpreter implementing standard SLD resolution for Prolog.The proof of soundness of the operational semantics w.r.t. the semantics based on the greatest Herbrand model can be found in the PhD thesis of Simon [14].Module cosldmeta0 exports the main predicate cosld/1 which takes a goal as argument, and solves it according to the coSLD operational semantics, which is implemented through the predicate solve.The first argument of solve is the list of ancestor atoms that have been already processed (hence the list is initially empty), which are called coinductive hypotheses, whereas the second argument is the goal that have to be solved. The list of coinductive hypotheses are needed for building infinite regular derivations (see below).The first two clauses for solve deal with goals having more than one atoms and with the empty goal, respectively, while the remaining clauses manage the most interesting case when the goal contains just one atom. To solve an atom A the interpreter first tries to build an infinite regular derivation by searching for an atom in the coinductive hypotheses Hs that unifies with A (found(A,Hs)); for this simple version of the meta-interpreter predicate found coincides with the library predicate member that checks whether an element is a member of a list. If the search succeeds, then the atom is solved and removed from the goal, and the computed answer substitution is refined accordingly, since the atom A is unified with the coinductive hypothesis found in Hs.22The atom member(A,Hs) succeeds iff there exists an atom in Hs unifying with A.If no unifiable coinductive hypothesis can be found, then a clause in the program whose head unifies with the current atom is searched with the built-in predicate clause; if such a clause is found, then the unified body As of the clause is solved in the new list of coinductive hypotheses NewHs where the atom A unified with the head of the clause has been added; for this simple version of the meta-interpreter predicate insert just add the new atom at the beginning of the list.We show how the interpreter works with a very simple example program defining the predicate is_nat.In this case, the only difference with inductive Prolog is that is_nat succeeds also when N=s(N). The resolution of the goal cosld(is_nat(N)) (corresponding to the coSLD resolution of the goal is_nat(N)) returns the following infinite sequence of answers (we will consider shortly the problem of avoiding some redundant answers):This very basic meta-interpreter has two serious restrictions: built-in predicates cannot be used, since the clause predicate does not work with them; all predicates are interpreted coinductively, whereas there are cases where we may want the standard inductive interpretation for predicates (consider, for instance, library predicates). To this aim, we introduce two predicates inductive and coinductive to partition predicates: predicates are inductive by default, those coinductive (and necessarily user-defined) have to be explicitly specified by the user. Therefore the inductive predicates are either built-in or imported from a standard library or they have not been declared coinductive.If an atom is inductive, then it is directly solved by the Prolog interpreter; the cut allows the meta-interpreter to skip the clauses dealing with coinduction. Since true is a built-in predicate, the clause for the empty goal is no longer required. This solution enforces a stratification between coinductive and inductive predicates to avoid contradictions, as pointed out by Simon et al. [15]. Let us consider, for instance, the following example:Since q is inductive, its behavior should be determined by the least fixed point semantics of the program, hence q should fail; however, p is coinductive, therefore its behavior should be determined by the greatest fixed point semantics of the program, hence p should succeed, and, as a consequence, q should succeed as well. To avoid such semantic issues, Simon et al. have suggested to allow mixing of inductive and coinductive predicates in the same program as long as predicates as stratified, that is, an inductive predicate in a given strata cannot call a coinductive predicate in a higher stratum and vice versa. Since this paper is focused on other kinds of extensions to coSLD, the meta-interpreters proposed here impose a simple stratification with just two strata: the lowest one contains all inductive predicates, whereas all coinductive predicates are contained in the highest one; arbitrary stratification can be supported at the cost of complicating the code for the meta-interpreters.To allow regular coSLD resolution for predicate all, as defined in the previous section, we only need to declare it to be coinductive.As expected, the goal test succeeds.We extend the basic meta-interpreter to allow elimination of repeated answers due to the redundant application of coinductive hypotheses.Let us consider, for instance, the resolution of the goal cosld(is_nat(N)): initially the list of coinductive hypotheses is empty, the first clause for is_nat is applicable, and the first computed answer is N=z; if backtracking is forced, then the second clause for is_nat is considered, the substitution N=s(N0) is computed, and the goal is_nat(N0) is solved, with the list of coinductive hypotheses [is_nat(s(N0))].Since is_nat(N0) unifies with the unique coinductive hypothesis, the meta-interpreter can build an infinite regular derivation whose answer is N=s(N). Proceeding further, the meta-interpreter re-applies the first clause for is_nat, to get the answer N=s(z), and then re-applies the second clause for is_nat; the substitution N0=s(N1) is computed, and the goal is_nat(N1) is solved, with the list of coinductive hypotheses [is_nat(s(N1),is_nat(s(s(N1)))].At this point the basic meta-interpreter redundantly applies the two current coinductive hypotheses; indeed, the atomsucceeds twice, the first time with the answer N=s(_S1), _S1=s(_S1), the second time with the equivalent answer N=s(s(N)); this happens because member allows backtracking. One may solve this problem by using predicate memberchk which, differently from member, does not perform backtracking.Now found is defined by memberchk, thus making the searching more efficient. With this new version of the meta-interpreter the goal cosld(is_nat(N)) yields the following answers:Since the only difference between cosldmeta1 and cosldmeta0 is the replacement of member with memberchk, the set of answers computed by cosldmeta1 is included in those computed by cosldmeta0; such an inclusion is strict, as proved by the following program:If we solve the goal cosld(p(a,X)) accordingly to the meta-interpreter cosldmeta0, then we get X=b and X=a as the first and the second computed answers, respectively. If the same goal is solved with the cosldmeta1 meta-interpreter, then only the answer X=b can be computed. This is depicted by the coSLD tree in Fig. 2corresponding to the resolution of the goal33For simplicity, the atoms in the nodes of the tree have been deprived of the outermost application of predicates cosld and solve.cosld(p(a,X)) with the cosldmeta1 meta-interpreter. A node of the tree consists of the current goal and the list of coinductive hypotheses, whereas edges are labeled with the applied clause (ch means that a coinductive hypothesis has been applied) and the corresponding substitution. The difference between the two interpreters becomes apparent when we consider the node p(X,X),[p(b,X),p(a,X)]; the cosldmeta1 meta-interpreter considers only the first coinductive hypothesis p(b,X) whose application yields the answer X=b, whereas cosldmeta0 applies also the coinductive hypothesis p(a,X), thus yielding the answer X=a.Note that after the second application of clause c1, variable X is permanently bound to the atom b, and since the tree rooted by the node p(b,b),[p(b,b),p(b,b),p(a,b)] is infinite, clause c2 can never be applied; therefore the cosldmeta1 meta-interpreter cannot compute the answer X=a, while cosldmeta0 computes it just once. Of course, the different behavior of the two interpreters is also due to the fact that they perform a depth first search of the coSLD tree. If a breadth first search strategy would be considered, then both interpreters would compute the same set of answers.Meta-interpreter cosldmeta1 corresponds to the semantics of the coinductive logic programming as currently supported by SWI-Prolog through the library coinduction. Soundness w.r.t. the semantics based on the greatest Herbrand model follows directly from the soundness of cosldmeta0.In this section we present our first contribution, that is, meta-interpreter cosldmeta2.Both meta-interpreters cosldmeta0 and cosldmeta1 (and, hence, the SWI-Prolog library coinduction whose semantics is equivalent to that of cosldmeta1) suffer from a serious problem; it is easy to find examples of (even ground) goals whose resolution should fail that do not terminate with the two meta-interpreters. For instance, let us consider the following logic program:Atom eq(t1,t2) should succeed if and only if t1 and t2 are two equal infinite regular complete binary trees. Although the coinductive definition of eq is correct, the program fails to terminate (with both the interpreters cosldmeta0 and cosldmeta1) for goals whose resolution should fail; for instance, this happens for the goalLet t1 and t2 denote the two ground regular terms s.t.After one resolution step of the ground atom eq(t1,t2) we get the goalResolution of the first atom succeeds by coinductive hypothesis, whereas the second atom fails, therefore, by backtracking, resolution of eq(t1,t2) is tried again, thus entering an infinite loop with the following goal:The SWI-Prolog library coinduction suffers from the same problem:An ad hoc solution to this problem would consist in inserting a cut in the body of the clause, between the two atoms eq(LT1,LT2) and eq(RT1,RT2); here, instead, we propose a more general solution with an improved version of the meta-interpreter that avoids this kind of non-terminating failures.This new version of the meta-interpreter is based on the observation that if a coinductive hypothesis H can be applied to solve a certain atom A, then the clause c that generated H is applicable as well; furthermore, if atom A is subsumed by H, then re-applying clause c with a standard resolution step is unnecessary; in this case clause c is applied by simply removing the atom A from the goal.We recall that an atom A1 is subsumed by an atom A2 if there exists a substitutionθs.t.A2θ=A1=A1θ; to this aim we use the built-in SWI-Prolog predicate subsumes.Now there are only two clauses defining predicate solve in the case of single atoms: the first clause is unchanged, and is used for inductive predicates as in the previous versions, whereas the second, which is applied in case of coinductive predicates, has been modified: if the atom A can be unified with the head of a clause, and, after unification, is subsumed by some coinductive hypothesis in Hs (predicate subsumed), then resolution succeeds without any further action; otherwise, the unified atom may succeed because either it unifies with some coinductive hypothesis in Hs (predicate found) or the unified body As of the clause can be solved w.r.t. a new list NewHs of coinductive hypotheses where A has been added at the beginning.With such an interpreter the goalterminates with a failure, as depicted by the corresponding coSLD failure tree in Fig. 3; now if a clause is applied by coinduction, then the corresponding edge is labeled by the name of the clause followed by /subs (as in the figure) if the unified atom A is subsumed by a coinductive hypotheses, or by /unif if A unifies (but it is not subsumed) with a coinductive hypothesis.Termination is ensured by the fact that backtracking is not applied for atom eq(t1,t2), since it is subsumed by a coinductive hypothesis.We have already shown an example that proves that the meta-interpreter cosldmeta2 is not equivalent to cosldmeta1 (and to cosldmeta0 as well), since in some cases the resolution of a goal finitely fails with cosldmeta2, whereas it does not terminate with cosldmeta1 (or cosldmeta0).The same example program presented in Section 2.2.1 for showing that the answers computed by cosldmeta1 are a strict subset of those computed by cosldmeta0, can be used for showing that in some cases the set of answers computed by cosldmeta1 is a proper subset of those computed by coslmeta2.As depicted in Fig. 4, with cosldmeta2 the coSLD tree for goal cosld(p(a,X)) is finite, and both the two answers X=b and X=a are computed, whereas cosldmeta1 computes only X=b; furthermore, both cosldmeta0 and cosldmeta1 compute infinitely many times the answer X=b, whereas cosldmeta2 terminates after having computed the two different answers. Note that after the second application of rule c1, the computed substitution{X=b}affects also the list of coinductive hypotheses which becomes [p(b,b),p(a,b)], therefore the atom p(b,b) succeeds by subsumption, and no backtracking is performed. An analogous comment can be done also for the second application of rule c2.We can now compare cosldmeta2 with cosldmeta0. We first show that a goal that finitely fails with cosldmeta0, then it finitely fails with cosldmeta2 as well.Proposition 2.1For any program and goal ifcosldmeta0finitely fails, thencosldmeta2finitely fails as well.Trivially, if T is a finite failure coSLD tree for cosldmeta0, since the corresponding treeT′for cosldmeta2 is always obtained by removing branches of T,T′must necessarily be a finite failure tree as well.□Note that by virtue of the example in Section 2.3 defining the predicate eq on infinite binary trees, we can deduce that the set of goals that finitely fail with cosldmeta0 is a proper subset of the corresponding set for cosldmeta2. However, for certain programs and goals cosldmeta2 computes less answers than those computed by cosldmeta0.Let us consider the following program.When resolved with cosldmeta2, the goal cosld(p(a,X)) returns the following infinite lists of equal answers:However, with cosldmeta0 much more answers are computed:In this section we consider more significant examples of regular corecursion some of them will show the usefulness of interpreter cosldmeta2, some others will be used to motivate the features that will be introduced in the next sections. We also show how constraint logic programming can be usefully exploited in conjunction with regular corecursion.In the previous section we have shown how predicate all can be easily defined corecursively in Prolog for regular lists; more generally, this is true whenever predicates corresponding to universally quantified properties have to be defined on regular terms. However, properties which are existentially quantified on cyclic data cannot be defined so easily; a classical example is given by the member predicate for regular lists [14].At a first glance the definition above may seem correct, but a more thorough analysis reveals that this is not true. For instance, the resolution of goal cosld(L=[1,2,3|L],member(5,L)) succeeds, whereas it should fail. Indeed, after three steps the initial goal is found again, and resolution succeeds by coinductive hypothesis; in fact, all ground atoms built with predicate member always succeeds.To avoid this problem, one might define the complemented predicate not_member, which corresponds to a universally quantified property; unfortunately, this approach has the drawback that it requires coSLD negation [11].An alternative solution is given by the following program.The coinductive auxiliary predicate aux_member has a third argument corresponding to the Boolean result of the membership test; such an argument is not used by the main predicate member, but it is necessary for ensuring a correct behavior. The body of member ensures that initially the last argument of aux_member is a logical variable; this corresponds to the fact that the truth value is initially unknown. If the element is found (first clause), then the variable is unified with the constant t, representing true. If the initial list is found again, then the goal is resolved by coinduction hypothesis, but the variable corresponding to the result is not substituted; hence, atom aux_member(N1,L,R1) in the body of the second clause for aux_member always succeeds, but R1 is substituted with t if and only if the element has been found. For this reason, the atom is followed by the syntactic equality test R1==t.Such a solution is rather involved, but it is correct, providing that meta-interpreter cosldmeta2 is used: goals like cosld(L=[1,2,3|L],member(5,L)) finitely fail only with this version of the interpreter, otherwise the second clause of aux_member is selected infinitely many times.In Section 4 a new feature, called finally clause, is expressly introduced to overcome complex and ad hoc predicate definitions as defined in the example above.We now consider a classical application from formal languages, by defining a predicate that succeeds iff a finite deterministic automaton accepts all strings of a regular language (defined by an extended right linear grammar). In other words, the predicate succeeds iff the language defined by the grammar is a subset of the language defined by the automaton.Regular terms allow a very compact representation of automata and regular grammars.44In the example we consider extended right linear grammars since acceptance by a finite automaton can be defined more easily, and the standard Prolog constructors for lists can be suitably used for representing them.Let us consider the automaton depicted in Fig. 5, where S1 (pointed by the arrow) is the initial state, and S2 (with a thicker circle) is final.Such an automaton can be represented by the following cyclic Prolog term associated with the logical variable S1:Each state is represented by the term state(k,e), where k can be one of the two constants final and notfinal, and e is the list of outgoing edges, represented by pairs(σ,S), whereσis a symbol of the alphabet of the automaton, and S is one of its states. Since an automaton has only an initial state, there is no need to explicitly represent initial states. If we consider the definition above, then S1 is associated with the term corresponding to the automaton in Fig. 5, whereas S2 is associated with a term corresponding to another automaton, where S2 is both an initial and a final state (such an automaton accepts only the empty string).Let us now consider the following right linear grammar:A::=b |aA.Using the standard Prolog constructors for lists to represent the right-hand-side of a production (that is, a string of terminals possibly ending with a non-terminal), and the binary operation or for expressing alternative productions, we can easily represent such a grammar by the following cyclic Prolog term: A=or([b],[a|A]).The examples above can be easily generalized to encode any kind of finite automaton and extended right linear grammar into an equivalent cyclic Prolog terms. We are now ready for defining the predicate accept.The first clause specifies that any final state accepts the empty string, whereas the non-empty production[H|T](where H is necessarily a terminal symbol, by definition of right linear grammar) is accepted from the state state(_,E) if there exists an outgoing edge labeled with H and pointing to a state S starting from which the rest T of the production can be accepted. If we consider non-cyclic grammars, then corecursion is not needed, since termination is guaranteed by induction on the term corresponding to the grammar. For instance, the two grammarsA1 ::=abandA2 ::=baare represented by the terms [a,b] and [b,a], respectively, and the following two goals can be resolved without the predicate cosld (obviously resolution for the former succeeds, whereas it fails for the second).The third clause dealing with alternatives is self-explanatory: the union or(L1,L2) of the languages L1 and L2 is accepted if both languages are accepted starting from the state S. To verify that all strings generated by the grammarA ::=b |aAare accepted by our automaton we need regular corecursion, since the term representing the grammar is cyclic:To avoid infinite failure, we need the meta-interpreter cosldmeta2. The resolution of the following goal terminates and fails, as expected, only with meta-interpreter cosldmeta2.Clearly, the grammarA ::=aA|bA|bgenerates (among infinite others) the string bb which is not accepted by our automaton.The careful reader may have noticed that the definition of accept is not completely correct, since it does not correctly manage the corner case when a grammar generates the empty set. Consider for instance the following two goals:The former succeeds, while the second fails, even though both should succeed, since the two grammarsA::=aAandA::=cAgenerate the empty set. To overcome this problem, we introduce the coinductive predicate empty checking whether a grammar generates the empty set, and add a clause for dealing with this corner case.The whole program is very succinct and readable; the same compactness and readability cannot be achieved with a program written in standard Prolog.The definitions of the two predicates are extremely concise and simple to understand. The concatenation of a symbol with a set of strings T is empty iff T is empty, and the unionor(L1,L2)of L1 and L2 is empty iff both L1 and L2 are empty. The definition works because empty is interpreted coinductively, and it fails (as expected) on the empty list (which represents the singleton set containing the empty string).It is well-known that every rational number is either a terminating or repeating decimal, that is, all rational numbers can be represented by an infinite regular lists of digits.In the sequel we only consider rational numbers in the interval[0,1]represented with base 10; all clauses shown in this section can be generalized in a straightforward way to deal with the whole set of rational numbers, represented with any base(≥2).For instance, the term associated with N inN=[5|P],P=[7,2|P]corresponds to the repeating decimal0.572¯that equals the fraction63110. Indeed, multiplying a repeating decimal by10e(withe>0) is equivalent to a left shift of e positions, therefore we have that the following equations hold:From the two equations above we can deriveFor uniformity, we represent terminating decimals as infinite regular lists as well (by definition, a decimal is terminating if it has a repeating final 0). For instance, 0.5 is represented by the term associated with N inN=[5|Z],Z=[0|Z].We can now define a coinductive predicate to compute the addition between two repeating decimals represented as infinite regular lists of digits. Since the operands have infinite digits, we cannot simply mimic the conventional algorithm for addition, because the notion of least significant digit does not make sense in our case. We first consider a simple solution which consists in using an auxiliary predicate that computes digit-wise result and carry for all positions, and returns two corresponding regular lists.The predicate takes two operands[D1|N1]and[D2|N2], computes the addition RD and the carry CD for the two most significant digits D1 and D2, and then continues corecursively for the rest of the digits N1 and N2.We can now define the main predicate add.If the second operand is zero (second clause), then the result is the first operand O1, and the carry digit for the next more significant position is 0.Otherwise (first clause) the partial result PR and all carry digits[CD1|C]of the additionO1+O2are computed with aux_add; then we have to accommodate the carry digits: first they need to be left shifted of one position (thus we get C). Indeed, the carry digit generated at position i (corresponding to10i, withi<−1) must be added to the digit of the partial result PR at position i+1. Therefore the addition between PR and C is computed, to get the final result R and a carry digit CD2 that has to be combined with the most significant digit CD1 of the carry digits computed by aux_add, to get the carry digit CD corresponding to the next more significant position.The computation terminates because of regularity, and because each position can yield a carry of 1 just once.In the next section we will see how finally clauses allow a simpler solution that does not require the use of an auxiliary predicate. A simpler and also more efficient solution can be obtained by exploiting constraints over finite domains; the following example shows how constraint logic programming fits well with regular corecursion.With constraints, propagation of the evaluation of integer expressions can proceed in both directions, therefore we can avoid using aux_add and define add coinductively with just one clause.To compute[D1|N1]+[D2|N2], first N1 and N2 are added, to get the result R, and the carry PC; then the carry PC is added to the most significant digits D1 and D2 to get the most significant digit RD of the result, and the corresponding carry C.Since the predicate is coinductive, the atom add(N1,N2,R,PC) can be placed indifferently before or after all constraints; the atom label([RD]) is required for obtaining ground solutions (all values for the finite domain variable RD are systematically tried out), since in some cases there exist two different solutions. For instance, let us consider the addition0.08¯+0.01¯:The meta-interpreter finds two different solutions (clearly equivalent):0.10¯with carry 0, or0.09¯with carry 0.As a final remark, both definitions (with or without constraints) work with all versions of the meta-interpreter.In Section 3 we have seen that properties which are existentially quantified on cyclic data (as membership for regular lists) cannot be defined easily in a coinductive way, and a rather involved and ad hoc solution has been proposed.Here we propose a new feature aiming to solve this problem, by allowing the user to define the specific behavior of a predicate when an atom is solved by coinductive hypothesis, by means of finally clauses.While facts are used in Prolog for defining the base cases for induction, finally clauses specify the behavior in case of application of the coinductive hypothesis in regular coinduction.Before extending the meta-interpreter to support finally clauses, let us consider again predicate member on regular lists; we have already seen in Section 3 that such a predicate cannot be defined so easily on cyclic lists. For instance, the goalcosld(L=[1,2,3|L],member(5,L))is expected to fail, but a too naive solution would make it succeed. To understand which intuition finally clauses are based on, we can consider the listL=[1,2,3|L]as the limit of the following infinite sequence of finite lists:In this case member(5,l) fails for all finite lists l that approximate the cyclic list L; hence member is expected to preserve the limit, since member(5,L) must fail as well. However, since the list is cyclic, such a limit can be computed in a finite number of steps; for instance, in this case when the finite list [1,2,3,1] is considered, then it can be deduced that the predicate fails for all lists in the sequence.Let us now see how such a limit can be computed concretely by using finally clauses.As already seen, the coinductive hypothesis is applied only for all the elements of the cyclic list that have been already inspected, and hence we are sure that member cannot succeed; therefore in this case the goal must fail. The last clause with finally is used for specifying such a behavior: when a coinductive hypothesis can be applied for member (independently of the arguments), then the goal must fail.The semantics of finally clauses is specified by the following meta-interpreter, which is an extension of the cosldmeta2 meta-interpreter presented in Section 2.For keeping the treatment simple, finally is managed as a predicate symbol, hence in this approach finally cannot be chosen for naming user-defined predicates; in a real implementation this limitation can be easily avoided with a suitable syntax.In comparison with meta-interpreter cosldmeta2 defined in Section 2, the only difference is the introduction of the predicate applycoind, which deals with the application of the coinductive hypothesis, if the current atom A either is subsumed or unifies with some coinductive hypothesis in H after successful application of a clause for A.Predicate applycoind checks whether there exists a finally clause applicable for A, with the atom clause(finally(A),As); if it is the case, then the body of the corresponding finally clause is solved; if no finally clause is found, then the default behavior is implemented: the atom A succeeds.We recall that, in contrast with−>, the built-in predicate*->allows backtracking on the premise. For instance, the two operators exhibit the following behavior in SWI-Prolog:The built-in predicate*->has been used instead of−>, to allow backtracking on finally clauses; we will see in the following why backtracking for finally clauses may be useful.With finally, predicate comember[14] can be easily defined in terms of predicate member previously defined.The atom comember(n,l) succeeds only if n occurs infinitely many times within l.Predicate comember always fails on finite lists (they cannot contain infinite occurrences) since there is no clause for the empty list. If the list is infinite, then the finally clause is applied when the periodic part of the list is reached; at this point, any element occur infinitely many times in the list, hence predicate member can be employed.We conclude this section with two examples showing more advanced uses of the finally clause.We define the predicate max/2 to compute the greatest element of a regular (hence, possibly cyclic) list of integers.The main predicate max/2 is defined in terms of the auxiliary predicate aux_max/3 where the second argument is used as an accumulator to store the maximum value computed so far.As usual, the predicate correctly works for both cyclic (that is, coinductive) and non-cyclic (that is, inductive) lists.If the list is not cyclic, then the empty list is eventually reached, and then the returned value is the current value of the accumulator (fact aux_max([],N,N)).If the list is cyclic, then the atom eventually unifies with a coinductive hypothesis, and then the returned value is the current value of the accumulator (finally clause).For instance, the following atoms succeed:Note that in the worst case for cyclic lists k+2n elements have to be inspected to return the correct value, where n is the length of the repeating part, while k is the number of elements that precede it; indeed, to be able to apply the coinductive hypothesis the second argument to aux_max must first become the maximum of the whole list. This limitation will be overcome in the next section, by allowing the user to restrict coinductive hypotheses to the first argument of predicate aux_max.Finally, we point out that the following direct definition for max is not correct.For instance, the following goal fails:Indeed, as happens in this case, the first element of the repeated pattern of a cyclic list is not guaranteed to be the maximum of the whole list. Again, the more expressive semantics proposed in the next section allows us to make the definition above correct, with minimal changes.With finally clauses, the definition of predicate add/4, as given in Section 3 (without constraints), can be significantly simplified.Such a definition works correctly because the meta-interpreter allows backtracking for finally clauses. When the coinductive hypothesis is eventually applied, the only unknown value is the final carry, which, however, must be either 0 or 1. As already shown in Section 3, there are cases where both values of the carry are correct as happens in the following example of goal:In this section we further extend the semantics defined in Section 4 to make corecursion even more expressive. More precisely, the meta-interpreter we present here allows the user to select only a part of the arguments that are considered when a coinductive hypothesis is applied for a certain predicate.Let us consider again the definition of predicate max given in the previous section.As already noted, in the worst case for cyclic lists k+2n elements have to be inspected to return the correct value, where n is the length of the repeating part, while k is the number of elements that precede it; indeed, to be able to apply the coinductive hypothesis, the second argument to aux_max must first become the maximum of the whole list.This problem is due to the fact that all arguments of aux_max are involved when a coinductive hypothesis is applied, whereas coinduction could be confined to the first argument only.To this aim, we allow the user to annotate the argument of a coinductive predicate with n, if application of a coinductive hypothesis must not depend on such an argument; for brevity, the arguments which are not annotated with n are called coinductive.Now, it is made explicit that the first argument of aux_max is the only one on which regular corecursion depends on; all other arguments are annotated with n. This allows the program to compute the maximum of a cyclic list in k+n steps, instead of k+2n.Note that, differently from the examples in the previous section, here finally has arity 2 instead of 1, even though in this example the second argument is unused. We will explain its use in the last example of this section.With annotations, predicate max can be easily defined directly, without introducing an auxiliary predicate that uses an accumulator.Now that a coinductive hypothesis can be applied by only considering the first argument of the predicate (recall the same example without annotations in the previous section), the definition of max works correctly:We show another example of the usefulness of argument annotations, by defining the function first for non-terminal symbols (and, more in general, any string of terminal and non-terminal symbols) in a context free grammar.Let us consider for instance the following grammar:Function first is at the basis of all algorithms for building tables for generating parsers for LL(k) and LR(k) grammars; when applied to a stringγof terminal and non-terminal symbols, it returns the set of all terminal symbols with which any string derived fromγcan start. For instance,first(A)={a,b,c}.Since here we are not considering just right linear grammars as in Section 3, but all context free grammars, besides the operator for alternatives, we introduce the binary operator*for concatenation, instead of using the constructors for lists. Furthermore, we assume that all terminal symbols are represented by Prolog atoms, and that the empty stringϵis represented by the atom eps. Following this convention, the grammar above is represented by the unification problemA=(eps|c|(A*B)|(a*A)),B=((b*B)|A).Predicate first/2 is defined in terms of the auxiliary predicate first/3 which uses a second argument for accumulating the computed terminal symbols. As in previous examples, the only coinductive argument is the first input argument of first/3.Predicate first/3 uses predicates nullable, and its negation55Predicate notnullable would not be required in a more realistic implementation supporting the cut operator.notnullable, to check whether the empty string is derivable or not from a string of terminal and non-terminal symbols.Note that the finally clause for notnullable can be safely removed, since in this case the predicate has to simply succeed when a coinductive hypothesis is applied.As an example goal, let us consider the previous grammar, and compute the value of first for the non-terminal A.Finally, let us consider an example where the second argument of finally can be usefully exploited. If all arguments are coinductive, then after subsumption or unification with a coinductive hypothesis the processed atom of the goal is equal to the applied coinductive hypothesis; however, if some argument is not coinductive, then this is no longer the case, and retrieving the applied coinductive hypothesis could provide some useful additional information in some cases. The second argument of finally is used to get the applied coinductive hypothesis.To show the usefulness of this, we define a predicate for testing bipartiteness of a graph. We recall that a bipartite undirected graph is a graph whose set of vertices can be partitioned in two sets such that the two vertices of every edge belong to different sets.In a similar way shown for automata, a graph can be represented by one of its vertices, together with its adjacency list.The implementation of predicate bipartite is based on the well-known property that states that a graph is bipartite if and only if it does not contain an odd cycle (that is, a cycle containing an odd number of vertices). The predicate uses the auxiliary coinductive predicate no_odd_cyc which takes the graph and a parity bit (initially set to 0), and succeeds only if the graph does not contain an odd cycle. Only the first argument of no_odd_cyc is coinductive, hence the parity bit of a resolved atom can differ from the parity bit of the applied coinductive hypothesis.If the graph does not contain a cycle, then predicate no_odd_cyc trivially succeeds. For every detected cycle, the finally clause is applied: the parity bit N1 of the current atom no_odd_cyc(_,N1) must be equal to the parity bit N2 of the applied coinductive hypothesis no_odd_cyc(_,N2), otherwise an odd cycle has been detected, and the predicate fails.We conclude this section by showing the extension to the meta-interpreter presented in the previous section, needed to support argument annotations.The main modifications with respect to cosld2finally involve the third clause for solve dealing with the coinductive cases, and the predicates found, subsumed, and applycoind that now take a third argument corresponding to the retrieved coinductive hypothesis, which has to be passed as second argument to finally.Furthermore the predicate filtered, together with some auxiliary predicates, has been introduced to filter out the arguments that are not coinductive and to add a first argument corresponding to the arity of the predicate, to correctly deal with overloaded predicate symbols: indeed, one might declare two coinductive predicates with the same name, different arity, but the same number of coinductive arguments.For instance, given the annotation aux_max(_,n,n), we have that the goal?filtered(aux_max([],1,X),A) succeeds withA=aux-max(3, []), since only the first argument is coinductive. The definition of filtered is based on the new overloaded predicate coinductive/2 that takes a compound atom as first argument, succeeds if its predicate symbol is declared coinductive, and returns the atom where coinductive and non-coinductive arguments have been replaced by distinct fresh variables and by the constant n, respectively.Coinductive hypotheses are stored in a list as before, but now predicates subsumed and found (and their corresponding auxiliary predicates found_subs and found_unif) use predicate filter to remove non-coinductive arguments in the processed atom of the goal and in the coinductive hypotheses.For instance, consider the following goal resolution (assuming the annotation aux_max(_,n,n)):The first argument of found (that is,aux_max(L2,2,R1)) is the atom to be found in the list of coinductive hypotheses, whereas the third one (that is,aux_max(L2, 1, R2)) is the found coinductive hypothesis (after unification): the only argument which remains the same in both atoms is the coinductive one.

@&#CONCLUSIONS@&#
