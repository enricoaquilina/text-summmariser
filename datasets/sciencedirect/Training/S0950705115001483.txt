@&#MAIN-TITLE@&#
PHandler: An expert system for a scalable software requirements prioritization process

@&#HIGHLIGHTS@&#
A scalable software requirement prioritization system is proposed.The system utilizes RV function of VIRP technique for requirement value.The neural network is used to predict the requirement value.The initial competition is resolved with the application of proposed exceptions.The AHP is applied to resolve the final competition among requirements.

@&#KEYPHRASES@&#
Software requirement prioritization,Artificial neural networks,Expert systems,Hybrid model,Decision support,

@&#ABSTRACT@&#
Software requirements engineering is a critical discipline in the software development life cycle. The major problem in software development is the selection and prioritization of the requirements in order to develop a system of high quality. This research analyzes the issues associated with existing software requirement prioritization techniques. One of the major issues in software requirement prioritization is that the existing techniques handle only toy projects or software projects with very few requirements. The current techniques are not suitable for the prioritization of a large number of requirements in projects where requirements may grow to the hundreds or even thousands. The research paper proposes an expert system, called the Priority Handler (PHandler), for requirement prioritization. PHandler is based on the value-based intelligent requirement prioritization technique, neural network and analytical hierarchical process in order to make the requirement prioritization process scalable. The back-propagation neural network is used to predict the value of a requirement in order to reduce the extent of expert biases and make the PHandler efficient. Moreover, the analytical hierarchy process is applied on prioritized groups of requirements in order to enhance the scalability of the requirement prioritization process.

@&#INTRODUCTION@&#
Software requirement prioritization is a process in which requirement engineers find the most important stakeholders’ requirements in order to develop a system [65], particularly an innovative system. These core requirements must be implemented within the defined constraints of time, resources, cost and quality, in order to satisfy the customers [2,34,64,71,73]. The software requirement prioritization process helps to identify conflicts among various requirements and ultimately helps in the resolution of these conflicts; it also provides a future road map [72]. Nonetheless, the selection of the right requirements is the main challenge in order to satisfy all the key needs of the stakeholders and maximize the business value of the product [60]. The wrong set of requirements for an innovative system leads to an increased cost in the modification of the system. The wrong requirements also have an adverse effect on the quality of the system. The value of the requirements is calculated by using a suitable requirement prioritization technique. For decision making, the prioritization of requirements is also considered as highly significant [7]. The requirement prioritization process is also a very complex decision-making process [21,33,47,52]. In order to apply requirement prioritization techniques, the experts must have sound knowledge of the domain and possess the relevant professional skill set [40].The satisfaction of the stakeholders is taken into account when a quality software system fulfills all the requirements of the stakeholders or users [18,49]. The consideration of all requirements in the development of a software system is not possible because of the constraints such as the time to market, budget, and other resources. Thus, only important requirements are taken into account in a single release [35]. Software requirements have different features such as risk [7,52,64,71], importance [47], volatility [52], cost, penalty and time [71] and dependencies with other requirements based on cost, technical importance or value, customers and changes in the requirements [24,61]. On the basis of the above-mentioned features, the unimportant requirements are not given consideration; rather they are totally rejected. Only value-added requirements are considered in the requirements set in order to develop a valuable system of high quality. The value of the system may be in terms of profit, efficiency, the services, good performance, correct data, fulfillment of the right user needs and acceptance by a wide community [12].Different software requirement prioritization techniques are used in order to prioritize the most important requirements, and the requirement prioritization process is still immature [7]. Software engineers use multiple techniques on the basis of factors such as cost, time, and relevant importance, but such an approach is the cause of certain conflicts. These conflicts are initiated due to the effect of one aspect on another aspect. For instance, cost has an immense effect on the requirement prioritization process. If the cost of an important requirement is high, then there is a possibility that the stakeholders may change their mind about the requirement. Such a change in the mind of the customer also results in the change of the priority of that very requirement [43]. In the software requirement prioritization process, the requirements’ attributes or aspects are directly affected by the role of the customers or stakeholders involved in the development process of an innovative system. In addition, it is pointed out that different stakeholders perceive the term “prioritizing requirement” differently [27].This paper comprises eight major sections. This paper first describes the research background in Section 2. Section 3 is about the value-based intelligent requirement prioritization (VIRP) technique. Section 4 describes the proposed expert decision support system PHandler followed by a description of the experimental setup in Section 5. Section 6 discusses the experiments, while Section 7 presents the experimental results. Section 8 presents an overview of the related works and discussion. Lastly, Section 9 concludes the paper.Different software requirement prioritization techniques are used to select the user requirements in order to develop systems of high quality. Some of the most prominent software requirement prioritization techniques are the analytical hierarchical process (AHP), binary search tree, ranking, the numerical assignment, top ten requirements, cumulative voting or hundred dollar test, and many different hybrid techniques are presented. Different methods are used to prioritize the requirements. In one study, the researchers applied different software requirement prioritization techniques “to prioritize 13 well-defined quality requirements on a small telephony system” [38]. The results obtained from the different prioritization techniques demonstrated that the bubble sort technique and AHP are more reliable than the other techniques. It is also noted that in the case of bubble sort and AHP, the time consumption is very high due to the rising number of decisions. The implementation of the AHP is complex, and in it the pairwise comparisons consume too much time for larger datasets. Karlsson et al. [38] conclude that the AHP and bubble sort are problematic for larger projects, and these techniques face the issue of scalability. In a research study, it is concluded that the AHP is not suitable for resolving the problem of scalability due to the exponential increase in the number of comparisons [44]. Laurent et al. [44] stated that the existing techniques are suitable for smaller or medium sized projects, and they are not suitable for larger projects with a large number of requirements. The AHP is only suitable for a small number of requirements [46]. Some of the existing software requirement prioritization techniques are described as follows:Due to the high reliability of the results, the AHP is used in this research. The AHP is a statistical assessment technique proposed by Saaty [62]. The AHP is used to determine the best alternative, to set priorities and to allocate the resources [62]. Saaty [62] did not present the AHP for requirement prioritization; rather it was presented to solve the problems in the domains of social science, economics and management sciences. In this research, the AHP is applied for requirement prioritization. For n number of software requirements, the following formula is used to calculate the number of comparisons:n×(n-1)/2If there will be 25 requirements in a software project, then the total number of comparisons will be 300. In this research, the divide and conquer approach is applied on the requirements dataset based on some key aspects. The smaller clusters of the requirements are gathered which comprise competing requirements. In order to resolve such a situation, the AHP is chosen. The AHP is then applied on these clusters in order to provide a scalable solution for projects with a large number of requirements. The technique is suitable for software requirements with different dimensions or goals; for example, time, significance, associated risks, accuracy and benefits. The AHP works in an efficient and reliable way to solve the problem of requirement prioritization for projects with a small number of requirements. A complete description of the steps of the AHP is given in Section 5.2. Table 1describes the pairwise comparison method of the AHP.The Hierarchy AHP (HAHP) is introduced in order to solve the scalability issue of the AHP [38]. As the number of requirements increases in the AHP then the number of comparisons also increases. An increase in the number of comparisons reduces the efficiency of the AHP. Moreover, the AHP is only suitable for projects with few requirements and is not suitable for projects with large-scale requirements. Hence, in order to overcome this deficiency of the AHP the new approach HAHP is introduced. However, the HAHP is difficult to apply and is less reliable as compared to the AHP.The Minimal Spanning Tree (MST) is presented in order to reduce the pairwise comparisons among requirements [38]. The redundant comparisons are eliminated, and the number of comparisons is reduced to n−1 as compared to the AHP. The MST claims that the reduced number of comparisons is sufficient to measure the relative importance of the requirements.The cost-value approach is presented in order to prioritize the requirements [37]. This approach focuses on the relationship between requirement value and implementation cost. The term value is taken as a benefit associated with the requirement, and the term cost is taken as expenditure in terms of finance and time in order to implement the requirement. Later, the AHP is applied in order to find out the cost-value relationship of the requirements.In numerical assignment technique, the ordinal scale is used for grouping. The requirements are classified into different groups by the stakeholders [41]. The technique suffers from severe issues like how to define the exact group of a given requirement. In this technique, all the requirements are placed in the critical group. Hence, the implementation of all the requirements is considered as essential. It makes the technique less effective, and it loses its real purpose [4]. There are three major groups that are introduced in this technique like critical, standard and optional. Thus, all the requirements will be part of these three classes, and there may be some more. However, the requirements in each group possess same priority, and the competition exists among the requirements [15].Theory W, also known as Win–Win Model, is based on initial planning, risk assessment and handling. The stakeholders rank all the requirements in the first stage based on the VBSE practices. Hence, all negotiations, related to the requirement value, are carried out in the first stage. The two main principles of this theory are ‘What values are important?’ and ‘How is success assured’ [20]. The technique is heavily based on expert judgments and is costly in terms of time consumption.This technique is based on the principle of selection of top ten valuable requirements by the stakeholders. However, in this technique the individual priority of the requirement is not taken into account. The technique is suitable for a limited dataset of requirements in order to select a critical set of requirements. The granularity of the technique is not good [41]. The stakeholders are treated at par, and the same importance is given to all the entities. Hence, the technique loses its credibility as a prioritization technique.Planning game is a customer-oriented prioritization technique. The representation of the requirements is made in the form of stories, and these stories are comprised of small sentences. Experts decide the inclusion and exclusion of a story in the first release and the effort, in terms of time, is also calculated by the experts. The stories are selected by the customers for the next releases of the software based on the time or effort estimated by the experts [17]. The technique is suitable for innovative developmental models, like extreme programming, due to the flexible behavior. In this technique, the two major parts of the planning process are release planning and iteration planning. In release planning, it is determined that which requirements must be realized in the first and the later releases of the software. In iteration planning, the different developer actions are planned after finalization of the requirements.Cumulative voting (CV) or the hundred dollar test [45] is based on discussions. The requirements are analyzed holistically in the discussions. The stakeholders have an authority of 100$ money that they can assign to different requirements based on the significance of the requirements. Any number of dollars can be assigned to any requirement by a stakeholder. The dollars assigned by the different stakeholders to a given requirement are calculated and based on the sum of the dollars the final priority of the requirement is defined. The technique works well for a small number of requirements and is not suitable for projects that comprise large number of requirements.The B-Tree prioritization technique is presented in [14]. The technique can cope with the issue of requirements volatility and a change in the dynamics of the requirements. In the B-Tree, the function f is used in order to plot the requirements based on the calculated priority values as given in the prioritized set of the requirements.Ranking and numerical assignment are similar to each other due to the application of the ordinal scale [15]. The requirements are prioritized in a linear fashion, and the requirement with high priority is assigned a value of 1, the requirement with second highest priority is assigned a value of 2 and so on. However, the last requirement is assigned a value of n where n is the total number of requirements in the set. In the ranking approach, different algorithmic ways can be adopted to prioritize the requirements which may include bubble sort, quick sort, binary search tree and many others [74].In bubble sort, the ranking approach is adopted to prioritize the requirements [38]. The priority is decided based on the importance of the requirement. However, it is not taken into account that to which extent a requirement is important. The steps adopted in the bubble sort technique are as follows:(a)The requirements are arranged in the form of a column.The top two requirements are compared and based on the priority the swapping is performed. The requirement with the higher priority is placed at the top.All the requirements are compared and swapping is performed in order to define priority of each requirement.Repetition is carried out from the start, and the top two requirements are compared again.The hierarchical cumulative voting (HCV) deals with the issue of scalability [16]. The concept of HCV is same as in CV. In the HCV, the points are allocated to the requirements as the points are assigned in the CV. The only difference is in the selection process for a given set of requirements. In the HCV, the requirements are divided into different hierarchies or groups and later the requirements are prioritized based on the concept of CV.The following steps are performed in the priority groups technique [38].(a)Prepare a set of all requirements.Define the priority groups of the requirements like high priority, medium priority and low priority.More sub-groups may be created based on the number of requirements, and the requirements may be adjusted in these sub-groups.Repeat step 3 until a relationship of one on one is not achieved.Read the requirements from the left to right.This technique is suitable for a small number of requirements. However, in the case of large number of requirements the technique is not viable.It is a priori or posteriori approach which is based on the interactive genetic algorithm (GA) and pairwise comparison [67,68]. The main purpose of this technique is to “extract the relevant knowledge from the user”. In the existing techniques, the exhaustive pairwise comparisons are impractical. Hence, the GA is introduced in order to reduce the number of comparisons. In this technique, the input to the fitness function is incremental and in the beginning it is partially known.The case-based ranking (CBR) technique is proposed to design a decision-support system for interactive preference elicitation [10]. The pairwise comparison, in order to support the elicitation of preferences, is based on the Boolean values. The CBR technique provides an acquisition policy to recommend that which pairs of the cases must be analyzed in the first attempt. The machine learning approach is adopted to predict or approximate the preference values of the pairs that are unknown. The error and effort minimization approach is adopted to achieve the accurate approximated ranks of the requirements.The value-based intelligent requirement prioritization (VIRP) technique comprises three major steps. In step one, the requirements are elicited and prioritized by the stakeholders. The step two is based on expert level prioritization in which the value of a requirement is calculated based on the RV function. The RV function comprised two types of requirement factors. There are requirement specific requirement classification factors which are denoted by rRCFs and project specific requirements classification factors which are denoted by pRCFs. In step three of the VIRP, fuzzy c-means is used in order to classify the requirements into different clusters. Step 2 of the VIRP technique is used in this research. The VIRP technique is described in detail in Section 3.The existing techniques are not suitable for the projects that have large or medium datasets [13]. The aim of this research paper is to solve the problem of the scalability of larger projects when the requirements grow to the hundreds or even thousands. The problems of existing software requirement prioritization techniques are as follows:•The existing techniques do not provide a scalable solution when the requirements are scaled up in the case of a large number of requirements [3,13,69].The existing techniques do not provide sufficient automation and are not intelligent enough [55].Most of the techniques are time-consuming [4,13,70].Difficult to implement due to the complexity [42,70].The results are faulty and do not recall [13,39].The existing techniques mostly solve the issues of small-scale requirements but with errors [13,31,42].This research focuses on the first problem, namely, that the existing techniques do not provide a scalable solution when the requirements are scaled up in the case of a large number of requirements. An expert decision support system, called PHandler, is proposed for the requirement prioritization process in order to make the prioritization process scalable and effective. In this research paper, three different research approaches are used to develop an expert system for a scalable software requirement prioritization process: the VIRP technique, neural networks, and the AHP.The requirement prioritization process shows a higher degree of opinions about requirements’ values, and estimates of the different requirements’ attributes add a higher level of uncertainty in the process. The different degrees of opinions and uncertainty make the process highly nonlinear. However, the Artificial Neural Network (ANN) can solve both linear and non-linear problems without the prior assumptions that are normally required in statistical models. In this research, the ANN is applied for requirement value prediction which works as an information processing system and has a resemblance to biological neural networks [26,54]. The ANNs are normally used to predict, approximate and solve the linear and nonlinear problems [28,66]. The ANNs can map a relationship between the given inputs and the intended outputs for the intended process without taking into account the phenomenon of physics explicitly [75]. The application of ANN is described in detail in Section 5.1.VIRP is a multi-level iterative technique for the prioritization and classification of software requirements and works in collaboration with stakeholders, experts and automated fuzzy logic [55]. The purpose of iteration in VIRP is to evaluate the requirements iteratively with the help of different actors in order to achieve reliable results. The VIRP model is shown in Fig. 1.The VIRP technique consists of the following three major steps [55]:(i)Requirement elicitation and stakeholder level prioritizationExpert level prioritizationFuzzy logic-based requirement prioritizationThe three steps are briefly described below.There are two main activities in the requirement elicitation and stakeholder level prioritization step. First, all the requirements are gathered and stored in the database using a web-based application along with the requirement priorities set by the stakeholders. Second, by using the same web-based application the stakeholders will also submit their profiles by giving a brief description. Based on the profiles, the quantification of stakeholders is also performed in order to know the worth of the stakeholders. The profiles of the quantified stakeholders are later used to resolve the conflicts among competing requirements.In the second step of expert level prioritization, the experts have to play a vital role. Three main tasks are performed by the experts at this level. In the first task, the experts review the requirements in quick sessions without taking into account the profiles of the stakeholders. The modifications of the priorities are performed by the experts in this task. In the second task, the quantification of the stakeholders is performed by the experts using a ranking method. Stakeholders are the key entities which may help to improve the software quality to a great extent. A high priority is given to stakeholders in the STAR triangle [11]. In the VIRP, a score or value is assigned to each stakeholder in the range of 1–10 for their quantification. The stakeholder values are defined on the basis of key attributes such as significance, domain knowledge, participation level, dependency, control and level of decision making. The third task in this step is to assign a value to each requirement based on certain requirements classification factors (RCFs). The valuation is performed to prioritize the requirements. RCFi denotes factor whose degree of presence or absence in a requirement can have a direct bearing on its value [55]. The RCFs are of two main types. The first type is the project specific RCFs denoted by pRCFs, that show the requirement’s value or importance with respect to the project. The pRCFs are feasibility, modifiability, urgency, traceability, and testability. The second type is the requirement specific RCFs, denoted by rRCFs. The rRCFs illustrate the requirement attributes in order to find the value of a requirement. The rRCFs are completeness, consistency, understandability, within the scope and non-redundancy. Once again, a ranking system is used by the experts to score all the RCFs. A value is assigned to each RCF in the range of 0–5. The scores of all these RCFs are used to determine the value of a requirement (RV) using Eq. (1):(1)RV=0.35+0.02∑i=15pRCFi+∑i=15rRCFiIn Eq. (1), i denotes the requirement classification factors (RCFs) and the integer 5 shows the total input to the RV function in the form of five pRCFs and five rRCFs. The RV obtained is in the range of 0.35–1.35 with an interval of 0.02 between each consecutive value. Thus, there is a total of 51 data classification values. A situation may arise during prioritization when the values of two or more requirements will be the same. Hence, the following five exceptions are given to solve this problem.Exception 1: When two or more requirements have similar RV, then the value of pRCF is used as a deciding measure. A high priority is given to a requirement that possess higher pRCF value. For example for any two requirements i and j when the situation is:RVi=RVjthenif∑i=15pRCFi>∑i=i5pRCFjthenhighpriority⇒RVielsehighpriority⇒RVjException 2: When the value of requirements i is equal to the requirement j and the value of pRCFi is equal to the value of pRCFj. For example, for any two requirements i and j, when the situation is:RVi=RVjthenif∑i=15pRCFi=∑i=i5pRCFjThen the prioritized profiles of the stakeholders are used. The stakeholder profile value (vST) helps to determine which stakeholder is more important among the competing ones [55]. Based on the importance of the stakeholder profiles, the priority of a requirement is defined. The stakeholders are divided into the following three categories based on their profile scores or values.•The stakeholders with high profile valueThe stakeholders with medium profile valueThe stakeholders with low profile value.The following criterion is used to categorize the stakeholders based on their profile values.(2)Avg(all)=∑i=1nvSTNStakeholderwithhighervST=vST⩾Avg(all)Take the average of the vST of all the selected stakeholders who are part of the requirement elicitation phase. In Eq. (2), the sum of the vST of all stakeholders(n)is taken and is divided by N, which represents the total number of selected stakeholders. The stakeholders with the vST greater than or equal to the average of all stakeholders are placed in the stakeholder category with higher vST or profile values. The stakeholders with the vST less than Avg(all) are denoted as remaining stakeholders (RS), and their number Nr is calculated by subtracting the total number of stakeholder with higher vST from N. The average of the vST of the remaining stakeholders (RS) is calculated by using Eq. (3):Nr=N-StakeholderwithhighervST(3)Avg(RS)=∑i=1nvSTNrThe stakeholders with the vST less than Avg(all) and greater than or equal to Avg(RS) are placed in the stakeholder category with medium vST or profile value:StakeholderwithmediumvST=Avg(RS)⩽vST<Avg(all)StakeholderwithlowvST=vST<Avg(RS)However, the stakeholders with vST value less than Avg(RS) are placed in the stakeholder category with low vST or profile value.Exception 1 and Exception 2 are not sufficient to resolve the competition among requirements when the requirements increase in number. Hence, based on the vST three more exceptions are derived from Exception 2 of the VIRP for requirement conflict resolution and scalability. Exception 2 is formulated based on the vST and is denoted by Exception 2a.Exception 2a: When two or more requirements have similar RV and the value of pRCFi is equal to the value of pRCFj and the value of stakeholder i is greater than the value of stakeholder j, then the stakeholder with a stakeholder value vST greater than the other stakeholder is used as a deciding measure. For example, for any two requirements, i and j, when the situation is:RVi=RVjandif∑i=15pRCFi=∑i=i5pRCFjandvSTi>vSTjthenhighpriority⇒RViofvSTielsehighpriority⇒RVjofvSTjException 3: When two or more requirements have similar RV and the value of pRCFi is equal to the value of pRCFj and the value of stakeholder i is equal to the value of stakeholder j, then the requirements of the stakeholders with high vST values are given high priority as compared to the stakeholders with medium and low stakeholder values. For example, for any two requirements i, and j, when the situation is:RVi=RVjandif∑i=15pRCFi=∑i=i5pRCFjandvSTi=vSTjthenhighpriority⇒RViofstakeholderofhighvSTException 4: When two or more requirements have similar RV and the value of pRCFi is equal to the value of pRCFj and the value of stakeholder i is equal to the value of stakeholder j, Then the requirements of the stakeholders with medium vST values are given high priority as compared to the stakeholders with low stakeholder value. For example, for any two requirements i, and j, when the situation is:RVi=RVjthenif∑i=15pRCFi=∑i=15pRCFjandvSTi=vSTjthenhighpriority⇒RViofstakeholderofmediumvSTException 5: When two or more requirements have similar RV and the value of pRCFi is equal to the value of pRCFj and the value of stakeholder i is equal to the value of stakeholder j, then the last priority is given to the requirements of the stakeholders with low vST values. For example, for any two requirements i, and j, when the situation is:RVi=RVjthenif∑i=15pRCFi=∑i=15pRCFjandvSTi=vSTjthenpriority⇒RViofstakeholderoflowvSTvalueThe second step is non-scalable, manual and is the cause of biases induced by the experts. It also reduces the performance of the technique in terms of time. The Back Propagation Neural Network (BPNN) is applied in the second step (expert level prioritization) of the VIRP technique in order to make the technique scalable and less prone to biases. The function used to calculate the RV of a requirement is the base of input parameter or data for the BPNN. The RV is predicted using the BPNN. The use of the BPNN reduces the experts’ bias and improves the performance in terms of time. Section 5.1 describes the application of the BPNN.In the third step of the VIRP technique, the fuzzy c-means (FCM) clustering method is used in order to create clusters of the requirements. The FCM clustering method was presented in order to divide data into different clusters of similar types of data sets [25]. An improved version of the FCM was later presented in [19]. There are two major types of clustering, namely, fuzzy clustering and hard clustering based on the fuzzy problem and hard problem. In clustering, the data possess two properties, namely, homogeneity and heterogeneity. In the case of homogeneity, the objects of one class or cluster are similar to each other. In the case of heterogeneity, the objects in one class are dissimilar to the objects of other classes [57,59]. The data points in fuzzy clusters possess a degree of fuzzification that shows their links with different clusters instead of showing their association with a single cluster. However, the situation is different in the case of RV. The RV data are homogenous and the set of requirements with the same RV cannot be associated with other clusters or sets of requirements which have a different RV. Based on the RV, the RV function divides requirements into 51 key clusters which are an example of hard clustering. The RV data in the current research belong to a hard problem and not a fuzzy problem. Hence, the fuzzy clustering in the case of the VIRP model is unable to provide a scalable solution for large-scale projects with a large number of requirements. In this research, the AHP is applied in order to achieve scalability.An expert decision support system deals with a planning problem. “Very often a planning problem can be formulated as a ranking problem: i.e. to find an order relation over a set of alternatives. This order relation is usually interpreted as a sort of priority index that supports a selection policy” [10]. Hence, in this paper the planning problem approach is adopted. An expert system is a computer program which mimics the reasoning and behavior of a human specialist or expert [29,51]. In an expert knowledge-based system, the expert heuristics is applied in order to produce optimum results.The proposed expert system, PHandler, is shown in Fig. 2. The PHandler expert system heavily relies on expert knowledge in order to make the requirement prioritization process efficient and scalable. The PHandler system comprises three stages. The first stage of the PHandler is based on the VIRP approach. In the first step of VIRP, the stakeholder analysis is carried out as per the given ranking criteria and the requirements are gathered by conducting regular sessions with stakeholders. In the next step, the requirements are prioritized using the RV function that comprises the requirement classification factors, pRCF and rRCF. The values assigned to the pRCF and rRCF, by the experts, are given as an input to the BPNN for RV prediction. In order to resolve the conflicts among the requirements, which have same RV, the five exceptions are proposed in the VIRP as described above in Section 3.2. The exceptions are based on the stakeholders’ profile values. The stakeholders’ profile values are given as an input to the exceptions along with the RV. The data flow of the stakeholders’ profiles is represented by brown arrows in Stage 2 of the PHandler system as illustrated in Fig. 2. In the second stage of the PHandler system the exceptions are applied in order to resolve the competition. In the third and last stage of the PHandler system, the AHP is applied in order to resolve the conflicts among the requirements that are prioritized after the application of the proposed exceptions. In Fig. 2, the parallelogram symbols are the inputs and outputs of the system; the rectangles represent the processes, and the arrows represent the flow of the data and process at the same time.The proposed exceptions divide the requirements with the same RV into five sub-clusters as shown in Fig. 2. Firstly, the requirements with the same RV and higher pRCF values are given a priority of 1 (P1). Secondly, the requirements with the same RV and higher stakeholder value (vST) are given a priority of 2 (P2). Thirdly, the requirements with same RV, the same vST but stakeholders with high values are assigned a priority of 3 (P3). Fourthly, the requirements with the same RV, the same vST but stakeholders with medium values are assigned a priority of 4 (P4). Lastly, the requirements with the same RV, the same vST but stakeholders with low values are assigned a priority of 5 (P5). In the case of P1 and P2, the requirement sets consist of the requirement values that are already prioritized. However, the clusters of P3, P4 and P5 are later prioritized using the AHP due to the induced competition. After applying the AHP on P3, P4 and P5, there will be five prioritized lists of the requirements as an output in the form of data. By combining them, a final prioritized list of the requirements data is obtained. The next Section 5 describes the experimental setup.In this section, the experimental setup related to the application of the BPNN and AHP is described in detail.In the PHandler system, the requirement value is predicted by using the BPNN in order to reduce the expert biases and make the VIRP efficient and scalable. The BPNN consists of three main layers i.e. weighted input layer, a hidden layer, activation or transfer function and the output layer. In Fig. 3, b is the bias that is normally added in order to force a network to learn a pattern. The circles represent the weights ‘ω’ that are multiplied with the inputs. The weights are initialized randomly, and the network is trained to minimize the mean squared error (MSE) in order to obtain the optimized results. However, overtraining leads to the reduced performance of the BPNN due to several training epochs [22]. In order to overcome this issue, the BPNN is simulated using different activation and training functions for optimized results.The two main types of learning approaches are supervised and unsupervised learning. Normally, a supervised ANN is used for real world problems. In the supervised learning process, historical data are required in terms of examples, cases and instances of all participating classes. The data are used to know the similarities in the data in unsupervised learning and are used to predict the class of an object by using supervised learning [5]. In the case of requirement prioritization, the historical data are not available. Hence, the training data for the ANN are gathered from ten factors of pRCF and rRCF as described in the RV function of the VIRP. We have selected seven projects for data collection. The stakeholders of the projects were prioritized as per the criteria given in the VIRP. The requirement sets were handed over to industry professionals in order to assign values to factors of pRCF and rRCF for each requirement. The experts assigned a value in the range of 0–5 to each factor. The input to the ANN can be represented as:xi={x1,x2,x3,…,xn}For example, an expert selects the valuesx={4,3,1,5,2,3,5,4,5,2}for the ten factors of pRCF and rRCF for a given requirement. The net input to the RV function is the sum of all ten factors (i.e. 34), and the value of the RV is 1.03 according to Eq. (1). The input data P or RCF values are added here and given as an input to the ANN as they are homogenous mixtures. There are 51 classes of input data P in the range of 0–50 with a geometric progression of one. The target data T is in the range of 0.35–1.35 with a geometric progression of 0.02. The input and target data represent all the possibilities that may occur in a given problem domain. The summation of the ten factors is directly mapped with the output of the RV function in order to train the BPNN. The experts also calculated the RV of each requirement in the range of 0.35–1.35 by applying Eq. (1). Table 2describes a partial dataset sample.In order to train and optimize the BPNN, different training functions are applied to predict the RV for an optimum solution of the problem. For an optimized solution, the knowledge of the process is also highly desirable which means the key aspects of all the procedures must be well defined. Moreover, for optimized results, the input data are pre-processed by using normalization in order to obtain an even distribution of data in the range of −1 to 1. The ‘tanh’ hyperbolic tangent activation function is used in the hidden layer and is represented by the following formula:(4)tanh=ex-e-xex+e-xTable 3presents the initial training results after using different training functions before the validation phase. The training functions used in the BPNN application are trainlm, trainbr, trainbfg, trainrp, trainscg, traincgf, traincgp, trainoss, traingdx, traingdm and traingd. The BPNN is trained by applying all the specific training parameters in order to obtain the optimized results. The results are reported after several cycles of the training. Initially, the RV of a requirement is predicted by using the BPNN architecture of 1-10-1 (input-hidden nodes-output). However, in the validation phase of the BPNN application, the different architectures are applied in order to find out the impact of the hidden nodes on accuracy of the results. The BPNN architecture mainly depends on the number of hidden units in the hidden layer. Such an application of the BPNN methodology helps in finding out the most optimized BPNN architecture that best resolves the problem of requirement prioritization.The results in Table 3 show that the RV obtained from the trainlm and trainbr functions are highly optimized as compared to other functions. The other functions are unable to produce the optimized results due to the following reasons:(i)The training cycles have met the stated threshold.The time threshold to train the network has been reached.The performance goal is not met.The performance gradient has fallen below the adjusted value of mingrad.The threshold of mu_max is exceeded.The max_fail times increased the validation performance since its last decrease.The MSE of the BPNN decreases with an increase in the training iterations. The observation of the MSE helps in the verification and validation of the BPNN with the change of each epoch [30]. The initial training results show that the training functions of trainlm (Levenberg–Marquardt backpropagation) and trainbr (Bayesian regularization) are the possible solutions for the RV problem. Hence, initially the trainlm and trainbr training functions are selected for further experimentation. The results of the selected training algorithms for the validation data are given in Table 4as a sample.The predicted output of the trainlm and trainbr training functions shows that the results produced by trainlm are more optimized as compared to the trainbr function. The error in the case of trainbr is higher than in trainlm. Fig. 4shows that the predicted RV, using trainbr, do not map the training data, and the deviation from the training data points is very high. The software requirements with a higher RV have higher errors in the case of trainbr. However, in the case of trainlm the predicted RV shows a lesser deviation trend from the training data in Fig. 5. The solution given by the trainlm training algorithm is more optimized as compared to the other training algorithms. Moreover, trainlm is an efficient and fast back-propagation training function and is highly recommended for supervised learning [50]. Hence, the trainlm training function is selected for the requirement prioritization process and is used in different neural network architectures in order to optimize the BPNN. The BPNN architecture depends mainly on the use of hidden layers, hidden nodes and activation functions. The results of the different BPNN architectures, based on the hidden nodes, are shown in Table 5. The best-generalized results are achieved using BPNN architecture 1-16-1 and are shown in Table 6. The results achieved with the 1-16-1 BPNN architecture have less error than the results achieved with the 1-10-1 BPNN architecture as shown above in Table 4. Moreover, the same BPNN architecture has been tested for trainbr and resulted in the over-fitting problem and bad performance generalizations [32].Different BPNN architectures were used to obtain an optimized solution. The change in the number of hidden nodes results in the evolution of new BPNN architectures. The results are analyzed carefully, and the BPNN architecture of 1-16-1 is selected as the best solution for the said problem. Table 5 presents the results of the different BPNN architectures for single input 35 and single target output 1.0500. However, the whole training dataset is used in the experimentation. Table 6 presents the optimized results of the selected architecture. The other BPNN architectures are not suitable due to the higher errors and over-fitting problems. The architectures with hidden nodes greater than 16 resulted in the over-fitting problem.For larger requirement datasets, the VIRP is not scalable. Hence, during requirement prioritization, several requirements are competing with each other in terms of having the same RV as predicted by the BPNN. Initially, the competition can be resolved by using the exceptions (Section 3.2]. The proposed five exceptions divide the requirements with the same RV into five sub-clusters. Later, to resolve the competition of sub-clusters, the AHP is applied as “a tool of information communication and signification” [62]. The AHP is concerned with semiotics in which a semantic system is used for signal codification using a pre-defined set of rules [63]. The AHP is applied on competing requirements and for each sub-cluster of competing requirements the eigenvalues are estimated in order to find out the priority matrix (PM). The consistency index (CI) and consistency ratio (CR) are calculated in order to identify the consistency or accuracy of the results. The AHP comprises the following five steps:Step 1: Matrix formulation of order nIn the first step of the AHP, a matrix of order n is formulated. A matrix of order n is actually an n x n matrix where n represents the number of rows and columns. In this research, we assume n as the candidate requirements.Step 2: Pairwise comparisons of the requirementsIn this step, the pairwise comparisons of all the requirements in the matrix of order n are performed. The fundamental comparison method for pairwise comparisons is shown above in Table 1. The requirements are compared with each other (starting with R1 and R1, R1 and R2, R1 and R3 and so on). Here, R represents a requirement. The main diagonal of the matrix must be a 1 because when a requirement in the matrix is compared with itself then it is treated as equally important. Hence, a value of 1 is inserted in all positions of the diagonal. The case of R1 and R2 is taken here. When R1 of the matrix is compared with R2 of the matrix, then the relative value is placed in a position where the row of R1 meets the column of R2. The reciprocal value is placed in a position where the row of R2 meets the column of R1.Step 3: Normalization of matrix and estimation of eigenvaluesSaaty [62] proposed the averaging over normalized columns method to normalize the matrix in order to estimate the eigenvalues. The value of each requirement in the column is divided by the sum of the column and later the average value is computed for each row. This mechanism results in a normalized matrix and estimation of eigenvalues. The estimation of the eigenvalues results in the priority matrix.Step 4: Assignment of value to each requirementIn this step of the AHP, a relative value is assigned to each requirement of the matrix based on the eigenvalues.Step 5: Result accuracy estimationIn order to estimate the accuracy of the results, the first step is to calculate the CI. The CI is calculated using the following formula:(5)CI=(λmax-n)(n-1)The λ max is the maximum principle eigenvalue, which is estimated by multiplying the comparison matrix with the priority matrix. In Eq. (5), n refers to the total number of requirements. Then each element of the resulting vector is divided by the respective element in the priority vector. Element 1 of the resulting vector is divided by Element 1 of the priority vector, Element 2 of the resulting vector is divided by Element 2 of the priority vector, and so on. In order to identify the acceptability of the CI value, the CR is calculated by using the following formula:(6)CR=CIRIwhere RI is the random index based on the scale of 1–9 as shown above in Table 1. The RI values applied in this research are taken from [6]. Alonso and Lamata [6] gave the RI values for a matrix where the value of n (number of requirements) is 39.

@&#CONCLUSIONS@&#
