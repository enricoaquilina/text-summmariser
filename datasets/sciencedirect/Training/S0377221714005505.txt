@&#MAIN-TITLE@&#
Robust optimization for the cyclic hoist scheduling problem

@&#HIGHLIGHTS@&#
We propose a method to measure the robustness of a cyclic hoist schedule.A bi-objective mixed integer linear programming (MILP) model is proposed.The model aims to minimize the cycle time and maximize the robustness.Pareto solutions are obtained by solving single-objective MILP models using CPLEX.The optimal cycle time is a piecewise linear increasing function of the robustness.

@&#KEYPHRASES@&#
Cyclic scheduling,Hoist scheduling,Robust scheduling,Mixed integer linear programming,

@&#ABSTRACT@&#
This paper deals with the robust optimization for the cyclic hoist scheduling problem with processing time window constraints. The robustness of a cyclic hoist schedule is defined as its ability to remain stable in the presence of perturbations or variations of certain degree in the hoist transportation times. With such a definition, we propose a method to measure the robustness of a cyclic hoist schedule. A bi-objective mixed integer linear programming (MILP) model, which aims to optimize cycle time and robustness, is developed for the robust cyclic hoist scheduling problem. We prove that the optimal cycle time is a strictly increasing function of the robustness and the problem has infinite Pareto optimal solutions. Furthermore, we derive the so-called ideal point and nadir point that define the lower and upper bounds for the objective values of Pareto front. A Pareto optimal solution can be obtained by solving a single-objective MILP model to minimize the cycle time for a given value of robustness or maximize the robustness for a specific cycle time. The single-objective MILP models are solved using commercial optimization software CPLEX. Computational results on several benchmark instances and randomly generated instances indicate that the proposed approach can solve large-scale problems within a reasonable amount of time.

@&#INTRODUCTION@&#
Many production systems employ a computer-controlled hoist to perform the transportation of parts between processing stages, such as automated electroplating lines in the manufacture of printed circuit boards (PCBs). Such a system generally consists of a sequence of tanks with a variety of chemical solutions for part surface processing, and a single computer-controlled hoist in charge of material handling between the tanks. The parts are treated successively in the tanks according to their processing routine. There is no intermediate storage buffer between the tanks. After the processing in a tank has been completed, the part should be unloaded by the hoist, then transported to the next tank according to its processing routine, and loaded into that tank for the next processing. Due to specificity of chemical processing, the processing time in each tank must be within its prescribed time window defined by a lower bound and an upper bound. If the processing time window in any tank is violated, i.e., the processing time in a tank is shorter than the given lower bound or longer than the upper bound, defective parts would be produced. As all the material handling operations between tanks are performed by the hoist, the efficiency of such a production system is strongly dependent on the schedule of the hoist operations. This problem is the so-called hoist scheduling problem in the literature (Chauvet, Levner, Meyzin, & Proth, 2000; Che & Chu, 2007; Chen, Chu, & Proth, 1998; Kats, Lei, & Levner, 2008; Kats & Levner, 2011; Leung, Zhang, Yang, Mak, & Lam, 2004; Levner, Kats, de Pablo, & Cheng, 2010; Liu, Jiang, & Zhou, 2002; Phillips & Unger, 1976; Shapiro & Nuttle, 1988).As a large amount of parts is processed in the production line, the system commonly runs in a cyclic mode. That is to say, the hoist is programmed in advance to perform a specified sequence of operations repeatedly, referred to as a cyclic hoist schedule. Each repetition of such a sequence of hoist operations is called a cycle, and its duration is called cycle time.The cyclic hoist scheduling problem has been well examined over the past three decades. Phillips and Unger (1976) developed its first mixed integer linear programming (MILP) model. The problem was proven to be strongly NP-hard by Lei and Wang (1989). Numerous researchers, such as Shapiro and Nuttle (1988), Lei and Wang (1994), Ng (1996), Chen et al. (1998) and Yan, Chu, Yang, and Che (2010), put forward various branch-and-bound procedures for the cyclic hoist scheduling problem. Other researchers proposed various heuristics for the problem, such as Lim (1997), Hindi and Fleazar (2004) and Paul, Bierwirth, and Kopfer (2007).The above basic cyclic hoist scheduling problem was improved from several facets. Liu et al. (2002) and Che and Chu (2007) developed exact approach for the problem with re-entrant and parallel tanks. Armstrong, Lei, and Gu (1994), Varnier, Bachelu, and Baptiste (1997), Manier, Varnier, and Baptiste (2000), Leung et al. (2004), Che and Chu (2004), Manier and Lamrous (2008) proposed a variety of exact algorithms or heuristics for the cyclic multi-hoist scheduling problem.As mentioned above, the production system usually runs in a cyclic mode in mass production. In such a mode, an optimal cyclic hoist schedule is computed in advance according to the deterministic problem parameters concerning the processing time windows and the hoist transportation times. The hoist is programmed to perform this cyclic schedule repeatedly. However, in industrial applications, the transportation times of the hoist are subject to variations due to many random factors, such as the variations in part weights, material-handling engine problems, communication-delay between the control system and the hoist (Fleury, Gourgand, & Lacomme, 2001). Under such a cyclic running mode, any variation in the transportation times of the hoist may have a great consequence. Defective parts would be produced due to the violation of the processing time windows, or more seriously, a deadlock may occur.Fleury et al. (2001) proposed stochastic metaheuristics to determine a non-cyclic hoist schedule for which the consequences of the variations in hoist transportation times on the makespan and the violation of the time windows are minimized. Differently from their work, we try to generate a cyclic hoist schedule that is “robust” within a reasonable range of variations in the hoist transportation times. In other words, as long as the hoist transportation times vary within some range due to random events, the generated robust cyclic hoist schedule can still be implemented without altering its corresponding cycle time and without violating the processing time windows.In the literature, the robustness of a schedule is usually defined as its ability to perform well under dynamic and uncertain operational environments (Billaut, Moukrim, & Sanlaville, 2008; Dooley & Mahmoodi, 1992). Two types of robustness are usually defined in scheduling: solution robustness and quality robustness (Briskorn, Leung, & Pinedo, 2011; Herroelen & Leus, 2004; Sevaux & Sörensen, 2004; Van de Vonder, Demeulemeester, Herroelen, & Leus, 2005). The solution robustness is measured in terms of the deviation between the planned and realized start times of operations, while the quality robustness is measured in terms of deviation from the criterion (e.g. makespan, flow time, and due date) between the planned schedule and the realized schedule (Van de Vonder et al., 2005). Most studies in the literature considered the quality robustness, such as the deviation of makespan between the planned schedules and the realized ones (Rahmani & Heydari, 2014; Storer, Wu, & Vaccari, 1992; Xiong, Xing, & Chen, 2013), the deviation of flow time (Lu, Lin, & Ying, 2012) or due date (Ranjbar, Davari, & Leus, 2012). Al-Hinai and ElMekkawy (2011) considered three measures of solution robustness: the average deviation between the completion times of predicted and realized operations, the total deviation between the completion times of predicted and realized operations, and the average deviation between the completion times of affected predicted operations and the affected realized ones. In other studies, both the solution robustness and quality robustness are addressed (Leon, Wu, & Storer, 1994; Rangsaritratsamee, Ferrell, & Kurz, 2004; Wu, Storer, & Chang, 1993).To the best of our knowledge, no work in the literature has addressed the robust optimization for the cyclic hoist scheduling problem. This paper is the first one that deals with the robust optimization for the cyclic hoist scheduling problem. The contribution of this paper is as follows. Firstly, we propose a method to measure the robustness of a cyclic hoist schedule. Secondly, a bi-objective mixed integer linear programming (MILP) model is proposed for the robust cyclic hoist scheduling problem, which aims to optimize the cycle time and the robustness. Thirdly, we prove that the optimal cycle time is a strictly increasing function of the robustness and the problem has infinite Pareto optimal solutions. We derive the so-called ideal point and nadir point that define the lower and upper bounds for the objective values of Pareto front. A Pareto optimal solution can be obtained by solving a single-objective MILP model to minimize the cycle time for a given value of robustness or maximize the robustness for a specific cycle time. Computational results on several benchmark instances and randomly generated instances are depicted.The remainder of this paper is organized as follows. In Section 2, a detailed problem description is given. In Section 3, we propose a method to measure the robustness of a given cyclic hoist schedule. Section 4 is devoted to the formulation of the bi-objective MILP model. In Section 5, the properties of the proposed bi-objective MILP model are analyzed. In Section 6, computational results on benchmark instances and randomly generated instances are presented to validate the effectiveness of the proposed approach. We summarize our work in Section 7.The production line studied is physically similar to those largely studied in the literature (e.g. Che & Chu, 2007; Chen et al., 1998; Leung et al., 2004; Liu et al., 2002; Phillips & Unger, 1976; Shapiro & Nuttle, 1988). The reader can find similar problem description in these works. For the sake of self-consistency, we recall this description and the notation that will be used throughout the paper, which are similar to those existing in the literature. This production line is composed of a single computer-controlled hoist for material handling and N+2 tanks arranged in a row according to the processing routine. The tanks are indexed as M0, M1, …, MN+1, where the loading station and the unloading station are indexed as M0 and MN+1, respectively. In some cases, the loading station and unloading station may be the same one. All the parts to be processed are of the same type. The parts are first moved away by the hoist from the loading station M0, then processed on M1, M2, …, MNsuccessively and finally leave the system from the unloading station MN+1. Each tank can process at most one part at a time. There is no intermediate storage buffer between the tanks. After the processing in a tank has been completed, the part must be moved away and transported by the hoist to the next tank. The actual processing time of each part in tank Mimust be within its corresponding time window defined by a pair of lower and upper bounds [Li, Ui], 1⩽i⩽N. The material handling between the tanks is realized by a hoist. For simplicity of description, the hoist operation of transporting a part from tank Mito tank Mi+1 is called (loaded) move i, 0⩽i⩽N. The time required to execute move i is di, 0⩽i⩽N. In contrast with loaded hoist moves, the empty hoist travel from a tank to another is called an empty move. The empty hoist travel from tank Mito tank Mjtakes ei,junit times, 0⩽i, j⩽N+1.In a cyclic system, the hoist performs a prescribed schedule repeatedly, and its duration is the cycle time T. A hoist schedule is composed of a sequence of hoist moves and the associated start time of each hoist move in a cycle. Hence, a hoist schedule can be represented by (T, s[0], s[1], …, s[N]), where [i] is the index of the i-th move that the hoist performs during a cycle and s[i] is its corresponding start time, 0⩽i⩽N. For instance, if [2]=3, then the second move of the hoist during a cycle is move 3, i.e. the (loaded) move from tank M3 to tank M4. Note that each loaded move is followed by an empty hoist move in a hoist schedule. For simplicity of expression, the unoccupied hoist move immediately after loaded move i is called empty move i hereafter. Thus, for schedule (T, s[0], s[1], …, s[N]), the hoist first performs loaded move [0], then empty move [0], loaded move [1], …, loaded move [N] and empty move [N].When a cyclic schedule obtained offline for a production line is being executed, there are many random factors that may lead to variations in the hoist transportation times, which may cause a deadlock or defective parts due to the violation of the time windows. This can degrade seriously the performance of the production line. A robust schedule should have the ability to remain stable in the presence of perturbations or variations of certain degree in the hoist transportation times.We assume that the empty hoist travel times satisfy the commonly known triangular inequality:(1)ei,k+ek,j⩾ei,j,forall0⩽i,j,k⩽N+1,(2)di>ei,i+1,forall0⩽i⩽N.With the problem described above, our objective is to first develop a bi-objective MILP model that optimizes two criteria, i.e. the cycle time and the robustness, subject to all constraints of the problem. The developed bi-objective model will serve as a framework to minimize the cycle time for a given value of robustness, as done in this study, or maximize the robustness for a specific cycle time according to the preference of a decision-maker. To develop the model, the robustness of a hoist schedule should be first defined and measured.We define the robustness of a given cyclic hoist schedule as its ability to remain stable in the presence of perturbations or variations of certain degree in the hoist transportation times. With such a definition, the robustness of a given hoist schedule (the initial schedule) can be measured as the free slacks in the transportation times of loaded moves and empty moves within which the initial hoist schedule can still be implemented without altering its corresponding cycle time and without violating the processing time windows. As the variations in the transportation time of a loaded move or an empty move affect the stability of a hoist schedule in different ways, we analyze the two cases separately.We first consider how the variation of the traveling time of an empty move affects a given hoist schedule. Note that tanks M[i] and M[i]+1 are the origin tank and the destination tank of move [i], respectively. If the empty move [i] is delayed, it may affect the start time of its next loaded move, i.e., move [i+1]. We define free slackq¯[i]as the amount of time that empty move [i] can vary without delaying the start of move [i+1]. That is to say, as long as the time required for empty move [i] is not more thane[i]+1,[i+1]+q¯[i](i.e. with a delay not more thanq¯[i]), move [i+1] can still be started at its expected time s[i+1] and, consequently, the initial hoist schedule can still be implemented without any change. In what follows, we derive the free slackq¯[i]for a given hoist schedule (T, s[0], s[1], …, s[N]).Note that if no random event happens, then upon the completion of move [i], the hoist arrives at tank M[i+1] at time s[i]+d[i]+e[i]+1,[i+1]. To guarantee that move [i+1] can be executed at its expected time, i.e., s[i+1], the free slack for empty move [i] is s[i+1]−(s[i]+d[i]+e[i]+1,[i+1]). Hence, we have:(3)q¯[i]=s[i+1]-s[i]-d[i]-e[i]+1,[i+1],forall0⩽i⩽N-1.It is worthwhile to note that if s[i+1]=s[i]+d[i]+e[i]+1,[i+1] for some move [i], then its correspondingq¯[i]would be zero. That is, no delay is allowed for empty move [i]. In particular, after the last move in a cycle, i.e. move [N], has ended, the hoist should have sufficient time to travel back to tank M[0] (i.e. the loading station) for the execution of the first move in the next cycle. Hence, we have:(4)q¯[N]=T-(s[N]+d[N]+e[N]+1,[0]).Now, we consider how the variation of the traveling time of a loaded move affects a given hoist schedule. If the time required to perform move [i] is longer than its expected value due to random events, then the hoist would arrive at tank M[i]+1 later than its expected time. This delay may affect the processing time in tank M[i]+1 by delaying the start of the part processing in the tank. It may also affect the start time of move [i+1] by delaying the start of the empty move [i], which may further affect the actual processing time in tank M[i+1]. To handle this case, we define free slackp¯[i]as the amount of time that move [i] can vary without violating the processing time window in tank M[i]+1 and without delaying the start of move [i+1].For a given hoist schedule (T, s[0], s[1], …, s[N]), we first derive the free slack for move [i] without violating the processing time window in tank M[i]+1. If no random event happens, a part arrives at and departs from tank M[i]+1 at times s[i]+d[i] and s[i]+1, respectively. Hence, the actual processing time of the part in tank M[i]+1 is s[i]+1−(s[i]+d[i]) if move [i]+1 is executed after move [i] within a cycle; and T+s[i]+1−(s[i]+d[i]) if move [i] is executed after move [i]+1 within a cycle. Thus, to guarantee the processing time in tank M[i]+1 still be within its time window [L[i]+1,U[i]+1] when random events happen, the free slack for move [i] is s[i]+1−(s[i]+d[i])−L[i]+1 in the former case and T+s[i]+1−(s[i]+d[i])−L[i]+1 in the latter case.For a given hoist schedule (T, s[0], s[1], …, s[N]), we now derive the free slack for move [i] without delaying the start of move [i+1]. Note that if no random event happens, then upon the completion of move [i], the hoist arrives at tank M[i+1] at time s[i]+d[i]+e[i]+1,[i+1]. To guarantee that move [i+1] can be executed at its expected time s[i+1], the free slack for move [i] is s[i+1]−(s[i]+d[i]+e[i]+1,[i+1]). From the above analysis, we have:(5)p¯[i]=min(s[i]+1-s[i]-d[i]-L[i]+1,q¯[i]),ifmove[i]+1isexecutedaftermove[i],0⩽[i]⩽N-1,(6)p¯[i]=min(T+s[i]+1-s[i]-d[i]-L[i]+1,q¯[i]),ifmove[i]+1isexecutedbeforemove[i],0⩽[i]⩽N-1,(7)p¯N=q¯N.The robustness of a given hoist schedule (the initial schedule) is measured as the minimum value among the free slacks for all loaded moves and empty moves within which the initial hoist schedule can still be implemented without altering its corresponding cycle time and without violating the processing time windows. According to the definition, the robustness of a given hoist schedule, denoted by R, can be formulated as:(8)R=min0⩽i⩽N{p¯[i],q¯[i]}=min0⩽i⩽N{p¯[i]}.We note that the robustness proposed in this study is firstly a solution robustness. On the other hand, if the start times of all moves remain unchanged, the cycle time would also be the same. At this point, the proposed robustness is also a quality robustness. With the above definition, in the worst case, every loaded move, say move [i], (resp. every empty move [i]) can be delayed with up to the values ofp¯[i](resp.q¯[i]) while the initial hoist schedule can still be implemented without altering its corresponding cycle time and without violating the processing time windows. However, it should be noted that the delay in a loaded hoist move and the delay in the empty hoist move immediately following that loaded move are dependent. From the above analysis, if both loaded move [i] and empty move [i] are delayed, their delay cannot exceedp¯[i]andq¯[i], respectively. Furthermore, the sum of their delay times should not exceed the value ofq¯[i]. Otherwise, the initial hoist schedule cannot be implemented as expected.Fig. 1shows a cyclic hoist schedule for an electroplating line with four processing tanks. In Fig. 1, the horizontal axis is a timeline, and the vertical axis represents the position of tanks. Tank 0 and tank 5 are loading station and unloading station, respectively. The empty hoist travel time ei,j=ej,i=∣i−j∣/0.4s. The time windows and loaded move times for this example are given in Table 1.The hoist schedule given in Fig. 1 can be represented by (T=121s, s0=0s, s2=15.5s, s3=53.5s, s1=73s, s4=94.5s). We know that [0]=0, [1]=2, [2]=3, [3]=1 and [4]=4. That is, the hoist first performs move 0, then empty move 0, move 2, empty move 2, move 3, empty move 3, move 1, empty move 1, move 4, and finally empty move 4. Note that empty move 2 is not actually executed. That is, after releasing the part into tank 3, the hoist just waits at it for completion of the part processing.We obtain using formula (3) and (4) the free slacks for empty moves as follows:q¯0=1s,q¯1=1.5s,q¯2=21s,q¯3=2s,q¯4=1s. We can also obtain using formula (5)–(7) the free slacks for loaded moves as follows:p¯0=1s,p¯1=1.5s,p¯2=1s,p¯3=1s,p¯4=1s. We know from formula (8) that R =1s. This means that as long as the delay time in any loaded move or any empty move is not more than 1s, the initial hoist schedule can still be implemented without any change. To illustrate this point, we take move 0 as an example. If move 0 is executed as scheduled, it is completed at time instant 12s, as illustrated in Fig. 1. In this case, the actual processing of the part in M1 is (73−12)=61s. Upon completion of move 0, the hoist travels to and arrives at M2 at time instant 14.5s in order to execute move 2 starting at time instant 15.5s. Now assume that move 0 is delayed with 1s. In that case, the hoist finishes move 0 at time instant 13s. Thus, the actual processing of the part in M1 becomes (73−13)=60s, which is still within its required time window [60, 90]. Furthermore, due to this delay, the hoist will depart from M1 at time instant 13s, instead of 12s as scheduled. As a result, it will arrive at M2 at time instant 15.5s. As move 2 starts at time instant 15.5s, the initial schedule can still be implemented without any change.Let piand qibe the actually incurred delays in the execution of move i and empty move i, respectively. To build the MILP model, we also define a set of binary variables yi,j, where yi,j=1 if move j starts after move i within a cycle; otherwise, yi,j= 0, for 1⩽i<j⩽N.The problem studied in this paper can be formulated as the following MILP model, whose constraints will be explained in detail later.(9)ProblemP:MinimizeT(10)MaximizeRsubjecttoProcessing time window constraints considering robustness:(11)s1-d0⩾L1+p0,(12)s1-d0⩽U1,(13)si-si-1-di-1⩾Li+pi-1-M(1-yi-1,i),forall2⩽i⩽N,(14)si-si-1-di-1⩽Ui+M(1-yi-1,i),forall2⩽i⩽N,(15)T+si-si-1-di-1⩾Li+pi-1-Myi-1,i,forall2⩽i⩽N,(16)T+si-si-1-di-1⩽Ui+Myi-1,i,forall2⩽i⩽N.Hoist capacity constraints considering robustness:(17)s0=0,(18)si⩾d0+e1,i+q0,forall1⩽i⩽N,(19)T⩾si+di+ei+1,0+qi,forall1⩽i⩽N,(20)si+di+ei+1,j+qi⩽sj+M(1-yi,j),forall1⩽i<j⩽N,(21)sj+dj+ej+1,i+qj⩽si+Myi,j,forall1⩽i<j⩽N.Other constraints:(22)pi⩽qi,forall0⩽i⩽N,(23)R⩽pi,forall0⩽i⩽N,(24)yi,j∈{0,1},forall1⩽i<j⩽N.The processing time window constraint associated with each processing tank ensures that the actual processing time of each part in each tank must fall into its prescribed time window. The violation of the time window constraints may cause defective parts. The basic processing time window constraints without considering robustness can be formulated as (Chen et al., 1998; Liu et al., 2002; Phillips & Unger, 1976):(25)s1-d0⩾L1,(26)s1-d0⩽U1,(27)si-si-1-di-1⩾Li-M(1-yi-1,i),2⩽i⩽N,(28)si-si-1-di-1⩽Ui+M(1-yi-1,i),2⩽i⩽N,(29)T+si-si-1-di-1⩾Li-Myi-1,i,2⩽i⩽N,(30)T+si-si-1-di-1⩽Ui+Myi-1,i,2⩽i⩽N.If the execution of move i−1 is delayed, it may affect the processing time of a part in tank Mi, and consequently may violate the time window constraint, as explained in Section 3. To ensure that the time window constraint for tank Miis respected, the delay in the execution of move i-1 must satisfy:(31)p0⩽s1-d0-L1,(32)pi-1⩽si-si-1-di-1-Li,forall2⩽i⩽N,ifyi-1,i=1,(33)pi-1⩽T+si-si-1-di-1-Li,forall2⩽i⩽N,ifyi-1,i=0.Constraint (31)–(33) can be derived from (5)–(7) and the fact thatpi⩽p¯ifor all 0⩽i⩽N. From (25)–(33), we can obtain the time window constraints considering robustness (11)–(16).Without loss of generality, move 0 is assumed to be started at the beginning of a cycle. Since all the moves are executed by a single hoist, the hoist capacity constraints ensure that no conflicts exist in the use of the hoist between any pair of moves at any time. In particular, any move i, 1⩽i⩽N, cannot start until move 0 finishes. After the last move in a cycle has finished, the hoist should have sufficient time to return to the loading station M0 to start the first move of the next cycle. The basic hoist capacity constraints without considering robustness can be formulated as (Chen et al., 1998; Liu et al., 2002; Phillips & Unger, 1976):(34)s0=0,(35)si+di+ei+1,j⩽sj+M(1-yi,j),forall1⩽i<j⩽N,(36)sj+dj+ej+1,i⩽si+Myi,j,forall1⩽i<j⩽N,(37)si⩾d0+e1,i,forall1⩽i⩽N,(38)T⩾si+di+ei+1,0,forall1⩽i⩽N.If the execution of an empty move is delayed, it may affect its immediately subsequent loaded move. To guarantee that the execution of the loaded move starts at its expected time, the delay in the execution of an empty move must satisfy:(39)q0⩽si-d0-e1,i,forall1⩽i⩽N,(40)qi⩽sj-si-di-ei+1,j,forall1⩽i<j⩽N,ifyi,j=1,(41)qj⩽si-sj-dj-ej+1,i,forall1⩽i<j⩽N,ifyi,j=0,(42)qi⩽T-(si+di+ei+1,0),forall1⩽i⩽N.Constraint (39)–(41) can be derived from (1)–(3) and the fact thatq[i]⩽q¯[i], 0⩽i⩽N−1, while constraint (42) can be derived from (1), (2) and (4) and the fact thatq[N]⩽q¯[N]. With constraints (34)–(42), we can obtain the hoist capacity constraints considering robustness (17)–(21).As explained above, both the delay of a loaded hoist move and the delay of an empty hoist move may affect the hoist schedule, and these two types of delays are inter-related. Inequality (22) is derived from (5)–(7), while constraint (23) can be derived from (8) and (22). Constraint (23), together with inequality (22), means that the robustness of a hoist schedule is the minimum value among the free slacks for all the loaded moves and empty moves. In addition, formula (24) is the binary-variable constraint.Note that the robustness of a given hoist schedule is measured as the minimum value among the free slacks for all loaded moves and empty moves. We may define other measures of the robustness. For example, the robustness may be defined as the total sum of all the free slacks. In that case, it is sufficient to replace (23) withR=∑i=0N(pi+qi)and the other constraints of the model remain unchanged.As a schedule with higher robustness may lead to a longer cycle time, the two objectives of the proposed MILP model (i.e. cycle time and robustness) are conflicting. To derive the relation between them, we first define a new problem as follows:(43)ProblemP(R0):MinimizeTsubjecttoR=R0,and constraints (11)–(24). Problem P(R0) aims to minimize the cycle time for given robustness R0. Let T∗(R0) be the optimal cycle time of P(R0). With the new defined problem, we have the following Proposition 1.Proposition 1The optimal cycle time of problem P(R0) is a strictly increasing function of its robustness R0, i.e. for any two values of robustness R1and R2, if R2>R1, then T∗(R2)>T∗(R1) always holds.We first show that if R2>R1, then T∗(R2)⩾T∗(R1) always holds. For any two values of R1 and R2, if R2>R1, then constraint (23) of problem P(R2) is tighter than that of P(R1) and other constraints of the two problems remain the same. Thus, the optimal cycle time of P(R2) is not less than that of P(R1), i.e., T∗(R2)⩾T∗(R1). We now show that in this case, T∗(R2)=T∗(R1) is impossible by contradiction. Assume that T∗(R2)=T∗(R1). Let Δ=R2−R1. Suppose that (T∗(R2), s[0], s[1], …, s[N]) with robustness R2 be the optimal hoist schedule for T∗(R2). From this schedule, we construct a new hoist schedule (T∗(R2)−Δ, s[0], s[1]−Δ, …, s[N]−Δ) with robustness R2−Δ. According to the constraints of problem P(R0) and the definition of robustness, we can verify that the new hoist schedule (T∗(R2)−Δ, s[0], s[1]−Δ, …, s[N]−Δ) with robustness R2−Δ satisfy all the constraints of problem P(R1), and it is a feasible schedule with robustness R2−Δ (i.e., R1). By assumption T∗(R2)=T∗(R1), this means that we have found a feasible hoist schedule with the cycle time T∗(R1)−Δ and the robustness R1. This is in contradiction with the fact that T∗(R1) is the optimal cycle time among the hoist schedules with robustness R1. Hence, it is impossible that T∗(R2)=T∗(R1). Consequently, if R2>R1, then T∗(R2)>T∗(R1) always holds. This ends the proof. □As R is a continuous (real) variable, we have the following corollary according to Proposition 1.Corollary 1Problem P has infinite Pareto optimal solutions.With Proposition 1 and Corollary 1, a Pareto optimal solution can be obtained by solving a single-objective optimization problem to minimize the cycle time for a given value of robustness or maximize the robustness for a specific cycle time according to the preference of a decision-maker. In addition, it is important for the decision-maker to know the lower and upper bounds of the robustness and the cycle time for a given problem. In what follows, we first determine the lower and upper bounds of the robustness for a given problem.Let RLand RUare the lower and upper bounds of R, respectively. In our study, the values of RLand RUcan be obtained through an analysis of the properties of the problem as stated below. We give in Proposition 2 an upper bound of R.A theoretical upper bound of R for any feasible hoist schedule is min1⩽i⩽N(Ui−Li).Given a hoist schedule (T, s[0], s[1], …, s[N]), we first consider the case that move [i]+1 is executed after move [i] within a cycle, 0⩽[i]⩽N−1. In this case, it follows from (5) that:(44)p[i]⩽s[i]+1-s[i]-d[i]-L[i]+1,0⩽[i]⩽N-1.On the other hand, as the schedule is feasible, the time window constraints must be satisfied. Thus, we have:(45)s[i]+1-s[i]-d[i]⩽U[i]+1,0⩽[i]⩽N-1.From (44) and (45), we must have:(46)p[i]⩽U[i]+1-L[i]+1,0⩽[i]⩽N-1.Similarly, for the case that move [i]+1 is executed before move [i] within a cycle, (46) also holds. It follows from (23) and (46) that a theoretical upper bound of R for any feasible hoist schedule is min1⩽i⩽N(Ui−Li). Thus, the upper bound of R can be set as RU=min1⩽i⩽N(Ui−Li).□(RU,T*(RU)) is a Pareto optimal point in the objective space for problem P.We now derive the lower bound of R. First, let us consider the following standard non-robust cyclic hoist scheduling problem:ProblemP∗:MinimizeTsubject to (24)–(30), (34)–(38).Let (T∗,s[0]∗,s[1]∗, …,s[N]∗) be an optimal schedule to problem P∗. Let R∗ be the value of its robustness. We have the followingProposition 3.For the optimal hoist schedule (T∗,s[0]∗,s[1]∗, …,s[N]∗) of problem P∗without considering robustness, we have R∗=0.First, it is clear that R∗⩾ 0. Below, we demonstrate by contradiction that R∗>0 is impossible. Assume that R∗>0. Similarly to the proof of Proposition 1, we can obtain a new schedule (T∗-R∗,s[0]∗,s[1]∗-R∗, …,s[N]∗-R∗). According to the constraints of problem P∗ and the definition of robustness, we know that the schedule (T∗-R∗,s[0]∗,s[1]∗-R∗, …,s[N]∗-R∗) satisfies all constraints of P∗. This means that we have found a feasible schedule for problem P∗ with its cycle time T∗−R∗<T∗, which is in contradiction with the fact that T∗ is the optimal cycle time of problem P∗. Hence, the robustness of the optimal solution obtained from problem P∗ without considering robustness must be zero, which also implies that a lower bound of the robustness is zero. This ends the proof.□(0, T∗) is a Pareto optimal point in the objective space for problem P.As mentioned above, a decision-maker may also want to maximize the robustness for a specific cycle time. In this case, the decision-maker should also know the lower and upper bounds of the cycle times of Pareto front for the given problem, which can be determined by the following proposition.It is sufficient to restrict the values of the cycle time within the interval [T∗, T∗(RU)] in order to obtain the Pareto front of problem P.First, it is clear that the lower bound on the cycle time is T∗ since it is the minimum cycle time of the single-objective optimization problem P∗. Note that T∗(RU) is the minimum cycle time corresponding to robustness RU. As RUis the theoretical upper bound of the robustness, any schedule whose cycle time is greater than T∗(RU) must be dominated by any solution corresponding to (T∗(RU), RU). Thus, to obtain the Pareto front, it is unnecessary to consider the values of the cycle time greater than T∗(RU). This ends the proof.□Now we can define the so-called ideal point and nadir point in the objective space, which define the lower and upper bounds for the objective function values of Pareto front. The ideal point (objective vector) is composed of the optimal values of all objective functions when a single objective is optimized. The nadir point (objective vector) represents the upper bound of each objective function to be minimized or the lower bound of each objective to be maximized in the Pareto front (not in the entire solution space). In other words, a nadir point and an ideal point together define upper and lower bounds on the objective function values of Pareto front (Branke, Deb, Miettinen, & Slowinski, 2008).According to the above analysis, the ideal point and the nadir point of problem P are (RU, T∗) and (0,T*(RU)), respectively, which are shown in Fig. 2. In this figure, the region above the solid line is the feasible objective space. With Proposition 4, the Pareto front is located in the solid region of Fig. 2.Proposition 5Problem P(R0) can be transformed into the standard non-robust cyclic hoist scheduling problem (i.e., problem P∗) with new loaded move timesdi′=di+R0and new upper bounds for time windowsUi′=Ui-R0.It is easy to demonstrate that there is an optimal solution for problem P(R0) such that pi=qi=R0 for all i=0,1, …, N. Therefore, we can substitute all pi’s and qi’s with R0 throughout the model. After this substitution, we can replace all di+R0 in constraints (11), (13), (15), and (18)–(21) withdi′. Note that these constraints withdi′are equivalent to constraints (25), (27), (29), and (35)–(38) with new loaded move timesdi′of the standard non-robust cyclic hoist scheduling problem.We now consider constraints (12), (14) and (16). Take constraint (14) for example, it is equivalent to the following inequality:(47)si-si-1-(di-1+R0)⩽Ui-R0+M(1-yi-1,i),forall2⩽i⩽N.By substituting di−1+R0 and Ui−R0 in constraint (47) withdi-1′andUi′, respectively, we find constraint (14) is equivalent to constraint (28) with new loaded move timesdi′and new upper boundsUi′of the standard non-robust cyclic hoist scheduling problem. Similarly, we can show that constraints (12) and (16) are equivalent to constraint (26) and (30) respectively with new loaded move timesdi′and new upper boundsUi′of the standard non-robust cyclic hoist scheduling problem. After the above transformation, problem P(R0) is equivalent to the standard non-robust cyclic hoist scheduling problem that minimizes the cycle time T subject to (24)–(30) and (34)–(38) with new loaded move timesdi′and new upper boundsUi′. This ends the proof.□With Proposition 5, problem P(R0), which aims to minimize the cycle time for given robustness R0, can be solved by various approaches for the standard non-robust cyclic hoist scheduling problem in the literature, such as Chen et al. (1998), Liu et al. (2002). However, the proposed bi-objective MILP model is still valuable for the following reasons. Firstly, in some circumstance, a decision-maker may want to maximize the robustness for a specific cycle time. In that case, the proposed bi-objective MILP model can be reduced to a single-objective MILP model that maximizes the robustness for a given cycle time. Secondly, as mentioned above, the robustness may be defined as the sum of all the free slacksp¯[i]andq¯[i], 0⩽i⩽N, in some cases. In those cases, the corresponding problem cannot be transformed into the standard non-robust cyclic hoist scheduling problem. However, with the proposed bi-objective MILP model, we can use the ε–constraint method (Kirlik & Sayın, 2014; Zhang & Reimann, 2014) to obtain the Pareto front of the problem.In this section, we solved six well-known benchmark instances as well as randomly generated instances to validate the effectiveness of the proposed approach. The model formulation was implemented using C++ and CPLEX (Version 12.5). The MILP model was solved using the MILP solver of CPLEX (Version 12.5). The computation was done on a HP PC with a Processor 3.1 GHZ. For each problem, we ran the MILP solver until it obtains the optimal solution.The six benchmark instances are called Phillips, Ligne1, Ligne2, Bo1, Bo2 and Mini. Their data can be found in Phillips and Unger (1976), Manier and Lamrous (2008) and Leung et al. (2004). Table 2gives the computational results for the benchmark instances. We see from Table 2 that the theoretical upper bound of R ranges from 10 to 60 for these benchmark instances. Note that this is a theoretical upper bound of R. In industrial applications, production managers can usually obtain the historically incurred maximum value of variations in the hoist travel times from the past operation data. Hence, the actual upper bound of R is usually determined based on theoretical upper bound of R and the past operation data. In our experiments, we set this actual upper bound of R as 10. We solved problem P(R) continually for R=0, 1, …, 10 and obtained 11 Pareto optimal solutions for each instance. With Proposition 5, problem P(R) is solved by the resolution of the corresponding standard non-robust cyclic hoist scheduling problem (i.e., problem P∗) withdi′=di+RandUi′=Ui-R.As we can see from Table 2, the cycle times increase when the robustness R increases due to the strictly increasing relationship between cycle time and robustness. Table 3shows the computational times for the instances, and indicates that these benchmark instances can be solved in very short time.We now examine how the cycle time varies when the robustness changes. For this purpose, we uniformly divide the robustness interval [0, 10] with 1000 points with a step of 0.01 between two successive points. We then solve a set of problems P(R) for R=0, 0.01, 0.02, …, 10 and obtain 1001 Pareto optimal solutions. The Pareto optimal points in the objective space for these Pareto optimal solutions are plotted in Fig. 3, which provides a visual illustration of partial Pareto Fronts for the six benchmark instances.It is interesting to see from Fig. 3 that the optimal cycle time T is a piecewise linear increasing function of the robustness R. That is, the optimal cycle time increases linearly with the robustness in some interval. However, it increases discontinuously at some special points. We explain this phenomenon as follows.To simplify the discussion, we analyze how the cycle time varies when the robustness increases from R=0 to R=δ, where δ is an arbitrarily small positive number. As mentioned above, the hoist schedule (T∗,s[0]∗,s[1]∗, …,s[N]∗), whose robustness is zero, is the optimal schedule to problem P∗ without considering robustness. Lett[1]∗,t[2]∗, …,t[N]∗be its corresponding actual processing times in tanks M[1], M[2], …, M[N], respectively.Let us now consider the cyclic hoist scheduling problem with fixed processing times (t[1]∗,t[2]∗, …,t[N]∗). According to Levner, Kats, and Levit (1997), such a problem can be formulated as the following set of prohibited intervals of the cycle time:MinimizeTsubjecttoT∉Q=-∞,β∪⋃j=0N-1⋃i=j+1N⋃k=1NZi-Zj-dj-ej+1,ik,Zi-Zj+di+ei+1,jk,whereβ=max1⩽i⩽N(ti∗+di+ei+1,i-1+di-1),Zi=∑j=1i(dj-1+tj∗), 1⩽i⩽N.According to Levner et al. (1997),Qis a union of open prohibited intervals that may intersect with each other. Levner et al. (1997) proved that the optimal cycle time for this problem is necessarily one of the upper bounds of prohibited intervals inQ. This means that the optimal cycle time T∗∈{β}∪{(Zi−Zj+di+ei+1,j)/k, 0⩽j⩽N−1,j+1⩽i⩽N, 1⩽k⩽N}. Note thatβ=max1⩽i⩽N(ti∗+di+ei+1,i-1+di-1)=max1⩽i⩽N(Zi-Zi-1+di+ei+1,i-1). Thus, we have T∗∈{(Zi−Zj+di+ei+1,j)/k, 0⩽j⩽N−1, j+1⩽i⩽N, 1⩽k⩽N}.Without loss of generality, we assumeT∗=(Zi∗-Zj∗+di∗+ei∗+1,j∗)/k∗for some i∗,j∗ and k∗, which is called optimal upper bound hereafter. Note that the robustness for (T∗,s[0]∗,s[1]∗, …,s[N]∗) is zero. We now analyze how the optimal cycle time changes if the robustness increases from R=0 to R=δ. Two cases are possible:(1)The optimal upper bound for R=0 is still the optimal upper bound for R=δ. This implies thatt[1]∗,t[2]∗, …,t[N]∗are still the optimal processing times in tanks M[1], M[2], …, M[N] for R=δ. Consequently, the new optimal cycle time can be represented byTδ=(Zi∗-Zj∗+di∗+ei∗+1,j∗)/k∗+(i∗-j∗+1)δ/k∗. As a result, the increase in the optimal cycle time, i.e. (i∗−j∗+1)δ/k∗, is a linear function of δ.The optimal upper bound for R=0 is no longer the optimal upper bound for R=δ. In this case, the former is covered by some prohibited intervals and becomes infeasible when the robustness increases from R=0 to R=δ. As a result,t[1]∗,t[2]∗, …,t[N]∗are not necessarily the optimal processing times in tanks M[1], M[2], …, M[N] for R=δ. In this case, the optimal cycle time may suffer from a discontinuous increase when the robustness increases from R=0 to R=δ.In addition, three sets of randomly generated instances were used to further test the proposed approach. The instances were generated using integer uniform distributions. In the following, let U(a, b) denote a uniform distribution with lower bound a and upper bound b. The parameters used to generate the first set of random instances are:Li=40+U(0,140),Ui=[1.5Li],ei,i+1=1+U(0,4),ei,j=ej,i=∑k=ij-1ek,k+1,di=ei,i+1+12,0⩽i⩽N,N∈{12,14,16,18,20,22}, where [x] represents the nearest integer of x. The parameters of the second and third sets of instances are the same as the first set except the upper bounds of time windows are Ui=2Liand Ui=[2.5Li], respectively. The three sets of instances represent the time windows with different widths. For each given value of N, ten instances were generated according to the generation method of parameters given above.For the randomly generated instances, we also set the actual upper bound of R as 10. We solved a set of problems P(R) successively for R=0, 1, …, 10 and obtained 11 Pareto optimal solutions for each randomly generated instance. The computational results are listed in Table 4. In Table 4, the rows for R=0 give the average cycle time of ten instances for each pair of parameters (N, R), while the rows for 1⩽R⩽10 list the average increasing ratio of the cycle time for 1⩽R⩽10 with respect to its corresponding cycle time for R=0.We see from Table 4 that for each set of instances, the average cycle time increases with robustness R due to the fact the optimal cycle time is a strictly increasing function of the robustness. Furthermore, after a comparison of average increasing ratio of the cycle time of instance set 2 (resp. set 3) with set 1 (resp. set 2), we see that as the time windows become wider, the average increasing ratio of the cycle time generally shows a decreasing trend. That is, the wider the time windows, generally the smaller the average increasing ratio of the cycle time. This suggests that when time windows are wide, the impact on the cycle time resulting from the increase in the robustness is relatively small. This observation can be explained as follows. When the time windows are wide, a smaller increase in the cycle time can be expected by exploring the greater flexibility resulting from the time windows when the robustness R increases. Thus, it provides a greater possibility for achieving a smaller average increasing ratio of the cycle time.The computation times for the randomly generated instances are given in Table 5. The results in this table suggest that the average computation time of an instance has an obvious increasing trend as the number of its tanks (i.e. N) increases. Furthermore, for each pair of (N, R), the average computation time of the instances in each set has an obvious increasing trend as the time windows become wider. However, it seems that there exists no obvious relationship between the computation time and the robustness R. We also see from Table 5 that even for the problem with 22 tanks, the proposed approach can find the optimal cycle time for any given R within one hour.

@&#CONCLUSIONS@&#
