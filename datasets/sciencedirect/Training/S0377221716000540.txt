@&#MAIN-TITLE@&#
A heuristic algorithm for container loading of pallets with infill boxes

@&#HIGHLIGHTS@&#
The algorithm is suitable for container loading of pallets with infill boxes.The algorithm satisfies the single support constraint on pallets.The algorithm achieves competitive results for BR1–BR15.

@&#KEYPHRASES@&#
Packing,Container loading,Heuristic algorithm,Tree search,Greedy algorithm,

@&#ABSTRACT@&#
We consider the container loading problem that occurs at many furniture factories where product boxes are arranged on product pallets and the product pallets are arranged in a container for shipments. The volume of products in the container should be maximized, and the bottom of each pallet must be fully supported by the container floor or by the top of a single pallet to simplify the unloading process. To improve the filling rate of the container, the narrow spaces at the tops and sides of the pallets in the container should be filled with product boxes. However, it must be ensured that all of the infill product boxes can be entirely palletized into complete pallets after being shipped to the destination. To solve this problem, we propose a heuristic algorithm consisting of a tree search sub-algorithm and a greedy sub-algorithm. The tree search sub-algorithm is employed to arrange the pallets in the container. Then, the greedy sub-algorithm is applied to fill the narrow spaces with product boxes. The computational results on BR1–BR15 show that our algorithm is competitive.

@&#INTRODUCTION@&#
Cutting and packing (Dyckhoff & Finke, 1992; Wäscher, Haußner, & Schumann, 2007) are two classic combinatorial optimization problems. Cutting problems address the best possible utilization of materials, such as wood, steel and cloth, whereas packing problems address the best possible capacity use of packing space. The effective use of material and transport capacities is of great economic importance in production and distribution processes. It also contributes to the economical utilization of natural resources.According to Wäscher et al. (2007), cutting and packing problems have an identical structure in common. They can be summarized as follows:First, a set of large objects and a set of small items are given. The large objects and the small items are defined exhaustively in one, two, three or an even larger number of geometric dimensions. Select some or all of the small items, group them into one or more subsets and assign each of the resulting subsets to one of the large objects such that the geometric condition holds, i.e.•all small items of the subset lie entirely within the large object, andthe small items do not overlap,Container loading problems are sub-problems of the cutting and packing problems. In Bortfeldt and Wäscher (2013), container loading problems are interpreted as geometric assignment problems, in which three-dimensional small items (called cargo) have to be assigned (packed into) to three-dimensional, rectangular (cubic) large objects (called containers) such that a given objective function is optimized and two basic geometric feasibility conditions hold, i.e.•all small items lie entirely within the container, andthe small items do not overlap.In this paper, we consider a container loading problem for pallets with infill boxes (CLPIB), which is a special container loading problem case. Given an empty rectangular container and m rectangular product pallets, we determine a subset of pallets with maximal volume that can be placed in the container. Each product pallet contains a single type of rectangular product boxes. Some product pallets can be divided into product boxes for transportation. The product boxes can be placed in the narrow spaces between the pallets and the container after a container is filled with pallets. After the container is shipped to its destination, these product boxes should be exactly palletized onto their original pallets. The pallets must be placed with their bottoms parallel to the container, whereas the product boxes can be placed in all six orthogonal orientations. Additionally, the bottoms of each pallet must be fully supported by the container floor or by the top of a single pallet to simplify the unloading process and to ensure the stability of the pallets. The product boxes can be easily fastened on the pallets by adhesive tapes because they are relatively small and light. Thus they do not need to be fully supported.Fig. 1lists four pallet arrangements in a container. The arrangements in Fig. 1(a) and (b) are feasible, whereas the arrangements in Fig. 1(c) and (d) are not feasible.An example solution for CLPIB is illustrated in Fig. 2.The rest of this paper is divided as follows: Section 2 provides an overview of the literature, Section 3 presents the approach for CLPIB, Section 4 describes the computational experiments and presents the results, and Section 5 summarizes the paper.Bortfeldt and Wäscher (2013) introduced a scheme to categorize the constraints of loading a container for the first time and found that the existing approaches have limited practical value because they do not pay sufficient attention to the constraints encountered in practice. The problem discussed in this paper is a knapsack container loading problem with several practical constraints (listed in the Section 1). There are no published approaches that address the container loading problem with these practical constraints. Because it is a knapsack container loading problem, we will briefly discuss some of the recent advances in three-dimensional container loading.The three-dimensional container loading problem (3D-CLP) can be broadly characterized as type 3/B/O/-, according to the typology presented by Dyckhoff and Finke (1992), or type 3D-R-IIPP/SLOPP/SKP, according to the typology presented by Wäscher et al. (2007). A consignment of goods wrapped up in boxes is assumed to be loaded into a single container of known dimensions, and the boxes and containers are assumed to have a rectangular shape (Junqueira, Morabito, & Sato Yamashita, 2012).3D-CLP is a typical NP-hard problem (Bischoff & Marriott, 1990) that cannot be solved optimally by an algorithm in polynomial time. When the number of box types increases, exact algorithms are usually confronted with a situation called “combinatorial explosion”. Thus, they can only solve problems with a weak heterogeneous box set. As a result, heuristic methods are usually the first selection for addressing the three-dimensional container loading problem. Heuristic methods may not obtain the best of all of the actual solutions to 3D-CLP, but they can usually produce sufficiently good solutions within acceptable times. Researchers have provided various heuristic methods.Heuristic methods for 3D-CLP can be divided into two groups according to the method type.(1)Tree search methods: Tree search or graph search methods were successfully utilized in 3D-CLP. Morabito and Arenales (1994) suggested an And/Or graph search method. Eley (2002) tried to fill the container with homogeneous blocks made up of identical items. Hifi (2002) presented a tree search method using hill-climbing strategies. Pisinger (2002) proposed an algorithm that first divides the whole container space into several vertical layers, then divides the layers into a number of horizontal or vertical strips and then generates the strips by solving the one-dimensional knapsack problem. Bortfeldt and Mack (2007) presented a heuristic algorithm that was derived from a branch-and-bound approach. Fanslau and Bortfeldt (2010) proposed an effective tree search algorithm based on the idea of a composite block. Zhang, Peng, and Leung (2012) designed a heuristic block-loading algorithm based on a multi-layer search. Liu, Tan, Xu, and Liu (2014) presented a heuristic wall-building algorithm. Araya and Riff (2014) proposed a beam search approach to the container loading problem.Non-tree search methods: Non-tree search methods include classic heuristic methods and intelligent heuristic methods. The former methods for solving 3D-CLP were presented by Bischoff and Ratcliff (1995), Bischoff, Janetz, and Ratcliff (1995), and Lim, Rodrigues, and Wang (2003), whereas the latter methods have been the most used method types for 3D-CLP in recent years. Gehring and Bortfeldt (1997, 2002), Hemminki (1994), and Bortfeldt and Gehring (2001) utilized genetic algorithms (GAs). Sixt (1996) and Mack, Bortfeldt, and Gehring (2004) provided simulated annealing methods (SAs). Bortfeldt and Gehring (1998), Sixt (1996), and Bortfeldt, Gehring, and Mack (2003) suggested tabu search algorithms (TSs). Faroe, Pisinger, and Zachariasen (2003) and Mack et al. (2004) suggested local search methods. Moura and Oliveira (2005) and Parreno, Alvarez-Valdes, Oliveira, and Tamarit (2007) introduced a greedy randomized adaptive search procedure (GRASP).In addition to classification according to method type, Pisinger (2002) grouped the methods into five classes according to the packing approaches: the wall building approach (suggested by Bortfeldt & Gehring, 2001; George & Robinson, 1980; Pisinger, 2002); the block building approach (representatives of this approach are the TS methods from Bortfeldt et al., 2003; the tree search methods from Eley, 2002; Fanslau & Bortfeldt, 2010; Zhang et al., 2012; Zhu & Lim, 2012; and the SA/TS hybrid methods from Mack et al., 2004); the horizontal layer building approach (realized by Bischoff et al., 1995; Terno, Scheithauer, Sommerweiß, & Rieme, 2000); the stack building approach (presented by Bischoff & Ratcliff, 1995; Gehring & Bortfeldt, 1997); and the guillotine cutting approach (mixed with the graph search method by Morabito and Arenales (1996)). Otherwise, Huang and He (2009) and He and Huang (2011) proposed heuristic algorithms based on the idea of caving degree. Lu and Cha (2014) proposed an algorithm on how to pack small items onto a large rectangular pallet. Zhu, Huang, and Lim (2012) proposed a prototype column generation strategy for the multiple container loading problem. Wei, Zhu, and Lim (2015) presented a goal-driven prototype column generation strategy for the multiple container loading cost minimization problem. Tian, Zhu, Lim, and Wei (2016) developed a two-phase algorithm to solve the multiple container loading problem with preference.The great majority of methods mentioned above obey the orientation constraint and the support constraint as well. Several mentioned methods also include additional constraints from the packing context in the problem, e.g., a weight constraint for the freight (Bortfeldt & Gehring, 2001; Terno et al., 2000; Lim, Ma, Qiu, & Zhu, 2013). The shipment priority constraint was considered by Ren, Tian, and Sawaragi (2011) and Wang, Lim, and Zhu (2013).The remarkable paper by Egeblad, Garavelli, Lisi, and Pisinger (2010) is one case study of and an application related to practical container loading problems. It represents the type of publications that are concerned with the systematic integration of several types of constraints into solution approaches. The cargoes that will be loaded consist of a mixture of regular and irregular items that require satisfying specific stacking and orientation constraints.In practical applications, the pallets must be placed with their bottoms parallel to the bottom of the container. To compare our method with existing algorithms, we assume that the pallets may have at most six admissible orthogonal orientations. It is easy to adjust the orientation constraints to fit practical applications.As shown in Fig. 3, a container is placed in the first octant of a 3D coordinates system (3D-CS). Let(1)C=(L,W,H)denote a container. Symbols L, W and H denote the container length, width and height, respectively.Let(2)P={p1,p2,…,pm}be the product pallet set that contains m pallets. piis the ith pallet in P that is defined as(3)pi=(li,wi,hi,αi,βi,γi,di,bli,bwi,bhi)where li, wiand hiare the length, width and height of pi, respectively. The implications of αi, βi, γiand diare listed:αi={1,ifpicanbeplacedwithliparalledtoH0,otherwise,βi={1,ifpicanbeplacedwithwiparalledtoH0,otherwise,γi={1,ifpicanbeplacedwithhiparalledtoH0,otherwise,anddi={1,ifpicanbedividedintoproductboxes0,otherwise.The symbols bli, bwiand bhiare the length, width and height of each product box in pi, respectively.As described in Section 1, CLPIB consists of two sequential sub-problems that regard how to load the product pallets into the container and how to fill the narrow spaces between the product pallets and the container with product boxes, respectively. The first sub-problem can be written as:(4)max{ZQ=∑i=1mqiliwihi|qi∈{0,1}i=1,2,…,m}qi={1,ifpiisplacedasawholeinthecontainer0,otherwisewhereas the second sub-problem can be expressed as:(5)max{ZR=∑i=1mriliwihi|ri∈{0,1}ri≤1−qi,di=1i=1,2,…,m}qi={1,ifpiisplacedasproductboxesinthecontainer0,otherwiseIn both Formulas (4) and (5), two basic geometric constraints must be satisfied:•all small items lie entirely within the container, andthe small items do not overlap.A feasible solution for CLPIB is denoted as(Q={q1,q2,…,qm},R={r1,r2,…,rm}).We design a heuristic algorithm for CLPIB which is referred to as HCLPIB. HCLPIB consists of a tree search sub-algorithm that solves the sub-problem defined in Formula (4) and a greedy sub-algorithm that solve the sub-problem defined in Formula (5). The tree search sub-algorithm is referred to as QTS (Quaternary Tree Search), whereas the greedy sub-algorithm is referred to as GIB (Greedy Algorithm for Infill Boxes). QTS and GIB will be described in detail in Sections 3.1 and 3.2, respectively.QTS places multiple pallets into the container by using the wall building strategy. Thus, the obtained container loading plan consists of a set of pallet layers, and each pallet layer consists of a set of pallet strips. The pallets in a strip are stacked along a line parallel to the z-axis in 3D-CS. The strips in a layer are arranged along a line that is parallel to the x-axis or y axis in 3D-CS. If the strips in a layer are along a line parallel to the x-axis, the layer is called the x-layer. Otherwise the layer is called the y-layer. The surfaces of each pallet must be parallel to one of the three planes: xy, xz and yz in 3D-CS. An example solution for QTS is shown in Fig. 4.Let ls and ws be the length and width (generallyls ≥ ws) of a pallet strip s (see Fig. 5(a)). The filling rate of s is defined as:(6)FRS(s)=∑i=1mliwihiqi/(ls*ws*H)qi={1,ifpiisplacedins0,otherwise,i=1,2,…,mLet ll and thickl denote the length and width of layer l, respectively.Let(7)R=(lr,wr,H)denote the rectangular residual space of a container. The symbols lr, wr and H are its length, width and height, respectively. If a residual space is not completely rectangular, we consider the length, width and height of the maximum cuboid inside it as its length, width and height, respectively. When no layers are placed in the container,R=(L,W,H). When an x-layer, which is shown in Fig. 5(b), is placed in an empty container,R=(L,W−thickl,H). When a y-layer, which is shown in Fig. 5(c), is placed in an empty container,R=(L−thickl,W,H).If l is the x-layer, which is shown in Fig. 5(b), and l is placed in the residual space (lr, wr, H), the filling rate of l is defined as:(8)FRL(l)=∑i=1mliwihiqi/(lr*thickl*H)qi={1,ifpiisplacedinl0,otherwise,i=1,2,…,mIf l is the y-layer, which is shown in Fig. 5(c), and l is placed in the residual space (lr, wr, H), the filling rate of l is defined as:(9)FRL(l)=∑i=1mliwihiqi/(wr*thickl*H)qi={1,ifpiisplacedinl0,otherwise,i=1,2,…,mLet(10)S={s1,s2,…,sn}be a strip sequence, which contains n strips.The length and width of a strip are determined before the strip is created. Length ls and width ws are always equal to two dimensions of the length, width and height of one pallet in P, respectively. To explain how to create strips one by one using P, we introduce several definitions.(11.1)Hαi(ls,ws)={li,if(max{wi,hi}≤ls,min{wi,hi}≤ws,andαi=1)+∞,otherwiseEq. (11.1) means the height of the envelope cuboid of piin a strip with length ls and width ws if the length of piis parallel to the z-axis.(11.2)Hβi(ls,ws)={wi,if(max{li,hi}≤ls,min{li,hi}≤ws,andβi=1)+∞,otherwiseEq. (11.2) means the height of the envelope cuboid of piin a strip with the length ls and width ws if the width of piis parallel to the z-axis.(11.3)Hγi(ls,ws)={hi,if(max{li,wi}≤ls,min{li,wi}≤ws,andγi=1)+∞,otherwiseEq. (11.3) means the height of the envelope cuboid of piin a strip with the length ls and width ws if the height of piis parallel to the z-axis. The value+∞in Formulas (11.1)–(11.3) means that the corresponding orientations are prohibited or that the pallet exceeds the boundary of the envelope cuboid of the strip.Therefore, it is obvious that(12)Hi(ls,ws)=min{Hαi(ls,ws),Hβi(ls,ws),Hγi(ls,ws)}is the height of the envelope cuboid of piin a strip with length ls and width ws.Let(13)KSstrip(H,ls,ws)=max{∑i=1mliwihiqi|Q={q1,q2,…,qm}isafeasiblesolution,qi∈{0,1},∑i=1mqi*Hi(ls,ws)≤H,i=1,2,…,m}denote a one-dimensional knapsack model to generate a strip with length ls and width ws, where qimeans that piis placed in the strip (qi=1) or is not placed in the strip (qi=0).When we group a pallet set into a strip sequence S, we utilize two of the three sizes (length, width and height) of each pallet as the length and width to create a strip. Thus, we obtain a candidate strip sequence S_CAN. Then, we select a strip from S_CAN and insert it into S. If we select the first (or the last or the middle) strip with a filling rate higher than a given value (called strip filling rate threshold, sfrt for short, usually in [0.9, 1]) from S_CAN, we can usually obtain a better solution than by selecting the strip with the highest filling rate. The three strip selecting types (sst for short) are defined as “FIRST”, “LAST” and “MID”. Therefore, we define the function:(14)SelectStrip≥sfrtsst(S_CAN)If sst=“FIRST”, Formula (14) returns the first strip whose filling rate is not less than sfrt in S_CAN. If sst=“LAST”, Formula (14) returns the last strip whose filling rate is not less than sfrt in S_CAN. If sst=“MID”, Formula (14) returns the middlemost strip whose filling rate is not less than sfrt in S_CAN. If no strip exists in S_CAN whose filling rate is not less than sfrt, Formula (14) returns the strip with the highest filling rate in S_CAN.If we create a layer from a strip sequence S, the thickness of a layer is always equal to the length or width of one strip in S. To explain how to create a layer using the strips in S, several definitions are presented.(15)L(si,thickl)={lsi,if(lsi>thicklandwsi≤thickl)wsi,if(lsi≤thicklandwsi≤thickl)+∞otherwise}means the length of the envelope cuboid of the strip siin a layer with thickness thickl. The strip must be placed such that it does not exceed the boundary of the layer. The value+∞means that sicannot be placed in a layer with thickness thickl.Let(16)KSlayer(H,ll,thickl)=max{∑i=1nVi|Q={q1,q2,…,qn}isafeasiblesolution,qi∈{0,1},∑i=1nqi*L(si,thickl)≤ll,i=1,2,…,n}denote a one-dimensional knapsack model to generate a layer with length ll and thickness thickl. Herein, Viis the total volume of the pallets in the strip siand qiindicates whether siis included in the layer (0 not included; 1 included).The mathematical model(17)LAYERx(lr,S)={KSlayer(H,lr,lsi),KSlayer(H,lr,wsi)|i=1,2,…,n}creates a set of candidate x-layers whose lengths equal to the length of the current residual space. lr is the length of the current residual space.The mathematical model(18)LAYERy(wr,S)={KSlayer(H,wr,lsi),KSlayer(H,wr,wsi)|i=1,2,…,n}creates a set of candidate y-layers whose lengths equal to the width of the current residual space. wr is the width of the current residual space.The mathematical model(19)L2=SORT(L1)={l21,l22,l23,…}sorts the layers in the layer set L1 and obtains a layer sequence L2 such that FRL(l21) ≥ FRL(l22) ≥ FRL(l23) ≥ ⋅⋅⋅.QTS loads pallets into a container with two different priority styles. For the first style, QTS loads undividable and dividable pallets with the same priority. For the second style, QTS loads undividable pallets prior to the dividable pallets. We call the first style “SAME_PRIORITY” and the second style “DIFFERENT_PRIORITY”.The main procedure for QTS is described in Procedure 1. L, W, H, P, and prior_style represent the length, width, and height of the container, the pallet set, and the priority style, respectively. We find that we can keep a good balance between the solution quality and the computation time if we use SFRT = {0.9,0.904,0.908,0.912,…,1} as the sfrt value set. We consider all three sst values, which are “FIRST”, “LAST” and “MID” in QTS. The invoked procedure FillCuboidSpace is described in Procedure 2.As shown in Procedure 2, FillCuboidSpace is invoked recursively to create and place new layers into the residual space of the container. The symbols lr, wr and H are the length, width and height of the residual space. The symbols P, sst, sfrt, and prior_style are the pallet set, strip selecting type, strip filling rate threshold, and the priority style, respectively. If the residual space (lr×wr×H) cannot accommodate any pallet in P, Procedure 2 returns an empty layer set. Otherwise, an x-layer sequence and a y-layer sequence are created using CreateCandidateLayers (described in Procedure 3), respectively. The first x-layer and the first y-layer will be placed in the container. If the filling rate of the second x-layer is no less than the filling rate of the first y-layer, the second x-layer is considered. If the filling rate of the second y-layer is no less than the filling rate of the first x-layer, the second y-layer is considered. In the end, Procedure 2 returns the layer set with the maximum pallet volume or with the maximum undividable pallet volume.CreateCandidateLayers (Procedure 3) creates a sequence of candidate layers that can be placed in the corresponding residual space. The symbols ll, max_thickl and H are the length, the upper bound of the thickness and the height of the layers. The symbols P, sst and sfrt are the pallet set, strip selecting type and strip filling rate threshold, respectively. The symbol layer_type indicates that x-layers or y-layers will be created. First, a strip sequence S_D is created by circularly invoking CreateCandidateStrips (Procedure 4) andSelectStrip≥sfrtsst()(Formula (14)). With ll and S_D as the parameters, a layer set L_SET is created by invoking LAYERx() (Formula (17)) or LAYERy() (Formula (18)). By arranging the layers in L_SET, a layer sequence L_SEQ is obtained. L_SEQ is the solution for CreateCandidateLayers (Procedure 3).Procedure 4 describes how to create a sequence of candidate strips from a pallet set P. The symbols lr, wr, and H are the length, width and height of the residual space where the candidate strips will be placed. P is the pallet set. With the dimensions of the three different surfaces of each pallet in P as the lengths and widths, we create three strips by invoking KSstrip() (Formula (13)). All of these strips form a strip sequence S. S is the solution for CreateCandidateStrips (Procedure 4).After a container is filled with pallets, narrow spaces often exist at the tops and sides of the pallets in the container. To improve the filling rate, some of the remaining pallets are divided into product boxes and are placed in these narrow spaces. After the container is shipped to its destination, these product boxes will be palletized onto their original pallets.To fill the narrow spaces with product boxes, we divide all of the narrow spaces in the container into multiple cuboid spaces. As shown in Fig. 6, there is only one cuboid space on the top of each good strip and one cuboid space between the right side (or back side) of each good layer and the right side (or back side) of the container. Additionally, the back right corner contains one cuboid space.Procedure 5describes how GIB fills the gaps with product boxes in a loaded container. P is a set of dividable pallets. C_SPACE is a set of cuboid residual spaces (to denote the narrow spaces in the container). GIB tries to divide each pallet and insert the obtained product boxes into the residual spaces. The algorithm for packing identical small items into a large empty box (characterized as the Identical Item Packing Problem, IIPP, by Wäscher et al., 2007 and implemented by George, 1992) is employed to insert the product boxes into an individual residual space. Typically, more than one pallet can be divided and completely inserted into the residual spaces. Only the pallet with the highest volume will be divided to fill the residual spaces. We repeat the process until there are no pallets that can be divided and placed in the residual spaces.HCLPIB was implemented in C# and run on an Intel Q9400 @2.66 gigahertz with Microsoft Windows XP Professional. The compiling environment was Microsoft Visual Studio 2005.First, we test QTS using the cases in BR1–BR15. Then, we test HCLPIB using the cases that are generated from the cases in BR1–BR15.Many algorithms for solving 3D-CLP have been published in recent years. H_BR (Bischoff & Ratcliff, 1995), GA_GB (Gehring & Bortfeldt, 1997), PT_SA (Bortfeldt et al., 2003), CLTRS (Fanslau & Bortfeldt, 2010), ID-GLTS (Zhu & Lim, 2012), HBMLS (Zhang et al., 2012) and HBTS (Liu et al., 2014) meet the orientation constraint and the full support constraint, whereas GRASP (Moura & Oliveira, 2005), MSA (Parreno et al., 2007), A2 (Huang & He, 2009), VNS (Parreno, Alvarez-Valdes, Oliveira, & Tamarit, 2010) and FDA (He & Huang, 2011) obey the orientation constraint only. To our knowledge, CBGAT by Gehring and Bortfeldt (1997) and HBTS by Liu et al. (2014) may satisfy the support constraint and the orientation constraint in this paper. We used the same data cases as the ones utilized by CBGAT and HBTS. To compare QTS with CBGAT and HBTS, we obeyed the orientation constraints defined for the boxes in BR1–BR15. Thus, there are at most six admissible orientations for one box.Table 1reports the computational results of CBGAT, HBTS and QTS for BR1–BR15 (CBGAT was only tested with BR1–BR7). QTS outperforms the other two algorithms for all of the test data. The computation time of QTS increases when the number of box types increases. The computation time of QTS for each case is acceptable, with the longest one requiring less than 30 minutes.We briefly give the results of several famous algorithms. The mean filling rates for BR1–BR15 by CLTRS, ID-GLTS and HBMLS are 91.89 percent, 92.40 percent and 92.81 percent, respectively, when the orientation constraint and the full support constraint are met. QTS with an average filling rate of 91.90 percent for BR1–BR15 is slightly weaker than ID-GLTS and HBMLS on the filling rate. This is partly because of the need to satisfy the extra constraint (as shown in Fig. 1, the bottom of each pallet must be fully supported by the container floor or by the top of a single pallet).Due to the lack of universally acknowledged test data for HCLPIB, we generated 1500 cases from the 1500 cases of BR1–BR15 by considering that some box types can be divided into small rectangular boxes if their serial numbers are even numbers. The length, width and height of each small box are 1/2, 1/2, and 1/3 of the length, width and height of the corresponding box type, respectively. Accordingly, we call the obtained case groups BR1p, BR2p,…, BR15p. The undivided boxes in BR1p–Br15p obey the same orientation constraints as the ones in BR1–BR15. However, if one box is divided, the obtained small rectangular boxes can be placed on six admissible orientations.Table 2reports the computational results of HCLPIB for BR1p–BR15p. The mean filling rates for BR1p–BR15p by HCLPIB are 92.97 percent when the undividable boxes have the same priority as the dividable boxes. The mean filling rates for BR1p–BR15p by HCLPIB are 92.15 percent when the undividable boxes are loaded prior to the dividable boxes. It is obvious that the same loading priority for both undividable boxes and dividable boxes may provide better results than the different loading priorities.

@&#CONCLUSIONS@&#
The container loading of pallets with infill boxes occurs at many typical furniture factories. There are many pallets of different sizes in these factories. We would like to load as many of these pallets as possible into a container. Usually, a certain number of pallets cannot be completely loaded into a container. Some pallets should be divided into product boxes to fill the narrow spaces at the sides and tops of the pallets placed in the container. We should guarantee that all of these infill boxes can be entirely palletized into complete pallets. We utilize a heuristic algorithm that consists of a tree search sub-algorithm and a greedy sub-algorithm to solve this problem. The tree search sub-algorithm is employed to arrange the pallets in the container. Then, the greedy sub-algorithm is applied to fill the narrow spaces with product boxes. The computational results on BR1–BR15 show that our algorithm is competitive under the proposed conditions. We also conclude that the same loading priority for both undividable boxes and dividable boxes may provide better results than the different loading priorities for them.