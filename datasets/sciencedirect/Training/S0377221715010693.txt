@&#MAIN-TITLE@&#
Analysis of a parallel machine scheduling problem with sequence dependent setup times and job availability intervals

@&#HIGHLIGHTS@&#
We examine a parallel machine scheduling problem with setup times and time windows.Integer programming (IP) and constraint programming (CP) models are proposed.Two logic-based Benders decomposition algorithms are developed.Extensive computational tests on a real-life case study are performed.We report the effectiveness of the algorithms over pure IP and CP models.

@&#KEYPHRASES@&#
Constraint programming,Mixed integer programming,Logic-based Benders decomposition,Scheduling with job availability intervals,Sequence dependent setup times,

@&#ABSTRACT@&#
In this study, we propose constraint programming (CP) model and logic-based Benders algorithms in order to make the best decisions for scheduling non-identical jobs with availability intervals and sequence dependent setup times on unrelated parallel machines in a fixed planning horizon. In this problem, each job has a profit, cost and must be assigned to at most one machine in such a way that total profit is maximized. In addition, the total cost has to be less than or equal to a budget level. Computational tests are performed on a real-life case study prepared in collaboration with the U.S. Army Corps of Engineers (USACE). Our initial investigations show that the pure CP model is very efficient in obtaining good quality feasible solutions but, fails to report the optimal solution for the majority of the problem instances. On the other hand, the two logic-based Benders decomposition algorithms are able to obtain near optimal solutions for 86 instances out of 90 examinees. For the remaining instances, they provide a feasible solution. Further investigations show the high quality of the solutions obtained by the pure CP model.

@&#INTRODUCTION@&#
This study aims to provide novel modeling and solution techniques for the problem of managing a fleet of resources that is composed of a limited number of unrelated machines subject to operational and tactical level restrictions. For a given time horizon, we seek to assign non-identical jobs to machines and provide the best sequence of jobs on each machine. During the search for the best assignment and job sequence, one must also account for the time spent in between jobs due to setup or travel. Moreover, the procession time of each job depends on the type of the machine assigned to it. Each job has a cost, profit, availability interval(s) and can be assigned to at most one machine. The total cost of operations across all jobs has to be less than or equal to a known budget level. Subject to all these requirements, a typical decision-maker’s objective is to maximize the total profit within a given time horizon. In order to clarify some other aspects of the problem description, the following assumptions are made for all models given in this study:•Release time and deadline of each job are start and end of planning horizon, respectively. A job cannot be completed after the end of planning horizon.All jobs are available for processing at the beginning of time horizon.A machine can work on at most one job at a time.Job preemption is not allowed.Job processing times are deterministic, but vary based on the machine type.Sequence dependent travel (setup) time between jobs is deterministic and assumed to be same for each machine.There is no travel (setup) time before the first job and after the last job in a machine’s schedule.A job might have more than one availability interval. A restricted period is defined as a complementary concept for availability interval to represent the times when job processing is prohibited.Due to limited resources and time, jobs are selective. In other words, a job can be assigned to at most one machine.The remainder of the paper is organized as follows. Section 2 discusses the integer programming (IP), constraint programming (CP) and decomposition algorithms developed to solve the scheduling problem defined above. A real world application of this problem with corresponding instances is introduced in Section 3. Finally, Section 4 compares the performance of the proposed solution techniques.The scheduling problem defined in Section 1 shares similar properties with the operational fixed interval or job scheduling problem (OFISP or OFJSP). OFJSP aims to schedule number of jobs with a fixed or known start and end time on parallel resources in order to maximize the total weights (profits) by processing a subset of jobs (Kroon, Salomon, & Wassenhove, 1995). OFJSP is a generalized version of the Fixed Job Scheduling Problem (FSP) in which the objective is to find a feasible non-preemptive schedule of jobs with fixed start and end times on identical parallel machines. Both OFJSP and the problem of interest in this study assume that (i) no preemption is allowed, (ii) jobs are selective and (iii) at most one job can be processed by a machine at a given time. Aside from these three common fundamental properties, the proposed problem in this study differs from OFJSP. OFJSP assumes that the processing times are fixed and can be calculated by subtracting fixed start time from fixed end time. Moreover, the processing time of a job does not vary based on the machine assignment in OFJSP. On the other hand, the investigated problem in this study seeks to find the best start and end times to process a job with varying processing times due to unrelated parallel resources. Additionally, it accounts for job availability interval restrictions, sequence dependent setup times between jobs and a budget constraint.Arkin and Silverberg (1987) developed a polynomial algorithm for the fixed job scheduling problem (FSP) and showed that the FSP with unrelated machines is NP-complete. Later on, Kroon et al. (1995) designed an exact algorithm for the OFJSP with the single machine based on the polynomial time algorithm in Arkin and Silverberg (1987) and developed two dual-cost heuristics that are able to find good solutions with 0–7 percent optimality gap for the OFJSP problem instances with unrelated machines and non-identical jobs. Türsel Eliiyi and Azizoğlu (2009) studied FSP with machine dependent job values (weights) and developed a branch and bound algorithm that is capable of obtaining optimal solutions for large problem instances. Türsel Eliiyi and Azizoğlu (2010, 2011) further proposed efficient solution techniques for the OFJSP with working and spread time constraints where working time constraints limit the total processing load and spread time constraints limit the time between the start of the first job and the finish of the last job on each machine.Rojanasoonthon and Bard (2005) addressed a parallel machine scheduling problem with time windows and priority levels on jobs under the objective of maximizing the number of jobs scheduled. They reported that their integer linear programming (ILP) model is unable to report even a feasible solution and therefore, they provided a greedy randomized adaptive search procedure that produced good quality solutions for the data instances with 400 jobs and 6 machines. Pearn, Chung, and Yang (2002) studied a parallel machine scheduling problem in a wafer probing factory with non-identical jobs, identical machines and sequence dependent setup times between jobs. They proposed an ILP model and its transformation to a well studied vehicle routing problem with time windows. Three different heuristics were used to find the near-optimal solutions for real-world test instances. Cakici and Mason (2007) also considered parallel scheduling problem in semiconductor manufacturing with auxiliary resource constraints and proposed a heuristic that produced solutions with 0.78 percent optimality gap.In recent years, constraint programming has been widely applied to a variety of scheduling problems as an alternative or in conjunction with mathematical programming (MP). One of the fundamental differences between CP and MP is the way that they express constraints and define decision variables to solve an optimization or a feasibility problem. On one hand, CP allows declarative, flexible and compact formulations that make adding new constraints to the search more straightforward (Focacci, Lodi, & Milano, 2002; Hooker, 2007a). Especially, without the need for a reformulation, being able to represent complex relationships (i.e. if-then, nonlinearity, logical conditions, etc.) in terms of global (logical) constraints is the competitive advantage of CP over MP in finding good quality feasible solutions (Jain & Grossmann, 2001). Thus, CP has been very effective in tackling highly constrained discrete optimization and feasibility problems such as scheduling, planning and resource allocation. On the other hand, MP is more likely to perform better than CP when the tackled problem has a pure (well studied) geometrical structure (Focacci et al., 2002; Lombardi & Milano, 2012). However, as the side constraints are added to the problem, the structure becomes less pure and solving MP models becomes more challenging. In this case, the application of CP becomes more appropriate. A recent increase in the number of studies which employ CP as a (part of) solution technique for many different combinatorial optimization problems demonstrates a growing interest for this modeling technique.Jain and Grossmann (2001) compared pure CP and MP models with a hybrid CP/MP model on a scheduling problem that involves unrelated parallel machines, non-identical orders with different release times and deadlines. They demonstrated that the hybrid model is able to solve larger instance as opposed to pure CP and ILP models. Besides, the decomposition (logic-based Benders) algorithm outperforms all other alternatives in terms of solution time and objective function value. Later, Sadykov and Wolsey (2006) studied the same problem and generated efficient decomposition algorithms based on column generation (branch and price) and branch and cut approaches. Harjunkoski and Grossmann (2002) also studied the parallel scheduling problem motivated by Jain and Grossmann (2001) with sequence independent setup times and developed another decomposition method in which both master and subproblems are formulated as ILP. More details on CP/MP based decomposition algorithms and hybrid modeling approach are given in Section 2.3.For some other versions of parallel machine scheduling problems, a double or combined modeling approach is reported to be an efficient solution method. Edis and Ozkarahan (2011) developed a combined CP/MP model formulation which tackles “resource-constrained identical parallel machine scheduling problem with machine eligibility restrictions” and showed that the combined CP/MP model is able to find the optimal solution in most of the test instances with substantial improvements in solution time as opposed to pure ILP and CP models. Similar success of the combined CP/MP approach is reported by Edis and Oguz (2012) who tackled parallel the machine scheduling problem with flexible resources. We also see successful implementations of the combined CP/MP approach over some other operations research problems such as time-tabling/rostering (He & Qu, 2012; Topaloglu & Ozkarahan, 2011), sport scheduling (Trick & Yildiz, 2007, 2011) and project scheduling with time windows (Cesta, Oddi, & Smith, 2002). For further information about double or hybrid modeling and other decomposition methods, we refer the reader to Hooker (2006b) and Van Hoeve and Katriel (2006).The necessary notation for the scheduling problem is given in Table 1.Van den Akker, Hurkens, and Savelsbergh (2000) pointed out that LP relaxations of the time-indexed IP formulations provide good bounds for the overall scheduling problem although it generates more decision variables and constraints than a classic sequence-based formulation. We introduce the time-indexed mixed integer programming model (DS) as follows:maximize∑j∈J∑d∈Dqjydj(DS)subjectto(1)∑d∈Dydj≤1j∈J(2)∑j∈J∑d∈Dcjydj≤B(3)∑t∈Tzdjt=ydjj∈J;d∈D(4)∑t′=tmin{|T|,t+pjd+tjj′}zdj′t′≤1−zdjtj∈J;j′∈J;j≠j′;d∈D;t∈T(5)∑d∈D∑t=max{1,bw−pjd}ewzdjt=0w∈Wj;j∈J(6)(t+pjd)zdjt≤|T|j∈J;d∈D;t∈T(7)ydj≥0d∈D;j∈J(8)zdjt∈{0,1}d∈D;j∈J;t∈TThe objective of the DS model is to maximize the total profit. Constraints (1) ensure that job j is processed by at most one machine d, whereas constraint (2) states that the total cost incurred by such assignment cannot exceed the total budget. Constraints (3) assure that job j has a start time if it is processed by machine d. Constraints (4) specify that if machine d starts processing job j in period t, then machine d cannot start working on another job, j′, untiltjj′+pjdperiods have passed (i.e. the time to complete job j on machine d plus the time to travel to job j′ from job j). Constraints (5) prevent a job from being processed in a time period that overlaps with its restricted period(s). Constraints (6) ensure that the completion time of a job cannot exceed the end of the planning horizon. Finally, constraints (7) and (8) specify the appropriate domain of each variable in the model.As with many integer programs for scheduling problems, providing the exact optimal schedule for each machine gets more challenging as the number of decision variables and constraints increases. Given the difficulty in solving the problem DS in an IP context and the strengths of CP in finding feasible solutions for highly constrained problems, next two sections discuss the equivalent CP model formulation of the DS and propose two decomposition algorithms that possess the competitive advantages of both CP and IP.The effectiveness of CP is highly correlated with the constraint and variable definition choices a modeler makes. Heipcke (1999) pointed out that CP models, in general, carry much more specific information about decision variables, constraints and the relationships between/among them. This creates a flexible environment for developing stronger, more efficient and specialized solution strategies for highly constrained complex problems. Conveying information between constraints and variables is made possible through constraint propagation (filtering) iterative process of global constraints. Each global constraint is associated with a propagation algorithm that is used to remove the values of variables from their domains in order to prevent constraints from being infeasible (Hooker, 2006b; Van Hoeve & Katriel, 2006). The propagation algorithm of a constraint is called each time a change occurs on a variable. The constraints are related to each other through shared variables. Whenever a change occurs on the domain of a shared variable due to the propagation algorithm of a constraint, the filtering algorithms of other constraints are also triggered to evaluate possible other reductions in the domains of all variables (Harjunkoski & Grossmann, 2002; Lombardi & Milano, 2012; Van Hoeve & Katriel, 2006). Once all possible reductions on domains are made and yet a feasible solution has not been found, branching on a variable takes place. At this point, one can see that addition of new constraints does not impact the search since the propagation algorithms of the previous constraints will remain unchanged due to incremental search (Focacci et al., 2002). In other words, the newly added constraints due to branching interact with the previous ones through the shared variables and the propagation algorithms might have already reduced their domains. Thus, the order in which the constraints are propagated is irrelevant to finding a feasible solution within the iterative constraint propagation process.There are two main properties of a CP problem formulation that might be useful in speeding up the search process. First one is the size of the variable domains. The tighter the variable domains are defined, the less number of candidate values is going to be evaluated for feasibility by the propagation algorithms. Secondly, the constraints should be specified by the most appropriate global constraints available for the application. Each global constraint has a special filtering algorithm that might be triggered several times during a search. Since these algorithms are designed specifically for a global constraint, a failure in global constraint selection may lead to less effective propagation (Focacci et al., 2002; Van Hoeve & Katriel, 2006). This is because, employing global constraints handles non-primitive constraints in CP (Focacci et al., 2002; Heipcke, 1999; Hooker, 2002). In both ILP and CP, primitive constraints are those that are easily handled, while non-primitive ones are those for which no complete method exists for satisfiability in polynomial time (Focacci et al., 2002). In CP, primitive constraints are≤,≥,≠,=,and integrality, while all other constraints are non-primitive. Since constraint propagation algorithms of non-primitive constraints enforce tightening on variable domains, complex constraints should always be formulated in terms of a global constraint, the propagation algorithm of which is proved to be efficient (Focacci et al., 2002; Hooker, 2006b; Lombardi & Milano, 2012). Finally, Hooker (2002) pointed out that CP is more effective than MP if the constraints do not contain too many variables.In addition to the notation in Table 1, the following parameters and decision variables are used in developing the CP formulation.•I(j) is the step function of job j ∈ J. That isI(j)=0percent, if the job j is not allowed to be processed at time t such that bw≤ t ≤ ew,I(j)=100percent otherwise.TD(tjj′)is the transition distance function between job j ∈ J and j′ ∈ J. It is used to inform other global constraints that the travel time between job pairs j and j′ should be at leasttjj′.An interval variable (IBM, 2014) is a powerful way of representing generic decision variables of a scheduling problem. As depicted in Fig. 1, it addresses the time interval of a job that is being processed by explicitly assigning start and end times. One of its important features is that these variables can be optional which enables modeling different assignment alternatives in combinatorial problems. For instance, if an interval variable is optional and absent, it is not considered in the solution schedule and its domain is left empty. Otherwise, if an optional interval variable is present, it implies that it is considered in the solution and its domain should be filtered to a single value represented by a start and end time. The status or Boolean value of an interval variable can be retrieved by using the presenceOf(Interval Variable) constraint. In light of the basic definition of an interval variable, we define the following interval decision variables and sets.•Yjd, optional interval variable when job j ∈ J is assigned to machine d ∈ D with job duration of pjd;Zj, optional interval variable associated with job j ∈ J;Qj={Yj1,Yj2,…,Yj|D|},set of interval variables representing possible machine d ∈ D that can be assigned to job j ∈ J;Vd={Y1d,Y2d,…,Y|J|d},set of interval variables representing possible jobs j ∈ J that can be assigned to machine d ∈ D (interval sequence variable for d).The constraint programming formulation of the parallel machine scheduling problem with maximizing total profit (CP-DS) is given below.maximize∑j∈JqjpresenceOf(Zj)(CP-DS)subjectto(9)Alternative(Zj,Qj)j∈J(10)Cumulative(Zj,cj,B)(11)Cumulative(Zj,1,|D|)(12)Zj.StartMin=1j∈J(13)Zj.EndMax=|T|j∈J(14)ForbidExtent(Zj,I(j))j∈J(15)NoOverlap(Vd,TD(tjj′))d∈DThe objective function of (CP-DS) seeks to maximize the total profit in a planning horizon. Constraints (9) ensure that each job can only be assigned to at most one machine. Alternative constraints enforce that if Zjis present in the solution (i.e. job j is to be processed), then only one of the elements ofQj={Yj1,Yj2,…,Yj|D|}will be present in the solution in order to assign job j to a machine in D. Note that this assignment will also attribute a final processing time (pjd) to Zj. On the other hand, if Zjis not present in the solution (i.e. job j is not to be processed), Constraints (9) guarantee that none of the elements of Qjwill be present in the solution. Constraint (10) assures that the total cost of operations cannot exceed the budget. Cumulative constraint is used to model the resource usage over time and computed with the help of its elementary sub-functions such as Step, Pulse, StepAtStart and StepAtEnd (IBM, 2014). StepAtStart(Zj) is used to increase the total money spent on operations at the start of interval variable Zjby cjamount. Cumulative in constraint (10) is utilized for restricting total spending not to exceed the budget at any time. Similarly, the Cumulative constraint and Pulse(Zj) function are used to make sure that total number of occupied machines at any time cannot exceed the fleet size (|D|) as in constraint (11) where Pulse(Zj) increases and decreases the cumulative usage of fleet by one at the start and end of interval variable Zj, respectively.Constraints (12) and (13) set the minimum start time and maximum end time of each job to the first and last day of the planning horizon, respectively. ForbidExtent constraint (14) states that if interval variable Zjis present in the solution, it cannot overlap with the time intervals where its step function is 0 percent.NoOverlap constraints (15) ensure that the interval sequence variable Vdwhich consists of optional interval variables constitutes the order of the non-overlapping intervals for each machine d ∈ D. Moreover, it also has TransitionDistance function (TD(tjj′)) which puts a minimal time (tjj′) to be maintained between the end of interval variable Yjdand the start of interval variableYj′d.A powerful aspect of ILP techniques is that the impacts of all constraints are evaluated simultaneously, and therefore it has a global perspective while the search tree is being explored (Harjunkoski & Grossmann, 2002; Rodosek, Wallace, & Hajian, 1999). On the other hand, CP propagation algorithms explore the impacts of constraints sequentially through domain reduction of variables (local perspective) (Jain & Grossmann, 2001). These two important features, global vs. local perspectives, originate from the unique differences in defining models (constraints and variables) within these two techniques. These differences have significant impact on the subsequent search procedures. The most important bottleneck arises when the integrality constraints are tackled in the branch-and-bound search tree of the ILP. This process might result in evaluating an exponential number of combinations due to the number of subproblems. Furthermore, if the initial gap between the objective value for the optimal solution and the initial relaxed linear subproblem is large, the effectiveness of ILP tends to degrade. In addition to the number of the constraints and variables, representation of complex relationships between/among variables and constraints can be a major difficulty in providing a concise model. This is because, ILP can handle only inequality and equality constraints which might be insufficient to represent real life constraints. On the other hand, such a strong limitation on constraint expression is minimized in CP since application-based global constraints can be utilized to express complex relationships with no need for reformulation. However, selecting the most appropriate global constraint is crucial since the quality and speed of the domain reduction process at each node depends on the filtering algorithms running behind these global constraints. Since these propagation algorithms are called multiple times during a search, inefficient algorithms might dramatically slow down the search process. It should be remembered that not all global constraints have efficient constraint propagation engines (Jain & Grossmann, 2001). Therefore, hybrid approaches aim to develop integrated methods to merge the complementary strengths of MP and CP to solve problems that are intractable using either of these two methods alone. Modeling an entire problem in both the CP and ILP contexts is referred to as double modeling.More recently, Benders decomposition and Branch & Price algorithms have been very effective when reformulated in a hybrid CP and ILP framework. In the Branch & Price algorithm, the master problem and subproblem are formulated in ILP and CP, respectively (He & Qu, 2012; Topaloglu & Ozkarahan, 2011). Using CP as a column generator takes advantage of CP’s flexibility to formulate complex relationships that might occur in pricing problems (Hooker, 2006a). Similarly, the classic Benders decomposition master problem is formulated as an ILP and resolved with the Benders cuts generated from the CP formulated subproblems (Hooker, 2006a; 2007b; Jain & Grossmann, 2001).We realize that (CP-DS) model provides a feasible solution for all of the problem instances introduced in Section 3. However, it fails to report the optimal solution within a specified time limit. In order to overcome this weakness, we propose two novel logic-based Benders decomposition algorithms based on (DS) and (CP-DS). As a first step towards the optimality, we utilize the solution generated by the (CP-DS) model. We define zCPas the objective function value of the best solution found by the (CP-DS) model within 300 seconds which also serves as a lower bound for the entire problem.Hooker (2007b) states that classical Benders decomposition is not appropriate for highly combinatorial problems such as scheduling, because it enforces subproblems to be continuous linear or nonlinear programming problems. Therefore, recent studies have focused on implementing logic-based Benders decomposition in which subproblems are discrete feasibility problems and solved to generate Benders cuts. After the master problem is solved to optimality, all subproblems are solved and feasibility cuts are added to the master problem. If the master problem is solved to optimality and all subproblems are feasible, the solution is optimal to the global problem. However, if there is at least one infeasible subproblem, corresponding cuts are added to the cut set, and the master problem is called to perform the next iteration of the logic-based Benders algorithm. At a specific iteration (k) in which an infeasible solution is obtained by the subproblem(s), we keep the objective function value generated by the feasible master problem and use it as an upper bound throughout the remaining iterations. Therefore, we definezkB1andzkB2as the objective function values obtained by the master problems of Benders 1 and 2, respectively, at iteration k.Given the competitive advantage of ILP in proving optimality through linear relaxation, the objective function of the problem is modeled in the master problem of logic-based Benders decomposition (M1-DS) which contains assignment (16) and budget (17) constraints. Lower and upper bound restrictions on the objective function are enforced by constraints (19) and (20). In order to limit the symmetric solutions and tighten the solution space, additional inequalities are added to (M1-DS). Constraints (21) make sure that total processing time of machine d cannot exceed the planning horizon length (|T|). Finally, constraints (22) prevent assigning job j to machine d if the sum of the total restricted period length of job j and its processing time on d exceeds |T|.maximize∑j∈Jqj(∑d∈Dydj)(M1-DS)subjectto(16)∑d∈Dydj≤1j∈J(17)∑j∈Jcj(∑d∈Dydj)≤B(18)∑j∈Hdkyd′j≤|Hdk|−1d′∈D¯d;k={1,2,…,K−1}(19)∑j∈Jqj(∑d∈Dydj)≥zCP(20)∑j∈Jqj(∑d∈Dydj)≤mink=1,2,…,K−1{zkB1}(21)∑j∈Jpjdydj≤|T|d∈D(22)ydj(pjd+∑w∈Wj(ew−bw))≤|T|d∈D;j∈Jydj∈{0,1}d∈D;j∈JNote that (M1-DS) has no impact on the scheduling and sequencing decisions of jobs with respect to the machine they are assigned to. Therefore, we need to solve |D| independent subproblems to check if the assignments made by (M1-DS) are feasible or not. Hence, letHdk={j|ydjk=1}be the set of jobs j ∈ J that are assigned to machine d ∈ D at kthiteration. We next define AjdandA¯dwhere Ajdis the compulsory (not optional) interval variable associated with job j and machine d andA¯dis the interval sequence variable for machine d ∈ D. Then, the following feasibility problem (without an objective function) is formulated in the CP context and solved for each machine d in order to make specific scheduling and sequencing decisions subject to restricted periods and travel times between jobs.(S1-DS: Subproblem for each d ∈ D)NoOverlap(A¯d,tjj′)Ajd.StartMin=1j∈HdkAjd.EndMax=|T|j∈HdkForbidExtent(Ajd,I(j))j∈HdkCumulative(Ajd,1,1)If (S1-DS) is feasible for each machine, the solution for both master and subproblems will be the optimal solution to the overall problem. Otherwise, a “Benders cut” will be generated for each machine that fails to provide a feasible schedule for the assigned jobs. Such cuts are first offered by Hooker, Ottosson, Thorsteinsson, and Kim (1999) and referred to as “no good” and later used by Jain and Grossmann (2001) on a parallel machine scheduling problem. These studies report a significant decrease in solution times when logic based Benders decomposition is applied with “no good” compared to pure CP or ILP formulations. Assume that jobs inHdkare not successfully completed by machine d. Also, letD¯d={d′|rd′≤rd,d,d′∈D,d≠d′}be the set of machine operation rates which are less than or equal to the operation rate of d ∈ D. Then, following cuts are formed;(23)∑j∈Hdkydj≤|Hdk|−1(24)∑j∈Hdkyd′j≤|Hdk|−1d′∈D¯d.Note that “no good” (23) can be satisfied by omitting just one job from the setHdkin later iterations. Moreover, constraints (23) cannot prevent assigning same jobs inHdkto another machined′∈D¯d. In order to prevent this, we developed the cuts in (24). Thus, if the subproblem for machine d at iteration k is infeasible, then inequalities (24) are added to (M1-DS) to enforce that all jobs inHdkcannot be assigned to machinesd′∈D¯dfor the later iterations. Note that such inequalities cut off several assignment combinations which might only be revealed by several branching & propagation operations in a CP search when the whole problem is approached by a pure CP formulation. Moreover, since all the subproblems are solved independently in this decomposition approach, it is easy to identify which subproblem (machine) produces infeasible solutions. The size of the master problem increases as the algorithm generates cuts. However, the size of each subproblem cannot exceed the total number of jobs, |J|. As a consequence, if the optimal solution is not obtained in the early iterations of the algorithm, the time required for solving (M1-DS) to optimality will increase significantly. In order to lessen the intensity of the Benders cut added to (M1-DS), we developed a second logic-based Benders decomposition algorithm. The master and subproblem of this alternative approach are given below as (M2-DS) and (S2-DS), respectively.maximize∑j∈Jqjxj(M2-DS)subjectto(25)∑j∈Jcjxj≤B(26)∑j∈Gkxj≤|Gk|−1k={1,2,…,K−1}(27)∑j∈Jqjxj≥zCP(28)∑j∈Jqjxj≤mink=1,2,…,K−1{zkB2}(29)xj(mind∈D{pjd}+∑w∈Wj(ew−bw))≤|T|j∈Jxj∈{0,1}j∈Jwhere xjis a decision variable and will be 1 if job j is completed by any machine, 0 otherwise.Gk={j|xjk=1}is the set of jobs that are decided to be processed at iteration k. The objective of M2-DS is to maximize the total profit subject to budget constraint (25), Benders cuts (26) and some additional inequalities in order to cut off infeasible or low-quality solutions in the early stages of the algorithm. The lower and upper bound restrictions are enforced by constraints (27) and 28, respectively. Constraints (29) ensure that the sum of the minimum processing time and total restricted period length of job j does not exceed the planning horizon length (|T|). Since the job-machine assignment decisions are not made by (M2-DS), they have to be handled in (S2-DS) through optional interval variables. Hence, let Yjdbe the optional interval variable when job j ∈ Gkis assigned to machine d ∈ D at iteration k and Vdbe the interval sequence variable for machine d ∈ D. Therefore, we can write the subproblem as(S2-DS)(30)Alternative(Zj,Qj)j∈Gk(31)Zj.StartMin=1j∈Gk(32)Zj.EndMax=|T|j∈Gk(33)ForbidExtent(Zj,I(j))j∈Gk(34)NoOverlap(Vd,tjj′)d∈D(35)Cumulative(Zj,1,|D|)j∈Gkwhere Zjis the compulsory interval variable for job j ∈ GkandQj={Yj1,Yj2,…,Yj|D|}is the set of interval variables Yjdfor each j ∈ Gk. Similar to problem (CP-DS), (S2-DS) controls the job assignments to machines. However, in this case, Zjis a compulsory interval variable that must be present in the solution because M2-DS determines the set of jobs that must be processed. Therefore, constraints (30) assure that each job j ∈ Gkis processed by exactly one machine. Constraints (31) and (32) enforce that each job must be started and finished within the given planning horizon. Moreover, constraints (33) forbid the restricted periods of each job j ∈ Gk, represented by intensity function (I(j)), overlapping with its processing time. Similarly, constraints (34) make sure that machine d cannot operate while traveling between jobs j and j′ such that j, j′ ∈ Gkand j ≠ j′. Finally, (35) is a redundant constraint that strengthens the formulation by ensuring that the total number of machines in operation cannot exceed the fleet size at any given time. Note that there are only two problems that need to be solved at each iteration in the second Benders decomposition algorithm. However, the size of subproblem (S2-DS) is significantly larger than the ones in (S1-DS). Performance of these two algorithms are evaluated in Section 4.Each year the U.S. Army Corps of Engineers (USACE) dredges hundreds of navigation projects through its fleet of government dredges and individual contracts with private industry. The decision of assigning dredge resources (government and private industry) to navigation projects is predominately made regionally by awarding the contract to the lowest cost bid that meets the scheduling demands of the dredge job. Most likely, efficiencies can be gained by optimizing the entire portfolio of dredging jobs. The proposed models and solution approaches in Section 2 are used to optimize the decision of allocating dredge resources to projects under necessary constraints such as environmental windows, dredge resource cost and availability, and sequence dependent travel times. Using these approaches, sensitivity analysis on resource levels are performed in order to demonstrate under which circumstances USACE can complete the entire dredging portfolio while achieving compliance and desired system performance.A specific challenge investigated in this study is the concept of environmental window restrictions. The USACE describes environmental windows as temporal constraints placed upon dredged material disposal operations in order to protect biological resources or their habitats from potentially detrimental effects (Dickerson, Reine, & Clarke, 1998). The USACE has documented an increase in total dredging cost without a proportionate increase in total volume of material dredged (Pointon, 1996). Dickerson et al. (1998) stated that a widely-held explanation for this increase in dredging costs is system inefficiencies associated with environmental window compliance. In order to be compatible with the related model constraints, we define restricted periods for each environment window (job availability interval).Dredge fleet scheduling and sequencing optimization is challenging due to the highly variable and uncertain feature of natural processes, engineering capacity, dredging operations and economic conditions (Gedik, 2014; Ratick & Garriga, 1996). Despite its difficulty level, risk and reliability based dredging optimization papers (see Lund, 1990; Menon & Lansey, 1990; Nachtmann, Mitchell, Rainwater, Gedik, & Pohl, 2014; Ratick & Garriga, 1996) are frequently seen in the literature that model the volatile river and environmental situations that influence dredging operations at a specific project or reach level. The solution techniques in this study provide a system wide optimization perspective which can efficiently and effectively use resources across the entire dredging project portfolio.Historical USACE dredge project data collected between 1997 and 2011 was utilized to parameterize the model. The data was provided by the Corps Dredging Information System, and a total of 116 unique channel maintenance dredging jobs were identified as seen in Fig. 2. Table 2demonstrates the descriptive statistics of the model input parameters such as volume of jobs (qj), cost of jobs (cj), length of restricted periods (ew−bw) and production rate of dredge vessels (rd). Since the USACE cannot currently afford to meet all the dredging requests, we set the available budget (B) to 75 percent of the total cost of the 116 jobs. A from–to distance matrix was constructed by using a GIS layer to compute travel distance on the waterways between prospective dredge project locations. Then, the travel (setup) time between each job pair is calculated by assuming the velocity of a dredge vessel is 50 miles per day.We identified 130 distinct restricted periods across the 116 jobs that are time intervals when dredging is not permitted at certain job locations due to environmental concerns. Note that some jobs may have none, one or multiple restricted periods. Production rates of dredge vessels in Table 2 reflect a historical statistical average of multiple dredging projects.Table 3demonstrates the properties of 90 problem instances that were used to measure the performance of the solution techniques described in Section 2. The first (|J|=32) and second (|J|=57) sets of jobs do not have any common dredge projects; whereas, the final job set (|J|=116) includes all job locations and restricted periods. For each problem instance, we either select the fastest, slowest or randomly picked distinct dredge vessels to build the fleet from a 40 vessel fleet. We also generate job sizes while keeping all other parameters constant with respect to a discrete uniform distribution in a range of [10K, 1M]. Thus, “32-10-33-O-F” stands for the problem instance with 32 jobs with Original job sizes, 33 restricted periods and the fastest 10 dredge vessels of the fleet.The parallel machine scheduling problem formulations in Section 2 are modeled in IBM ILOG CPLEX Optimization Studio 12.6 (IBM, 2014) which uses IBM ILOG CPLEX 12.6 to solve ILP, IBM ILOG CP Optimizer 12.6 to solve CP and both to solve logic based Benders algorithms. All formulations are modeled in C++ programming language. IBM ILOG Concert Technology is utilized for embedding the formulations in C++ language into IBM ILOG CPLEX and CP Optimizer. We run all test problems on a Core 2 Duo 2.93 gigahertz, 16 gigabyte RAM computer. We create and solve the master problems from scratch with the updated Benders cuts at each iteration.As mentioned before, we observe that for a medium size problem instance (|D|=10and|J|=32), CPLEX cannot even begin to solve the (DS) model presented in Section 2.1 due to the large number of decision variables and constraints. Therefore, we do not report any experiment results for models (DS). Tables 4–6demonstrate the performance of the Benders decomposition algorithms over the problem instances with|J|=32, 57 and 116, respectively. These results are obtained by solving the parallel machine scheduling problem with maximizing total profit objective. For each algorithm, we report total run time, total master and subproblem(s) run time, number of iterations and final gap on each problem instance. Initial 300 seconds (CP-DS) model run time to get a lower bound (zCP) is excluded from the time statistics listed in these tables. Finally, Table 7 comparatively illustrate the number of optimal solutions obtained by the decomposition algorithms for the problem instances with original and randomly generated job sizes. Unless an optimal solution is attained, Benders 1 and 2 terminate the search under three circumstances:(i)the total algorithm time reaches 10,800 seconds or,the number of iterations is equal to 2000 or,ϵ=zkB2−zCPzkB2≤0.01andϵ=zkB1−zCPzkB1≤0.01at iteration k.Decomposition algorithms are very efficient and effective in providingϵ-optimal solutions within a reasonable amount of time and allowed iteration limit. Table 7 points out that out of 90 problem instances, 75 and 83ϵ-optimal solutions are achieved by Benders 1 and 2, respectively. It also shows that 39 (44) of the 45 problem instances with original job sizes and 36 (38) out of 45 problem instances with randomly generated job sizes are solved to near optimality by Benders 1 (Benders 2).Both algorithms are able to capture a feasible solution for the problem instances with no optimal solution (highlighted in italic font in Tables 4–6). Larger solution times and number of iterations are required for both Benders 1 and 2 as the number of jobs increases. However, the average master and subproblem solution times of Benders 2 are smaller than counterparts produced by Benders 1 although Benders 2 requires significantly more number of iterations, on average. Note that assignment of jobs to machines are handled by the master problem of Benders 1 whereas subproblem of Benders 2 makes the same decisions once its master problem identifies the set of jobs need to be processed at each iteration. Moreover, feasibility cuts generated by Benders 1 after an infeasible subproblem associated with machine d are also applied to other machines with smaller operation rates. Hence, Benders 1 adds more feasibility cuts to its master problem than Benders 2 at a given iteration and as the algorithm progresses, solving the master problem of Benders 1 gets more difficult and requires more time than the one in Benders 2. Despite this cost, the feasibility cuts of the first variant carry more information from subproblems to master problem and therefore, eliminate more inferior solutions at an iteration which ultimately results in exploring near optimal solutions at earlier iterations. On the other hand, it is faster to solve a single feasibility subproblem in the second variant even with assignment decisions. This situation exemplifies the high efficiency of CP in obtaining feasible/infeasible solutions for highly constrained problems. By exploiting the competitive advantage of CP in delivering quick feasible solutions, Benders 2 evaluates many more different job combinations in more iterations. As a consequence, it outperforms the first variant in terms of number of near optimal solutions across all problem instances.In order to assess the quality of the solutions obtained by the (CP-DS) model with 300 and 10,800 seconds time limit, we calculate the optimality gap percent based on the optimal solutions obtained by the decomposition algorithms for the problem with maximizing total profit objective as shown below.OptimalityGappercent=100*(OptimalObjectiveValue−(CP-DS)ObjectiveValueOptimalObjectiveValue)Table 8 shows the optimality gap percent of the (CP-DS) model for the 86 problem instances that are solved to optimality by at least one of the decomposition algorithms. An interesting observation is that although the (CP-DS) model with 300 and 10800 seconds time limit terminates with an optimal solution for only eight problem instances, the average optimality gap is 1.12 percent and 0.77 percent, respectively. This indicates that the pure CP model is able to explore high quality solutions (optimal with 0 percent optimality gap for some instances) early, but it is only able to prove the optimality of eight of them. These findings also suggest that the lower bound (zCP) obtained from the (CP-DS) model within 300 seconds is very useful in findingϵ-optimal solutions by Benders 1 and 2 algorithms.In this study, we discuss the advantages and disadvantages of three modeling approaches for the parallel machine scheduling problem with sequence dependent setup times, job availability intervals, unrelated machines and non-identical job durations. We propose three different problem formulations (i) integer linear programming, (ii) constraint programming, and (iii) logic-based Benders decomposition algorithms to tackle this problem with a maximizing total profit objective function.We prepare real-life test instances in collaboration with the USACE in order to optimize their inland waterway infrastructure maintenance operations and make the waterways navigable for the supply chain activities. For most of the problem instances, we observe that the two proposed Benders algorithms are much more efficient and effective than the standalone ILP and CP models. Collectively, Benders 1 and 2 are able to obtain 86ϵ-optimal solutions out of 90 problem instances with original and randomly generated job sizes. Based on our further computational experiments, we observe that the number of optimal solutions for the 45 problem instances with randomly generated job sizes (qj∼ DU(10K, 2M)) decreases to 22 whereas the number of optimal solutions for the problem instances with the original job sizes remains at the same level.This work can be extended in several directions. First of all, this study assumes that the cost and profit of processing a job is independent from the machine type. This assumption can easily be relaxed in pure ILP and CP formulations. However, developing a decomposition algorithm with this extension requires further analysis. Second of all, soft transition periods between the time availability constraints and environmental work windows should be incorporated in the modeling. This can be easily made possible in CP by assigning different values to the intensity function where the operation rate is defined for specific time intervals. Finally, the master problems of the decomposition algorithms are created from scratch at every iteration in the current implementation scheme. A more efficient strategy would be to store the search trees of the master problems and tighten the formulation by adding the Benders cuts at each iteration. This approach can be implemented in several ways. However, the most recent and promising way is to use lazy constraint technology. In this method, Benders cuts would be treated as lazy constraints for which a callback routine is triggered every time an incumbent solution candidate is reached. Most of the lazy constraints are not expected to be active at the optimal solution. The callback will either result in validating the incumbent solution or rejecting it due to a violated Benders cut (lazy constraint). By this way, some time savings might be obtained since the search tree would not be created from scratch every time the master problem is invoked.

@&#CONCLUSIONS@&#
