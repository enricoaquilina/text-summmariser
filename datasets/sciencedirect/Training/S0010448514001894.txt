@&#MAIN-TITLE@&#
Feature-preserving T-mesh construction using skeleton-based polycubes

@&#HIGHLIGHTS@&#
We present a novel algorithm which uses skeleton-based polycube generation to construct T-meshes.Three kinds of features are preserved: open curves, closed curves, singularity features.With a valid T-mesh, we calculate trivariate T-splines for isogeometric analysis.

@&#KEYPHRASES@&#
Skeleton,Polycube,Feature preservation,T-mesh,Trivariate T-splines,Isogeometric analysis,

@&#ABSTRACT@&#
This paper presents a novel algorithm which uses skeleton-based polycube generation to construct feature-preserving T-meshes. From the skeleton of the input model, we first construct initial cubes in the interior. By projecting corners of interior cubes onto the surface and generating a new layer of boundary cubes, we split the entire interior domain into different cubic regions. With the splitting result, we perform octree subdivision to obtain T-spline control mesh or T-mesh. Surface features are classified into three groups: open curves, closed curves and singularity features. For features without introducing new singularities like open or closed curves, we preserve them by aligning to the parametric lines during subdivision, performing volumetric parameterization from frame field, or modifying the skeleton. For features introducing new singularities, we design templates to handle them. With a valid T-mesh, we calculate rational trivariate T-splines and extract Bézier elements for isogeometric analysis.

@&#INTRODUCTION@&#
Isogeometric analysis is a novel analytical method which has attracted a lot of attention recently  [1,2], with its advantage of accuracy and robustness studied in detail  [3,4]. NURBS models were first used in isogeometric analysis  [2,5,4], and then T-splines  [6] were incorporated for its local refinement property [7,2]. Based on these pioneering research, an isogeometric design-through-analysis methodology  [8] was proposed, with the purpose of integrating the whole process from designing of models to the analysis results. However, automatically and robustly constructing trivariate T-spline models is still a challenging problem.Only a few approaches have been designed for volumetric spline construction. Parametric mapping plays an important role in this research area, such as trivariate B-spline fitting using harmonic functions  [9], parametric mapping of tetrahedral meshes  [10], and Periodic Global Parameterization  [11]. Polycubes and parametric mapping were used together to generate solid T-spline models [12,13], and Boolean operations were further introduced to manipulate polycubes  [14]. A generalized polycube method usingTshape templates was introduced to handle high-genus models and extraordinary nodes for T-spline construction  [15]. The generalized polycubes were further extended in  [16] to generate volumetric splines from surface meshes, with no singularity and controllable number of ill-points. However, in these polycube-based methods, the generated solid T-splines follow the directions of the initial polycubes and certain detailed features cannot be preserved in the final result.Since T-mesh can be recognized as a special type of hexahedral (hex) mesh which allows T-junctions, we may apply some promising hex meshing algorithms to solid T-spline construction. CubeCover  [17] used 3D frame fields to perform volumetric parameterization and all-hex mesh generation. This research was extended in  [18], which brought forward a method to generate a singularity-restricted frame field for all-hex meshing. A boundary aligned cross-field was also studied in  [19], which uses spherical harmonics to represent the 3D field. The field was then improved with singularity correction for hex mesh extraction  [20]. However, performing volumetric parameterization from frame field is not robust, especially for complex geometry. And the frame field may yield very dense hex meshes with singularity restrictions and corrections. Harmonic volumetric mapping was employed in hex meshing with better boundary feature capture  [21]. Common base-domains  [22] were designed for volumetric parameterization of models with homeomorphic topology. Polycubes were also used to construct hex meshes  [23]. A constrained discrete optimization technique was developed in  [24] for better mesh segmentation and volumetric parameterization using polycubes. In  [25], hex remeshing was performed based on polycube construction and optimization.L1based polycubes for complex geometries were proposed for hex meshing with better quality  [26]. Octree-based methods were developed to generate adaptive hex dual-meshes  [27,28], and were improved to preserve sharp features [29,30]. However, they yield many singular points on the surface.To robustly build T-meshes following the geometry topology and preserve detailed features, in this paper we develop a new algorithm to use the skeleton as a guide for polycube construction. In the generated polycubes, each cube has at most one patch on the boundary, which provides the necessary condition to generate good-quality elements. The singularity graph of the constructed T-mesh follows the cube edges in the interior. Instead of singular edges, there are only a few singular points on the surface. With this property, we can control the singularity distribution on the constructed solid T-spline. For surface features, we classify them into three groups: open curves, closed curves and singular features, and design different schemes to preserve them.The main contribution of this paper lies in a new skeleton-based polycube construction method, and different approaches to preserve surface features. Compared to other methods, our algorithm has the following three unique properties: (1) the constructed T-splines follow the topology of the input model, and all singular edges lie on the polycube edges in the interior; (2) open and closed curve features are preserved with different methods, and Boolean operations are introduced to simplify the T-mesh construction; and (3) three templates are developed to introduce and preserve certain singular points on the surface.The remainder of this paper is organized as follows. The main steps of the algorithm are overviewed in Section  2. Section  3 discusses how to generate polycubes and split the domain. Different approaches of feature preservation are described in Section  4. The results are shown in Section  5. Section  6 draws conclusions and points out the future work.The overview of our algorithm is shown in Fig. 1. We use polycubes to split the domain and perform parametric mapping to construct the T-mesh. With the skeleton generated from a mean curvature flow algorithm  [31], we split the skeleton into different branches. Each branch yields one interior cube and several boundary cubes. These cubes split the domain into different cubic regions. From the input model, we classify the surface features into three groups and preserve them with different approaches.Polycube construction. We use the generalized cube definition here. For a generalized cube, it is one boxed region enclosed by six surface patches. There are two kinds of cubes here, interior cube and boundary cube. We first construct interior cubes directly from the skeleton branches, and then project their corners onto the surface to generate new boundary cubes. Interior and boundary cubes are combined together to split the whole model into different cubic regions. Since for the boundary cubes, there are at most one face on the surface, all the singularity edges from the cubes stay in the interior.Feature preservation. The input surface features are classified into three groups: open curve, closed curve and singularity feature. Here, the open curve is required to satisfy the condition that it can be mapped onto one certain parametric line. We use parametric mapping and volumetric parameterization from frame field to preserve such features. The closed curve is required to topologically enclose a disc area and each closed curve can be mapped onto a unit square. To preserve such features, the skeleton is modified to add or remove branches. The singular feature is a singular point on the surface. It can be a sharp corner, saddle point of a function, or point with discontinuous curvatures. We develop three templates to insert new singularity points on the surface. With the modified polycube containing surface features, we construct T-meshes by octree subdivision and projection  [12,14].Solid T-spline construction. From the T-mesh, we build rational solid T-splines  [32]. The basis function of rational solid T-splines has the property of partition of unity by definition, which makes it suitable for analysis. Different templates are developed to deal with the singular nodes in the T-mesh, to make it valid for gap-free solid T-spline calculation. From the valid T-mesh, we extract the local knot vectors  [6,33] and construct solid T-splines. The Oslo knot insertion algorithm  [34,33] is used to calculate the transformation matrix from rational T-spline basis functions to Bézier basis functions. This matrix is then used to extract Bézier elements from T-splines, which can be directly used for isogeometric analysis.Skeletons are simplified 1D representation of 3D objects, which can reflect the geometry and topology. They contain geometrical information for volumetric parameterization and can be used to assist our polycube construction.There are different algorithms developed to extract skeletons from surface meshes, such as mesh contraction  [35], mean curvature flow  [31], and the generalized sweeping method  [36]. In this paper, we use the algorithm given in  [31]. With the skeleton, we first split it into different branches. For each branch, we define a B-spline curve and calculate the tangent direction at each point. We decide if it needs further splitting by calculating the angle change of the tangent directions at each point compared to the starting point:θ=acos(t0→⋅ti→). A predefined thresholdθ0=30°is used here. Some user interactions may be involved to simplify the skeleton in this step, such as cleaning up small branches, combining nearby bifurcations to trifurcations, or making the local branching region coplanar. Fig. 2(a) shows the extracted skeleton and splitting result of the Bunny model.To construct a generalized cube from one skeleton branch, we need to generate its 6 bounding patches. These patches can be either planar or curved surfaces. We first shift the branches about itself 8 times to generate 20 curves, as shown in Fig. 3(a). For each point on the skeleton, we generate one plane perpendicular to the skeleton, and then calculate 8 equally-spaced direction vectors on this plane to perform the shifting. Sometimes this method may produce interior cubes with improper orientations, which can be adjusted interactively to yield good parameterization results. The black curve is the original branch, the 8 blue curves are generated from shifting, and the 8 green curves and 4 red curves are generated by connecting the starting/ending points of the shifted curves. These curves are defined as quadratic B-spline curves. With four B-spline curves, we define one Coons patch  [37]. So for a skeleton, we generate 6 patches from the 20 curves. With these 6 patches, we define a cubic domain.Deal with branches. To join cubes from different branches together at the bifurcation or trifurcation, we split the cube patches to half planes and combine them together. The detailed algorithm was present in  [4,38]. During this process, singularities will be introduced to the polycubes along the shared edges of the half planes. Fig. 3(b) and (c) show how to combine the cubes at the bifurcation and trifurcation situations. Instead of Coons patches, the half planes at the intersection region are defined as planar patches, and points on the plane are calculated from a linear interpolation of the corner points. Fig. 2(b) shows the generated interior cubes of the Bunny model.After all the interior cubes are connected properly, we iteratively enlarge each cross-section of the cubes to adapt to the input model. For each node, we project it onto the surface along the radial direction from the cross-section center. Smoothing is performed to reduce the distortion from enlargement  [27]. The enlarged and smoothed interior cubes of the Bunny model are shown in Fig. 2(c).With the interior cubes constructed, we can generate the boundary cubes to split the whole model. The boundary cubes are generated by projecting the patches of the interior cubes onto the surface. The detailed steps are explained as follows with one patch of a sphere model in Fig. 4as an example.1.Project corners onto the surface. For one cornerciof the interior cube, if shared by one cube, the projection direction is defined asd⃗=−(u⃗+v⃗+w⃗)(Fig. 4(b)), whereu⃗,v⃗,w⃗are the unit direction vectors along the edges atci. If shared by two cubes, the direction isd⃗=−(2u⃗+v1⃗+v2⃗+2w⃗)(Fig. 4(c)). For bifurcation or trifurcation, the projection direction is perpendicular to the plane defined by the skeleton branches at that intersection point.Generate curves. Suppose the corresponding point ofcion the surface isci′, see Fig. 4(a). The curve connectingciandci′is named a connecting curve (blue curves). For one curve of the interior cube (black curves), we can find out one projected curve on the surface (red curves) by finding the geodesic shortest path between the projected corners. After projecting 4 corners of the interior patch, we define 4 connecting curves and 4 projected curves. Intersections are not allowed between any pair of boundary curves except at the endpoints. So when finding the path, vertices lying on the path between two projected corners will not be revisited. If the projected corners are far away from each other, or the geometry changes severely, we can project the middle or quarter points of the interior curves onto the surface, and use them to help find the path. However, if the projected corners are crowded or the valence of the projected corners is low, we may locally subdivide the input mesh to ensure there is no intersection among the paths. This projection curve searching step is crucial to our surface decomposition. Our method works well in general, but some improved surface splitting methods like the greedy strategy  [39] can help generate better results for very complicated models.Build patches. We define a connecting Coons patch with an interior curve, its corresponding boundary curve and two connecting curves (light green patches in Fig. 4(a)). Four connecting patches will be generated after the projection of an interior patch. The four boundary curves define one boundary patch (yellow patch in Fig. 4(a)). For the boundary patch, instead of using Coons patch, we directly use the surface region surrounded by these four curves.Generate boundary cubes. With each interior patch, its corresponding boundary patch and four connecting patches, we define the enclosed domain as a boundary cube.For an interior cube, depending on whether the bounding patches are shared by other cubes, it can generate at most 6 new boundary cubes. For one boundary cube, it shares one interior patch with the interior cube from which it is derived, and has only one bounding patch on the surface. We can calculate a series of points on the Coons patches by givingm×npairs of parametric values, and use them for parametric mapping and octree subdivision. The connecting patches may be distorted if the surface is bumpy or has a lot of features. We can optimize the control points of interior and boundary curves. To perform optimization, we should first unify the number of control nodes on the two opposite sides of one patch, then generate one coarse hex mesh. With this hex mesh, we optimize the control points by moving them toward the direction which can produce the maximum scaled Jacobian  [12]. Fig. 5(a) shows the four connecting patches generated and optimized from one interior cube of the Bunny model.With the interior and boundary cubes, we can split the model into different sub-domains. This domain splitting result follows the skeleton of the input model and thus the generated T-mesh follows the topology of the input. If we want to change the orientation or the number of cubes, we can simply modify the skeleton at the beginning. In addition, the location of the projected cube corners on the surface can be optimized to help generate better parameterization results  [40].An interior cube edge is a singular edge if it is not shared by 4 cubes. All the control nodes lying on these singular edges are singular nodes. The singular graph of the T-mesh is the graph which connects all the singular nodes. This graph satisfies the constraint that the singular graph of a hex mesh should not start or end in the interior of the volume  [41,17]. After polycube construction, the singular graph is fixed. We can predict the positions of singular points generated from octree subdivision. Fig. 5(b) shows the singular graph of the Bunny model.Surface features, such as smooth curves, sharp curves, and singular points, play an important role in representing the surface details. In our algorithm, feature preservation is carried out during T-mesh construction. For each cube, we project it onto a unit cube in the parametric domain and perform octree subdivision to generate the T-mesh. This T-mesh contains all the information from the input. The detailed projection and subdivision algorithm was present in  [12,13]. The main difference between our T-mesh generation method and previous research on skeleton-based volumetric composition and structured grid generation  [42] is that our T-mesh allows T-junctions, and there is no singular edge lying on the surface. We classify surface features into three different groups: open curves, closed curves and singularity points. They are dealt with different approaches.In this section, two methods are developed to preserve open curves: parametric mapping and volumetric parameterization from frame field. We require that the open curves preserved here can be mapped onto parametric lines. For curves with self-intersection or spiral shape, we have no way to map them onto any parametric line in our algorithm, so we cannot preserve them.Parametric mapping. For an open curve feature, we align it to a certain parametric line during parametric mapping. By doing this the generated T-mesh contains a sequence of nodes to follow this curve. If one feature line crosses two different boundary cubes, we would constrain that the shared point on the boundary of these two cubes should be mapped to the same parametric value. Then there would be no discontinuity in the resulting subdivision between the two cubes. The detailed steps are as follows (Fig. 6):1.For a feature curves, we first find out the patchpcontaining it in the cubeCand map patchpto a unit squarep′in the parametric domain. The feature curveswill be mapped to curves′onp′;Calculate the average angleθ̄between the tangent direction at each point and theuaxis. Ifθ̄<π/4, we alignp′to thevdirection. Otherwise we align it to theudirection;Set the coordinate at the aligned direction to be the same value for all the points lying onp, calculate the parametric coordinate at the other direction by a chord length parameterization, and then perform surface mapping again to get results with aligned features.For an open curve within one surface patch, if the tangent directions at the two end points vary a lot (e.g., they form an angle greater than60°), or the curve intersects with two adjacent boundaries of one patch, we may need to map half of the curve to the parametricudirection and the other half to thevdirection. The turning point isC0-continuous along the curve.It is convenient to perform the alignment during parametric mapping. However, it is difficult to propagate this feature information into the interior of the T-mesh. This is because nodes on the surface are calculated from mapping and projection, but nodes in the interior are from a linear interpolation  [12]. So the deeper into the interior, the less influence the feature information has. As a consequence, it may yield distorted T-mesh elements even with smoothing performed. To resolve this issue, in the following we use parameterization from 3D frame field to preserve these open curve features.Frame field. A volume parameterization of geometryVfrom frame field can be recognized as an atlas of mapsf:V→R3,p↦(u,v,w)T.fis a piecewise linear field in each input tetrahedral mesh element. The integer grids inR3would induce a hex tessellation of the geometry. The volume parameterization from the field  [17] is performed by:(1)min∑tvol⋅Dt,where(2)Dt=‖c∇f(u)−Ut‖2+‖c∇f(v)−Vt‖2+‖c∇f(w)−Wt‖2,vol is the volume of a tetrahedron,cis the length scale of parameterization, and{Ut,Uv,Uw}are the initialized frame field.For a detected feature curve lying in cubeC, we use the six patches of the cube to generate a high quality uniform tetrahedral mesh using TetGen  [43] and apply a frame field to it. We initialize the frame field cube by cube. For each cube, we first initialize the cross field on the bounding patches with one direction following the patch normal, and then propagate it to the interior. Field optimization is also performed after the propagation. The permutation matrix  [17] between any pair of neighboring tetrahedral elements is set to be the identity matrix if they are in the same cube. The permutation matrix among different cubes is set properly to ensure that the shared cube edges are singular edges. During frame field initialization, the feature line information is used to guide the field. Then we perform volumetric parameterization to get an all-hex mesh. This mesh will be used as the initial T-mesh, combined with other cubes for subdivision to generate the T-mesh for the whole model. For one cube, if subdivided byntimes without T-junctions, there will be2n+1control points at one parametric direction. To make the parameterization result compatible with the subdivision of neighboring cubes, we adjust the length scalecand modify the isoparametric line spacing to perform remeshing.Fig. 7shows the Bunny model without and with feature alignment. An open curve is preserved on the back of the Bunny. Fig. 8shows the result of a sphere model with an open curve feature aligned from direct mapping and frame field parameterization. Compared to direct mapping, the frame field parameterization method has the following advantages: (i) the change of the element size is gradual, and the influence of the feature line to its surrounding elements is smoother; and (ii) the feature information can propagate further into the interior. As shown in Fig. 8(d), the feature curve even influences the subdivision of the interior cube.The domain splitting and polycube construction result depend on the skeleton. By modifying the skeleton, we can change the ways of domain splitting and the design of polycube. Since the patches of interior cubes are projected onto the surface to generate boundary cubes, we can generate one boundary cube with the enclosed region by the closed curve as its boundary patch. To build this boundary cube for the closed curve and preserve such a feature, we should add one new branch to the skeleton.To add a new branch, we find out the center point of the enclosed surface region and connect it to the skeleton. With this branch, a new bifurcation is introduced to the skeleton. After building a new interior cube from the new branch, its four corners away from the bifurcation are projected back onto the closed curve on the surface. These four projected corners split the close curve into four consecutive ones. The region enclosed by the closed curve is defined as a boundary patch and a boundary cube is built. With the modified polycube, we can preserve the closed curves during the following subdivision.Fig. 9shows a torus model with skeleton modification. The original skeleton of the torus model is one circle. We modify it by adding one or two new branches. The results show that by modifying the skeleton, we cannot only change the domain splitting, but also change the number of singular points on the surface. When one new branch is added, six new singular points are introduced on the surface, two from the bifurcation part and four from the corners of the new branch. Fig. 9(e)–(f) show the constructed T-spline models. Fig. 10(b) shows the torus model with one closed curve feature preserved on the surface. The closed curve feature will impact both the elements inside the enclosed region, and those from the neighboring cubes.Boolean operations. By combining feature alignment and skeleton modification together, we can perform different kinds of Boolean operations on the generated model, like union and subtraction. Fig. 10(c) shows the modified torus model with all the elements in the feature curve region removed. Fig. 10(d) shows the new torus model with the closed curve region extruded from the surface. With Boolean operations, we can simplify the modeling process with proper skeleton modification.After generating the interior and boundary cubes, the topology of the singular graph is fixed. If there are other singular points on the surface to be preserved, we may have to regenerate our polycube. As indicated in Section  4.2, modifying the skeleton can change the number of the singular nodes on the surface, but this modification also changes the structure of the polycubes.To preserve surface singularities without changing the polycube, we design some templates which follow the property of singularity distribution in hex meshes. As indicated in  [17], the singular graph should not start or end in the interior of the hex meshes. So the designed template should provide a singular edge path connecting the desired surface singularity to the existing singular graph in the interior. We develop three templates to insert surface singularities. These templates can be applied to boundary cubes or elements containing the desired singularity. The cube or element will be split into smaller elements and new singularities are introduced on the surface and in the interior. The templates are designed with the following two constraints: (a) the introduced face singularities should only lie on the boundary patch of the polycube, or the boundary face of the element; and (b) the four edges of the face containing the face singularity should not be singular edges. These two constraints ensure that the templates will only change the interior region of the cube or element without influencing its neighbors. We design three templates, each of which changes the surface singularity of the polycube differently.Template 1 is derived from a 2-refinement splitting primitive of unstructured hex meshes  [30]. It introduces three singular nodes on three different faces, see Fig. 11(a). We combine four of them together and perform simplification whenever possible. The initial primitive is first extended by combining it with its mirror image corresponding to one face containing face singularity. The face singularity is therefore wrapped into the interior. Simplification is performed by merging elements together, see Fig. 11(b). The simplified mesh is combined with its mirror image again with further simplification to get the final template, as shown in Fig. 11(c).This template introduces four new singular points on the surface of the initial cube. During mapping we align the singular points in this template with the desired singular points on the surface. This template may change the property of the original four corners on the surface. If these corners are regular points, they will become irregular after applying the template. Otherwise they will switch from singular to regular.Template 2 uses two of the 13 meshable primitives introduced in  [44,41]. Fig. 11(d) shows two of the solid primitives combined together and their splitting pattern. The splitting pattern of these two primitives guarantees that there is no gap when matching them together. The cube built from the combination has three singular points on three different faces. We use the same merging-simplifying technique to wrap undesired face singular points into the interior. The final template is shown in Fig. 11(g). This template will insert four new collinear singularity points on the surface. The four corners of the original cube are changed in the same way as Template 1.Template 3 is different from Template 2 in choosing meshable primitives, see Fig. 11(h). As shown in Fig. 11(k), this template will insert eight new singularity points on the surface. Four of them are collinear and the other four form one surrounding circle. The original four corners of the cube are not influenced by this template.We have applied all the three templates to a sphere model to demonstrate how they change the singularity points on the surface and the singular graph in the interior. Fig. 12shows the singular graph (blue curves) of the T-mesh with singular points (red point) on the surface, and solid T-spline results. Template 1 does not change the total number of singular points on the surface, but shrinks the region enclosed by the four singular nodes. Template 2 erases the original four singular nodes of the boundary cube, and introduces four new collinear singular points. Template 3 does not influence the original four singular points, with four collinear singular points and the other four forming one circular region. All the singular points on the surface are connected to the singular graph in the interior.For a singular point in T-mesh, it decreases the continuity of T-spline fromC2toC0within its two ring neighborhood. Which template should be chosen to preserve certain surface singularity depends on the size of the two-ring neighborhood influenced by the singular point, and whether the singular information is allowed to propagate outward. The singularity points we insert on the surface are either valence 3 or valence 5. Our templates cannot handle higher-valence singularities.

@&#CONCLUSIONS@&#
