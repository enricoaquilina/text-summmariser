@&#MAIN-TITLE@&#
A model driven architecture for the development of smart card software

@&#HIGHLIGHTS@&#
A model driven architecture to ease smart card software development is introduced.Platform-independent and platform-specific modeling of smart card systems are provided.Application of the defined transformation rules has enabled automatic code generation.Lessons learned during the industrial usage of the architecture are reported.Development of a domain-specific language for smart cards has also been considered.

@&#KEYPHRASES@&#
Model driven architecture,Metamodel,Model transformation,Smart card,Java Card,Basic card,

@&#ABSTRACT@&#
Smart cards are portable integrated devices that store and process data. Speed, security and portability properties enable smart cards to have a widespread usage in various fields including telecommunication, transportation and the credit card industry. However, the development of smart card applications is a difficult task due to hardware and software constraints. The necessity of the knowledge of both a very low-level communication protocol and a specific hardware causes smart card software development to be a big challenge for the developers. Written codes tend to be error-prone and hard to debug because of the limited memory resources. Hence, in this study, we introduce a model driven architecture which aims to facilitate smart card software development by both providing an easy design of smart card systems and automatic generation of the required smart card software from the system models. Differentiating from the previous work, the study in here contributes to the field by both providing various smart card metamodels in different abstraction layers and defines model-to-model transformations between the instances of these metamodels in order to support the realization of the same system on different smart card platforms. Applicability of the proposed methodology is shown for rapid and efficient application development in two major smart card frameworks: Java Card and ZeitControl Basic Card. Lessons learned during the industrial usage of the architecture are also reported in the paper. Finally, we discuss how the components of the architecture can be integrated in order to provide a domain-specific language for smart card software.

@&#INTRODUCTION@&#
Smart cards are portable, integrated circuit devices that securely store and process data [1]. These tiny computers with their own memories and processors have a widespread usage in various fields including telecommunication, transportation, banking and healthcare. For instance the operation of a cellular phone is directly based on a smart card which carries an identification number unique to the owner, stores personal data and prevents operation if removed. Also most of today’s credit cards are in fact smart cards that store account information for a bank customer and provide authorization and authentication for electronic money transfers.Since hardware and software capabilities of a smart card are very limited compared to a desktop personal computer, the development of smart card applications is a difficult task. The necessity of having a deep knowledge of both a very low-level smart card communication protocol [2] and a specific hardware causes smart card software development to be a big challenge for the developers. Limited memory resources force developers to deal with very primitive data structures. The design of the software for the process of incoming hexadecimal data packages and preparation of the outgoing data packages byte-by-byte, again in hexadecimal format, are difficult and time-consuming jobs for the developers. Development environments dedicated to the smart cards are mostly incapable of code debugging and this makes written codes tend to be error-prone.Like other smart card developers, we also experienced above difficulties in the design and implementation of various smart card software which were developed during our academic research (e.g. [3–5]) or for commercial purposes. Based on our experience, we may conclude that working in a higher abstraction level different from the code level is mandatory for an efficient design and implementation of smart card software systems. Within this context, model driven engineering (MDE) (or model driven development (MDD)) [6], which aims to change the focus of software development from code to models, may also provide easy and efficient production of smart card software. In such an MDE environment, card developers can graphically design their system models conforming to metamodel(s) at various abstraction layers which in fact present entities and their relations needed for a smart card system, and then software codes needed for the designed system are automatically generated as the result of a model to text transformation. Hence, in this paper, we introduce a MDD process which aims to facilitate the smart card software development by both providing an easy design of smart card systems and automatic generation of smart card programs. We use model driven architecture (MDA) ([7,8]) which is one of the realizations of MDD to support the relations between platform independent and various platform dependent smart card entities to develop software for smart cards.Following the derivation of smart card metamodels in different abstraction layers, definition and implementation of model-to-model (M2M) transformations for the instances of these derived metamodels were performed. Finally, model-to-text (M2T) transformations were provided to automatically generate required software codes.Apart from the related work (e.g. [9–12]) which mainly considers model driven smart card software development only specific for the Java Card framework [13], the study presented in this paper introduces a platform independent metamodel (PIMM) for smart card systems in order to free the developer from taking into consideration the specific needs of different smart card platforms such as Java Card. Furthermore, the proposed PIMM enables the developer to model the smart card system conforming to data transmission and data storage standards brought by ISO/IEC 7816 standards family [2]. This standards family includes various standards for smart card development such as the physical characteristics, electrical interface, transmission between smart cards and host devices and personal verification.On the other hand, transformability from the general smart card PIMM to the dedicated smart card platforms is also presented in this study. Metamodels of two major smart card frameworks, Java Card [13] and ZeitControl Basic Card [14], are defined as the platform specific smart card metamodels (PSMM). Hence, applied M2M transformations and following M2T transformations provide the implementation of the same smart card system on different execution platforms.The rest of the paper is organized as follows: a brief discussion on smart card technology is given in Section 2. Section 3 includes the proposed smart card PIMM and related modeling environment. Platform specific metamodels and modeling tools for the MDD of Java Card and Basic Card applications are given in Sections 4 and 5 respectively. Defined model transformations between general smart card models and Java Card and Basic Card models are discussed in Section 6. Section 7 covers the automatic code generation from platform specific card instance models. Evaluation of the study by considering the lessons learned during the industrial usage of the architecture is reported in Section 8. Related work is given in Section 9. Section 10 concludes the paper.Smart cards are tiny computers with their own processor and memory. For instance, the integrated circuit on a bank credit card is in fact a smart card. Also, subscriber identity modules (SIM), used inside our cellular phones, are smart cards that store subscriber information to use the phones properly. A smart card includes a micro-processor, read-only memory (ROM), random access memory (RAM) and electrical erasable programmable ROM (EEPROM). Operating system of the card is stored in ROM. Similar to the main memories of our desktop PCs, applications run on RAM. Finally, EEPROM stores applications and data while the card is unpowered. Connection points on the card support the input/output and communication with the host computers [1,15]. Fundamental functionality (e.g. commands for interchange, structure of transmitted data packages) and characteristics (such as electrical interface or contact type) for smart cards are defined with ISO/IEC 7816 standards [2].Depending on the usage type, smart cards may be classified as contact or contacless. Contact cards should be inserted in a card reader which is directly connected to a host computer whereas contactless cards do not need to be inserted or contacted physically for operation. Such kind of cards communicates with and is powered by the reader through Radio Frequency (RF) induction technology.Like Transmission Control Protocol/Internet Protocol (TCP/IP) and related data package transmission used in computer networks, there also exists a standard communication infrastructure defined for smart cards again in ISO/IEC 7816 Standards family. Whole communication between a smart card and a host computer (terminal) is provided by the exchange of Application Protocol Data Unit (APDU) packages [2]. A host terminal application sends Command APDU packages and receives Response APDU packages from the smart card. Based on the received command APDU, related application residing in the card is chosen by the smart card operating system and the chosen application now begins to process the received command APDU packages and sends back responses in response APDU packages to the terminal. A command APDU package has a 4-byte mandatory header with the following fields: CLA, INS, P1, P2. In addition to these fields, it may also include data up to 256 bytes.Table 1 lists command APDU fields and their descriptions.A response APDU package is sent by the card to the reader. The package contains a mandatory 2-byte status word and up to 256 bytes of data (Table 2). Status word (SW1 and SW2) denotes whether the requested operation successfully performed or not. For example, hexadecimal 0×9000 value for SW1 and SW2 bytes indicates that the operation has been successfully performed.Both programming interface and structure of the programs stored in the smart cards vary despite the above discussed unique hardware and standard communication protocol. Some of the cards support file systems and allows file-oriented data processing. On the other hand, a group of smart cards includes middlewares that enhance actual read/write operations over different abstractions such as object-orientation. In this section, we discuss a PIMM for smart card applications which enables software developers to model their card software conforming to common smart card data transmission and data storage standards without considering the specifications of programming for different smart card platforms (e.g. Java Card [13]). The preliminary version of the metamodel is introduced in [16].Derivation of the metamodel entities and their relations was performed as the result of a feature-oriented domain analysis. With the collaboration of smart card software developers, both features of smart card software and dependencies among those features were determined. While studying on the features, we also specified the system constraints. Further, the analysis also enabled us to determine mandatory and optional features. For instance, a smart card application should support the APDU protocol and own the required properties for the convenient communication between the host computers. On the other hand, it would be better to have authorization features for accessing the data stored on the card in most of the situations. However it is not a must for all smart card applications. Obtained feature model supported the creation of the smart card PIMM in question.Fig. 1 depicts the proposed common smart card metamodel which is encoded according to the well-known Ecore meta-metamodel included in the Eclipse Modeling Framework (EMF) [17]. Similar to Unified Modeling Language (UML) class diagrams, boxes with compartments represent meta-entities while lines show the associations like inheritance and composition between the card entities. Some of the meta-entity attributes are suppressed in the figure to provide clear reading.The key entity of the metamodel is the Application which represents a smart card program. The platform independent modeling of a smart card software starts with the inclusion of an Application instance. As will be discussed later, platform dependent counterpart of this entity can be an applet for Java Cards or a file definition for Basic Card applications. At least one instance of the Application entity should be included in a smart card application model. Notice that the implementation of such constraints required for the metamodel entities and their relations was provided with using the well-known Object Constraint Language (OCL) [18], [19]. Special OCL rules were written for describing those constraints which also constitute the static semantics for the models.Another important meta-entity is the APDU. Communication between smart cards and terminals is realized over APDU packages. Each communication in an interaction model can be represented with an APDU instance. The metamodel includes two specialization of this meta-entity as expected: CommandApdu and ResponseApdu. Comforming to ISO/IEC 7816 specifications, these APDU types cover proper attributes in our metamodel. For instance, instruction bytes (INS) in a CommandApdu entity manages the instructions that will be executed in the card application. Data and/or notification on a card process are returned by ResponseApdu instances. A ResponseApdu includes a group of SWConditions which define status word types of ISO/IEC 7816 APDU responses.For a smart card application, all needed CommandApdu and ResponseApdu instances are encapsulated within an APDUOperation meta-entity. That entity provides the definition of data types and variables needed during the execution of commands or card operations. The relation between a modeled Application and every added APDUOperation is established over an Including entity.Almost every smart card software requires a user authorization via the input of a valid personal identification number (PIN). Hence a meta-entity called PIN is included in the metamodel. Before the establishment of the connection between the smart card and the host, the value of the PIN should be verified. Terminal sends an APDU including an entered PIN value and the application in the smart card checks that value. Validation of the PIN is mandatory for the execution of successor commands. An Access_key entity in a smart card model associates PIN instance(s) with an Application.Constant and Data entities are used for the definition of information processed in the card application. Each data owns name, type and value attributes. Some fundamental smart card data types are already defined in the model with SCDataTypes entity. These types are “number”, “numberArray”, “string”, “boolean” and “byte”. User defined data types can be included in the models via DataUnit entities. Hence, new data structures can be constructed from the collection of existing data types (e.g. SCDataTypes or again DataUnits). Association of the new DataUnit instances with an Application is realized over an Instance.Now let us consider the modeling of smart card applications according to above discussed PIMM since the MDE of software systems naturally requires a phase in which the modeling of the system is realized. Models are the main artifacts of the development process and software developers should be supported with appropriate modeling tools for the production of these artifacts. Hence, in this study, a set of modeling tools were designed and implemented to support our approach proposed for the MDE of smart card systems.The modeling tools introduced in this paper were developed on Eclipse platform [20] by using the Graphical Modeling Framework (GMF). GMF [21] is a framework for building graphical modeling tools for various domains. In our study, we (1) provide domain models for various smart card environments (including both platform independent and platform specific) as Ecore metamodels, (2) prepare graphical elements representing the smart card domain elements and their relations, and (3) map smart card components with the graphical nodes to generate smart card modeling tools/editors according to GMF specifications.Considering the generation of the modeling tool for our general smart card models, above introduced metamodel naturally presented a base on which the related modeling editor is built. Since we already derived the Ecore encoding of the PIMM, remaining work just covered the tasks given in (2) and (3).The screenshot inFig. 2 shows a fragment from the modeling environment provided by the platform independent smart card modeling tool. Developers can visually model their smart card systems by using the editor palette shown in the right side of Fig. 2. The palette includes the nodes and links that can be used for preparing a smart card application instance model. Each node or link is a graphical element which represents a unique meta-entity of our PIMM. The editor environment also supports developers in model consistency and prevents wrong relation establishments between smart card model elements. Further, constraints on the model entities and their relations (e.g. compartment constraint, number of relations constraints, relationship source and destination constraint, entity-relation consistency constraint) are also checked automatically within the editor environment. As previously mentioned, such constraints were implemented by using OCL [18]. For this purpose, built-in features of the GMF were utilized. The "gmfmap"s were prepared for the components of each Ecore metamodel (both PIMM and PSMMs) in our study. Inside each "gmfmap" description file, OCL constraints can be inserted e.g. for the compartment setting between the top node and the child nodes or creating the link mappings such as association or aggregation. OCL constraints were also written for the determination of the relation types inside Feature-Value expressions.A developer simply drag-and-drops a smart card software component from the palette to the design area, sets the attribute values for the component (if applicable) and associates it with already existing smart card elements according to the above metamodel definitions and constraints. Modeling of a smart card software is started with the inclusion of an Application instance (shown in the upper left of Fig. 2). Successor instances (such as APDUs, PIN, data or smart card operation types) are added into the model by connecting them with proper association links (Instance, Including or Access_key) again based on the metamodel specifications.As can be seen from Fig. 2, some elements such as Application and APDUOperation instances own a set of compartments in order to encapsulate other elements. Hence, an appropriate settlement of the elements is achieved. Furthermore, metamodel constraints for each model element are checked automatically by the editor. These constraints include unique settlement of the elements (e.g. CommandApdu and ResponseApdu elements can only be inserted into an APDUOperation) or the use of the correct association links (e.g. Access_key relation can only be established between a smart card Application and a PIN element). The modeling editor also controls the derivation and use of data variables and constants only inside the suitable elements such as Application and DataUnit.Each model designed in the editor environment is in fact an instance of our PIMM. Fig. 2 also shows such an instance model for a classic e-purse smart card system. Suppose a smart card software is required for an e-purse (wallet) application. In this application, customers use their smart cards during online payment operations. The electronic money transfer is realized based on the customer account information stored on the smart card. The smart card application instance (seen at the left of Fig. 2) provides the storage of the customer account information and user authentication (over a PIN) and includes appropriate smart card operations (modeled as APDU Operations) for e-money transfer (credit / debit) and balance inquiry (getBalance APDUOperation in the model).Today Java Card [13] is perhaps the most preferred type of smart cards and its application programming interface, called Java Card API, is one of the widely chosen software libraries for the development of smart card software. The Java Card technology provides application development for smart cards and other memory-limited devices by using the features of the Java programming language. However only a subset of the Java programming language can be used due to the resource limitations of a smart card. For example, only Boolean, short and byte can be used as primitive data types. Integers, characters and the String class cannot be used. Furthermore multidimensional arrays, dynamic class loading, garbage collection, threads, object serialization and cloning are also not supported in Java Card.A card program written for a Java Card is named as the card applet. Java Card Framework (JCF) supplies the API to develop smart card applications that conform to the ISO/IEC 7816 standards [2]. After a card applet is prepared using the Java Card API, a Converted Applet (CAP) file is formed from the written applet and any other on-card class files needed by this applet. Converter loads this CAP file to the smart card and the interpreter installs the applet encapsulated in the CAP file. After the installation, all the permanent Java objects are created on the card and are ready to use [22].Software developers use the Java packages and classes distributed within the Java Card API for the implementation of smart card applications. However, above discussed restrictions of the API make the development process difficult and time-consuming. In order to cope with those deficiencies, a MDE methodology for the development of Java Card programs is defined in this study. The methodology includes the visual modeling of Java Card programs and then automatic code generation from the prepared system models. For this purpose, we first need a metamodel for describing Java Card entities and their relations. The definition of a M2T transformation originating from this metamodel enables us to automatically generate Java Card software codes. In the following, we discuss the related metamodel and visual modeling of the Java Card software based on this metamodel. M2T transformations defined for the Java Card programs will be later discussed.Based on the specifications of the Java Card API, we derived a metamodel for the Java Card programs. The metamodel includes Java Card components and their associations. According to our approach, the derived metamodel is considered as a PSMM for smart cards within the MDA perspective [7]. We provided a transformation mechanism from the platform-independent smart card metamodel (introduced in Section 3) to this PSMM in order to obtain Java Card platform-specific counterparts of the models conforming to the platform-independent smart card metamodel. Related transformation mechanism will be discussed later in Section 6 of this paper.Like the PIMM discussed in the previous section, derived Java Card metamodel is encoded again according to the Ecore meta-metamodel [17]. That encoding provides the XML Metadata Interchange (XMI) serialization of our Java Card metamodel and hence the metamodel can be employed in various M2M transformations as source or target metamodels.Fig. 3 depicts the derived Java Card metamodel. Some of the entity attributes are omitted for clarity.The key entity in the metamodel is the Applet. An applet is a Java Card program residing on a smart card. It receives incoming requests from the host, processes the request and responses back to the host program. The APDU meta-entity in our metamodel represents packets of data that conform to the specifications of the ISO/IEC 7816. As discussed before, an APDU can be a command or a response APDU. In Java Card technology, the host application sends a command APDU and a Java Card applet responds with a response APDU. In fact, a Java Card applet remains idle until it receives a command APDU.The PIN, as its name denotes, provides an interface for declaring passwords for the authorized access to the smart card programs. The OwnerPIN is a concrete implementation of the PIN interface. It maintains the PIN value, the maximum length of PIN allowed, the maximum number of times an incorrect PIN can be presented before the PIN is blocked and the remaining number of times an incorrect PIN presentation is permitted before the PIN becomes blocked. Java Card API provides a ready-to-use class for this PIN implementation with the same name. So, the OwnerPIN is also represented with a meta-entity in the proposed Java Card metamodel. The traditional way is to provide an attribute with type OwnerPIN for each Java Card applet. Properties (e.g. maximum length and maximum try limit) of this PIN are set when the applet is installed into the smart card. Before opening a communication session between the host application and the Java Card applet, the verification of the entered PIN is performed inside the smart card: The host application sends an APDU containing a PIN value; the applet processes that PIN value and checks whether the PIN is valid. The session is not opened until the PIN is verified.The upper part of Fig. 3 consists of the meta-entities representing the base of the JCF. It resembles the metamodel of the core of the Java programming language with the definition of classes, parameter types, fields and methods. The relations between the Java Card classes (Association, Aggregation, Generalization and Implements) are also given in the metamodel. However, we organize the metamodel as it reflects the restrictions originating from the use of just a subset of the Java programming language for the Java Card. For instance, JClass represents the Java class entity for the JCF which is the base class for all Java Card classes (e.g. Applet, APDU and any user-defined Java Card classes). We introduce JClass meta-entity as a limited version of a classic Java Class with inabilities such as it cannot be cloned or serialized. Likewise, primitive data types in Java Card API (JCDataTypes) are restricted with only three primitive data types: byte, short and Boolean. These primitive types are represented in the metamodel with JCByte, JCShort and JCBoolean meta-entities. Representations of the exception types specific to the Java Card (e.g. PINException, APDUException) are also included in the metamodel.The derivation of the Java Card metamodel has allowed us to develop another modeling tool for smart card software development. By following the development steps discussed in Section 3, a GMF-based tool has been produced. The screenshot given inFig. 4 shows the modeling environment presented by this tool. Again a developer can simply drag-and-drop a Java Card software component from the palette to the design area, sets the attribute values for the component and associates it with already existing smart card elements according to the Java Card metamodel definitions and constraints. All attributes of the smart card components can be set by using the properties tab of the editor (shown at the bottom of Fig. 4).A huge number of attributes can also be set or altered graphically on the model (e.g. type and cardinality of association links). Associations and attribute settings that violate the specifications and the restrictions of the Java Card metamodel are detected and prevented by the editor. For instance, if a ParamType or a Field instance is in array type, more than one dimension is not allowed for this defined array since multidimensional arrays are not allowed in Java Card programs. Other examples for the violation check can be listed as follows: Field and Method instances can only be inserted into the instances of JClass, Applet and OwnerPIN. The initial value of an OwnerPIN instance׳s attribute for the remaining number of incorrect PIN trials should be equal to the value of the same instance׳s attribute for the maximum number of incorrect PIN entries.Fig. 4 also includes the Java Card instance model for our sample purse application introduced in Section 2. The Java Card applet ("PurseApplet"), seen at the center of Fig. 4, provides secure storage of the customer account information and includes appropriate methods for user authentication and e-money transfer (debit/credit). Other required Java Card components for the program (e.g. Purse, pursePIN) and their relations with the main applet class are also included in the model. Purse object, that will be stored in the smart card, includes balance information for a user. Instance fields and methods for the Purse object are encapsulated in proper compartments during the system modeling in the editor. Based on the received command APDUs, PurseApplet calls proper getter/setter methods of the Purse object and sends response APDUs to inform host application for the result of the operations. To keep simplicity, the complete definition of applet methods required for processing all command APDUs is not given in the current instance model. Also Java Card components needed for the exception mechanism are omitted in the model.ZeitControl Basic Card [14] (hereafter referred to as Basic Card) is another programmable smart card. It fully supports the smart card communication protocol defined in ISO/IEC 7816 standards [2]. The operating system of the Basic Card consists of a directory-based, PC-like file system. The built-in chip of the Basic Card has lower memory resources comparing to other smart card technologies (such as Java Card). However, this also causes Basic Card to be cheaper than other cards.The Basic Card programs are written in a special programming language called ZC-Basic Language [14], a dialect of the Basic language. That language is naturally not object oriented and each written program for Basic Cards is usually made up of a single code file in which the whole functionality needed for all card processing and host communication operations is defined as a set of Basic procedures. Similar to the Java Card׳s CAP conversion mechanism, a Basic Card program is converted to an image file (with .IMG extension) and uploaded to the Basic Card.To provide MDE of Basic Card software in the defined MDA, again we need a metamodel for Basic Card programs and provide a development environment in which both visual modeling of Basic Card software and auto-generation of program codes are easily performed. In the following, we discuss these ingredients for the proposed methodology.First of all, we derived the required metamodel from the structure of Basic Card programs. The metamodel describes the building blocks (data types, functions, subroutines, etc.) of a Basic Card program and relations between these blocks.Fig. 5 depicts the Ecore encoded Basic Card metamodel. Entity attributes are not shown here again for the sake of simplicity.Similar to the Java Card metamodel, the metamodel for Basic Card is considered as another PSMM in our MDE approach. Hence another set of model transformations were defined from the platform-independent smart card metamodel (introduced in Section 3) to this PSMM in order to obtain Basic Card platform-specific counterparts of the models conforming to the platform-independent smart card metamodel. Related transformation mechanism will be later discussed in Section 6.The ZCardProgram meta-entity (shown in the bottom-left of Fig. 5) is the representation of a Basic Card source program. A ZCardProgram is composed of program attributes, card initialization code, card operation procedures and references to external file(s) and definition file(s). The card initialization is the first block of code that is not contained in a procedure definition.A BasicMember in the model represents any unit of a Basic Card program (e.g. a command, a function or a parameter). A Basic Card procedure definition can be a Function, a Subroutine or a Command. A function returns a value to the caller whereas a subroutine does not return a value but carries data through its arguments. A Command is defined like a subroutine, however, two ID bytes should be specified as well. These ID bytes represent the command that will be invoked later by the card.Data types for variable and parameter declarations can be String, floating-point, single (4 byte single precision number), long, integer and byte in ZC-Basic Language. Hence, in the proposed metamodel, we define corresponding meta-entities (e.g. BasicString and BasicFPoint) and an enumeration for these types, called DataTypes. Constants for the declaration of command types are encapsulated in a DefinitionFile. Such definition files are included at the beginning of a Basic Card program. Also other source files, represented with the IncludeZCardProgram entity in the metamodel, can be included by the main card program.The Persistence meta-entity denotes the storage type and access rights of a data field in a Basic Card. Four flags (EEPROM, public, private and static) are defined in ZC-Basic Language for this purpose and any Persistence instance conforming to our metamodel stores values of each of these flags for a specific data field.As expected, another visual modeling editor, based on the above metamodel of Basic Cards, has been developed for the Basic Card programmers (Fig. 6). Fig. 6 also includes the Basic Card instance model for our sample purse application introduced in Section 3. The elements in the model constitute a ZCardProgram which stores the related customer account information and includes appropriate Basic Card commands, subroutines and functions designed for electronic money transfer. The program has the same functionality with the previously discussed Purse applet. Instances for command definitions and required program attributes of the ZCardProgram are also included in the model.Sendall and Kozaczynski [23] describe model transformation as the heart and soul of model driven software development. Indeed, definition of metamodels is required but not sufficient for a complete MDE process. We have to define transformations between those metamodels to obtain the main artifacts of the process: target models. We define transformations between the aforementioned platform independent and platform specific smart card metamodels and apply those transformations where generic smart card models conforming to the PIMM discussed in Section 3 are accepted as the source models and their platform specific counterparts (target models) conforming to the specifications of Java Card or Basic Card metamodels are automatically achieved.In fact, benefits of the definition and application of the model transformations on generic smart card models are twofold. (1) We provide an operational semantics for the generic smart card models designed according to the PIMM since the models can be transformed into the models of card execution platforms such as JCF or Basic Card environment. (2) Developers model their card applications by just concentrating on the smart card domain without dealing with the specifications of various card platforms and later they obtain real implementations of their designed models by first the application of the model transformations and then code generation.Entity mappings between our smart card PIMM and Java Card and Basic Card PSMMs pave the way for the definition and implementation of the model transformations that are applied on platform independent smart card model instances at runtime in order to obtain their counterparts in real smart card infrastructures. Mappings, which we determine between smart card PIMM and PSMM entities, are in n-to-m manner. That means n number of PIMM entities can be mapped to m number of Java Card PSMM entities (or k number of Basic Card PSMM entities).Table 3 lists some of these mappings. For instance, Application entity of the PIMM is mapped to Applet in Java Card PSMM and DefinitionFile in Basic Card PSMM. On the other hand, APDUOperation, CommandApdu and ResponseApdu of PIMM are mapped to Method of Java Card PSMM and Command of Basic Card PSMM.After determination of the entity mappings between PIMM and above discussed target PSMMs, we need to provide model transformation rules which are applied at runtime on platform independent instances to generate platform specific counterparts of these instances. For that purpose, transformation rules should be formally defined and written according to a model transformation language. To this end, many languages are proposed (e.g. [24–27]). In this study, we prefer to use ATL Transformation Language (ATL) to define required model transformations. ATL [27] is one of the well-known model transformation languages which is specified as both a metamodel and a textual concrete syntax. An ATL transformation program is composed of rules that define how source model elements are matched and navigated to create and initialize the elements of the target models. Besides, ATL can define an additional model querying facility which enables to specify requests onto models [28]. ATL has a transformation engine and an integrated development environment (IDE) that can be used as a plug-in on Eclipse platform [29]. Finally, ATL can be used on the metamodels that conform to Eclipse Ecore meta-metamodel. Those features of ATL caused us to prefer ATL as the implementation language for the transformations between our platform independent and specific smart card models.To give some flavor of the written transformations, some of the defined rules are discussed in here. For instance, Listing 1 includes a fragment of the ATL rule written for the transformation of platform independent smart card application instances into Java Card applets. While transformation rules are being defined, source and target metamodels must be indicated in ATL code as shown in lines 2 and 3 of Listing 1. This information is also given in the properties of the created ATL project on Eclipse platform. As shown in Listing 1, "SmartCard.ecore" file is the input metamodel for transformation rules (denoted with “IN” keyword in line 4) and "Javacard.ecore" file is the output metamodel (denoted with “OUT” keyword in line 4).Listing 1A fragment from the ATL rule for the transformation of smart card application instances into Java Card applets.01module SmartCardtoJavaCard;02-- @path MM=/SmartCard/model/PIMModel/SmartCard.ecore03-- @path MM1=/SmartCard/model/PSMModels/JavaCard/Javacard.ecore04create OUT: MM1 from IN: MM;0506rule Application2Applet{07from08appl: MM!Application09to10applet: MM1!Applet(11name <- appl.name,12fields <- Sequence{appl.constants, appl.datas},13methods <- appl.getAssociations())14...15}"Application2Applet" rule will execute on a platform independent smart card model and for each Application instance (Listing 1, line 8), it will generate a corresponding Java Card Applet (line 10). In order to provide that generation, data and constants of the application are transformed into instance fields of an applet object by executing some inner rules (line 12). For example, during transformation of each data in the application into a field in the applet, "Data2Field" rule, shown in Listing 2, is executed. Every data attribute is converted into a field attribute (lines 6–11 of Listing 2). Default values for the unmapped attributes are also given (e.g. "static" and "final" are specific to the Java Card so just default values are given (lines 7 and 9 of Listing 2) instead of a transformation since there is no counterpart in the PIMM for these attributes).Listing 2Rule for the transformation of application data into Java Card applet fields.01rule Data2Field{02from03dts: MM!Data04to05flds: MM1!Field(06name <- dts.name,07static <- true,08comment <- dts.comment,09final<- false,10dataType <- dts.getDataType(),11IsArray <- dts.IsArray())12}It is worth noting that some helper rules are used during entity transformations. These helpers are the realization of the constraints to query the source models. The constraints in ATL are specified with using OCL [18,19]. Same helper rules and constraint repetitions may be required both for other rules in the same target model transformation or other platform specific model transformations (e.g. for Basic Card). Hence this kind of rule decomposition makes the definitions easier. The helpers correspond to the constraint part of the related rules. There are two types of helpers in our transformations. The first type helpers are used to check if the smart card model element is the part of the required pattern or not. The second type helpers are used to select the smart card elements for creating relations between target elements. For example, as a second type helper, the execution of "getDataType" helper rule in line 10 of "Data2Field" rule (in Listing 2) provides the determination of the appropriate Java Card data type for the source data. A fragment from that helper rule is given in Listing 3. Likewise, execution of "getAssociations" helper rule in line 13 of Listing 1 creates Java Card applet methods for APDU operations modeled in the platform independent smart card model while "IsArray" helper rule returns Boolean true value when it encounters a string or a number array in the smart card application model.Listing 3A fragment from getDataType helper rule.01helper context MM!Data def: getDataType(): String =02if (self.type = #number)then ׳JCShort׳03else if (self.type = #string)then ׳JCByte׳ endif04else if (self.type = #boolean)then ׳JCBoolean׳ endif05else if (self.type = #byte) then ׳JCByte׳ endif06…07endif;In order to transform platform independent smart card software models into file-oriented Basic Card program models, another group of transformations is defined between the entities of PIMM and Basic Card PSMM and they are written in again by using ATL. For example, "SmartCard2BasicCard" rule given in Listing 4, creates a Basic Card program with all required components based on the transformation from a platform independent SCProject into a Basic Card ZCardProgram. Basic Card commands corresponding to APDUs, DefinitionFile(s) for each smart card Application instances and other remaining attributes are all determined and set by processing the source model (lines 12–16 in Listing 4).Listing 4The ATL rule for the transformation of platform independent smart card software instances into Basic Card programs.01module SmartCardtoBasicCard;02-- @path MM=/SmartCard/model/PIMModel/SmartCard.ecore03-- @path MM1=/SmartCard/model/PSMModels/BasicCard/BasicCard.ecore04create OUT: MM1 from IN: MM;0506rule SmartCard2BasicCard{07from08smartCard: MM!SCProject09to10basicCard: MM1!ZCardProgram(11name <- smartCard.title,12commands <- Set{MM!APDUOperation.allInstances()->13select(a|a.oclIsKindOf(MM! CommandApdu) = false)},14attributes <- Set{MM!PIN.allInstances()->15select(a|a.oclIsKindOf(MM! APDUOperation) = false)},16defFile <- Set{MM!Application.allInstances()}17)18}Although both the graphical modeling and M2M transformations may facilitate the development of smart card software systems, it is not sufficient for real life implementations of such systems. Proposed software development methodologies should provide a step in order to assist developers for code generation. Within this perspective, various M2T transformations for each platform specific smart card framework are designed and implemented in this study.We implement the related transformations by using the MOFScript [30]. MOFScript is a language specifically designed for the transformation of models into text files and it deals directly with metamodel descriptions as input. Also, it provides a tool as an Eclipse plug-in and hence MOFScript transformations can be written and directly executed inside the Eclipse environment. Taking into account all these advantages, we chose MOFScript as the implementation language for the M2T transformations that produce program codes for smart card applications.The output smart card system models, achieved as the result of applying M2M transformations discussed in the previous section, now become the inputs of the defined M2T transformations. When a developer completes the visual modeling of a platform independent smart card system and executes above discussed M2M transformations to obtain that model׳s platform specific (Java Card or Basic Card) counterparts, the Ecore representation of the output model is stored in a file. The MOFScript engine applies our M2T transformations on this file and produces smart card program codes for the related application. It is worth noting that a developer may prefer to work just in the platform specific level and visually model a platform specific card application (e.g. a Java Card applet) by using the appropriate platform specific modeling editor(s) (introduced in Sections 4 and 5 of this paper) and finally that model can directly be accepted as an input for the M2T transformations to generate codes.An excerpt from the prepared MOFScript transformation for Java Card programs is given inFig. 7. This text transformation uses the metamodel of the Java Card discussed in Section 4. The transformation, in here, reads a Java Card system model, determines each Applet instance and generates codes for each Applet class. Codes for each Java Card component are generated according to the rules and constraints of the Java Card programming language. These auto-generated program codes are ready to be both compiled and converted to the CAP format.Transformation script, given in Fig. 7, first controls whether the applet instance implements any interface and generates required Java Card codes. Later instance fields of the applet are determined and codes for their visibility, modifiability and type are generated based on the input model. For each attribute, their type (object reference, array, JCByte, JCShort, etc.) are set. However the amount of scripts required for that transformation is too big to be included here and hence it is not completely shown in Fig. 7. In the next step, generation of the install method for the applet takes place. As its name already denotes, codes required for the installation of the software on the smart card are generated in here (see the middle part of Fig. 7). Scripts for APDU command detection and process selection are shown at the lower part of Fig. 7. Reaction of the applet for each received command is determined in the process method of the applet. So, related transformation provides automatic generation of the process method’s body. At the bottom part of Fig. 7, code generation scripts for remaining methods of the applet are shown. However, full listing of scripts prepared for the generation of both process and other methods needs much more space and hence not discussed in this paper.Fig. 8 includes an excerpt from the auto-generated code of the example Purse applet previously discussed in Section 4. The transformation engine applies the transformation on the Java Card model of the e-purse application and Java class files belonging to each model component are achieved. For instance, excerpt in Fig. 8 includes some of the auto-generated codes of Purse applet for hexadecimal APDU processing and packet control. Application of the transformation, shown in Fig. 7, outputs the JavaCard applet body including applet instance fields, constructor, install, process and remaining APDU methods.In this study, another M2T transformation was defined and written in MOFScript for the generation of Basic Card programs according to the ZC-Basic Language. The serialized Basic Card models (in Ecore) are processed by the transformation engine and written rules are applied on these models to generate ZC-Basic codes. InFig. 9(a), an excerpt from the MOFScript transformation for Basic Card is given.By using the script (Fig. 9(a)), external definition files and card command procedures for a ZCardProgram are determined in a Basic Card model. ZC-Basic codes for each determined model element are generated. For instance, ZC-Basic code of our example Purse program is automatically generated when the model depicted in Fig. 6 of this paper is given into this transformation. Fig. 9(b) includes an excerpt from the auto-generated ZC-Basic code of our example Purse program. Generated codes also include subroutines and functions but they are not shown in the figure to keep simplicity.

@&#CONCLUSIONS@&#
