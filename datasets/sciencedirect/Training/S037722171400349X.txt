@&#MAIN-TITLE@&#
Single-commodity robust network design problem: Complexity, instances and heuristic solutions

@&#HIGHLIGHTS@&#
Robust network design problems with a discrete set of supply/demand scenarios.Complexity of special cases and characterization of the difficulty of the instances.Generation of difficult random instances.Heuristic solutions based on Large Neighborhood Search.

@&#KEYPHRASES@&#
Robustness,Network design,Complexity,Heuristic,Proximity search,

@&#ABSTRACT@&#
We study a single-commodity Robust Network Design problem (RND) in which an undirected graph with edge costs is given together with a discrete set of balance matrices, representing different supply/demand scenarios. In each scenario, a subset of the nodes is exchanging flow. The goal is to determine the minimum cost installation of capacities on the edges such that the flow exchange is feasible for every scenario. Previously conducted computational investigations on the problem motivated the study of the complexity of some special cases and we present complexity results on them, including hypercubes. In turn, these results lead to the definition of new instances (random graphs with {−1,0,1} balances) that are computationally hard for the natural flow formulation. These instances are then solved by means of a new heuristic algorithm for RND, which consists of three phases. In the first phase the graph representing the network is reduced by heuristically deleting a subset of the arcs, and a feasible solution is built. The second phase consists of a neighborhood search on the reduced graph based on a Mixed-Integer (Linear) Programming (MIP) flow model. Finally, the third phase applies a proximity search approach to further improve the solution, taking into account the original graph. The heuristic is tested on the new instances, and the comparison with the solutions obtained by Cplex on a natural flow formulation shows the effectiveness of the proposed method.

@&#INTRODUCTION@&#
Network design problems arise in many different areas, such as transportation and telecommunication. Recently, the class of robust network design problems has received increasing attention. The term robust can represent the capability of the network to cope with disruptions or to deal with different traffic scenarios in different times of the day, as is the case of our work.In this paper, we study the single-commodity Robust Network Design problem (RND) defined as follows. We are given an undirected graphG=(V,E), a cost vector(ce)(e∈E)and an integer balance matrixB=(biq)(i∈V,q=1,…,K). The qth rowbqof B is called the qth scenario.For a given scenario, we call a node with nonzero balance a terminal. More specifically, a node i with positive balance is called a source and we call the balance of i its supply. A node with negative balance is called a sink and its balance is called demand.Let us denote by(i,j)and(j,i)the arcs (directed from i to j and from j to i, respectively) corresponding to edgee={i,j}∈E. In addition, let us callfi,jq∈Z+the integral amount of flow that is sent along arc(i,j)from i to j in scenario q and byfqthe corresponding flow vector.RND calls for determining integer capacities(ue)∈Z+|E|(e∈E)with minimal costscTusuch that, for each q(q=1,…,K), there is a directed network flowfqin G that is feasible with respect to the capacities and the balances of the qth scenario. In particular, the flowfq(q=1,…,K) must fulfill the following constraints:1.fi,jq+fj,iq⩽uefor all edgese={i,j}∈E, which imposes that the sum of the flows going along every edge (in both directions) must respect the installed edge capacity, for every scenario.∑{i,j}∈E(fi,jq-fj,iq)=biqfor all nodesi∈V, which implies that the flow must satisfy the required integer balances.An overall natural model for RND reads as follows(1)min∑{i,j}∈Ecijuij(2)∑j:{j,i}∈Efjiq-∑j:{i,j}∈Efijq=biq∀i∈V,q=1,…,K(3)fijq+fjiq⩽uij∀{i,j}∈E,q=1,…,K(4)fijq⩾0∀{i,j}∈E,q=1,…,K(5)uij∈Z+,∀{i,j}∈Ewhere the objective function (1) is to minimize the total cost of the installed capacities. Constraints (2) ensure flow-conservation in each scenario and impose to satisfy the required balances. Constraints (3) model that the capacity of an edge is at least as large as the flow it carries. Integral flows are enforced through integrality of the capacity variables, as all balances are integral (Ford & Fulkerson, 1957).As described in Buchheim, Liers, and Sanità (2011), an example of a practical application of the considered problem is the following: some clients wish to download some programs stored on several servers. For a client, it is not important which server he or she is downloading from, as long as the demand is satisfied. In other words, we consider servers that store identical data: examples are video on demand or large data centers in which one mirrors his data over several locations. This is opposed to multi-commodity network design, in which point-to-point connections are considered, i.e., each client requests a specific server. In addition, we consider the robust version of the problem: at different times of the day, the demands may change (e.g., different clients show up), and the goal is to design a network that is able to route all flow in all different scenarios. In particular, we consider a finite list of demands, i.e., we sample different times of the day.Contribution of the paper. Preliminary computational investigations have been performed on classical graphs from the literature with random balances (Buchheim et al., 2011) and on special hypercubes with{-1,0,1}balances (Álvarez-Miranda et al., 2012). The results in both papers have shown that the former instances are surprisingly easy for a general-purpose Mixed-Integer Programming (MIP) solver on the natural flow-formulation (1)–(5), while the latter instances are structurally difficult. The first contribution of the paper is in studying the complexity of some RND special cases1The RND problem is strongly NP-hard (Sanità, 2009).1associated with the above instances and enlightening the reasons of the observed computational behavior. Second, based on the complexity results, we propose a new family of randomly generated RND instances that are computationally challenging for the natural flow formulation already for|V|=50andK=10. Third, motivated by those instances (available upon request from the authors), we propose new Matheuristic approaches that provide high-quality approximated solutions for large graphs (tests are reported for|V|up to 500) in short computing times.2A preliminary version of the heuristic approaches described here was introduced in Álvarez-Miranda et al. (2012) where the first phase of the investigation on RND, which was the topic of the “Vigoni 2011–2012” project between the University of Köln and the University of Bologna, was summarized.2The motivation for developing Matheuristic methods, i.e., optimization algorithms made by the interoperation of Metaheuristics and Mathematical Programming (MP) techniques, instead of classical Metaheuritic relies on the possibility of working with a MP model. This allows, in general, the exploitation of effective and reliable software for solving sub-problems as, for example, the local search MIP neighborhoods, and guarantees a certain flexibility in accommodating modifications and extensions to the original version of the problem.Organization of the paper. Section 2 reviews the (vast) related literature by pointing out differences and similarities. In Section 3 we present the complexity results we achieved on special classes of instances, while Section 4 describes the proposed heuristic algorithm and its performance is reported in Section 5. Finally, in Section 6 we draw conclusions and describe ideas for future research.The work on classical (i.e., non-robust) network design goes back as far as the early 1960s where it was studied by Chien (1960) and Gomory and Hu (1961, 1962). Since then, network design has evolved to a vast field of research which we cannot fully discuss in the scope of this article. We rather refer to Chekuri (2007) for a complete overview and restrict ourselves to a few exemplary related works that are of direct importance for us here.The common theme of network design problems is installing optimum-cost capacities in a given network topology such that a set of traffic requests can be routed through the network. In practice, however, the traffic requests are not exactly known in advance. This can be due to measuring errors or simply because they cannot be predicted (Ben-Tal & Nemirovski, 2000). Here, the robustness comes in: Following an idea by Soyster (1973), Ben-Tal and Nemirovski (1999) coined the term of an uncertainty set that is added to the model and contains all possible (or likely) scenarios against which the robustness should protect.In particular, they consider ellipsoidal uncertainty sets. Bertsimas and Sim (2004) introducedΓ-robustness as a general model for robustification in MILPs. They consider a polyhedral uncertainty set where the parameterΓis used to control the number of coefficients that can simultaneously assume different values from the nominal ones in each constraint. Since then, robust network design has been very actively studied. The notions of network topology, cost, capacity, traffic request and routing can vary – as well as the exact way in which the problem is robustified.In this paper, we study a worst-case robust model in the sense of Ben-Tal and Nemirovski (1999). This means that our solutions must be feasible for all the scenarios from the uncertainty set. The uncertainty set is finite and explicitly given as part of the input (an idea that goes back to Minoux (1981)). We use an undirected graph as the network topology and allow dynamic routing (each scenario may be routed on different paths). Furthermore, we assume linear costs for the capacities and integer multiples of a unit capacity may be installed on each edge. Each node specifies its traffic request by a scalar number that gives its supply or demand and each such traffic request may be routed on an arbitrary number of paths (the routing is splittable) as long as each edge carries an integer amount of flow in total. Therefore, the underlying flow model is a standard single-commodity, splittable network flow in our case.To the best of our knowledge, only two prior publications on this specific problem exist. The problem was first studied by Buchheim et al. (2011). They gave an exact branch-and-cut algorithm that solves a flow-model MIP through sophisticated general-purpose cutting planes. Lately, Álvarez-Miranda et al. (2012) introduced a capacity-based MIP-model, and discussed a preliminary set of results of the biennial “Vigoni 2011–2012” between the universities of Köln and Bologna.Atamtürk (2000) considers a variant of the non-robust single-commodity network design problem where integer multiples of a facility with fixed capacity can be installed on each arc. Ortega and Wolsey (2003) report on the performance of general MIP solvers on various network design problems and develop an exact algorithm for the single-commodity fixed-charge network design problem (all arcs may be bought at a fixed-charge and then be used at full capacity).A close variant of single-commodity RND is the multi-commodity robust network design problem. Here, the traffic requests specify the amountdijof flow that should be exchanged among all pairs of nodes i and j. In particular, this defines fixed source/sink pairs – which is not the case in our problem. Also, each commodity has a single source (or sink). While this condition can also be established in the single-commodity case, it requires the use of fixed-capacity edges and therefore, our single-commodity variant is not a true special case of the multi-commodity problem. Sanità showed in her doctoral thesis (Sanità, 2009) that the multi-commodity variant is NP-hard even if there are only three scenarios, all scenarios use a unique source node and all demands are from{-1,0,1}. This immediately implies that the single-commodity variant is NP-hard as well. The thesis contains many further complexity results; among others Sanità gives aO(log|V|)-approximation for the multi-commodity robust network design problem with unsplittable routing and shows that removing the integrality constraint from the capacities makes the problem polynomial time solvable. This is also true for the single-commodity RND. The multi-commodity RND was also first considered as a classical (non-robust) problem (Bienstock, Chopra, Günlük, & Tsai, 1998).A vast variety of problems exists in the multi-commodity case. The case where the uncertainty set is finite was studied by Minoux (1981), though fractional capacities are assumed in Minoux (1981) and Labbé, Séguin, Soriano, and Wynants (1999). Duffield et al. (1999) introduced the Hose uncertainty model in which the uncertainty set is defined by inflow and outflow bounds on all nodes. Ben-Ameur and Kerivin (2005) observed that this type of uncertainty set is a polytope and developed an exact approach that additionally assumes static routing (i.e., in all scenarios, the flow must be routed along the same subset of pathsand using the same percentage splitting). This configuration is also known as the Virtual Private Network problem. An exact approach for this problem was given in Altın, Amaldi, Belotti, and Pınar (2007) under the additional constraint that each commodity may only use a single path (unsplittable routing). The polytope of Bertsimas and Sim (2004) has also been used in the context of multicommodity robust network design (see, e.g., Koster, Kutschka, & Raack (2013)) in which static routing is considered. In the case of dynamic routing, an exact approach by Mattia (2013) exists.Finally, one of the most basic network design problems, the Steiner Tree problem, is the special case of the single-commodity robust network design problem where for each pairi,jof Steiner nodes, there exists a scenario in which exactly i and j are terminals with supply/demand of1/-1. If not all the Steiner node scenarios are present, the single-commodity RND instance is instead a special case of the survivable network design problem. Note, however, that, in general, RND does not consider the requirement of disjointness that is in Survivable Network Design. We refer the reader to Kerivin and Mahjoub (2005) for an extensive survey on this subject.In this section, we characterize the complexity of some RND special cases. The RND case in which we have a single scenario (K=1) corresponds to a standard polynomial time minimum cost flow problem. Already forK=3, RND is NP-hard (see Sanità, 2009): the reduction comes from the 3-Dimensional Matching Problem for the special case of RND in which there is the same source in each scenario and balances are{-1,0,1}.Motivated by the computational investigations in Buchheim et al. (2011) and Álvarez-Miranda et al. (2012), in the following, we analyze some special cases:•RND with balances different from 1 and from −1.RND on hypercubes with all balances equal to 1, 0, or −1.RND on hypercubes with all balances equal to r, 0, or-r, with r integer and>1.The analysis is intended to show some classes of hard instances and some classes of easier instances. According to the results that we present in the following subsections, we are able to get a better understanding of empirical results in Buchheim et al. (2011) and Álvarez-Miranda et al. (2012), and we propose a family of randomly generated instances that are challenging for the natural flow formulation already for|V|=50andK=10.Because instances defined on random graphs with random integer balances on the (randomly chosen) terminals turn out to be surprisingly easy for a general-purpose MIP solver on the natural flow-formulation (1)–(5), a natural question to ask is if this special case remains NP-hard. The following theorem answers positively through a reduction from Hamiltonian cycle (Sanità, 2013).In order to prove that RND, defined on graphG=(V,E)(|V|⩾3), with balances different from 1 and from −1, is NP-hard, let us define the following RND instanceIR. We use G without modifications and install a cost of 1 on each edge. We choose some arbitrary numbering of the nodes. We install|V|-1scenarios. In scenario i, only nodes 1 andi+1are terminals; node 1 gets a balance of 2 while nodei+1has a balance of-2.Theorem 1A graphG=(V,E)(with|V|⩾3) has a Hamiltonian cycle C if and only if thedescribed RND instanceIRhas a solution with cost equal to|V|.If G has a Hamiltonian cycle C, we build a feasible solution forIRby installing a capacity of 1 on each edge of C. In each scenario i, both unique terminals 1 andi+1lie on C. The nodei+1decomposes C into two pathsP1,P2from 1 toi+1(one clockwise, one counterclockwise). We can route one unit of flow onP1and one unit of flow onP2, satisfying the demands of scenario i. Thus, our solution forIRis feasible and additionally, it has cost of|C|=|V|.On the other hand, suppose we have a solution forIRof cost|V|. By our choice of scenarios (we have a single source at node 1 and all other nodes are terminals in some scenario), each node must be connected to node 1. Therefore, any feasible solution forIRmust have a support S that induces a connected component of G containing all nodes. S must contain at least|V|-1edges, otherwise it cannot be connected. If S contains exactly|V|-1edges, a capacity of 2 must be installed on each edge in S in order to route all demands. However, such a solution has cost of2·|V|-2>|V|and therefore S must contain at least|V|edges. If some node inG[S]has a degree of 1, then we must install a capacity of 2 on its unique incident edge. By the same argument as before, the remaining nodes|V|-1nodes must be connected by at least|V|-1edges. Then again, the cost of the solution is at least|V|-1+2>|V|. Therefore, all nodes inG[S]must have a degree of at least 2 and because we can have at most|V|edges in S, each node must have exactly degree 2. Together with our observation thatG[S]is connected and contains all nodes, we have a Hamiltonian cycle.□In Álvarez-Miranda et al. (2012) a structurally difficult class of instances for RND is defined. This class is based on d-dimensional hypercubes. In the following we repeat the construction.Definition 2A d-dimensional hypercubeHdis the result of the following recursive construction:H0is the graph that consists of a single node. Ford>0,Hdis obtained by duplicating the nodes and edges ofHd-1and connecting each node v to its copyv′with an additional edge{v,v′}.We say that two nodesv,ware diagonally opposite onHdiff the shortest path from v to w inHdhas maximum length, i.e.,length d.Notice that for every node v inHdthere is exactly one nodevothat is diagonally opposite to v. It is well-known thatHdhasNd≔2dnodes andMd≔d·2d-1edges.We can now define a class of instances on d-dimensional hypercubes as follows. Ford∈Z+, consider the following instanceIdof the RND problem onHd. Observe thatHdis composed of two hypercubesHs,Htof dimensiond-1. Add2d-1scenarios toHd. In scenario1⩽q⩽2d-1, assign a supply of 1 to the qth nodevq(in some fixed numbering) ofHsand a demand of-1to its diagonally opposite nodevqowhich lies inHtby our construction. Set all other balances of scenario q to zero and set the costs for each edge to 1. Fig. 1shows the construction.We denote the instance obtained in this way byHd1. Scaling all balances inHd1byr∈Z+, we obtain the instanceHdr.It is shown in Álvarez-Miranda et al. (2012) that this class of instances is difficult for MIP-based solution approaches as the integrality gap (i.e., the ratio of an optimum integral solution value and an optimum fractional solution value) ofHd1converges to 2 asd→∞. We refer the reader to Álvarez-Miranda et al. (2012) for details.We characterize the integrality gap forr>1. The optimum values for integer and fractional solutions are the same, i.e., the integrality gap is 1. This is shown by Theorem 8 but we need the following series of Lemmata to formally state and prove the result.It is a well-known fact thatHdis hamiltonian for anyd⩾2and we shall use this fact on several occasions. In particular, we can obtain a feasible integer solution forHd2by installing a capacity of 1 on each edge of a Hamiltonian cycle inHd2.Lemma 4For anyd⩾2, there is a feasible integer solution forHd2with costs2d.To derive the cost of this solution, recall thatHdhas2dnodes. Similarly, we can state a feasible integer solution forHd3.Lemma 5For anyd⩾3, there is a feasible integer solution forHd3with costs3·2d-1.Letd⩾3. ThenHddecomposes into two copiesH1,H2ofHd-1and a set of edges F connectingH1andH2. We install a capacity of 1 on each edge in F. Sinced-1⩾2, we find Hamiltonian cyclesC1,C2inH1andH2, respectively, and install a capacity of 1 on each edge ofC1and ofC2.This solution is feasible: For any scenarioi∈{1,…,q}, letsi,tibe the corresponding terminal pair. We need to route three units of flow fromsitoti. To do that, letsi′∈H2andti′∈H1be the unique nodes such thate1={si,si′}∈Fande2={ti′,ti}∈F. Also, lete3={u,v}∈Fwithu∈H1andv∈H2be an arbitrary connecting edge that is different frome1and frome2. Mark here that F contains at least four edges becaused⩾3. Fig. 2shows an example for the situation onH43. Now, by sending one unit of flow over each ofe1,e2,e3, we have reduced the instance to two instances onHd-1: The first instance is defined onH1; here,sihas a balance of 2 and both u andti′have a balance of-1. However, these balances can be routed along the HamiltonianC1. In the second instance, which is defined onH2, the sinktihas a balance of-2and bothsi′and v have a balance of 1. Again, these balances can be routed along the Hamiltonian cycleC2.BothC1andC2contain exactly2d-1edges, each with capacity 1. There are2d-1edges in F, all of them having capacity 1. This gives a total cost of3·2d-1.□We show next that we can construct an integer feasible solution for anyHdrusing the two previous ones.Lemma 6Letd⩾2and letr=2m+3nwithm∈Z+andn∈{0,1}. If there exists an integer feasible solution forHd2with cost at mostc2and an integer feasible solution forHd3with cost at mostc3, then there exist an integer feasible solution forHdrwith cost at mostm·c2+n·c3.We can decomposeHdrinto m copies ofHd2and, if r is odd, a single copy ofHd3. The copies have costs ofc2andc3each, respectively. For the ith copy andi=1,…,m+n, we have an integer capacity vectoruithat allows for routing all scenarios. Then,u=∑i=1m+nuiis an integer capacity vector that admits a routing of all scenarios ofHdrand has exactly costmc2+nc3. □To calculate the integrality gap for our solutions, we also need the value of an optimum fractional solution. Such a solution can be obtained by installingr/dunits of capacity on each edge ofHdand sinceHdhasd·2d-1edges, this gives the following result.Lemma 7An optimum fractional solution forHdrhas a value ofr·2d-1.Check that a solution that installsr/dunits of capacity on each edge satisfies the complementary slackness optimality conditions of the cut-set formulation (Álvarez-Miranda et al., 2012) for the problem. The corresponding dual solution has a variableξSfor all meaningful cutsS⊆V[Hd]. It setsξS≔1/2if|δ(S)|=dandξS=0. The remaining part of the proof is straight-forward if we observe that ford⩾3, we have|δ(S)|=dif and only if|S|=1. The full proof is shown in the Appendix A. □We can now prove that the optimum values for integer and fractional solutions are the same.Theorem 8Ford⩾3andr⩾2, an optimum integer solution forHdrhas valuer·2d-1. In particular, the integrality gap forHdris 1.Letr=2m+3nwithm∈Z+andn∈{0,1}. Putting together Lemma 6 with Lemmas 4 and 5, we obtain that there is an integer solution forHdrwith valuecr≔m·2d+n·3·2d-1. If r is even, we haven=0andm=r/2. Therefore,cr=r·2d-1. On the other hand, if r is odd, we haven=1andm=(r-3)/2. Then,cr=(r-3)/2·2d+3·2d-1=r·2d-1-3·2d-1+3·2d-1=r·2d-1. By Lemma 7, this is optimal. □In the previous sections we have shown that, although computationally easy (Álvarez-Miranda et al., 2012; Buchheim et al., 2011), RND instances defined on random graphs with random balances are difficult in theory. The explanation of this is suggested by the fact that structurally hard instances like those defined on hypercubes and{-1,0,1}balances become theoretically easy when balances are in r, 0, or-r, with r integer andr>1. have an integrality gap of value one. Building on top of those results, we concentrate on instances on random graphs with balances{-1,0,1}that turn out to be computationally challenging for the natural flow formulation already for|V|=50andK=10. An effective heuristic approach for this family is described and computationally evaluated in Section 4 and Section 5, respectively.In this section, we present our heuristic algorithm, which, although general, is designed having in mind the class of hard instances introduced in the precious section, i.e., random graphs with balances of{-1,0,1}. It consists of three phases. In the first phase (constructive phase, CP), the graph is reduced by heuristically deleting a subset of the arcs, and a feasible solution is built. The second phase (neighborhood search phase, NSP) consists of a neighborhood search on the reduced graph in order to improve the solution found: in particular, the MIP flow-formulation is solved, within a time limit, by the general-purpose MIP solver Cplex. Finally, the third phase (proximity search phase, PSP) consists of iteratively applying a local search (by solving a carefully constructed MIP) to further improve the solution, taking into account the original graph, and is based on the recent work Fischetti and Monaci (2013).In the following, we describe the three phases in detail.Initially, the graph we are dealing with is reduced, and then a solution is built. Our goal is to reduce the graph so that we are able to quickly compute a feasible solution, and we can warm start the NSP described in Section 4.2. At the same time, the graph reduction should not be too “aggressive”, because the NSP should be able to improve the solution found. In other words, we need to find a trade-off between reducing the computing time and reducing the solution space. Note that, since the (nonzero) balances are 1 or −1 in our problem, it is not common to have large capacity values installed on the edges. Therefore, solutions differ mainly because of the different set of edges on which capacity is installed. Our goal is to select a “large enough” set of edges for our reduced graph.The following steps are executed in the CP:1.Consider the scenarios from 1 to K and multiply all balances by a given constant F.Construct a feasible solution for the new obtained RND instance (see Section 4.1.1).Reduce the graph by deleting all the edges that are not used in the solution found (and the nodes such that they do not have any incident edge after edge deletion) and obtain graphG‾=(V‾,E‾).Set back the balances to 1 and −1, and construct a feasible solution (see Section 4.1.1) for the original RND instance on the reduce graphG‾.Step 1 is used to define the search space that we want to use in the NSP. Indeed, by increasing the absolute value of the balances, more edges are likely to be used in the solution computed in step 2 and they constitute the neighborhood of the solution computed in step 4. The next section describes how to compute a feasible solution for an RND instance.In the case of a single scenario, an algorithm for the Minimum Cost Flow (MCF) problem can be used to solve RND as follows: we define a directed graph having the same set of nodes as G and two arcs for each edge of G (one for each direction) with infinite upper bounds on the capacities. The flows that we obtain by solving the MCF problem on the defined graph determine the edge capacities, i.e., the RND solution.In the case of K scenarios, ordered from 1 to K, in a generic scenario q we can use for free the capacities that have already been installed on the edges in scenarios1,…,q-1. A straightforward heuristic algorithm consists of iteratively solving a MCF problem for each scenario (in the order from 1 to K), updating the capacities that can be used for free after each MCF execution. In particular, we define an auxiliary directed graphGdir=(V,A)having the same set of nodes of G and the set of arcs defined as follows. For each edgee={i,j}∈E, we introduce four arcsa1e,a2e,a3eanda4e:a1eanda2eare directed from i to j, whilea3eanda4eare directed from j to i. Two arcs are needed for each direction in order to take into account, in a generic scenario q, the previous scenarios1,…,q-1: one arc has an upper bound on its capacity equal to the capacity already installed on the corresponding edge in the previous scenarios1,…,q-1and has zero cost; the other arc has an infinite upper bound on its capacity and has cost equal to the cost of the corresponding edge. More precisely, for each arca∈A, we initialize the upper boundsUBaon the capacities and the costscaasUBa1e≔∞,UBa2e≔0,UBa3e≔∞andUBa4e≔0;ca1e≔ce,ca2e≔0,ca3e≔ce,ca4e≔0. A MCF problem is then solved for each scenario and the upper bounds are updated according to the capacities installed on each arc.The described algorithm follows a greedy approach. It would be useful if, when solving scenario q, we could know what happens in the next scenariosq+1,…,Kso that we could choose accordingly the best capacity installation. In addition, a MCF solution for a generic scenario q that installs capacity on more edges (at the same cost) should be preferred: indeed, it is more likely that free capacity can be used in scenariosq+1,…,K. Therefore, a MCF solution with integer flows split over disjoint paths should be preferred with respect to a MCF solution that sends flows along a single path.Based on these two observations, we derive an improvement of the described heuristic algorithm. We apply a preprocessing in which we divide each scenarioq=1,…,Kin R sub-scenariosg1q,…,gRq, where R is an integer positive number. We consider the sub-scenarios in the orderg1q, (q=1,…,K),g2q, (q=1,…,K), up togRq, (q=1,…,K). In this way, the generic sub-scenarioglqof scenario q can already take into account the partial solution computed for all the scenarios1,…,K. The balances are defined as follows:bvg1q=⌊bvq/R⌋,bvg2q=⌊bvq/(R-1)⌋, up tobvgRq=bvq,v∈V. This means that the complete MCF solution of a generic scenario q will more likely have a split integer flow over disjoint paths, because each sub-scenario might use different subsets of arcs.The improved heuristic algorithm iteratively solves a MCF problem for each sub-scenarioglq(l=1,…,R,q=1,…,K). Let us calluRNDthe RND solution that we compute with the improved heuristic algorithm. Ath=0,uRNDis initialized to be the zero vector. Letfh∗be the MCF solution obtained at iteration h corresponding to sub-scenarioglq. The flows infh∗along the arcs with infinite upper bound determine the additional capacities that must be installed on the corresponding edges: for eache={i,j}∈E,ueRND=ueRND+fa1eh∗+fa3eh∗. Note that, in each sub-scenario, there will always be an optimal solution using, for each edge, only arcs in one of the two directions: it is a single commodity flow, so we could simply do flow cancellation on cycles. In addition, the valuesuRNDare used to update the upper bounds on the capacities, before considering the following sub-scenario:UBa2e≔ueRNDandUBa4e≔ueRND. When all the sub-scenarios have been considered, the algorithm returns the solution founduRND.Note that in step 2 the described algorithm is used to define the reduced graphG‾: all edges such thatuRND=0are deleted from G and the nodes that do not have anymore incident edges are removed as well. Step 4 is instead used to obtain a first feasible solution to our problem and is executed on the reduced graphG‾. Let us calluCPthe solution obtained at the end of the constructive phase.This phase consists of solving an MIP flow-formulation for RND (1)–(5) on the reduced graphG‾defined in the previous section.Then, NSP explores the neighborhood of solutionuCPby allowing the use of different edges belonging toG‾and by allowing the installation of different capacities on the edges. The neighborhood is explored by solving the proposed model, initialized withuCP, by Cplex within a given time limit. Let us calluNSPthe obtained improved solution andcNSPits cost. Since we consider the reduced graph, this phase is able to quickly obtain an improved solution, as it will be seen in Section 5.Recently, Fischetti and Monaci (2013) investigated the effects of replacing the objective function of a 0–1 Mixed-Integer Convex Programming problem with a “proximity” one.The proximity objective function minimizes the distance from a feasible solution of the problem, with the aim of enhancing the heuristic behavior of a black-box solver. In particular, they consider the Hamming distance:(6)Δ(x,x̃)≔∑j∈J:x̃=0xj+∑j∈J:x̃=1(1-xj),wherexj∈{0,1},∀j∈J, andx̃is a feasible solution to the considered problem. The idea consists of starting with an initial feasible solutionx̃with costf(x̃), and iteratively searching for an improved solution by adding a cutoff constraint that imposes the cost of the improved solution to be smaller thanf(x̃)by at least a quantityθ. The search is performed by solving with a black-box solver the new model with objective function that minimizes the Hamming distance fromx̃, until a termination condition is reached, namely, until the first improved solution has been found. If no improved solution is found,θis reduced. The process is then iterated by using the improved solution found as newx̃. The algorithm is terminated when a given time limit is reached. The method can be enhanced by providing an incumbent solution to each iteration of proximity search. This is obtained by adding an auxiliary continuous variable z which is used to keep the cutoff constraint feasible:(7)f(x)⩽f(x̃)-θ+zand has a large cost M in the objective function. In this way,x̃is a (very costly) feasible solution for the MIP it defines. As soon as z becomes 0, an improved solution is found.We apply this idea to RND, i.e., we deal with an MIP. We start with initial solutionuNSPand we consider the original graph G (instead of the reduced one) in order to have a higher probability of improvinguNSP. Since capacities assume integer (and not only binary) values, we need to modify the definition of distance presented in Fischetti and Monaci (2013). Instead of expressing the distance as|u-uNSP|,uijinteger∀{i,j}∈E, we fix upper bounds on the capacity variables, based on the values ofuijNSP, as follows. For each edge{i,j}∈E‾such thatuijNSP>0, the upper bound is set touijNSP. For all the remaining edges the upper bound is the set to be infinite. The distance is then defined as(8)∑{i,j}∈E:uijNSP=0uij+∑{i,j}∈E:uijNSP>0(uijNSP-uij).By imposing upper bounds on the capacity variable, we limit the search space and, consequently, the computing time, by using the solution founduNSP. At the same time we leave the possibility of installing capacity on edges that were not used in the previous solution. Note that, by imposing upper bounds on the capacities, the proximity search becomes a heuristic method for RND. Given this distance measure definition, we iteratively solve the following proximity search model(9)min∑{i,j}∈E:uijNSP=0uij-∑{i,j}∈E:uijNSP>0uij+Mz(10)∑{i,j}∈Ecijuij-zθ⩽cNSP-θ,(11)∑j:{j,i}∈Efjiq-∑j:{i,j}∈Efijq=biq∀i∈V,q=1,…,K(12)fijq+fjiq⩽uij∀{i,j}∈E,q=1,…,K(13)uij⩽uijNSP∀{i,j}∈E‾:uijNSP>0(14)fijq⩾0∀{i,j}∈E,q=1,…,K(15)uij∈Z+∀{i,j}∈E(16)z∈{0,1},where the auxiliary variable z is to guarantee feasibility ofuNSP. The objective function (9) calls for minimizing the distance from the previous solutionuNSPand for obtaining a solution withz=0, i.e., an improved solution that respects the cutoff constraint (10). Constraint (10) imposes to obtain a reduction in the cost of the improved solution of at leastθ. Constraints (11) and (12) correspond to the RND problem constraints. Constraints (13) impose the upper bounds on the capacity variables. Finally, constraints (14)–(16) impose variables’ bounds. Note that z is defined as binary as it turned out in our computational experiments that it is very effective to impose branching priority on z, in order to quickly obtain a solution withz=0.Model (9)–(16) is solved by Cplex until the first feasible solution withz=0is obtained. In our experimentsθwas set to 1. Therefore, ifz=1the process is stopped. On the first feasible solution found, Cplex polishing (see, Rothberg (2007)) is applied until the first improved solution is found. Formulation (9)–(16) is then solved again by replacinguNSPwith the improved solution. The proximity search phase is executed until a given time limit is reached. When the time limit is reached, PS returns the best solution founduPSP.In this section, we report the computational results that we achieved on instances generated on random graphs with balances{-1,0,1}. Instances are generated as follows: n nodes are randomly located in a unit Euclidean square. Two nodes are connected with an edge if the Euclidean distance is less thanα/nwhereαis a parameter set to 2 in our generator. The edge cost for capacity installation is proportional to the Euclidean distance. For each scenario, 25%, 50% or 100% of the nodes are randomly selected to be terminals. We consider 5 or 10 scenarios.The heuristic was developed in C language, and Cplex version 12.5 with 4 threads was used as a general purpose solver. The tests were executed on a PC 1.73gigahertz, 6gigabyte Ram. The computing times are expressed in seconds. The algorithm CS2 by Goldberg (1997) was used for solving the Minimum Cost Flow. The following parameter setting is used for the heuristic: a time limit of 300seconds is given to NSP and a time limit of 600seconds is given to PSP. The total time limit for the heuristic is fixed to 900seconds, because the computation time of the CP is negligible. We fixF=100,R=10,θ=1andM=100uNSP, based on parameter tuning.An important feature of our heuristic algorithm is that it is robust to parameter setting, i.e., the efficacy of the algorithm does not really depend on the specific parameter values, as long as balances are increased and scenarios are split in sub-scenarios (i.e.,F>1andR>1). In particular, the difference between average gaps, computed with respect to the solutions obtained by Cplex 5h, for different combinations of F and R (withF>1andR>1) are negligible (below 1%), and the combination withR=10andF=100provides a good balance between average gap and standard deviation. The other parameter used in our heuristic algorithm isθ. We chooseθ=1as a conservative value, i.e., a value that allows us to obtain good solutions on average onall instances. In particular, we observed that, on the small instances (with 50–100 nodes), larger values forθdo not produce high quality solutions. For larger instances, a more aggressive policy, i.e., one targeting a (much) larger improvement of the incumbent value, can give better results. We decided to keep a conservative value that guarantees good performance on average.In Fig. 3, we show the results obtained, with a time limit of 900seconds, by the proposed method after each of the three phases described in Section 4. In particular, we show one graphic for each class of instances (from 50 nodes to 500 nodes). In this graphic, the comparison is presented with respect to the solutions obtained after the constructive phase and we show in black the percentage improvement of the solutions obtained after the neighborhood search phase (NSP) and in gray the percentage improvement of the solutions obtained after the proximity search phase (PSP). On the right of the figure, we also show the average and standard deviation for each class of instances. As it can be seen, both the NSP and the PSP are effective in obtaining improvements for all instances but six, on which only PSP is able to improve the solution found by the constructive phase. NSP is not able (in five out of the six cases) to improve the solution found by CP for large instances (400 or 500 nodes) with 10 scenarios due to the reached time limit. We decided to keep the time limit fixed for all instances to avoid parameter overtuning. The detailed results are reported in Table 2 in the Appendix A.In the following, we present a comparison of the results obtained by the proposed heuristic (indicated as RND Heur.) with those obtained by Cplex applied to the MIP flow model (1)–(5) on theoriginal graph G. In particular, we show the results obtained when Cplex is run with a time limit of five hours (Cplex 5h) in default setting, and the results obtained with Cplex in the effective heuristic configurations suggested in Fischetti and Monaci (2013) (Cplex Pol. 900s), i.e., solution polishing is applied, and the time limit is set to 900seconds. The proposed method, Cplex 5h and Cplex Pol. 900s are initialized with the solutionuCPconstructed as explained in Section 4.1.In Table 1, we report the results obtained by Cplex 5h, which will be used as our benchmark for comparison. In particular, we report the data on the instances, the solution (uCP) obtained at the end of the constructive phase and used for initializing each of the methods, the best lower bound (LB) and the best upper bound (UB) obtained by Cplex 5h, the duality gap (Gap%), the number of branch and bound nodes (BBn), and the computing time. As it can be seen from Table 1, the time limit is reached for all instances but the three smallest ones for which Cplex is able to prove optimality. For the remaining instances, the duality gaps are often quite large and for seven instances Cplex is not even able to improve the initial solution.In order to measure the performance of the proposed method, we show in Fig. 4 the comparison between the results we obtain in 900seconds of time limit and the results obtained by Cplex 5h and by Cplex Pol. 900s. The detailed results are reported in Table 3 in the Appendix A. In particular, we show one graphic for each class of instances (from 50 nodes to 500 nodes). In this graphic, the comparison is presented with respect to the solutions obtained by Cplex 5h and we show in black the percentage gap of the solutions obtained by Cplex Pol. 900s and in gray the percentage gap of the solutions obtained by RND Heur. On the right of the figure, we also show the average and standard deviation for each class of instances.As it is evident from Fig. 4, the three methods obtain comparable results for instances with up to 100 nodes. However, as the instances get larger, the proposed method becomes more effective than the other ones, and it is able to improve the results obtained by the other two methods. In particular, compared to Cplex Pol. 900s that has the same time limit, the proposed method always obtains better solutions for instances with at least 300 nodes. It obtains solutions with a cost less or equal than those obtained by Cplex Pol. 900s for 27 out of 36 instances, and is at most 1.05% worse for a single instance. The improvement is significant (between 3% and more than 14%) for 14 out of 36 instances. Even compared to Cplex run for five hours, the proposed method performs on average better on instances with at least 200 nodes, especially when we have 10 scenarios. It is able to obtain better or equal solutions for 20 out of 36 instances. The average percentage improvement with respect to Cplex 5h and Cplex Pol. 900s is 2.38% and 2.90%, respectively.In order to further validate the results presented in Fig. 4, we performed extensive computational experiments on instances withn=300andn=400nodes. In particular, we considered five instances for each sub-class, defined by selectingt∈{25%,50%,100%}andk∈{5,10}. This gives a total testbed of 60 instances. In Fig. 5, we show the comparison among the average performance of three methods. The comparison is presented with respect to the solutions obtained by Cplex in five hours. We show in black the percentage gap of the solutions obtained by Cplex Pol. 900s and in gray the percentage gap of the solutions obtained by RND Heur in 900s. Compared to Cplex Pol. 900s, that has the same time limit, the proposed method always obtains better solutions, and, compared to Cplex 5h, performs better on all instances with 10 scenarios. This behavior confirms the effectiveness of the proposed approach.Finally, we performed a comparison of RND Heur with the heuristic algorithm (BLS) developed by Buchheim et al. (2011). BLS initially solves the LP-relaxation of a flow model of the problem and rounds up the capacity variables in order to obtain a feasible solution. Then it computes K integral flows by solving K minimum-cost flow problems. Finally, the K flows are combined to derive a feasible solution with possibly smaller capacity values. In the minimum-cost flow resolution, the cost function is chosen randomly in order to have the chance of generating different solutions in each iteration. We considered the instances withn=300andn=400nodes and imposed a time limit of 900seconds to each method. The obtained results show that BLS is on average worse than RND Heur of about 15%. In particular, it turns out that the LP-solution rounded up has a very high cost, thus compromising the performance of BLS. We also tested BLS, when starting from the solution computed by the constructive phase of RND Heur. In this case, the overall performance of BLS improved significantly: it would be an interesting direction of research to exploit the behavior of BLS embedded within the proposed framework.We have presented a single-commodity robust network design problem and we have shown complexity results for special classes of instances, including hypercubes. By the complexity analysis, we have shown that instances with random integer balances different from 1 and from −1 are NP-hard, even if computationally easy (Álvarez-Miranda et al., 2012; Buchheim et al., 2011). In order to explain why, we have shown that instances defined on hypercubes with balances in{-r,0,r}(r integer,r>1) are theoretically easy, while instances defined on hypercubes with balances in{-1,0,1}are structurally hard. This has motivated us to study instances (defined on random graphs) with balances of{-1,0,1}. We have developed a Matheuristic algorithm composed of three phases.The first one reduces the instance graph and constructs a feasible solution, the second one solves an MIP flow-formulation of the problem on the reduced graph for a given time limit, in order to improve the solution found, and the last phase applies a modified version of the recent technique of proximity search to further improve the solution. We have tested the proposed method on randomly generated instances with balances of{-1,0,1}, and we have compared the obtained results with those obtained by Cplex both in 5hours (default version) or by using the polishing algorithm to enhance its heuristic behavior (for 900seconds). The results show that our method is comparable with the other ones for instances with up to 100 nodes, but obtains better solutions for larger instances. Future research can be devoted to extend the proposed algorithm to the multi-commodity case. In addition, the proposed methodtakes into account the balances of all the scenarios, but a less conservative approach could be considered, for example, by taking into account the probability of each scenario.Other extensions could be to tackle related variants of robust network design, such as Survivable Network Design: mostly the constructive phase needs to be modified, as long as a good MIP formulation exists. Additional parameter tuning might be necessary as well.

@&#CONCLUSIONS@&#
