@&#MAIN-TITLE@&#
Specifying model changes with UMLchange to support security verification of potential evolution

@&#HIGHLIGHTS@&#
We present a security verification approach which can deal with software evolution.It includes tools to analyze whether evolution preserves a security property.The tool can compute all possible evolution paths of the given model.We also present the UML profile UMLchange used for specifying potential evolutions.UMLchange makes our approach independent from specific modeling tools.

@&#KEYPHRASES@&#
Model evolution,Security verification,UML profile,Tool support,

@&#ABSTRACT@&#
In model-based development, quality properties such as consistency of security requirements are often verified prior to code generation. Changed models have to be re-verified before re-generation. If several alternative evolutions of a model are possible, each alternative has to be modeled and verified to find the best model for further development.We present a verification strategy to analyze whether evolution preserves given security properties. The UMLchange profile is used for specifying potential evolutions of a given model simultaneously. We present a tool that reads these annotations and computes a delta containing all possible evolution paths. The paths can be verified wrt. security properties, and for each successfully verified path a new model version is generated automatically.

@&#INTRODUCTION@&#
A significant portion of software development nowadays is based on models. Especially in safety or security critical domains, modeling offers advantages such as formal specification and automated code generation. The formal semantics of models allow us to specify recurring security requirements and security assumptions on the system environment. This way knowledge on prudent security engineering is encapsulated as annotations in models. The models can be verified with regard to certain properties such as consistency of security requirements. Such verification is performed by dedicated analysis tools [1–3].However, systems are neither developed in one step nor are they carved in stone. Hence, the task of evolving software systems such that the desired security requirements are preserved through a system's lifetime is of great importance in practice. We propose a model-based approach to support the evolution of software systems and preserving consistency of security requirements. Our approach allows the verification of potential future evolutions using an automatic analysis tool. An explicit model evolution implies the transformation of the model and defines a difference ∆ between the original model and the transformed one. The proposed approach supports the definition of multiple evolution paths, and provides tool support to verify evolved models based on the delta of changes. This idea is visualized in Fig. 1: The starting point of our approach is a software system model M which was already verified against certain security properties. Then, this model can evolve within a range of possible evolutions (the evolution space). We consider the different possible evolutions as evolution paths each of which defines a delta ∆i. The result is a number of evolved system models Mi′. The main research question is “Which of the evolution paths leads to a target model that still fulfills the security properties of the source model?”.Theoretically, one could simply re-run the security analysis done to establish the security of the original model on the evolved model to decide whether these properties are preserved after evolution. This would, however, result in general in a high resource consumption for models of realistic size, in particular since the goal in general is to investigate the complete potential evolution space (rather than just one particular evolution) in order to determine which of the possible evolutions preserve security. Also, verification efficiency is very critical if a continuous verification is desired (i.e. to determine in real-time and in parallel to the modeling activity whether the change preserves security).We use models specified using the Unified Modeling Language (UML) and the security extension UMLsec [4]. UMLsec is given in form of a UML profile. Stereotypes are used together with tags to formulate the security requirements such as secrecy, integrity, and authenticity, and other security-relevant information. Constraints give criteria to determine if the requirements are met by the system design, by referring to a precise semantics of the used fragment of UML. The security-relevant information added by using stereotypes includes security assumptions on the physical level of the system, security requirements related to the secure handling and communication of data, and security policies that system parts are supposed to obey. Based on UMLsec models and the semantics defined for the different language elements, possible security vulnerabilities can be identified at an early stage of software development. One can thus verify that the desired security requirements, if fulfilled, enforce a given security policy. This verification is supported by a tool suite22Available online viahttp://carisma.umlsec.de[5].In this paper we present a general approach for the incremental security verification of UML models regarding the consistency of security requirements inserted as UMLsec stereotypes. We discuss the possible atomic (i.e. single model element) evolutions annotated with certain security requirements according to UMLsec. Moreover, we present sufficient conditions for a set of model evolutions, which, if satisfied, ensure that the desired security properties of the original model are preserved under evolution. We demonstrate our general approach by applying it to a representative UMLsec stereotype, ≪secure dependency≫. As one result of our work, we demonstrate that the security checks defined for UMLsec allow significant efficiency gains by considering this incremental verification technique.To explicitly specify possible evolution paths, we have developed a further UML profile, called UMLchange, that allows a precise definition of which model elements are to be changed in a model. Constraints can be defined to coordinate and define more than one evolution path (and thus obtaining the deltas for the analysis).Note that UMLchange is not intended as a general-purpose evolution modeling language. While existing evolution specification or model transformation approaches (such as [6–10]) are primarily used as a tool to change models, we needed a notation that allows us to put evolution in the focus of analysis. Thus, UMLchange is specifically intended to precisely define possible evolution paths of models. This enables the investigation of the preservation of security requirements by evolution. Thus, UMLchange does not aim to be an alternative for any of the existing approaches mentioned above. It will be interesting future work to demonstrate how the results presented in this paper can be used in the context of those approaches.A preliminary version of UMLchange has been presented under the name UMLseCh at the ECMFA'11 conference [11]. Meanwhile we have improved the language. While UMLseCh was a set of additional stereotypes to UMLsec, we have now extracted the evolution specific parts and elaborated them into the UMLchange profile. This separation of concerns allowed us to deeper investigate the possible evolutions of a model, resulting in new stereotypes enabling a more precise description of evolution and supporting more complex types of evolution. Moreover, former limitations have been smoothed out. UMLchange is now fully compatible to UML version 2.4. The new grammar makes it possible to annotate multiple independent change alternatives to a single model element. New changes such as moving or copying elements can now be modeled, which better matches the perception of the user of how the model could evolve. Finally, the separation of evolution descriptions into a new profile enables its application of the evolution analysis to other quality properties. However, this is not the focus of this paper. Here, we introduce the new profile and how it can be used to describe different evolutions. In particular we will explain the grammar used to describe additive changes, which has been omitted in [11]. We furthermore show how the specified evolution paths can be verified wrt. preserving security properties.The remainder of this paper is organized as follows: The change-specific extension UMLchange is defined in Section 2. Section 3 explains our general approach for evolution-aware security verification. In Section 4, we give an overview of the verification tool and evaluate our approach in Section 6. We conclude with an overview of the related work (Section 6) and a brief discussion of the results presented (Section 7).The UMLchange profile consists of multiple stereotypes that can be used for the description of changes in a model. The majority of the stereotypes of the profile (excluding ≪old≫ and ≪keep≫) describe changes (i.e. the change stereotypes). To enable the description of all possible changes to a UML model, the change stereotypes can be applied to any UML model element. This is indicated by the extension relationships targeting the meta class Element, the super class of all UML elements.Fig. 2provides some basic examples for using UMLchange. Class Redundant will be deleted. Class TooConcrete is replaced with the Interface IGeneral. A new element NewClass is inserted into the main package. Furthermore, class OuterClass will be moved to package Outside and the class FalseName will be renamed to CorrectName.The components of the profile (see Fig. 3) are described in more detail below.Secure dependency. To be able to demonstrate the UMLchange profile for evolution-aware security analysis, we give a short description of the UMLsec stereotype ≪secure dependency≫. A detailed explanation of all of the tags and stereotypes defined in UMLsec can be found in [13]. ≪secure dependency≫ can be used to label subsystems containing static structure diagrams. It ensures that the ≪call≫ and ≪send≫ dependencies between objects or subsystems respect the security requirements on the data that may be communicated across them, as given by the tags {secrecy}, {integrity}, and {high} of the stereotype ≪critical≫. More exactly, the constraint enforced by this stereotype is that if there is a ≪call≫ or ≪send≫ dependency from an object or subsystem C to an interface I of an object or subsystem D then the following conditions are fulfilled:•For any message name n in I, n appears in the tag {secrecy} (resp. {integrity} resp. {high}) in C if and only if it does so in D.If a message name in I appears in the tag {secrecy} (resp. {integrity} resp. {high}) in C then the dependency is stereotyped ≪secrecy≫ (resp. ≪integrity≫ resp. ≪high≫).If the dependency goes directly to another object or subsystem without involving an interface, the same requirement applies to the trivial interface containing all messages of the server object.Each change stereotype has the following tags: {ref}, {ext} and {constraint}. To enable the description of multiple independent changes at a model element (e.g. two independent additions, each adding one operation to a class), each of these tags is multi-valued.Every change has an ID so that it can be referenced by other changes. The tag {ref} contains the change IDs for each change at the stereotype application. Each application of a change stereotype must at least have one ID. These IDs should be unique in the model scope. The change IDs are used in constraints and in change stereotype tags to relate their entries to the corresponding change. Examples for IDs are deleteTransition, some_Change and add2Operations.Stereotypes cannot be applied to UML extension elements themselves. {ext} helps to describe changes of stereotype applications and their tagged values. Its format is:ChangeID=StereotypeName.TagName.If a change is directed at a model element, no {ext} entry is necessary. If the change target is the extension of an element, {ext} follows a convention of most UMLchange stereotype tag values. Each entry has to be prefixed with the ID of the corresponding change so that entries in the value lists do not need to adhere to a certain order. If the target is a stereotype application, the name of the applied stereotype must be given. If a tagged value of a stereotype application is the target of the change, the stereotype name must be appended with the name of the targeted tag.Every change may have constraints attached to it describing when the change may or may not take place. The corresponding tag {constraint} has the following format:ChangeID=ANDOtherChangeIDNOTOtherChangeIDREQOtherChangeID,….The obligatory change ID is followed by a constraint that either forces another change to be simultaneously applied (AND(OtherChangeID)), excludes a change from being applied simultaneously (NOT(OtherChangeID)) or requires another change to be applied before the change in question (REQ(OtherChangeID)). A change may have more than one constraint. For ease of use, each constraint can either be a separate {constraint} entry or be part of a comma-separated list of constraints. Contradicting constraints lead to not including any of the conflicting changes.A change to a model element can be of one of three basic types:•deletion of an element from the modeladdition of a new element to an existing model elementsubstitution of an element with another element.Every possible evolution to a model can be described with one or more of these three types. The UMLchange profile offers the corresponding stereotypes to enable the description of the basic types.The stereotype ≪del≫ is used to delete the targeted model element. It recursively deletes all model elements owned by the targeted element. Any connecting model elements (e.g. associations) are also deleted to preserve the validity of the model. If the target of ≪del≫ is the multi-valued tagged value of a stereotype application, this stereotype deletes all values of the tag.The stereotype ≪add≫ serves the purpose of describing additions to model elements. ≪add≫ has to be applied to the elements which will own the new elements. If the target of ≪add≫ is a stereotype application, multi-valued tags receive additional values. Additions to single-valued tags are treated as substituting the old tagged value with the new value.Applying ≪subst≫ allows us to describe the substitution of the targeted model element by one or more new model elements. The owner of the new substitute element (or elements) is the parent of the old substituted element. By substituting old elements, all of their contained elements are removed from the model, as well as all connection model elements. To prevent deleting contained elements, the stereotype ≪keep≫ must be applied accordingly (see Section 2.3.3). If tagged values are to be substituted, both single and multi-valued tags are completely substituted by the new values.To describe the addition of new model elements or the substitutes of old elements, the stereotypes ≪add≫ and ≪subst≫ use expressions built with the UMLchange grammar. New elements are described by their metaclass names and pairs of keys and values. The new elements can be further defined by recursively describing contained elements. Changes on the grammar level are dependent on each other. Alternatives provide the ability to describe change variations. The elements described inside these alternatives are meant to be processed together.The UMLchange grammar expressions are used in the {new} tag. Its format is:ChangeID=UMLchangeGrammarExpression.For example, to describe the addition of a new class named someClass to a package, ≪add≫ has to be applied to the package. The appropriate {new} entry is:someID=Classname=someClass.someID is the ID of the corresponding change. The UMLchange grammar is described in detail in Section 2.4.In the example model in Fig. 4, the integrity tag value for the Server is substituted with a high requirement. As the resulting model would be insecure, the integrity tag value for the Client is removed and a security preserving appropriate high value is added.Although every change to a model can be described using the three basic stereotypes, these descriptions lead to long-winded and rather cumbersome applications of these stereotypes. It would, for example, be an arduous task to create a copy of an already existing model element in another package in the model, depending on how detailed the original element has been modeled. To ease the description of certain special forms of changes to a model, UMLchange provides several stereotypes for small modifications of model elements, moving and copying elements to another namespace, changes to multiple elements, and the description of more complex changes to a model.Minor changes can be expressed by applying ≪edit≫ to a model element, which can be mapped to the substitution of old with new property values. Its tag {values} has the format:ChangeID=KeyValuePairs,….KeyValuePairs represents the corresponding subset of the UMLchange grammar. The keys have to be valid attribute names of the targeted element. An example entry to change the name of a class to NewName and its visibility to private would be:someID=name=NewName,visibility=private.As with the description of new model elements, {values} entries can describe alternative evolutions using the correct syntax. Editing stereotype applications is not possible, as changes would amount to redefining the stereotype instead of its application. Editing tagged values is analogous to substituting old with new tag values.For structural changes, ≪copy≫ is used to indicate that the targeted model element is to be duplicated in one or more comma-separated namespaces given in the tag {to}. ≪move≫ works in the same vein, but removes the targeted model element from its original owner and only allows one target namespace. While ≪copy≫ can be mapped to the basic addition of the original element and its contents to the target namespace, ≪move≫ can simply be mapped to a substitution of the owner of the changed element.The format of {to} is:ChangeID=QualifiedNamespaceKeyValuePairs,…,….The QualifiedNamespace needs to be qualified in so far that the uniqueness of the namespace in the model is guaranteed. The copied or moved model element in the target namespace can then be modified with KeyValuePairs using the same format as in the {values} tag of ≪edit≫. Multiple destination namespaces must be comma-separated. An example for an entry in {to} is:copySomething={mainPackage::SubPackagename=NewName,mainPackage::SubPackagename=OtherNewName.This describes two copies of the targeted model element to the same SubPackage, renaming each one in the process. For obvious reasons it is not allowed to copy a model element to the same namespace as the source element without changing the name of the copied element.If a stereotype application is the target, all of its tagged values are also copied to the targeted element. If the targeted element already has the stereotype applied to it, all tagged values are replaced in the process. It is not allowed to change the name of the stereotype, as this would change the applied stereotype itself.In the example model (see Fig. 5) which uses ≪secure-links≫ [13], the Database is to be moved to its own node Database-Server. As there is a ≪secrecy≫ requirement at the dependency between the Webserver and the Database, the ≪Internet≫ link has to be substituted with an ≪encrypted≫ connection. Additionally, the adversary attacking the system is edited to be the custom attacker defined in [17]. ≪Internet≫ links would be vulnerable to this attacker, but since the link in question has already been substituted with an ≪encrypted≫ connection, this change does not invalidate security of the model.Describing changes to expansive models can be hard to manage. If, for example, all applications of a certain stereotype in the model are to be removed, finding each and every application of it can be tedious task. UMLchange provides stereotypes to ease the process of describing changes to multiple elements. The changes can be focused on certain types of model elements or elements having a certain property.≪del-all≫, ≪add-all≫ and ≪subst-all≫ are applied to the namespace in which the changes are to take place and can be mapped to multiple applications of the basic stereotypes. The {new} tag has the same syntax and semantics as the {new} tag of the respective basic stereotypes, while the {pattern} tag allows to identify the model elements in the namespace affected by the described change. The format of {pattern} is:ChangeID=TargetedElementsPattern.The tag uses the same syntax as the {new} tag of the basic stereotypes. First the metaclass of the targeted elements must be given. For example, if the given metaclass is Class, then the changes would affect all classes in the namespace marked with the *-all stereotype. The affected elements can be further filtered by giving key value pairs defining certain attributes that the affected elements must possess. For example, to affect all dependencies having a certain supplier, the entry would be Dependency(supplier=somePackage::certainSupplier). Some further examples for entries in {pattern} are•Dependency(supplier=somePackage::certainSupplier,contents=Stereotype(name=secrecy))–all dependencies that have the supplier somePackage::certainSupplier and the stereotype application of ≪secrecy≫Action(contents=Stereotype)–all stereotyped actions.In the example model (see Fig. 6) based on a smart card life-cycle, the stereotype ≪locked-status≫ is to be added to the TERMINATED state. Applying this stereotype adds the constraint that the marked state may not have any outgoing transitions. To fulfill this requirement, ≪del-all≫ is applied to the region containing the state machine. Its application, named removeOutgoing, describes the removal of all outgoing transitions of the state TERMINATED, securing the model once again.Describing complex changes with the UMLchange grammar can lead to long-winded grammar expressions. To provide a simpler method for modeling complex changes, UMLchange provides the ability to reference changes modeled in a namespace in the original model. The namespace containing the new model elements can be placed anywhere in the model.To connect the new model elements to the correct owner in the original model, the owner relation has to be modeled in the namespace by modeling the owners of the new elements. However, it is not necessary to completely re-model the owning elements. For example, one would not need to re-model a class with all of its operations and attributes to model two new operations for it. Instead it is sufficient to just model the owning class and its name, as long as the class can be uniquely identified within the original model. To support this method, ≪old≫ is used to mark those incompletely modeled references to the original model. Complex additions using ≪old≫ can be mapped to additions to the original elements in the model.In addition to that, ≪keep≫ is used to mark model elements that would otherwise be removed in the process of substituting a model element. Applications of ≪keep≫ can be mapped to the addition of the kept elements to the substitutes.Its tag {adopter} has the format:ChangeID=AdoptingElementDescription,….As each alternative description in {new} could describe different new elements, an entry in {adopter} must describe the receiving element for each alternative in {new}. If an alternative of {new} should not receive the element, its corresponding alternative in {adopter} is left empty. If, after a certain point, the remaining alternatives should not receive the element, then the entries can be omitted. Transferring model elements using ≪keep≫ is only supported when complex namespaces are used to describe the new model elements.The tag uses the same syntax as the {new} tag of the basic stereotypes (see also Section 2.4). For example, let ≪subst≫ be applied to a class. Its {new} entry:substClass=@newElements,@otherVersionmeans that the old class is either substituted by the elements in the namespace newElements or alternatively by those elements in otherVersion. To keep an old contained element of substituted class, it has to be marked with ≪keep≫. If, for example, an old element is to be left out in the first alternative and should be adopted by a class NewClass when using the second alternative, the appropriate entry for {adopter} is:substClass={},Classname=NewClass.In the example model (see Fig. 7), the dependency between the Algorithm interface and the Calculator UI receives both ≪call≫ and ≪high≫. The Calculator UI would violate the secure dependency property, but the UI class is substituted with the Secured Calculator UI, which adds a host of other attributes and operations to the previously relatively small class and provides security by using the appropriate ≪critical≫ application.The UMLchange grammar can be used to describe changes adding new model elements to existing elements. Each change consists of one or more comma-separated descriptions of alternative evolutions. The format for these alternatives is:Description.The description can be either a series of comma-separated simple element descriptions depicting new model elements or the single reference of a namespace wherein the additions to the model are shown.An example for the UMLchange grammar is:Classname=NewClass,Classname=OtherNewClass,visibility=private,@addClasses.This example poses two alternative evolutions. The first adds two classes named NewClass and OtherNewClass, of which the second receives a private visibility. The second alternative references a namespace add-Classes in the model. The referenced namespace contains new model elements to be added to the original model, by either adding to old model elements using ≪old≫ or substituting model elements while keeping some of their contents using ≪keep≫.Simple element descriptions (SED) succinctly describe a UML model element. The format of a SED is:MetaclassKeyValuePairs.Each SED starts with the metaclass name of the new element. Every UML metaclass of an actual non-abstract model element can be used.Apart from that, simple comma-separated key-value pairs can be given to set the properties of the new model elements, ranging from common properties (e.g. name) to connection-specific ones (e.g. source and target for an association). The format of a key-value pair is:key=value.When setting values for properties which reference other model elements in the original model, a sufficiently qualified string representation of the referenced model element has to be given. Assuming there are two different classes of the same name WantedClass in two different packages SuperPackage and SubPackage, referencing a class would need the containing package namespace to be incorporated into the attribute value. However, it is not necessary to add the model namespace to the reference, as the containing package namespace is sufficient to identify the referenced class.Table 1shows some metaclasses, their corresponding keys, their value type and a description. The value type of a key may be a String, an element of a given enumeration, or the adequately qualified reference to a model element.Apart from describing the new model element itself, an additional optional key named contents with the format:contents=SimpleElementDescriptionsprovides the means to describe further new model elements that are contained in the new element, e.g. an operation to be owned by a new class. The usage of the contents key is not restricted by a maximum depth.To avoid long descriptions of complex additions, the UMLchange grammar allows to reference namespaces containing the new elements. The syntax for namespace referencing is@NamespaceName.The namespaces referenced by the namespace name must be placed in the scope of the original model, but it is not necessary to place them in the same scope where the changes will take place. Connecting the new elements of the namespace to the original model is accomplished by modeling part of the target model element and application of the ≪old≫ stereotype (see Section 2.3.3).Other stereotypes of the UMLchange profile use subsets of the UMLchange grammar to provide a consistent syntax (see Table 2).The tag {values} of stereotype ≪edit≫ uses the same key-value pairs to describe changes to model element attributes, as does {to} of ≪copy≫ and ≪move≫. The target of the copy or move operation is an adequately qualified namespace equivalent to the model element references used in simple element descriptions. The descriptions of the targeted elements of the *-all stereotypes using {pattern} are the grammar's simple element descriptions, as is the target element description of {adopter}.Although UMLchange originates from UMLseCh, differences between the two profiles exist. While UMLseCh allowed multiple applications of the same stereotype to the same model element, this is not allowed in UML 2.x. Hence, to make UMLchange compliant to UML, the stereotypes and tagged values have been adopted to enable the definition of multiple changes to a single model element.With UMLseCh, it was very hard to describe more complex alternative evolutions which can now be easily modeled using the namespaces and simple grammar expressions. ≪keep≫ and ≪old≫ have been added to provide additional control when making complex changes to models.The stereotypes ≪copy≫, ≪move≫ and ≪edit≫ also provide easier methods to make both minor changes and to duplicate model structures, while the stereotypes for changing multiple elements have been reworked to both allow a more precise pattern-matching.While UMLseCh conceptually allowed us to change UML extensions, UMLchange provides the technical realization of these concepts, which prompted the change in syntax to certain tag values, i.e. the UMLchange grammar. The grammar further provides the additional ability to describe alternative evolutions to a model, as well as describing multiple independent changes of a type to the same model element, e.g. the independent addition of two stereotypes to a class.To provide a formal foundation for the UMLchange profile, the verification of evolutions described with the profile is discussed in the following section.The evolution information annotated with UMLchange stereotypes to the model elements is parsed into an internal representation. Based on this representation we can check whether an evolution path preserves the consistency of the security requirements, which is described in what follows.As stated in the previous sections, all changes can be expressed with the basic change stereotypes (see Section 2.2). All other change stereotypes could be mapped to their basic counterparts. Hence, evolving a model means that we add, delete, or substitute elements of this model. A set of these changes is called a Delta. To distinguish between big-step and small-step evolutions, we will call “atomic” the modifications involving only one model element (or sub-element, e.g. adding a method to an existing class or deleting a dependency). In general there exist evolutions from model A to model B such that there is no sequence of atomic modifications for which security is preserved when applying them one after another, but such that both A and B are secure. Therefore the goal of our verification is to allow some modifications to happen simultaneously. A DeltaFactory could be used to create all possible permutations of changes that can be applied simultaneously without violating basic modeling principles of the UML.Since the evolution is defined by additions, deletion and substitutions of model elements, we introduce the sets Add, Del, and Subs, where Add and Del contain objects representing model elements together with methods id, type, path, parent returning respectively an identifier for the model element, its type, its path within the diagram, and its parent model element. These objects also contain all the relevant information of the model element according to its type (for example, if it represents a class, we can query for its associated stereotypes, methods, and attributes). For example, the class “Customer” in Fig. 8can be seen as an object with the subsystem “Book a flight” as its parent. It has associated a list of methods (empty in this case), a list of attributes (“Name” of type String, which is in turn a model element object), a list of stereotypes (≪critical≫) and a list of dependencies (≪call≫ dependency with “Airport Server”) attached to it. By recursively comparing all the attributes of two objects, we can establish whether they are equal.The set Subs contains pairs of objects as above, where the type, path (and therefore parent) methods of both objects must coincide. We assume that there are no conflicts between the three sets, more specifically, the following condition guarantees that one does not delete and add the same model element:∄o,o′o∈Add∧o′∈Del∧o=o′.Additionally, the following condition prevents adding/deleting a model element present in a substitution (as target or as substitutive element):∄o,o′o∈Add∨o∈Del∧oo′∈Subs∨o′o∈Subs.As explained above, in general, an “atomic” modification (that is the action represented by a single model element in any of the sets above) could by itself harm the security of the model. So, one has to take into account other modifications in order to establish the security status of the resulting model. We proceed algorithmically as follows: we iterate over the modification sets starting with an object o∈Del, and if the relevant simultaneous changes that preserve security are found in the delta, then we perform the operation on the original model (delete o and necessary simultaneous changes) and remove the processed objects until Del is empty. We then continue similarly with Add and finally with Subs. If at any point we establish the security is not preserved by the evolution we conclude the analysis. Given a diagram M and a set ∆ of atomic modifications we denote M[∆] the diagram resulting after the modifications have taken place. So in general let P be a diagram property. We express the fact that M enforces P by P(M). Soundness of the security preserving rules R for a property P on diagram M can be formalized as follows:PM∧RMΔ⇒PMΔ.To prove that the algorithm described above is sound with respect to a given property P, we show that every set of simultaneous changes accepted by the algorithm preserves P. Then, transitively, if all steps were sound until the delta is empty, we reach the desired P(M[∆]).One can obtain these deltas by interpreting the UMLchange annotations presented in the previous section. Alternatively, one could compute the difference between an original diagram M and the modified M′. This is nevertheless not central to this analysis, which focuses on the verification of evolving systems rather than on model transformation itself.To define the set of rules R, one can reason inductively by cases given a security requirement on UML models, by considering incremental atomic changes and distinguishing them according to a) their evolution type (addition, deletion, substitution) and b) their UML diagram type. In the following section we will spell-out a set of possible sufficient rules for the sound and secure evolution of class diagrams annotated with the ≪secure dependency≫ stereotype.Incremental verification after change is a useful technique if only relatively small parts of the model need to be re-verified. In general, this is more challenging for security properties on behavioral models where small changes may impact the semantics in a non trivial way. To deal with this problem, a less local perspective of the system is useful: if the system model is built up on interacting components then the effects of changes to single components to the overall system security can be established if there exist a compositionality result for the security property under consideration. In other words, instead of re-verifying the complete system when modification is made to a small number of components, it suffices to re-verify the modified components only and apply the compositionality result. In the following we summarize two such compositionality results that can be applied in the context of evolution and security.Communicating processes can be specified as sequence diagrams, and it is possible to reason about the security of the communication by means of a semantic model based on process composition and a cryptographic DSL (as it is done for example in UMLsec). In [26] a sound decision procedure is presented that given proof artifacts for Dolev–Yao secrecy on separate components can establish whether their composition will be security preserving or not. The proof artifacts considered are dependency trees that represent the information needed by an adversary to obtain secret messages and keys. Those trees can be calculated separately for each process, and to decide on the security of a given composition the respective trees are merged. This merging process is empirically more efficient than the complete re-verification of the composition, as we will discuss in Section 5.3.Non-interference is an information flow property that relates the inputs and outputs of groups of users (typically high and low, that is privileged and unprivileged) for all possible runs of the system. This property can be specified for instance in state diagrams where the inputs and outputs are assigned to specific groups of users. For a deterministic version of this property defined in UMLsec it holds that:Theorem 1Let I=I|H∪I|Land O=O|H∪O|La partition of the input and output alphabets of A⊗B. If non-interference holds for an extension of the policy in I and O to the unspecified events in IB∩OAin A and B, then non-interference holds on A⊗B.In other words if both components are secure (non-interferent) their composition is also secure (for a proof see [46]). It is furthermore possible to verify that a component is non-interferent in a sound way using static analysis and unwinding techniques. This technique is a sound approximation: an exact verification of non-interference would require us in general to consider all possible input and output traces, which is in turn computationally unfeasible. For instance, assume there are only two possible kinds of input events to the system: a low event L and a high event H, parametric on a 64 bit long integer (that is for instance L(10), H(232)). Then to compute all possible outputs of the model one would have to consider at least 2128 inputs. However practical models usually contain a much smaller amount of internal transitions (usually less than 100). This number is the main input to the static approach presented in [46], allowing for practical verification, as observed empirically on models verified using a prototypical implementation of that technique.In this section we demonstrate the incremental verification strategy by applying it to the case of the UMLsec stereotype ≪secure dependency≫, which is defined for class diagrams. The associated constraint requires that for every communication dependency (i.e. a dependency annotated ≪send≫ or ≪call≫) between two classes in a class diagram the following condition holds: if a method or attribute is annotated with a security requirement in one of the two classes (for example {secrecy={method()}}), then the other class has the same tag for this method/attribute as well (see Fig. 8 for an example). In addition to that, the communication dependencies have to have the corresponding stereotypes applied to them. It follows that the computational cost associated with verifying this property depends on the number of dependencies. We analyze the possible changes involving classes, dependencies and security requirements as specified by tags and their consequences to the security properties of the class diagram.Formally, we can express this property as follows:PM:⇔∀C,C′∈M.Classes∃d∈M.dependenciesCC′⇒C.critical=C'.criticalwhere M.Classes is the set of classes of diagram M, M.dependencies(C, C′) returns the set of dependencies between classes C and C′ and C.critical returns the set of pairs (m,s) where m is a method or an object shared in the dependency and s∈{high, secrecy, integrity} as specified in the ≪critical≫ stereotype for that class.We now analyze the set ∆ of modifications by distinguishing cases on the evolution type (deletion, addition, substitution) and the UML type.Class: We assume that if a classC¯is deleted then also the dependencies coming in and out of the class are deleted, say by deletions D={o1,…,on}, and therefore, after the execution of o and D in the model M (expressed M[o,D]) property P holds since:PMoD⇔∀C,C′∈M.Classes/C¯∃d∈MoD.dependenciesCC′⇒C.critical=C'.criticaland this predicate holds given P(M), because the new set of dependencies of M[o,D] does not contain any pair of the typexC¯,C¯x.Tag in critical: If a security requirement (m,s) associated to classC¯is deleted then it must also be removed from other methods having dependencies with C (and so on recursively for all classesCC¯associated through dependencies toC¯) in order to preserve the secure dependencies requirement. We assume P(M) holds, and since clearlyM.Classes=M.Classes/CC¯∪CC¯it follows P(M[o,D]) because the only modified objects in the diagram are the classes inCC¯and for that set we deleted symmetrically (m,s), thus respecting P.Dependency: The deletion of a dependency does not alter the property P since by assumption we had a statement quantifying over all dependencies (C, C′), that trivially also holds for a subset.Class: The addition of a class, without any dependency, clearly preserves the security of P since this property depends only on the classes with dependencies associated to them.Tag in critical: To preserve the security of the system, every time a method is tagged within the ≪critical≫ stereotype in a class C, the same tag referring to the same method should be added to every class with dependencies to and from C (and recursively to all dependent classes). The execution of these simultaneous additions preserves P since the symmetry of the critical tags is respected through all dependency-connected classes.Dependency: Whenever a dependency is added between classes C and C′, for every security tagged method in C (C′) the same method must be tagged (with the same security requirement) in C′ (C) to preserve P. In addition to that, the dependency has to be marked with the stereotypes corresponding to the used ≪critical≫ tags. So if in the original model this is not the case, we check for simultaneous additions that preserve this symmetry for C and C′ and transitively on all their dependent classes.Class: If class C is substituted with class C′ and class C′ has the same security tagged methods as C then the security of the diagram is preserved.Tag in critical: If we substitute {requirement=method()} in class C with {requirement′=method()′}, then the same substitution must be made in every class linked to C by a dependency.Dependency: If a ≪call≫ (≪send≫) dependency is substituted by ≪send≫ (≪call≫) then P is preserved if the substitute dependency has the same subset of the stereotypes ≪secrecy≫, ≪integrity≫ and ≪high≫ applied to it. If this is not the case, we check for simultaneous additions that apply the required stereotypes to the new dependency.Example. The example in Fig. 9shows the Client side of a communication channel between two parties. At first (disregarding the evolution stereotypes) the communication is unsecured. In the packages Symmetric and Asymmetric, we have classes providing cryptographic mechanisms to the Client class.Applied to the Channel is ≪add≫ describing two changes with the reference ID's add_symenc and add_asymenc specifying two possible evolution paths: merging the classes contained in the current package (Channel) with either Symmetric or Asymmetric.Another application of ≪add≫, this time to the Client, describes the addition of either a pre-shared private key Ksym(ak1) or a public key Kserverof the server (ak2). To limit the allowed evolution paths for the model, the changes have constraints associated with them indicating that the addition of the symmetric and asymmetric mechanism have to be applied simultaneously with the addition of their respective keys (AND(ak1), AND(ak2)). The simultaneous addition of both keys is also forbidden (NOT(ak2)).The two deltas, representing two possible evolution paths induced by this notation, can be then given as input to the decision procedure described for checking ≪secure dependency≫. Both evolution paths respect sufficient conditions for the consistency of the security requirement to be satisfied.This section briefly describes the tool environment we have implemented to verify security properties of evolving models.The approach of evolution-based security analysis with the UMLchange profile has been implemented in the model analysis tool CARiSMA.33http://carisma.umlsec.deThe tool is built on the basis of Eclipse and fully integrates into the Eclipse GUI by providing different views for defining analyses and presenting results to the user.In order to analyze a model, the user has to define the analysis to be performed. The Analysis Editor provides a graphical user interface for the definition of analyses (see Fig. 10). The user can select the model he wants to analyze and choose one or more checks from a list of available checks. The different checks might require additional parameters. Therefore, the analysis editor displays a list of input fields for the currently selected check. The supported parameter types for a check are the primitives string, integer, float, and boolean, as well as folders and files. The analysis configuration is stored in a file which allows the user to repeat the analysis with the same configuration of parameters.During an analysis, CARiSMA loads the model and triggers all checks listed in the analysis configuration. The results are displayed in the Analysis Result View. Each performed analysis is shown as a root entry while the checks are second level entries. The checks return as either success or failure based on the result of their execution, which is indicated by different icons in the result view. Each check entry may contain further subentries offering details about the execution of a check. Subentries may be simple status information for the user, warnings in case of precautionary findings (i.e. noteworthy, but the check can still be successful), and errors that express the reasons why the check fails.In addition to the output presented in the analysis result view, CARiSMA generates a textual report. Each check can verbosely contribute to the report, e.g. by describing counterexamples for violated security properties or proposing improvements.Analysis of evolution. Apart from allowing the static analysis of models, CARiSMA provides mechanisms for analyzing evolutions to models. This is supported by certain checks that can be selected when defining an analysis.Basically, an evolution analysis follows the pipeline illustrated in Fig. 11. The steps shown have to be followed in the given order, using checks provided by CARiSMA. After identifying the changes to a model (Step 1), a second component computes the sets of deltas from the changes (Step 2). When analyzing model evolution with respect to security or compliance, it is possible that a subset of the changes are valid evolutions while others are not. The delta computation component computes these subsets for analysis. The actual security checks are then performed on either the deltas (Step 3a) or the modified models themselves (Step 3b). Valid deltas and the corresponding models can be persistently stored (Step 4). The process is explained in more detail in Section 4.3. CARiSMA allows the user to convert a normal analysis to an evolution analysis by providing a context menu entry for automatic conversion.Like Eclipse, CARiSMA has been implemented as a plugin based architecture. Using the modularity provided by this method, CARiSMA is distributed as plugins, of which the core plugin includes the main functionality. Furthermore, CARiSMA offers extension points facilitating the contribution of functionality of other plugins to provide different checks. CARiSMA can be started standalone as an RCP application or within an existing Eclipse. It is also possible to smoothly integrate it into existing modeling tools such as TOPCASED,44http://www.topcased.org/IBM Rational Software Architect55http://www.ibm.com/software/awdtools/swarchitect/or other tools based on Eclipse.CARiSMA is kept as model-type independent as possible. The framework and the core components are model-type independent, while the checks are mostly model type specific. Checking security properties specified with UMLsec stereotypes is of course bound to UML. However, it is also possible to realize model-type independent checks. For instance, we offer an OCL check plugin that can read arbitrary constraints from a catalog file and evaluate them on the structural properties of a model regardless of its type.Model access is provided via the Eclipse Modeling Framework (EMF) [18], which implements, among other tools, the OMG Meta Object Facility (MOF) specification [19]. It provides the basis for the metamodel implementation and allows us to work with models of arbitrary types.Fig. 12visualizes the overall architecture of CARiSMA. The CARiSMA core contains the graphical user interface and the routines for performing analyses, i.e. managing preferences, executing checks, etc. In order to enable the analysis of models of certain types, a metamodel wrapper plugin has to provide the EMF-based metamodel and register it at the CARiSMA core. The metamodel wrapper can further provide convenience functions for working with models of that type, e.g. for getting all elements of a certain type. The metamodel wrapper can be based on an existing metamodel implementation such as the Eclipse UML2 Plugin in case of UML models. Currently, we offer metamodel wrappers for UML2 and BPMN2. On top of the core and the metamodel wrappers, different plugins can be realized that contain the checks performed during model analysis. Some plugins, e.g. those checking UMLsec properties, might require further extensions of the metamodels such as the UMLsec profile offering security-related stereotypes. The evolution support will be explained separately in Section 4.3.The CARiSMA core provides a blackboard architecture that allows checks to exchange data. Required data can be specified as a pre-condition in the metadata of a check. Data provided by a check can be specified as a post-condition.Future contributions to CARiSMA. Users can easily contribute additional checks to CARiSMA. An extension point provides ability to define meta information of the check such as name, parameters, or conditions. The implementation of a checks is basically a simple Java class realizing the interface CarismaCheck provided by CARiSMA. The interface specifies the perform operations which will contain the actual model analysis of a check. The parameter values entered by the user are passed to that operation at runtime. The check also receives a reference to the framework to access the analyzed model and the blackboard as well as to generate output. For the latter, CARiSMA offers operations to append text to the analysis report and to create result entries. The report itself and the graphical components cannot be accessed by a check directly. The perform operation has to return a boolean expressing whether the check was successful.Support for additional modeling languages can be added by creating a corresponding metamodel wrapper plugin. It has to provide an EMF-based metamodel implementation or import it from some existing plugin and register it at the CARiSMA core.The components that provide the support for analyzing evolving models are shown in Fig. 13.Evolutions to a model are reflected by collections of change descriptions. A change consists of one or more exclusive alternative evolutions to a part of the model. These alternatives can then be broken down to one or more delta elements, which describe atomic changes to model elements. More specific, we support the description of the addition, deletion, substitution, editing and copying of model elements. The content of an alternative has to be applied in a single evolutionary step.Changes can be constrained using the three constraint types AND, NOT and REQ. While AND forces another change to be applied simultaneously, meaning during the same evolutionary step of the model, NOT excludes the referenced change from being applied to the model in the same evolution. Finally, REQ ensures that the referenced change is applied to the model before the constrained change takes place. This is to make sure that dependent changes are applied in the correct order.CARiSMA provides an interface to generate change descriptions (see Fig. 11, Step 1). Two implementations of this interface are incorporated into CARiSMA: the UMLchangeParser, which creates the change descriptions from UMLchange applications on the model [20], and the EMFDelta, which generates the change descriptions by computing the difference between the original and the evolved model using EMF Compare [21].A delta is a set of the above mentioned delta elements. The elements in the set are the atomic changes that amount to a possible evolution to the model. The delta factory (Step 2) receives a collection of change descriptions and processes the change constraints and alternatives, thereby generating all possible permutations over the alternatives, including the empty set, while following the constraints imposed by the changes. The elements of each valid change permutation are stored as a delta.A delta can be applied to the model using implementations of the IModifier interface (Step 3b). An existing implementation is the UMLModifier. The UMLModifier receives the original model, creates a copy of it and applies each atomic change described by a delta element to the model copy. The resulting model is stored for use in CARiSMA evolution-aware checks (Step 3a). To avoid unnecessary computation of model modifications, the models are lazily initialized only when a check needs the modified model for validation. Modifications are mainly executed via generic EMF methods, while the selection of UML-specific aspects are handled using a custom logic. It would therefore be easy to build other model-specific modifier implementations.The existing CARiSMA evolution checks each receive the list of computed deltas and iterate over each delta while checking the validity of the delta's modifications. If any change leads a model violating the checked security property, the corresponding delta is removed from the list to prevent subsequent checks from unnecessarily checking this delta again.The evolved models which passed all checks can then be persistently stored using the ModelExporter (Step 4), which is also able to store their corresponding deltas in an XML format alongside the models.

@&#CONCLUSIONS@&#
