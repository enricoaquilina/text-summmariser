@&#MAIN-TITLE@&#
A survey on scheduling problems with due windows

@&#HIGHLIGHTS@&#
The scheduling problems with due windows which generalize the due dates are surveyed.A job completed before (after) the due window incurs earliness (tardiness) penalty.The problems with both the given as well as the optimized due windows are reviewed.Job-dependent and job-independent earliness/tardiness penalties are considered.The paper is focused on computational complexity, algorithms, practical application.

@&#KEYPHRASES@&#
Scheduling,Due windows,Due window assignment,Earliness/tardiness,Number of early and tardy jobs,

@&#ABSTRACT@&#
In this paper, a survey of scheduling problems with due windows is presented. The due window of a job is a generalization of the classical due date and it is a time interval in which this job should be finished. If the job is completed before or after the due window, it incurs an earliness or a tardiness penalty. A review of an extensive literature concerning problems with various models of given due windows, due window assignment and job-independent and job-dependent earliness/tardiness penalties is presented. The article focuses mainly on the computational complexity of the problems, mentioning also their solution algorithms. Moreover, the practical applications of the reviewed problems are mentioned, giving the appropriate references to the scientific literature. One particularly interesting IT example is described in detail.

@&#INTRODUCTION@&#
Scheduling problems with due windows have their origins in Just-in-Time (JIT) philosophy. The main objective of JIT is to ensure that the required material is available exactly when it is needed, while maintaining the inventory at the lowest possible level, eliminating such waste components like overproduction, waiting time, unnecessary transportation, unnecessary processing, defective products, etc. (Kramer and Lee, 1993). Usually, JIT scheduling models assume an existence of job due dates and penalize both early and tardy jobs. If a job is completed before its due date, it implies earliness penalty, such as holding cost. On the other hand, a job finished after its due date implies tardiness cost, such as late charges, express delivery, or loss of sales. The recent results on JIT scheduling models with due dates can be found, e.g., in Shabtay (2012),Sourd (2005),Esteve et al. (2006),Ventura and Radhakrishnan (2003),Tuong and Soukhal (2010),Prot et al. (2013),Rasti-Barzoki and Hejazi (2013). For the earlier surveys on the problems with due dates see also Baker and Scudder (1990),Cheng and Gupta (1989),Gordon et al. (2002) and Lauff and Werner (2004). However, in manufacturing industry it is often expected that the jobs are finished in a certain time interval (due window) rather than at single point in time (due date) (Kramer and Lee, 1993). A due window is a generalization of the due date concept and defines a time interval in which a job should be finished. If the job is completed within the due window, then it is considered to be on time and no penalty is incurred. Otherwise it incurs an earliness or a tardiness penalty, depending on whether the job was completed before or after the due window, respectively.The scheduling problems with due dates as well as the ones with due windows are perceived as bicriteria or even multicriteria optimization problems. Namely, most of them are the problems of minimizing a linear composite objective function in earliness penalties, tardiness penalties and in some cases position of due dates or position and size of due windows (see e.g. Hoogeveen 2005 for details). Some of these problems consist in minimizing one objective (e.g., the sum of earliness penalties) subject to some constraints on other objectives (e.g., the sum of tardiness penalties), see e.g., Wan and Yen (2009),Cheng et al. (2014).There is a variety of applications of due window scheduling models in JIT manufacturing (Wu and Lai, 2007), semi-conductor manufacturing (Lee, 1991), chemical processing, PERT/CPM scheduling (Koulamas, 1996) as well as in IT. Consider, for instance, an IT company that provides access to multimedia data via Internet. Modern Internet services allow users to access multimedia data without downloading the whole file beforehand. An example of such a service is Video on Demand (VoD). Time constraints (required to ensure fluent and continuous data presentation) are very important in transmission of multimedia data. Constant miniaturization of mobile devices and the increase in popularity of high resolution video are the reasons, why not only the tardiness, but also earliness of the data transmission should be taken into account. This is connected with storing large amount of data in the mobile device’s input buffer (i.e., specially allocated part of the device memory). Namely, too early data transmission can cause overflow of this buffer. In such case, part of the data is lost and retransmission is necessary to keep the continuity of the data presentation. In an ideal case the data is delivered exactly at the moment when it needs to be displayed.User’s device (computer, tablet or smartphone) initiates communication with a server, demanding the start of various data transmission. The multimedia data is stored on the server hard disk drive and sent to each user’s device in fragments, usually in RTP (Real-time Transport Protocol (Schulzrinne, Casner, Frederick, and Jacobson, 2003)) packets (Perkins, 2003). The data fragments must be properly prepared (e.g. compressed, encrypted) on the server before they can be sent. Afterward, they are transmitted via server’s network interface. The user’s device stores the data packets in its buffer and creates subsequent video/audio frames by ordering, decrypting and decompressing the data packets. The order and time at which the data fragments are sent to the users’ devices are established according to the schedule created by the server’s software.Depending on the moment in which a given data fragment is sent by the server, three different situations are possible. First, and the most desirable is the one in which the user’s device buffer has enough free space to store the received fragment and there is still some time left before the video/audio frame is to be presented. This causes no interruption in the data presentation. In the second situation, the data fragment is received after the frame was to be presented, which obviously disrupts the presentation. In the third situation, the data is received too early which causes the buffer overflow, loss of the data packet and need for retransmission. Notice also that the device may increase the size of the buffer, causing additional software load that may lead to disruptions in the audio/video data being presented at the time. Either way, the customer may feel dissatisfied with an imperfect service (i.e., by disruptions). As a result, the provider can lose such a customer and have its profit lower than expected.The problem of data fragments scheduling described above is to assign each data fragment to one of the server’s processors and to determine the moments at which each fragment processing is to be finished. The objective is to ensure that all the data fragments are prepared for sending to users and that the total cost associated with the late deliveries, buffers reallocations and retransmission of these fragments is minimized.The above situation is reflected by the following scheduling problem with due windows. All the necessary actions performed by the server and needed to prepare the data fragment for sending are referred as a job. Each job is to be processed on one of the parallel processors. The job processing time is the time needed to perform the data processing actions, i.e., reading the data from the hard disk drive, preparation (i.e., compression, encryption, etc.) and sending them to the network interface. This time is proportional to the size of the data fragment.The beginning of the due window is the earliest moment at which the data packet can be sent to the mobile device and does not cause the buffer overflow. The end of the due window is the latest moment at which the data fragment can be sent and does not disrupt the presentation. These moments can be calculated based on the capacity and load of the user’s device buffer at the moment t (i.e., the amount of data stored in the buffer expressed in bytes), the speed of data reading from this buffer (in bytes per second), the amount of data (in bytes) sent from the server to the buffer after the moment t, the total amount of memory of the user’s device (in bytes), by which the buffer should be resized as a result of requests sent by the server, RTT (Round Trip Time, i.e., the amount of time, in seconds, needed to exchange the above mentioned control information). Note that these control information may be exchanged using the following RTCP (Real-time Transport Control Protocol) packets: Sender Report RTCP packets, Receiver Report RTCP packets and Application-defined RTCP packets (see Esteve et al. 2006 for details).The earliness penalty relates to the cost of the buffer resizing in the user’s device. The tardiness penalty is related to the cost of disruption of the presentation in the user’s device. Both above mentioned penalties are proportional to the charge for using the service by the customers (since in both cases the service becomes unreliable which can cause loss of dissatisfied customers). The exact value of these penalties should be determined by statistical analysis of the real data transmissions. The whole above example was originally presented in Januszkiewicz (2012).Notice that in the scheduling literature there also exist several other concepts of executing jobs in time intervals (windows). However, these concepts are more restrictive than the idea of due windows, i.e., job execution is forbidden outside these fixed (or optimized) intervals. The most restrictive seem to be the interval scheduling problems, in which there is given a set of available parallel processors and all jobs have fixed starting and completion times. The aim is to determine whether there exists a feasible non-preemptive schedule for all jobs (Kroon et al., 1995), or to minimize the total number of processors needed to process all jobs (Lee et al., 2012), or (in the case in which not all jobs need to be assigned) to maximize the total profit of accepted jobs (or minimize the total cost of rejected jobs) (Kovalyov et al., 2007; Spieksma et al., 2007).Less restrictive are scheduling problems with minimum and maximum time lags, where each job has a given interval (described by minimum and maximum time lags), in which it has to be started (this is not a time point like in the previous problems, but an interval). These time lags are associated with completion time of preceding job Sheen and Liao (2007).If the intervals are not associated with the preceding jobs, then such problems are known as scheduling problems with time windows (Sedeño-Noda et al., 2006; 2009). For the problems with time windows – similarly as for the previously mentioned problems – the jobs cannot be executed outside the time windows. Such problems are sometimes referred to as the problems with hard time windows, in contrast to the problems with soft time windows. In the latter problems it is allowed to execute jobs outside the time windows to some extent (which is obviously penalized in appropriate way) (Fagerholt, 2001). Thus, the concept of the soft time windows are very similar to the concept of the due windows. However, the soft time windows are used rather in the problems from transportation and logistics area (ship scheduling, vehicle routing, etc.), where the job scheduling is only a part of more complex optimization processes. For this reason, the problems with soft time windows are out of the scope of our survey paper.The purpose of this paper is to present the main features of approaches developed to solve scheduling problems with due windows. We concentrate on the computational complexity results for the considered problems and the proposed solution algorithms. The remainder of the paper is organized as follows. In the next section we present the three-field notation for the scheduling problems. Section 3 concerns scheduling problems with given due windows. In Section 4 we describe results for problems with a common due window assignment. Section 5 concentrates on scheduling problems with other models of due window assignment. We conclude the paper in Section 6.Now we present the notation which is used in the paper. We examine problems of scheduling n jobs (J1, J2, …, Jn) on m (mainly parallel) processors (M1, M2, …, Mm) to minimize a given objective function. It is assumed that a processor can process at most one job at a time and all jobs are ready for processing at time t = 0. Each job j, j = 1, …, n, is characterized by a set of m processing times pij, i = 1, …, m (i.e., there are different processing times on different processors for a given job). Some special cases with only one processing time for each job are also considered in our paper (there are especially the cases with a single processor or with identical parallel processors). Simplifying the notation, we denote the processing times as pj(i.e., without the processor index) for such cases. There is also given a set of weights, e.g., αj, βjfor each job.Let us define:•ej— the beginning of the due window (earliest due date) of job Jj;dj— the end of the due window (latest due date) of job Jj;Dj= dj− ej— the size of the due window;Sjand Cj— the starting time and the completion time of job Jj;Ej= max {ej− Cj, 0} and Tj= max {Cj− dj, 0} — the earliness and tardiness of job Jj;Vj={1,Cj<ej0,otherwiseandUj={1,Cj>dj0,otherwise;pmax  = max 1 ≤ j ≤ n{pj}.We will use the three field notation introduced by Graham et al. (1979) to describe the considered scheduling problems. The first and the third fields are devoted to characterize the processor environment and objective function, respectively. Now we will present the notation specific for scheduling problems with due windows that appears in the second field of this notation:•〈e^j,d^j〉— jobs have arbitrary due windows which are given in advance;〈e^,d^〉— jobs have a common arbitrary due window given in advance;〈e, d〉 — jobs have a common due window, its beginning and size are assigned in the optimization process;〈e, e + D〉 — jobs have a common due window, its beginning is assigned in the optimization process but its size is given in advance;〈ej= e + pj, dj= d + pj〉 — due window size is common for all jobs and is assigned in the optimization process while the beginning and the end of the due window are job specific and for a given job are equal to the sum of its processing time and some decision variables which are assigned in the optimization process (equal slacks (SLK) model of the due window assignment);〈ej= e, dj= d + pj〉 — the earliest due date is a decision variable and the latest due date is the sum of job processing time and some other decision variable;〈ej= e + pj, dj= d〉 — the earliest due date is the sum of the job processing time and a decision variable, and the latest due date is some other decision variable;〈e^,d〉— the earliest due date is given in advance and the latest due date is assigned in the optimization process.In some special cases it is assumed that the processing times of jobs and their weights are subject to some restrictions. For instance, if the earliness/tardiness weights are restricted such that for any two jobs, i and j, pi/αi< pj/αjimplies pi/βi≤ pj/βj, which we denote as pi/αi< pj/αj⇒pi/βi≤ pj/βj, then it is said that the ratios of the job processing times to the earliness/tardiness penalties are agreeable. These restrictions appear in the second field of the described notation. Other similar agreeable conditions are considered throughout this paper, e.g.,e^i<e^j⇒d^i≤d^j.Generally, all problem parameters and decision variables used in the reviewed papers are assumed to be real values. Possible assumption about positivity of the used parameters are mentioned when appropriate. There is one exception to the above assumption. Namely, the parameters are assumed to be integer (not real) values if the dynamic programming algorithm is constructed for a given problem. However, this assumption is not mentioned each time in this paper, since it is common assumption for dynamic programming algorithms (required by definition). Thus, each time when it is mentioned that a dynamic programming algorithm is constructed for a given problem, it is implicitly assumed that the parameters are integer.In this section we review the results for the problems in which all the jobs share a common due window that is given in advance, i.e.,ej=e^anddj=d^for each job Jj(j = 1, 2, …, n).The results analyzed in this section are summarized in Table 1, where the problems are described with the three field notation (introduced in Section 2). Next, a computational complexity status and the main solution algorithms are given for each problem, together with the appropriate literature references. For example, in the first position of the table we present the following single processor (1) problem (with the criterion αEj+ βUj, being the sum of the weighted (α) job earliness (Ej) and the weighted (β) number of late jobs (Uj)):1|〈e^,d^〉|∑(αEj+βUj),which was investigated by Liman and Ramaswamy (1994). The authors proved that the problem is NP-hard and constructed a pseudopolynomial time algorithm with time complexity O(n2d^∑pj).Generally, it can be seen in Table 1 that there are many pseudopolynomial time solution algorithms for the considered problems, which were constructed on the basis of the dynamic programming technique. The abbreviationB&Bused in positions 3 and 11 of the mentioned table denotes solution algorithms based on the Branch and Bound approach.In the remainder of the section we give the analysis together with some additional (in comparison to the information presented in the table) comments for selected the most interesting results from Table 1.At first, Biskup and Feldmann (2005) discussed the problem1|〈e^,d^〉|∑(αjEj+βjTj). Since the problem is at least NP-hard, the authors decided to use metaheuristic algorithms (particularly, evolutionary strategy, simulated annealing and threshold accepting) to solve the problem. Metaheuristic approach requires that every (potentially optimal) schedule must be representable in a way suitable for the metaheuristic algorithm. The representation should also be suitable for applying different operators like cross-over, mutation, etc. The authors decided to use permutation of the jobs extended by a number of dummy jobs (characterizing leading idle time) to represent the job schedule. For the detailed description of the schedule representation and used metaheuristic algorithms, please refer to Biskup and Feldmann (2005).Chen and Lee (2002) studied similar problem but with the parallel identical processors:P|〈e^,d^〉|∑(αjEj+βjTj).The authors proposed a branch and bound algorithm. The problem was first formulated as a set partitioning problem and then, in each iteration of the branch and bound algorithm, the linear relaxation of the reformulated problem was solved by the standard column generation procedure.The above mentioned problem was also extended to the case with the parallel uniform processors by Gerstl and Mosheiov (2013). The due window was assumed to be either restrictive (i.e.,e^was given sufficiently early to affect the optimal job sequence) or non-restrictive when it started late such that the optimal job sequence was not affected. It was also assumed that the jobs were identical and the earliness and tardiness costs were job-dependent. The objective was to find the jobs allocation to the processors and the job schedule such that the total weighted earliness and tardiness cost was minimized:Q|〈e^,d^〉,pij=1/vi|∑i∑j(αjEij+βjTij).Both non-restrictive and restrictive due window settings were studied and they were shown to be solvable in O(2mn3) and O(3mn3) time, respectively.Yoo and Martin-Vega (2001) investigated similar problems with the assumption that only the number of the early and tardy jobs was penalized. They showed that the problems1|〈e^,d^〉|∑(Vj+Uj)and1|〈e^,d^〉,rj|∑(Vj+Uj)can be solved in O(nlog  n) time by modified Moore’s Algorithm (Moore, 1968). Yeung et al. (2001b) proved that the above problem becomes NP-hard if the flow time penalty is additionally considered, i.e.,1|〈e^,d^〉|∑(αjVj+βjUj+θjCj).A dynamic programming algorithm with O(n3e^2pmax2∑pj(d^−e^))time complexity was constructed.In the same paper (Yeung et al., 2001b), the authors studied a similar problem with an additional assumption that the ratios of the job processing times to the earliness and tardiness weights were agreeable, i.e.,1|〈e^,d^〉,pi/αi≥pj/αj⇔pi/βi≥pj/βj|∑(αjEj+βjTj+αj′Vj+βj′Uj).It was shown that the problem is NP-hard and an O(n3e^(d^−e^)pmax2∑pj)time dynamic programming algorithm was constructed. The authors provided also polynomial time algorithms for several special cases of both of the above mentioned problems. Analyzing the above mentioned results, it seems to be enough in Yeung et al. (2001b) to consider the following agreeable condition: pi/αi> pj/αj⇒pi/βi≥ pj/βj.In Yeung et al. (2001a), the same authors discussed another very similar problem1|〈e^,d^〉|∑(αEj+βTj+α′Vj+β′Uj+θCj).Again, the problem was proven to be NP-hard and a dynamic programming algorithm with time complexity O(n2e^min{pmax,e}∑pj)was constructed.Huang et al. (2010) investigated the parallel processor version of the problem discussed by Yoo and Martin-Vega (2001):Pm|〈e^,d^〉|∑(Vj+Uj).This study presented some theoretical investigations and a heuristic algorithm. Additionally, rule characteristics were examined, and simulated data were used to verify the effectiveness and time consumption of the proposed algorithm.The following two-stage flowshop problem was studied by Yeung et al. (2004):F2|〈e^,d^〉|∑(Ej+Tj).The problem was shown to be NP-hard in the strong sense. The authors developed a branch and bound algorithm and a heuristic to solve the problem. They also showed that four special cases are either polynomially solvable or NP-hard in the ordinary sense.In Yeung et al. (2009), the same authors considered another two-stage flowshop problemF2|〈e^,d^〉|∑(αjUj+βjVj).It was shown that the problem is NP-hard. The authors derived several dominance properties and theorems, including elimination rules, sequencing rules based on Johnson’s order and lower bounds on the penalty, which helped to trim the search space for the problem. Finally, a pseudopolynomial dynamic programming algorithm with time complexity O(n2e^4(d^−e^))was developed to solve the problem.Mosheiov and Sarig (2010b) investigated the problem of minimizing the maximum weighted absolute deviation of the job completion time from a given common due window:1|〈e^,d^〉|maxj{wjEj, wjTj}. The problem is at least NP-hard, because its special case with a common due date is NP-hard (Li and Cheng, 1994). The authors showed that the special case of the problem with unit-time jobs is solvable in O(n) time.The results discussed in this section are presented in Table 2.The first researchers who studied scheduling problems with given job-dependent due windows were Sidney (1977), and Lakshminarayan et al. (1978) in the late 70’s. They considered the single processor scheduling problem in which penalties occurred for jobs that either started before their target start times or were completed after their due dates. The objective was to minimize the maximum penalty:1|〈e^j,d^j〉,e^i<e^j⇒d^i≤d^j|maxj{g(Ej′),h(Tj)},where g and h were monotonically nondecreasing continuous functions such that g(0) = h(0) = 0 andEj′=max{0,e^j−Sj}. To solve this problem, Sidney (1977) presented an O(n2) time algorithm and shortly after that Lakshminarayan et al. (1978) presented an O(nlog n) time algorithm.Koulamas (1996) studied the NP-hard problem1|〈e^j,d^j〉,d^j−e^j>pj|∑(Ej′+Tj).The author decomposed the problem into two subproblems: the first one was to find a good job sequence, and the second one was to insert optimally the idle times into a given sequence. He proposed several heuristics for the first subproblem and an exact algorithm for the second subproblem.Wan and Yen (2002) investigated a more general version of the problem, i.e.,1|〈e^j,d^j〉|∑(αjEj+βjTj).They presented several properties, proposed an exact algorithm to determine the completion time for each job in a given job sequence and constructed a tabu search algorithm to generate the job sequence.Behnamian et al. (2009) studied the parallel processor scheduling problemP|〈e^j,d^j〉,sjk|∑(Ej+Tj),where sjkwas the sequence-dependent setup time required before job k when it was scheduled after job j. The problem is NP-hard and the authors constructed hybrid metaheuristics to solve it. Ribeiro et al. (2010) proved that the problem1|〈e^j,d^j〉,sjk|∑(αjEj+βjTj)is strongly NP-hard and proposed an adaptive genetic algorithm. Various search operators were used to explore the solution space.Weng and Ventura (1995) investigated further the problem presented in Weng and Ventura (1994) by adding job-dependent tolerances, τj, of a common given due dated^,forming the following given job-dependent due window:〈d^−τj,d^+τj〉. Hence, the authors considered the problem1|〈d^−τj,d^+τj〉|∑(Ej+Tj),describing some optimality conditions and showing that the problem is NP-hard. A heuristic algorithm was proposed to find an approximate solution of the problem. The authors also showed that if agreeable condition pi≤ pj⇒τi≤ τjholds, then the problem1|〈d^−τj,d^+τj〉,pi≤pj⇒τi≤τj|∑(Ej+Tj)is solvable in pseudo-polynomial time O(n2min{d^,∑pj})by a dynamic programming algorithm.In this section we review the results for scheduling problems with a common due window assignment, in which the beginning of the due window (e) is to be assigned in the optimization process, but its size (D) is given in advance. The results are summarized in Table 3and – similarly as in the previous section – the most important facts are discussed and extended below. As it can be seen in the table, the analyzed problems are mostly solvable in polynomial or pseudopolynomial time. Moreover, the branch and bound algorithm (abbrev.B&B) and a Polynomial Time Approximation Scheme (abbrev. PTAS) were constructed for the problems in positions 2 and 6, respectively.Azizoglu and Webster (1997) studied the problem with the unrestricted due window location: 1|〈e, e + D〉|∑(αjEj+ βjTj), allowing job-dependent penalties. They showed that the problem is NP-hard and presented properties that characterize the structure of an optimal schedule, a lower bound and a two-step branch and bound algorithm. Finally, results from a computational experiment were reported.The following parallel processor problem was investigated by Kramer and Lee (1994): P|〈e, e + D〉|∑(αEj+ βTj). The authors showed that even two processor case is NP-hard. They provided an O(n2D) time dynamic programming algorithm and an approximation algorithm for the two processor case. The algorithm was extended to the general case and was shown to be asymptotically optimal.The following two processor flow shop problem was discussed by Yeung et al. (2009): F2|〈e, e + D〉|∑(αjUj+ βjVj) + δe. The authors derived several dominance properties and theorems, including elimination rules and sequencing rules based on Johnson’s order, lower bounds on the penalty, and upper bounds on the window location, which helped to trim the search space for the problem. They further showed that the problem is NP-hard and provided an O(n2e4D2P′) time pseudopolynomial dynamic programming algorithm, whereP′=∑i=12∑j=1npij.Yeung et al. (2001b) studied a series of single-processor scheduling problems with a common due window assignment and the given due window size. The authors investigated scheduling problems to minimize the sum of weighted earliness/tardiness, weighted number of early and tardy jobs, common due window location and flow time penalties. They assumed that the due window location had a tolerance d0 such that the location penalty was incurred only after d0. Pseudopolynomial dynamic programming and polynomial time algorithms were proposed to solve optimally the considered problems.In this section, we review the results for scheduling problems with a common due window assignment, in which the beginning and the end of the due window are to be assigned in the optimization process. The results are listed in Table 4. Note that the vast majority of the considered problems turned out to be easy to solve (i.e., in polynomial time).It can be also noticed that the objective criteria in the problems with given due windows do not take into account the due window parameters. If the due window size and location are considered decision variables, then the objective criterion includes additional penalties.In the above mentioned area, Janiak, Kovalyov, and Marek (2007) investigated the following problems: P|〈e, d〉|∑(Ej+ Tj) + γ(d − e) and P|〈e, d〉|max {αmaxjEj, βmaxjTj, γ(d − e)}. The authors proved that these problems are equivalent to the P||Cmax problem in the sense that an optimal solution of one of them can be derived from an optimal solution of any other of these problems in polynomial time. Therefore, the analyzed problems are strongly NP-hard, since P||Cmax is strongly NP-hard (Garey and Johnson, 1978). Moreover, each algorithm for one problem can be adapted to solve any other of them. In particular, a heuristic algorithm with the worst case ratio equal to43−13mand an exact algorithm based on the dynamic programming method with time complexity O(n(∑pj)m) can be constructed (based on the results known for P||Cmax). Additionally, note that the single processor versions of the above problems are polynomially solvable (see Janiak et al. 2007; Mosheiov 2001a).Mosheiov and Oron (2004) discussed the common due window assignment problem with unit job processing times and restricted number of parallel processors: Pm|〈e, d〉, pj= 1|∑(αEj+ βTj) + γ(d − e) + δe. The authors provided several properties of an optimal solution that allow a constant time (O(1)) due window assignment.The same problem but with job dependent earliness/tardiness penalties weights, i.e., Pm|〈e, d〉, pj= 1|∑(αjEj+ βjTj) + γe + δ(d − e) was considered by Janiak, Janiak, Kovalyov, and Werner (2012). The authors established properties of optimal solutions and reduced the problem to an assignment problem solvable in O(n5/m2). More efficient solution procedures were given for few special cases: the case in which the due window size cost did not exceed the due window start time cost, the single processor case, the case of proportional earliness and tardiness costs and the case of equal earliness and tardiness costs.Mosheiov and Sarig (2010a) analyzed yet another problem of scheduling identical jobs with due window assignment:Q2|p1j=1,p2j=s|∑j=1n(αEj+βTj)+γ(d−e)+δe.The authors showed that there are 12 candidate schedules for optimality and introduced an efficient constant time solution procedure.Janiak and Winczaszek (2003) investigated a problem in which the due window size is constrained from above and below: 1|〈e, d〉, Dmin ≤ d − e ≤ Dmax|α∑Ej+ β∑Tj+ θe + fW(d − e), where fWwas an arbitrary concave increasing function. The time complexity of the solution algorithm is O(nlog  n + log  pmax).A more general problem with non-linear earliness/tardiness penalty functions, i.e., 1|〈e, d〉, Dmin ≤ d − e ≤ Dmax|∑fE(Ej) + ∑fT(Tj) + fD(e) + fW(d − e), where fE, fTand fWwere arbitrary nondecreasing functions with fE(0) = fT(0) = fW(0) = 0, was studied by the same authors in Janiak and Winczaszek (2004). The problem is NP-hard, and the authors proposed a pseudopolynomial time O(n(∑pj− Dmin)2) algorithm based on the dynamic programming method.Janiak and Winczaszek (2006) further investigated the parallel processor version of the above problem: P|〈e, d〉, Dmin ≤ d − e ≤ Dmax|∑fE(Ej) + ∑fT(Tj) + fD(e) + fW(d − e). It was shown that the problem is strongly NP-hard and an exact algorithm based on the dynamic programming method with time complexity O(n(∑pj)3m − 1) was constructed.For the problem P|〈e, d〉|max {αmaxjEj, βmaxjTj, γe, δ(d − e)}, Mosheiov (2001a) proposed an O(max {nm, nlog  n}) time asymptotically optimal heuristic algorithm. If the job processing times are independent, identically distributed random variables with bounded support, then the absolute error of the solution obtained by this algorithm approaches zero. Moreover, for the special case of the problem with unit processing times of jobs, this algorithm delivers an optimal solution.There were also some attempts to minimize the maximum cost associated with job earliness, job tardiness and due window location and size. Janiak et al. (2012) studied the problem of scheduling n unit-time jobs on m identical parallel processors, in which a common due window had to be assigned to all jobs: Pm|〈e, d〉, pj= 1|max {αjEj+ βjTj+ γe + δ(d − e)}. The authors established properties of optimal solutions and reduced the problem to an assignment problem solvable in O(n4.5log0.5n/m2). More efficient solution procedures were given for several special cases.Mosheiov and Sarig (2010b) also discussed minimization of the maximum of the costs associated with job earliness, job tardiness and due window location and size in the following problems:1|〈e,d〉|maxj{αjEj+βjTj+γe+δ(d−e)},Pm|〈e,d〉|maxj{αjEj+βjTj+γe+δ(d−e)},Fm|〈e,d〉|maxj{αjEj+βjTj+γe+δ(d−e)}.They showed that for a given job sequence the optimal due window size and location can be found in polynomial time by solving appropriate linear programming problems (the abbrev. LP in Table 4).Mosheiov and Sarig (2009a) studied also some other min-max due window assignment problems, in which the goal was to schedule the jobs and assign the due window such that the highest cost among all jobs was minimized. The objective function consisted of four costs: for earliness, tardiness, due window starting time and due window size. The authors presented the following polynomial time solutions for the case with a single processor and for the case with two-processor flow-shop:•an O(n) time algorithm for the problem 1|〈e, d〉|max {αEj+ γe + δ(d − e), βTj+ γe + δ(d − e)};an O(n2log n) time algorithm for the problem F2|〈e, d〉|max {αEj+ γe + δ(d − e), βTj+ γe + δ(d − e)}.The cases of parallel identical processors and uniform processors were also proven to be strongly NP-hard, and simple heuristics and lower bounds were introduced and tested numerically.Mosheiov and Sarig (2008a) extended a classical single processor due window assignment problem to the case of position-dependent processing times: 1|〈e, d〉, pij|∑(αEj+ βTj) + γ(d − e) + δe. The authors did not restrict the processing time function to be neither monotonically increasing, nor monotonically decreasing. They provided an O(n3) time exact algorithm.Liman et al. (1997) studied the problem with controllable processing times:1|〈e,d〉;pj=pj′−xj|∑(αEj+βTj+Gjxj)+δe+γ(d−e),where pjwas the normal processing time,pj′was the minimum processing time, xjwas the amount of reduction in processing time (0≤xj≤pj−pj′) and Gjxjwas the cost of shortening the job. This problem is solvable in O(n3) time by transformation to the assignment problem. For more research on scheduling problems with controllable processing times see Shabtay and Steiner (2008) and Leyvand et al. (2010).Scheduling problems with a common due window assignment are still being extended with some additional (sometimes even bizarre) models, e.g., learning or/and aging effects or even maintenance activities. A learning effect is a phenomenon of improving workers’ production efficiency through a long time learning process. The aging effect (an opposite process to the learning one) is a phenomenon of decreasing workers’ production efficiency due to a long time tiredness process.The learning effect was first observed and described by Wright (1936) and then taken into account during the process of airplanes production. Subsequent literature shows that there are many examples of real-life applications of learning and aging effects, but without any scheduling processes.Biskup (1999) introduced the concept of dependency between the job processing times and the position of the job in a sequence to the scheduling problems. Next, several authors (Chen et al., 2006; Kuo and Yang, 2006; Mosheiov, 2001b; Wang and Xia, 2005; Wu, 2005; Wang, 2006; Yang and Chand, 2008) considered various models of the combination of scheduling processes with different variants of learning or aging processes (even in a multiprocessor flow-shop environment) without any reasonable real-life practical justification. The learning effect was also considered together with many other phenomena in scheduling processes (due dates, setups, deteriorating jobs, etc. – see e.g., Biskup and Simons, 2004; Biskup and Herrmann, 2008; Cheng et al., 2004; Gordon and Strusevich, 2009; Jiang et al., 2013; Wang and Cheng, 2007; Qian and Steiner, 2013).There were also considered scheduling problems with due windows and job processing times dependent on job starting times (i.e. deteriorating jobs), position or sum of normal processing times of the jobs already processed and even maintenance activities. The maintenance activity is an optional activity that requires a fixed time interval during which the production is stopped, as the processor is turned off. However, after the activity, the processor may become more efficient, which is reflected by the shortened job processing times (for recent papers in this area see e.g., Chen, 2008; Topal and Ramazan, 2010).Janiak et al. (2011) provided a survey of scheduling problems with learning and aging effects, paying particular attention to the practical applications of such problems considered in the literature. We must emphasize that, unfortunately, it appears (see Janiak et al. 2011) that a combination of scheduling problems and learning or aging effects in one model has no reasonable real-life applications in the literature. Obviously, there are several real-life applications of scheduling processes and learning (or aging) processes separately. Therefore, we see no point in further analysis of such scheduling problems (with learning and aging effects) from the practical (computer engineering, automatic control, technical and economical) point of view, unless a reasonable real-life example is provided. A survey of scheduling problems with maintenance activity with particular attention paid to practical applications of such models is also highly expected.To complete the survey of scheduling problems with common due window assignment, we will now provide results obtained for the mentioned extended models, even though some of them do not seem to have any practical example.Wang and Wang (2011) considered the single processor common due window assignment scheduling problem with learning effect and deteriorating jobs: 1|〈e, d〉, pj= (aj+ bt)rα|∑(αEj+ βTj) + γe + δ(d − e). The actual processing time of job Jjscheduled in position r in a sequence was given by pj= (aj+ bt)rα, where t > 0 was the starting time of job Jj, a ≤ 0 was the learning index and b was the deterioration rate common for all jobs. An O(nlog  n) time exact algorithm was constructed.Yang (2010) studied very similar problem with both start-time-dependent learning and position-dependent aging effects: 1|〈e, d〉, pjr= (pj− at)rb|∑(αEj+ βTj) + γe + δ(d − e), where pjr= (pj− at)rbwas the actual processing time of job Jjstarted at time t and scheduled in the rth position in a sequence. In this model, each job processing time consisted of a decreasing start-time-dependent function and an increasing position-dependent function. The author provided an O(nlog n) time exact algorithm.Zhao and Tang (2010) extended the above research by adding past-sequence-dependent setup times: 1|〈e, d〉, pj= aj+ bSj, spsd|∑(αEj+ βTj) + γe + δ(d − e), where the processor setup time (spsd) depended on the job sequence, i.e., the value of the processor setup time for a job in jth position in the sequence equaled tos[j]=δ∑i=1j−1p[i],s[1]=0and δ ≥ 0. The authors proposed an O(nlog  n) time exact algorithm.Mosheiov and Sarig (2009b) introduced the maintenance activity into scheduling problems with a common due window assignment. They studied the problem 1|〈e, d〉, ma|∑(αEj+ βTj) + γe + δ(d − e), in which a single maintenance activity (ma) that lasts a constant time t can be scheduled. The processing time of job Jjwas denoted by pjif the job was processed prior to the maintenance activity, and λjpj(0 < λj≤ 1) if it was scheduled after it. λjwas the modifying rate of job Jj. This model accurately reflects a maintenance break in a production environment during which the processor is turned off and no production is performed. The authors provided an O(n4) time solution.The above model was extended by Yang (2010) to include even learning and aging effects. He investigated the due window scheduling problem with the joint start-time-dependent learning and position-dependent aging effects under the deteriorating maintenance activity: 1|〈e, d〉, ma, pjr= (pj− at)rb|∑(αEj+ βTj) + γe + δ(d − e), where pjr= (pj− at)rbwas the actual processing time of job Jjstarted at time t and scheduled in the rth position in the sequence. The maintenance activity (ma) was defined as above. An O(n2log  n) time exact algorithm was provided.Cheng et al. (2010) introduced the following scheduling problem in which the duration of the maintenance activity was not constant: 1|〈e, d〉, ma, pj= aj+ bSj|∑(αEj+ βTj) + γe + δ(d − e). In this problem, the job processing time was given by a linear time-dependent deteriorating model. As before, the maintenance activity was allowed to improve production efficiency. But unlike in the previous model, the maintenance activity did not introduce a modifying rate λj. At most one maintenance activity was allowed throughout the planning horizon. It was assumed that the processor would be restored to its initial conditions by the maintenance activity and processor deterioration would start anew. The maintenance duration was a linear function of its starting time and was given by f(t) = μ + σt, where μ > 0 was the basic maintenance time, σ ≥ 0 was a maintenance factor, and t was the starting time of the maintenance activity. The later the production manager schedules the maintenance break, the worse is the condition of the processor and the longer it takes to restore it to its initial state. The authors proposed an exact O(n2log  n) time algorithm.The same authors studied in Yang et al. (2010) the same deteriorating maintenance concept but with a different job processing time model:1|〈e,d〉,ma,pjr=pjraj|∑(αEj+βTj)+γe+δ(d−e),where job Jjhad a normal processing time pjrand aj> 0 was a job-dependent aging factor. If job Jjwas scheduled in the rth position in a sequence, then its actual processing time pjrequaled topjr=pjraj. The maintenance activity (ma) was defined as above. An O(n4) time exact algorithm was provided.Zhao and Tang (2012) investigated the single processor due window assignment problem with deteriorating jobs and a rate-modifying activity:1|〈e,d〉,rm,pjA=pj+bSj|∑(αEj+βTj)+γe+δ(d−e).It was assumed that the actual processing time of a job (pjA) was a linear function of its starting time (Sj) and that the deterioration rate (b > 0) was common for all jobs. There was also a possibility to perform a rate-modifying activity (rm) with the duration of t units of time. The normal processing time of job Jjwas denoted by pjif the job was processed prior to the rate-modifying activity, and by λjpjif the job was scheduled after it, where λj> 0 was the modifying rate. If the normal processing time of job Jjwas pj(resp. λjpj) the actual processing time of job Jjif started at time Sjwas given bypjA=pj+bSj(resp.pjA=λjpj+bSj). The authors provided an O(n4) time solution. This rate-modifying activity model is very similar to the maintenance activity models presented by Mosheiov and Sarig (2009b) and Yang (2010), if λj≤ 1.Various other due window assignment models were also studied in the scientific literature. They are presented briefly in Table 5. The abbreviation FPTAS in positions 8 and 9 denotes Fully Polynomial Time Approximation Scheme.Janiak, Janiak, and Marek (2009) investigated the single processor scheduling problem, in which the earliest due date was a decision variable and the latest due date was the sum of job processing time and some other decision variable: 1|〈ej= e, dj= d + pj〉|max {αEj, βTj, γ(d − e)}. They considered also another problem where the earliest due date was the sum of job processing time and a decision variable, and the latest due date was some other decision variable: 1|〈ej= e + pj, dj= d〉|max {αEj, βTj, γ(d − e)}. It was shown that both problems are polynomially solvable in O(n) time.Janiak (2004),Janiak et al. (2007),Janiak, Janiak, and Marek (2009) and Janiak and Marek (2003) considered yet another group of scheduling problems, in which the due window size was common for all jobs and was assigned in the optimization process, while the beginning and the end of the due window of a job were equal to the sum of its processing time and some decision variables which were assigned in the optimization process. They showed the following results:•the minimization of the maximum weighted costs associated with job earliness, job tardiness, and due window size: 1|〈ej= e + pj, dj= d + pj〉|max {αEj, βTj, γ(d − e)} is polynomially solvable in O(n) time (Janiak, 2004; Janiak et al., 2007; Janiak, Janiak, and Marek, 2009; Janiak and Marek, 2003);the minimization of the sum of weighted costs associated with job earliness, job tardiness, and due window size: 1|〈ej= e + pj, dj= d + pj〉|∑(αEj+ βTj) + γ(d − e) is polynomially solvable in O(nlog  n) time (Janiak et al., 2007; Janiak and Marek, 2004b);the minimization of the sum of weighted costs associated with job earliness, job tardiness, and due window size, with unit earliness/tardiness penalty weights: 1|〈ej= e + pj, dj= d + pj〉|∑(Ej+ Tj) + γ(d − e) is polynomially solvable in O(n) time (Janiak et al., 2007).However, the problems in the parallel processor environment:P|〈ej=e+pj,dj=d+pj〉|max{αEj,βTj,γ(d−e)},P|〈ej=e+pj,dj=d+pj〉|∑(Ej+Tj)+γ(d−e)were proven to be strongly NP-hard. Janiak et al. (2007) proved the following theorems:Theorem 1An optimal schedule of the problem P|〈ej= e′ + pj, dj= d′ + pj〉|max {αEj, βTj, γ(d − e)} can be obtained from an optimal schedule of the problem P|〈e, d〉|max {αEj, βTj, γ(d − e)} by reversing the order of the jobs on each processor, and determining the appropriate due interval parameters from the following equations: ∑pj= e′ + d = d′ + e.An optimal schedule of the problem P|〈ej= e′ + pj, dj= d′ + pj〉|∑(Ej+ Tj) + γ(d − e) can be obtained from an optimal schedule of the problem P|〈e, d〉|∑(Ej+ Tj) + γ(d − e) by reversing the order of the jobs on each processor, and determining the appropriate due interval parameters from the following equations: ∑pj= e′ + d = d′ + e.According to these theorems, any algorithm constructed for the problem P|〈e, d〉|max {αEj, βTj, γ(d − e)} can be easily adapted to solve the problem P|〈ej= e′ + pj, dj= d′ + pj〉|max {αEj, βTj, γ(d − e)} and any algorithm constructed for the problem P|〈e, d〉|∑(Ej+ Tj) + γ(d − e) can be easily adapted to solve the problem P|〈ej= e′ + pj, dj= d′ + pj〉|∑(Ej+ Tj) + γ(d − e) (see also beginning of Section 4.2).If the number of the parallel processors is limited to two, then the above mentioned problems are ordinarily NP-hard. Janiak et al. (2007) and Janiak and Marek (2004a) provided an O(n∑pj) time dynamic programming algorithms and fully polynomial-time approximation schemes for both of the problems: P2|〈ej= e + pj, dj= d + pj〉|max {αEj, βTj, γ(d − e)}, and P2|〈ej= e + pj, dj= d + pj〉|∑(Ej+ Tj) + γ(d − e).In Mor and Mosheiov (2012c), the authors combined due window assignment based on a common flow allowance with an option of scheduling a maintenance activity. The flow allowance procedure adapted here was previously presented in Adamopoulos and Pappis (1998) and extended in Mosheiov and Oron (2010): each job has its own due window, but they all share a common due window size. The starting time of the due window of a given job was equal to the sum of its processing time and a job-independent constant (ej= pj+ e). Similarly, the completion time of the due window of a given job was equal to the sum of its processing time and a (larger) constant (dj= pj+ d).The model of the maintenance activity considered in Mor and Mosheiov (2012c) followed the one presented by Lee and Leon (2001), where the maintenance duration was a constant (T = t0) and its impact on the job processing times was job dependent. The processing time of the job scheduled after the maintenance was equal to θjpj, where θj(0 < θj≤ 1) was the modifying rate of job j, j = 1, …, n. It was proven that for a given position of the maintenance activity, the problem is reduced to a standard assignment problem. The number of these positions is clearly bounded by n (the number of jobs), implying that the total complexity (required for solving up to n assignment problems) is bounded by O(n4).Next, the authors considered in Mor and Mosheiov (2012c) also two other models of the maintenance activity: (i) time-dependent maintenance (the maintenance duration T(t) = t0 + ωt, where ω ≥ 0 is the deterioration factor), and (ii) position-dependent maintenance (if the maintenance is scheduled before the job in position r, its duration is T(r) = ɛr, where ɛris a constant, and ɛr≤ ɛr + 1, r = 1, …, n − 1). Moreover, the authors introduced in Mor and Mosheiov (2012c) also general position-dependent processing times of the jobs to the considered problem (general means here that the dependency of the job processing time on the job position may be described by any function). This extension was considered under all the above settings – the flow allowance and all three maintenance models (i.e., the constant, the time-dependent and the position-dependent). The authors showed that the computational complexity of the solution algorithm for all the above mentioned cases remains O(n4).In another recent paper, Mor and Mosheiov (2012a) studied a single processor due date assignment problem based on the flow allowance with a minmax objective function. In their paper, the goal was to schedule the jobs and assign due dates, such that the cost of the worst scheduled job was minimized. They introduced polynomial time solution algorithms for the above basic problem, as well as to several extensions (where one extension was the due windows setting based on the flow allowance instead of the due dates). In Mor and Mosheiov (2012b), the same authors extended their studies to the parallel identical processor case and the parallel uniform processor case and the setting of the due windows based on the flow allowance: P|〈ej= pj+ e, dj= pj+ d〉|maxj{max {αEj+ γe + δ(d − e), βTj+ γe + δ(d − e)}} and Q|〈ej= pj+ e, dj= pj+ d〉|maxj{max {αEj+ γe + δ(d − e), βTj+ γe + δ(d − e)}}. As the problem was proven to be strongly NP-hard for the parallel identical processor case, efficient heuristics and a lower bound on the optimal objective function value, based on the load balancing on the processors, were introduced. The proposed heuristics consisted of an allocation of the jobs to the processors (based on the Longest Processing Time first (LPT) for the parallel identical processors, and modified LPT for the uniform processors), followed by a simple procedure for obtaining the optimal common flow allowance value (for this job allocation). The latter step was based on a solution of a linear program, but it was shown that this solution can be replaced by some closed form expressions. The overall running time of the proposed heuristics required to solve all problems (due date and due window, parallel identical and uniform processors) is O(nlog  n) for any given number of processors.In this paper, the state of the art of scheduling problems with due windows was presented. Based on this survey, it can be noticed that the scheduling problems with due windows have been considered in the scientific literature for many years (the first papers in this area emerged in the 70’s of the twentieth century). Moreover, many different problems (with different types of due windows and different criteria) have been proposed and solved so far. For example, we have discussed problems with a given common due window, given job-dependent due windows, common due window assignment and a given due window size, due window size and location assignment and some other models of the due window assignment. Also, we have considered job independent and job dependent earliness/tardiness penalties criteria.The computational complexity and solution algorithm results obtained for the problems mentioned above (and considered in subsequent sections of this survey) are given in concise form in Tables 1–5.A currently noticeable trend in the above mentioned area is the concept of combining pure due window scheduling problems with other new and trendy phenomena, like e.g., learning or aging effects, deteriorating jobs, maintenance activities, etc. Many of the obtained models are very complicated from the mathematical point of view, but unfortunately they have no reasonable practical justification in the literature. Thus, it is rather a theoretical, not practical trend. Also, the due window scheduling problems with unit time jobs have been considered recently.In our opinion, among the future trends in this area there could be, for example, analysis of scheduling problems with due windows and preemptive jobs or precedence constraints, which seem to be more justified from the practical point of view than the above mentioned models (we believe that the practical justification will have significant impact on the future trends in the discussed field). Also, the problems with multiple due windows or the ones in which a due window is common but only for a subset of jobs seem to be interesting for the future research.We would like to thank the anonymous reviewers (especially reviewer #2) for their insightful and really helpful comments. The research was supported by National Science Center, decision no.: DEC-2011/03/B/ST6/00364.

@&#CONCLUSIONS@&#
