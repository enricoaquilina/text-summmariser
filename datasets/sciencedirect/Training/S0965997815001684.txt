@&#MAIN-TITLE@&#
Analysis and classification of flow-carrying backbones in two-dimensional lattices

@&#HIGHLIGHTS@&#
The application of the backbone effect in the transport throughput capacity of materials is considered.A novel parallel implementation of the backbone algorithm is proposed for percolation lattices.The theoretical algorithm complexity is estimated for data-flow implementation.The results are analyzed regarding the classical graph-based approaches and the execution efficiency.

@&#KEYPHRASES@&#
Flow,Current,Backbone,Infinite cluster,Percolation,Parallel algorithm,Data-flow,

@&#ABSTRACT@&#
The paper proposes a new data-flow based approach for the identification of backbones in infinite clusters on 2-D percolation site lattices of dimension L × L. The infinite cluster is identified first, then a multi step algorithm is applied for the reduction of the infinite cluster to its backbone. Algorithm performances are evaluated theoretically and experimentally. The algorithm is local and can therefore be efficiently implemented on data-flow parallel platforms in Θ(L) time if applied on percolation lattices near the critical percolation probability or in Θ(L2) in the worst case. The proposed methodology could resolve the problem of stack overflow at large systems that can appear with classical graph based algorithms, and has potential for a higher execution speed-up on parallel architectures.

@&#INTRODUCTION@&#
In the context of percolation theory, the concept of spreading hypothetical fluid particles through a random media  [1], e.g. porous materials  [2], was introduced in the past. The problem can be formulated as a bond percolation problem or a site percolation problem. In this paper, we deal with the site percolation problem, schematically illustrated by a 2-D lattice of square cells. Finding a spanning cluster, termed also infinite cluster (IC), is one of the fundamental tasks in this theory. Such clusters appear if the probability that a percolation site is occupied is higher than the critical probability threshold pc[3]. The backbone (BB) can be informally described as parallel pipelines, with no dead ends, that connect two opposite boundaries of the lattice. The BB has an important role in many transport processes through the percolation system, e.g. composite  [4] or photovoltaic materials  [5], nanoparticles  [6], etc. because it enables an accurate evaluation of the non-linear media resistance, permeability or other crucial parameters of various technological processes  [7].Well-known algorithms for the identification of ICs and its parallelization have been presented in  [8–10]. Also, several algorithms for BB identification in ICs are known and published in  [11–13]. Most of the algorithms for BB identification are recursive, with a risk of stack overflow in large systems. Observing the local characteristics of system elements, e.g. site connectivity, we have explored the system properties and propose a local seven-step algorithm for the determination of the BB.The algorithm is informally summarized in this paragraph. A lattice of black–white cells is generated, either by a random principle or by a rule. The existence of eventual ICs is confirmed by labeling the white components of the initial lattice, using only the information about the state and connectivity of local cells. If at least one IC exists, the algorithm removes ICs’ dead ends using the information about the site connectivity. Then the algorithm locally recognizes so called articulation cells (ACs), that can split an IC into two or more parts, if ACs are removed from the IC. A classification of ACs enables a local identification of the BB based on flooding.A simple illustrative case is shown in Fig. 1. In its left part, a percolation lattice with dimensions 21 × 21 cells (sites) is shown. The occupied cells, obtained with the percolation probabilityp=0.6,are colored black. In the middle, the corresponding IC is shown with black cells. In the right part, the corresponding BB is shown with red cells. The remaining cells are shown in light blue, for better visibility. We see that all dead ends of the BB have been removed. Only one conductive path has been identified. It spans from the top to the bottom lattice boundary and can therefore contribute to a flow or transport of a matter between boundaries.This paper is based upon Stamatović et al.  [14], extended with the following new contributions: (i) the improved algorithm for the identification of a BB in 2-D lattices has been upgraded with two additional steps, to manage all dangling IC parts on boundaries, (ii) the calculation and communication complexities of its data-flow implementation have been evaluated, and (iii) various lattices have been experimentally characterized regarding the number of time-steps and the sizes of ICs and BBs.In the rest of the paper, some essential definitions are given, supported by illustrative examples. A new algorithm for the identification of backbones in an infinite cluster on 2-D percolation lattices with open boundary conditions is proposed. Similar problems, or at least parts of them, have been considered in [8,11,12] but none of the suggested algorithms is entirely local. Our algorithm relies on local properties of the percolation lattice cells and is not limited by the size of the lattice. The proposed solution can resolve the problem of stack overflow that could appear with the classic algorithms for the backbone identification, if implemented on the standard sequential computers. An extensive experimental evaluation of 2-D lattices is done regarding the percolation probability, the size of BBs and the number of algorithmic time-steps. We confirmed that the proposed algorithm has a high potential for a scalable and efficient parallel implementation on data-flow computing platforms, e.g. graphics processing units (GPUs), many-core accelerators (Intel Phi), field programmable gate arrays (FPGAs), systems on chips (SoC), or other processing arrays with high radix interconnection networks [15].We consider a 2-D lattice network of unite squares (cells) whose centers are in an integer lattice. For simplicity, we suppose that the lattice hasN=L×Lcells ci, jwith positions determined by the indicesi,j=1,…,Lin x and y directions, respectively, with L ≥ 3. Each cell can exist in a finite number of states, marked by colors. The cells can change their states at the end of individual time-steps, i.e. at that are discrete moments in time that mark the completion of a computation. The state of all lattice cells in a time-step t is denoted by Ct, t ≥ 0.We use the Moore neighborhood with twenty-four neighbors. Each cell has four nearest neighbors (nn), four next-nearest neighbors (nnn) and sixteen not next-nearest neighbors (nnnn). Two cells ci, jand ck, lare nn-neighbors if|i−k|+|j−l|≤1,nnn-neighbors if(i−k)2+(j−l)2=2and nnnn-neighbors if4≤(i−k)2+(j−l)2≤8. For short notation, the relative positions of cells are denoted by the compass notation, e.g. E for the right nn-cell, NE for the right-upper nnn-cell, WNN for the left-upper-upper nnnn-cell, etc. The nn-path (nnn-path) is a sequence of black cells pi, 1 ≤ i ≤ n, n ≥ 2, such that each pair, piandpi+1,is nn-connected (nnn-connected). More definitions about connectivity can be found in [16].The initial configuration of the percolation sites C0 can be represented by a 2-D lattice of square cells and each cell can exist in two different states, marked by the white or the black color. The left (W) and the right (E) boundary cells of the lattice are white, while the remaining cells of the top (N) and the bottom (S) boundaries are black. The lattice is surrounded by one additional layer of white cells, to simplify the analysis of cells near boundaries when the nnnn-neighborhood has to be examined. This layer is not shown in illustrations of our examples. All the remaining inner cells of the lattice, are colored black with the site probability p, and white with the probability1−p. The probabilities are independent for each cell. A black nn-cluster is a group of black cells that are nn-connected. Note that the critical probability for such a percolation lattice of nn-connected sites is pc≈ 0.59, which is known from the site percolation theory  [1]. Site percolation probabilities p < pcshould not result in an IC.The infinite cluster (IC) is a large black nn-cluster that spans from the top to the bottom boundary of the above defined lattice. The neighboring cells of nn-clusters are connected by edges termed also as bonds. In the same way, an nnn-cluster is a group of cells in the same state that are nn- or nnn-connected. In particular, a white nnn-cluster is a group of white cells that are nn- or nnn-connected.The backbone (BB) is a set of black cells from the interior of the lattice that are nn-connected with the top and the bottom boundary by two nn-paths that have no bonds in common [18]. The BB is a subset of cells from ICs that are nn-connected and spans from the top to the bottom boundary of the percolation lattice. Some cells that are members of the IC are dangling, i.e. nn-connected with the IC through just a single cell. Consequently, they cannot be members of the BB. The shapes of such dangling parts can be single cells, branches or loops of cells, termed in our paper as dangling ends or dangling loops.The BB has an important role in the transport processes of percolation systems. For example, if we study a fluid flow across the bonds of a lattice that connect black cells, we will find out that some of the bonds experience the flow, while the others are dangling ends or loops with no flow. Another example of the applicability of BB identification is in conductivity studies of composite materials made from resistive nano particles, where the BB could be defined as a part of the cluster that can carry electric current if the top and the bottom lattice boundaries are on different electric potentials.The articulation cell (AC) is a black cell of a black IC if its removal (changing its state to white) splits the existing IC into two or more parts, with at least one part becoming unconnected with, or isolated from, the top and the bottom boundaries. The key for finding the BB is to find its ACs. However, local rules, limited to the nnnn-neighborhood, should be applied for the data-flow determination of ACs’ relations to the BB. Some specific cases of ACs are illustrated and informally explained in the left part of Fig. 2on an example of the IC from Fig. 1. In the right part of Fig. 2, the identified BB is colored red.The lattice shown in Fig. 2, with 21 × 21 cells, incorporates the top and the bottom boundaries, a single black IC (nn-cluster), thirteen white nnn-clusters Oi,i=1,2,⋯,13,and thirteen ACs aj,j=1,2,⋯,13,of which two are dangling ends a1 and a2. We know that a removal of an AC can isolate a part of IC from the top and the bottom boundary. For example, a removal of a12 or a9 would isolate the dangling parts A and C and hence, these ACs cannot be parts of the BB.Some ACs, however, can remain parts of the BB. For example, a7, a10a11 and a13 are parts of the BB. Any cell of the IC not in A, B, C or D, will not become isolated by removing these ACs. On the other hand, a4 and a8 are not in the BB, because they would become isolated through the isolation of the dangling part C or A, respectively.Hence, to correctly remove all the dangling parts of the IC, to obtain the final BB, ACs have to be identified and classified according to whether they belong to the BB or not. Note that each AC has in its nnn-neighborhood at least two cells from the common white nnn-cluster. For example, NE and W neighbors of a12 are in O1, and NE and SW neighbors of a13 are in O13. Now, if all white nnn-clusters can be labeled by unique colors, using Corollary 1[12], ACs can be identified and classified locally, just from the state of their nn- and nnn-neighbors.Corollary 1Let ci, jbe a cell of a black IC and let Gc be a set of ci, jand their nn- and nnn-neighbors. Cell ci, jis AC if and only if there are at least two white cells in Gc that belong to the same nnn-cluster but can not be nn-connected with white cells in Gc.With the unique labeling of white nnn-clusters by unique colors, and assuming that the number of white nnn-clusters of the initial lattice C0 is w < N/2, we can obtain the information whether two or more white cells of Gcbelong to the same or different white nnn-clusters. This information is important for the determination of AC’s relation regarding its membership in the BB. The unique colors genm,m=1,2,⋯,N,can be determined from the cells’ positions, for example as:m=iL+j,and must be different from white, black, green, blue, red and tagging colors (defined at the end of this section), that are reserved for special use.Let gen ∈ genmbe a generic name for a unique color. For each gen cell, a maximal gen value from the nnn-neighborhood can be used for coloring all separate white nnn-clusters uniquely, with a subset of genw⊂genmcolors. After such a labeling of all white nnn-clusters, we can identify ACs using the Corollary 1 and the classification of ACs’ Gc(nn- and nnn-neighbors). We distinguish two main cases in the classification of ACs.In Case 1, cell ci, jis an AC if it either has at least three gen cells in Gcthat are not nnn-connected in Gcby gen cells or has two opposite (N and S, or W and E) gen nn-neighbors.The state of ci, jhas to be changed to the state denoted by gen. All possible irreducible cases are shown in Fig. 3(a)–(c). Analogue cases are obtained by their rotation for 90°, 180°, and 270°. For example, the central cell ci, jof Gcin Fig. 3(c) has three black nn-neighbors, E, N and S, and three gen cells, EN, W and ES. By the counter clockwise rotation of the Gcfor 90°, we obtain N, W, E black cells and WN, S, EN gen cells. Note that the ACs a1, a2, a3 and a5 from Fig. 2 belong to Case 1 (Fig. 3(a)) and a12 is also Case 1 (Fig. 3(b)).We know that the cells of Gcwith the same gen belong to the same white nnn-cluster in the initial configuration C0. Hence, they are nnn-connected with gen cells in a configuration obtained after the labeling of white nnn-clusters. Such a gen nnn-cluster surrounds dangling ends and loops that are, in Case 1, composed of actual ACs. So, we must remove such ACs by coloring them with genwcolor and no further tagging is needed.In Case 2, cell ci, jis an AC if it either has three black nn-neighbors, one gen nn-neighbor and one same gen cell that is not nnn-connected with the gen nn-neighbor in Gcby the gen cells, or has four black nn-neighbors and two gen nnn-neighbors that are diagonally opposite (EN and WS, or WN and ES). Note that the ACs a4, a6, a7, a8, a9, a10, a11 and a13 from Fig. 2, are cases from Fig. 3(e), (d), (e), (e), (e), (f), (f) and (f), respectively. Now, ci, jperhaps belongs to the BB and we “temporarily” remove it by marking it with white.Applying the above classification of ACs, cells a1, a2, a3, a5, a12, from Fig. 2, are permanently removed and cells a4, a6, a7, a8, a9, a10, a11, a13 are marked with the white color. Now we tag contact couples that are pairs of orthogonally positioned black cells in the AC’s (now white) nn-neighborhood. For example, in Fig. 3(d), N and E cells are tagged as a contact couple, in (e), E and S are tagged as a contact couple, and in (f), N and E are tagged as a contact couple and also S and W. As another example, for cell a7 from Fig. 2, N and E are tagged as a contact couple. For cell a10, N and W are tagged as a contact couple and also S and E. Also, cell a13 has two tagged contact couples, N and W, and S and E.We know that two cells of a contact couple are nn-neighbors of a gen cell that is different from other genwcells in Gc, e.g. cells ‘O’ in Fig. 3(d)–(f). Notice that it is impossible to have two ‘*’ and two ‘O’ gen cells in Gc. Namely, if in Fig. 3(f), ‘X’ is a gen cell, then it cannot be the same as ‘O’, because the nnn-clusters of ‘*’ and ‘O’ that surround the part of the IC, would be “mixed up” with each other (two different gen nnn-clusters are separated by an IC). Based on the tagged contact couple cells, we will obtain the information whether they are in the BB or not, by the following reasoning. If, after previous coloring of ACs by white, a cell from a contact couple remains nn-connected with black N or S boundary cells, what we should see in the next step of the algorithm, then the remaining cell of the contact couple will use this information to declare itself as a part of the BB.The implementation of the proposed algorithm uses twelve tagging colors for twelve possible cases that are shown in Fig. 3(d)–(f) together with their rotations for 90°, 180°, and 270°. Different tagging colors are used for excluding all dangling loops from the IC. For example, in Fig. 3(f), if ‘X’ is not a black cell, then we have two contact couples (for ‘X’ and ‘O’) that must be tagged with different colors. After labeling ci, jwith white, the contact couples can not be both nn-connected with black N or S boundary cells, because the nn-connection was broken by just colored white ci, j. All the mentioned details are necessary for correct algorithm implementation, but are not essential for the conceptual understanding of the proposed local approach. Note that the implementation in  [17] admits some dangling loops.The proposed data-flow algorithm for the identification of BB has seven steps, as shown in Algorithm 1. All algorithmic steps are performed in all cells in parallel. The algorithm runs until the lattice state changes, i.e. the current time-step Ctis different fromCt−1. In Step 1, all white cells surrounded by S, E and SE black cells are marked with their unique genmcolors.Starting from these cells, in Step 2, all white nnn-clusters are colored with genwcolors, using flooding, until the state of the lattice becomes constant. Now, if the colors of the lowest left and right cells of the lattice are equal, these two cells are in the same nnn-cluster, which means that an nnn-path exists from the left to right boundary, which disconnects eventual IC. If an IC exists, the colors of these two cells must be different. Note that boundary cells are treated in the same way as inner cells, but taking into account that some neighbors are missing.In Step 3, ACs are identified and the tagging of specific cells is made. If an AC cannot disconnect the IC, the algorithm deletes it by coloring it with genwfrom its Gc. If an AC could disconnect the IC, it is marked by white. Then, the contact couple cells of the white cells are found, by examining the ACs’ nnnn-neighborhood, and tagged for Step 4.In Step 4, the algorithm colors some black and tagged cells in green. First, the black cells ci, j, fori=L−1ori=2are colored green. Then, all black and tagged cells that have green nn-neighbors are colored green with flooding. Eventually, the second cell of each contact couple that has got one green cell is also colored green, until the lattice state becomes stable.In Step 5, the algorithm marks some of the remaining ACs, which were colored white in Step 3, by green, to include them in the BB. To preserve the locality of the algorithm, nnnn-neighborhood is used for the implementation of the following rule (see [12]): If ci, jis a white cell, then it is a part of the BB if: (i) ci, jhas at least two green nn-neighbors or (ii) ci, jhas a green and a white nn-neighbor that are nn-connected with another green cell.In Step 6, green cells are flooded by a reserved color blue from the second to(L−1)th line of the lattice, while the Lth line is colored by a reserved color red. Now, the green cells that are nn-connected with top boundary cells but are not in the BB, become isolated. For example, in Fig. 2 cell a6 and its E neighbor become isolated from the BB after Step 6.In Step 7, blue cells are flooded with red from the(L−1)th line to the first line. Now, the blue cells that are nn-connected with bottom boundary cells but are not in the BB are isolated. Hence, the final BB remains colored by red.A natural approach for the implementation of a fast and scalable system that could implement the algorithm with maximal parallelism is an array of simple computing elements with a small memory and a simple arithmetic unit. Such technology is available today on various levels of granularity, from dedicated FPGA systems to general purpose GPUs or multicore computers. Note that more cells can be managed in parallel by a single computing element, but suppose now one element for each cell. The programming paradigm is data-flow, which is based on the same operations on many simple data items. It is known that such an approach could be extremely fast and energy efficient [19].From the description of the Algorithm 1 it is evident that calculation in each time-step is simple and limited only to the nnnn-neighborhood. However, because of the arbitrary shapes of ICs, the numbers of time-steps in the algorithm can not be expressed exactly. Steps 2, 4, 6, and 7 are based on flooding, which can be implemented, in the case of lattices obtained with percolation probability near pc, with Θ(L) time-steps, because just a few ICs can be present in this case with dimensions Θ(L). If an IC has a more complex shape, e.g. spiral, the number of time-steps could reach L2/2.Usually, the number of time-steps is much lower than L2, because the clusters are flooded earlier and the lattice reaches its stationary state. In order to use this advantage, a global communication is needed that can determine that the calculation can stop earlier. Now, after each time-step, or after a small number of time-steps, a global communication has to be implemented. One option is to design a line-wise shifting of local results to a single column vector that can also be shifted to a master cell. Such a global gather operation can be performed in 2L steps. Note that a similar approach must be present also for the initial loading of the data-flow system. Often, such a communication is not necessary in all time-steps. It could be more efficient to perform it only after several calculation time-steps. However, in the worst-case, after each time-step a global communication is needed, which becomes extremely expensive.Alternatively, the implementation of the stopping criteria can be done on the whole lattice by a special synchronization hardware that samples the status of each cell “running or idle” and synchronizes all computing elements by a single alert line in a single time-step. Taking into account this optimistic scenario we can conclude that the expected asymptotic complexity of the Algorithm 1 on parallel platforms is Θ(L), if applied on percolation lattices near the probability pc, because all the operations can be performed on all cells in parallel, for each time-step and with a single-time-step for the communication. However, some worst-case arrangements of the 2-D lattice cells could require Θ(L2) time-steps for the calculation.

@&#CONCLUSIONS@&#
