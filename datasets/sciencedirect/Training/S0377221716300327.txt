@&#MAIN-TITLE@&#
Exact and heuristic algorithms for the Hamiltonian p-median problem

@&#HIGHLIGHTS@&#
We provide three algorithms for the Hamiltonian p-median problem.The first algorithm is an exact branch-and-cut algorithm.The others are a constructive heuristic and an iterated local search metaheuristic.The exact algorithm can solve 100-vertex instances.The ILS metaheuristic solves the problem to near-optimality.

@&#KEYPHRASES@&#
Hamiltonian,p-median,Branch-and-cut,Metaheuristic,

@&#ABSTRACT@&#
This paper presents an exact algorithm, a constructive heuristic algorithm, and a metaheuristic for the Hamiltonian p-Median Problem (HpMP). The exact algorithm is a branch-and-cut algorithm based on an enhanced p-median based formulation, which is proved to dominate an existing p-median based formulation. The constructive heuristic is a giant tour heuristic, based on a dynamic programming formulation to optimally split a given sequence of vertices into cycles. The metaheuristic is an iterated local search algorithm using 2-exchange and 1-opt operators. Computational results show that the branch-and-cut algorithm outperforms the existing exact solution methods.

@&#INTRODUCTION@&#
This paper studies the Hamiltonian p-Median Problem (HpMP), defined on a complete undirected graphG=(V,E),where V is the vertex set, andE={(i,j):i,j∈V,i<j}is the edge set. There is a cost cijassociated with every edge (i, j). The aim is to partition the graph into p subsets of vertices, each connected by a single cycle. The objective is to minimize the total cost of edges belonging to the cycles. Following the convention of Gollowitzer, Gouveia, Laporte, Pereira, and Wojciechowski (2014), we only consider subsets (cycles) of cardinality 3 or more. The Traveling Salesman Problem (TSP) is a special case of the HpMP withp=1,and consequently the HpMP is NP-hard. It is worth mentioning that the 2-matching problem, which returns an arbitrary number of cycles is solvable in polynomial time (see, for example Miller & Pekny, 1995).Laporte, Nobert, and Pelletier (1983) introduced a series of location-routing problems and provided computational results for exact algorithms using cutting planes. One of these problems was to locate no more than p non-intersecting cycles in a graph with minimum cost, which was the precursor of the HpMP. The HpMP was introduced by Branco and Coelho (1990). It has received relatively little attention from researchers, and the existing studies have mostly focused on exact algorithms. Motivated by an application in laser multi-scanners, (Glaab & Pott, 2000) have studied the HpMP and presented a three-index formulation, together with results on the dimension of the associated polytope. Zohrehbandian (2007) has proposed a formulation for the HpMP based on a three-index Vehicle Routing Problem formulation, but did not provide any computational results. Gollowitzer, Pereira, and Wojciechowski (2011) have provided three formulations for the HpMP  together with valid inequalities and branch-and-cut algorithms. In a later study, (Gollowitzer et al., 2014) have introduced seven different formulations for the HpMP  which they have compared in terms of dominance relationships. They have also presented computational results for up to|V|=100. Hupp and Liers (2013) have conducted a polyhedral analysis of an HpMP formulation using only edge variables and proved that a subset of the well-known 2-matching inequalities from the TSP define facets of the HpMP polytope.There exist very few studies on heuristics for the HpMP and its variants. Glaab (2002) provided fast heuristics and improved lower bounds for a variant of the HpMP that arises in cutting problems. Uster and Kumar (2010) have studied the Balanced Ring Problem, which is another variant of the HpMP requiring the number of vertices on each cycle to be almost equal. They have provided a GRASP-based constructive algorithm as well as a local search heuristic. To the best of our knowledge, no metaheuristics have yet been proposed for the HpMP.The remainder of this paper is organized as follows. In Section 2, we recall a integer linear programming formulation for the HpMP proposed by Gollowitzer et al. (2014); we also introduce an alternative formulation with several reinforcements and we develop a branch-and-cut algorithm based on this formulation. In Section 3.1, we provide a giant tour heuristic based on a Dynamic Programming formulation. In Section 3.2, we provide an Iterated Local Search (ILS) algorithm for the HpMP. In Section 4, we present the computational results for our algorithms on benchmark instances. Conclusions follow in Section 5.Gollowitzer et al. (2014) have proposed a p-median based formulation, which they call Model 3. It uses variables for assigning vertices to other vertices. For the sake of completeness, we present their formulation below, which we call HpMP1. The authors denote the ordered vertex pairs of every edge (i, j) ∈ E asγ(i,j)={(i,j),(j,i)},and the edges between a subset of vertices W ⊂ V and the remaining vertices as δ(W). Let xijbe equal to 1 if edge (i, j) belongs to the solution, and 0 otherwise. Let yibe equal to 1 if it is selected as a depot, and 0 otherwise. Finally, let vijbe equal to 1 if vertex i is assigned to depot j, and 0 otherwise. The formulation is then:(HpMP1)(obj)minimize∑(i,j)∈Ecijxij(pm1)subjectto∑i∈Vyi=p(pm2)∑j∈V∖{i}vij+yi=1i∈V(pm3)vij≤yji,j∈V:i≠j(deg)∑j∈δ(i)xij=2i∈V(pm≤)∑(i,j)∈δ(W)xij≥2∑l∈V∖WvklW⊂V,k∈W(pm≥)vka+xij≤1+vla(i,j)∈E,(k,l)∈γ(i,j),a∈V∖{k,l}(pm≥′)yk+xij≤1+vlk(i,j)∈E,(k,l)∈γ(i,j)(sb)vij=0i,j∈V:i>j(bin)xij∈{0,1}(i,j)∈E(pm4)vij∈{0,1}i,j∈V:i≠j(pm5)yi∈{0,1}i∈V.The objective function (obj) minimizes the total cost of cycles. Constraint set (pm1) sets the number of cycles to p. Constraint sets (pm2) and (sb) require every vertex to be assigned to itself or to a vertex having a higher index. Constraint set (pm3) forces a vertex to be chosen as a depot if another vertex is assigned to it. Constraint set (deg) states that every vertex must have a degree of 2 which, in conjunction with (bin), enforces the minimum cycle size to be 3. Constraints (pm ≤) connect the vertices assigned to the same cycle by forcing two edges between the two complementary subsets if a vertex in one subset is assigned to a vertex in the other subset. Constraints (pm ≥) and (pm ≥ ′) eliminate connections between vertices that have been assigned to different depots. Constraints (sb) cut off symmetrical solutions by forcing all vertices in a cycle to be assigned to the vertex with the highest index. Finally, (bin), (pm4), and (pm5) are the integrality constraints on the variables.To facilitate our analysis, we propose an alternative formulation, called HpMP2, for the HpMP. It is obtained by unifying the variables vijand yjinto the variable wij, i.e. wijis a binary variable equal to 1 if and only if vertex i is assigned to vertex j, withwii=1meaning that vertex i has been chosen as a depot. This transformation results in a simpler presentation of (pm ≥) and (pm ≥ ′), and the new sets of inequalities we subsequently propose. For the sake of clarity, we present the resulting formulation in its entirety, including constraints that are not affected by the change of variables:(HpMP2)(1)minimize∑(i,j)∈Ecijxij(2)subjectto∑i∈Vwii=p(3)∑j∈Vwij=1i∈V(4)wij≤wjji,j∈V(5)∑j∈δ(i)xij=2i∈V(6)∑(i,j)∈δ(W)xij≥2∑l∈V∖WwklW⊂V,k∈W(7)wka+xij≤1+wla(i,j)∈E,(k,l)∈γ(i,j)a∈V(8)wij=0i,j∈V:i>j(9)xij∈{0,1}(i,j)∈E(10)wij∈{0,1}i,j∈V.Note that the transformation unifies constraints (pm ≥) and (pm ≥ ′) into (7). We now state our first result.Proposition 1The following inequalities are valid for HpMP2, and dominate(7):(11)∑k∈Swik+xij≤1+∑k∈Swjk(i,j)∈E,S⊂V.Since ∑k ∈ Swik≤ 1 and xij≤ 1, this inequality is valid whenever∑k∈Swik=0orxij=0. Thus, we only have to analyze the case where∑k∈Swik=1andxij=1. In this case,xij=1implies that i and j are assigned to the same depot and hence∑k∈Swjk=1. Therefore, the inequality (11) is valid. Note that (7) is a special case of (11) if|S|=1or|S|=|V|−1,and is therefore dominated by (11).□Although the number of constraints (11) is exponential, these can be separated in polynomial time. For any given edge (i, j) ∈ E, start withS=∅and include a vertex k ∈ V into S if and only if wik> wjk. This results in an overall complexity of O(|V|3).We now focus on (6). DefineF(W)as the set of all sets of pairs (i, j): i ∈ W, j ∈ V∖W or i ∈ V∖W, j ∈ W such that for every element ofF(W)there is at most one pair containing any vertex k ∈ V as its second component. We now state our second result.Proposition 2The following inequalities are valid for HpMP2, and dominate(6):(12)∑(i,j)∈δ(W)xij≥2∑(k,l)∈FwklW⊂V,F∈F(W).Consider a partition of {W, V∖W} of V, as depicted in Fig. 1, where the positive x variables are denoted with thin lines, the positive w variables are denoted with arrows, and the partition is denoted by a dashed line. In order to check that constraints (12) are valid, we will prove that a feasible solution of HpMP2,(x¯,w¯),satisfies them. LetF∈F(W). If for a pair (k, l) ∈ F we have thatw¯kl=1,then either vertex k ∈ W is assigned to depot l ∈ V∖W or vertex k ∈ V∖W is assigned to depot l ∈ W. In both cases the cycle represented by vertex l ∈ V has vertices in W and in V∖W. Thus, there are at least two edges of that cycle with end vertices in W and V∖W, i.e. there exist vertices i1, i2 ∈ W and j1, j2 ∈ V∖W, such that,x¯i1,j1=x¯i2,j2=1andw¯i1,l=w¯i2,l=w¯j1,l=w¯j2,l=1. Note that it is possible to havei1=i2orj1=j2,but not both. Moreover, by construction of F, no two pairs (k, l) and (k′, l) belong to F, i.e., each variable w equal to 1 in the right-hand side of constraints (12) represents a different cycle. Hence, for a givenF∈F(W),the summation in the right-hand side of (12) gives a number of different cycles crossing δ(W). Since the left-hand side counts the number of edges crossing δ(W), the left-hand side is at least twice the right-hand side (the number of different cycles crossing W represented by a vertex that is the second component of a pair of F). Hence, constraints (12) are valid. Finally, (6) is a special case of (12) when F is restricted to those subsets ofF(W)where the pairs have an identical component of W and the second component belongs to V∖W.□Despite our best efforts, we were neither able to find a polynomial time algorithm for the exact separation of this set of valid inequalities for the fractional solutions, nor to prove the NP-hardness of the separation problem. The closest problem in the literature is the separation of the cutset inequalities for the network loading problem (Barahona, 1996), which is NP-hard. However, the constraint imposing a maximum of one inflow arc per vertex and the unit capacities change the problem structure. We conjecture that the separation problem for fractional solutions is NP-hard. We have implemented a heuristic separation algorithm for the fractional solutions and applied it only at the root node of the branch-and-cut tree, due to the its high computational cost. The separation algorithm starts with a random W ⊂ V and greedily adds and removes vertices to maximize the violation, until no further improvement is found. To find a maximally violated inequality, it is sufficient to search over the space of the vertex subset W, since a matching F can be constructed optimally by a greedy algorithm that selects one wklvariable for each l. Let us denote the violation of an inequality defined by the set W as f(W). We now present the pseudocode for the separation algorithm, which we call Algorithm 1.For the solutions that satisfy integrality constraints, we have executed a depth-first search from each vertex to the depot it is assigned, and added members of (12) to ensure connectivity between the two vertices when necessary. This procedure separates all violated members of (12) and has a complexity of O(|V|3). We now provide the pseudocode of the separation algorithm, which we call Algorithm 2.The final set of valid inequalities we present is based on the observation that the fact that every cycle is composed of at least three vertices. We state the result without proof.Proposition 3The following inequalities are valid for HpMP2:(13)∑j∈V:j≠iwji≥2wiii∈V.We now present our branch-and-cut algorithm for HpMP2, which we call Algorithm 3. Denote the ith subproblem as si, the solution of the subproblem as (xi, wi), and the best known solution as (x*, w*). Furthermore, denote the objective function value of a solution as z(x, w).In this section, we provide a giant tour heuristic and an ILS algorithm for the HpMP.Beasley (1983) proposed a giant tour heuristic that optimally splits a TSP tour to construct a solution for the Capacitated Vehicle Routing Problem. The splitting algorithm was later used as a local search operator within a genetic algorithm by Prins (2004), and more recently within an ILS algorithm by Afsar, Prins, and Santos (2014). Notably, Love (1976) studied the problem of locating a number of facilities in the continuous search space on a line and proposed a dynamic programming formulation, which bears some resemblance to our dynamic programming formulation in terms of stage and state definitions. However, the cost of a solution for this problem is computed based on the distances of the existing facilities and the new facilities rather on than the sequential order of locations. We now present our splitting algorithm for the HpMP.Consider a sequence of the vertex indicesσ=(σ1,…,σn),which corresponds to a TSP solution on the vertices. We propose a dynamic programming algorithm to optimally partition this sequence into p cycles of the form(σi,σi+1,…,σj,σi),of costc^ij. Define gk(i) as the sum of the optimal cost of thekth,…,pthcycles if the kth cycle starts at the ith element of the sequence of TSP solution. The dynamic programming formulation is then:(14)gk(i)={min{c^ij+gk+1(j+1):ifk<p,3k−2≤ij∈{i+2,…,n−3(p−k)}}≤n−3(p−k)−2c^inifk=p,3k−2≤i≤n−2∞otherwise.An optimal partitioning can be determined by computing g1(1). We now provide an algorithm (Algorithm 4) that computesc^ijas well as gk(i). Denote by uk(i) the optimal endpoint of partition k starting at the ith element of the TSP sequence.The first part of Algorithm 4 computesc^ijin O(|V|2) time. The space complexity of the dynamic programming algorithm is O(|V|2) and its time complexity is O(|V|3). We first compute a TSP solution on G, from which we extract the sequence of the vertices. Note that the dynamic programming formulation does not allow for cycles of the type(σi,σi+1,…,σn,σ1,…,σi−1). To make up for this shortcoming, the giant tour heuristic executes the dynamic programming algorithm n times, changing the sequence by relocating the last element to the first position and shifting the remaining elements to the next position. We now present the detailed pseudocode of the heuristic, called Algorithm 5, where zTSP(σ) denotes the cost of the TSP tour defined by the sequence σ.An example run of Algorithm 5 is depicted in Fig. 2, for an instance of the HpMP withn=9andp=2,where the vertices are reindexed in the order in which they appear in the first sequence for the sake of simplicity. The best partitioning of each sequence into two cycles is denoted by the rectangles enclosing parts of the sequence. The best solution among all these partitions (highlighted) is chosen as the result of Algorithm 5. Although this brings the overall complexity up to O(|V|4), the CPU time requirement is still negligible since it is executed only once.We now present the details of our ILS algorithm, which is based on perturbing the best known solution through random swaps and relocations of vertices among the cycles, and reoptimizing through local search. The random feature of the ILS algorithm acts as a diversification mechanism, which reduces the likelihood that the search process will become trapped into a local minimum. Let us denote the solution as p sequences of vertices, each sequence corresponding to the vertices within the corresponding cycle, withx[i][j]∈{1,…,|V|}denoting the jth element of the ith sequence. Let us also denote the number of vertices in cycle i as y[i]. Finally, we writeU[a,…,b]to denote a discrete uniform random variable that returns values in the range{a,…,b}.The CPU time requirement is determined by the choice of the parameter kmax, the total number of iterations. At each iteration, a copy of the best known solution is created, and perturbed through randomly swapping α pairs of vertices from two cycles as well as relocating β vertices from their cycle to a position in another randomly chosen cycle. The choices of α and β are important for the performance of the algorithm, since very low values do not provide enough diversification, and very large values destroy the structure of the best known solution and inhibit intensification. After the perturbation, the resulting solution is reoptimized using the well-known local search operators 1-opt and 2-exchange, by selecting the best move among the operators at every step. If the objective function value of the local search is better than that of the best known solution, the best known solution is replaced by the current solution.We have conducted our computational experiments on a Lenovo T440p laptop with an i7 2.50 gigahertz CPU and 8 gigabyte RAM. A CPU time limit of 1 hour was imposed on the branch-and-cut algorithm. ILS were also coded in C++ and executed on the same computer. We have used the instances of Gollowitzer et al. (2014), in order to have a benchmark to compare the computational performance of our model. We have also preformed computational experiments on three TSPLIB (Reinelt, 1991) instances: dantzig42, gr96, and u159. In what follows, we compute the optimality gap as the ratio of the difference between the best solution value and the best lower bound found by the branch-and-cut algorithm to the best lower bound found by the branch-and-cut algorithm.Based on a number of initial experiments, we have chosen the values ofα=⌊|V|/5⌋andβ=⌊|V|/5⌋. We have observed that the best solution found by the ILS algorithm did not change much after a few thousand iterations, hence we have usedkmax=10,000. The aggregate results for the heuristic algorithms are presented in Table 1. For each instance, we have solved a 2-matching problem to determine the optimal number of cycles, and we report the average value of this result in the column labeled “Average p*” as a measure of how hard the instances are. We have omitted the details of the CPU time requirement of Algorithm 5, since Algorithm 5 did not require more than 0.01 CPU seconds for any of the instances. Algorithm 6has an average optimality gap of 0.69 percent, and requires no more than a minute of CPU time. Based on these results and its simplicity, we conclude that Algorithm 6 has a satisfactory performance.The aggregate results for HpMP2 are presented in Tables 2and 3. The best found solution from Algorithm 6 was fed in as an initial incumbent to the branch-and-cut algorithm. The improved valid inequalities and the tight upper bound have contributed to the performance of our algorithm, resulting in finding the optimal solution of 122 out of the 125 benchmark instances. The CPU time requirement of the branch-and-cut algorithm is also provided in Table 2. Note that all the CPU times we report for the branch-and-cut algorithm include the CPU time for the ILS algorithm that was used for generating the initial solution. The columns Model 1 and Model 3 correspond to the performance of the best two models of Gollowitzer et al. (2014) as reported by the authors, the former being the formulation in the space of natural variables, and the latter being the p-median based formulation our formulation is based upon. Model 1 has successfully solved 86 instances out of 125, whereas Model 3 could only solve 59. We thereby conclude that HpMP2 performs better than both of these models.The details of the initial optimality gaps computed at the root node of the branch-and-cut tree are presented in Table 3. We have analyzed the effect of separating only (11) and separating both (11) and (12). The results show that the difference between the initial gaps is 0.04 percent on the average, with a maximum of 0.4 percent and a minimum of−0.13 percent. We conclude that separating (12) is marginally useful for the smaller instances, but its importance grows as |V| increases. The initial optimality gap for the HpMP2 is quite small, 1.76 percent on average with a maximum of 13.87 percent. An analysis of the table shows that the initial gap for HpMP2 dominates Model 1 in 20 out of 25 parametric settings, and Model 3 in 17 out of 25 parametric settings. We emphasize that the initial gap depends on the strength of the lower bound, on the quality of the initial feasible solution, and on the performance separation heuristics for the valid inequalities for which we do not have a polynomial time exact separation algorithm. The quality of the lower bound is reflected into the computational performance, where our branch-and-cut algorithm for the HpMP2 successfully solves all instances for|V|=60andp=20and Models 1 and 3 cannot solve any.The most striking difference between the initial optimality gaps occurs for the largest values of p, which force at most one cycle to include more than three vertices. This is due to the valid inequality set (13), which provides a lower bound on the number of vertices assigned to a vertex selected as a depot. Unlike (11) and (12) that replace (6) and (7) and are necessary for the validity of HpMP2, (13) is optional. During our computational experiments, we have observed that adding all members of (13) to the formulation slows down the branch-and-cut algorithm. However, we have also observed that it is not possible to solve large instances without these inequalities. In our final implementation, we have chosen to add these inequalities when the maximum possible cycle size|V|−3(p−1)is less than or equal to 5 for the best performance.The results of our experiments on the TSPLIB instances are presented in Table 4. HpMP2 outperforms both Model 1 and Model 3 in terms of the CPU time for the instances that could be solved within the time limit. For the instances that could not be solved, the best lower bounds are also provided by HpMP2. To increase the size of the test bed for HpMP, we have solved 22 instances from the TSPLIB with sizes ranging from 21 to 100. For instances with vertex coordinates, we have computed and used the Euclidean distances between the vertices. For the rest of the instances, we have used the edge weights provided. We have used p ∈ {⌊|V|/10⌋, ⌊|V|/7⌋, ⌊|V|/5⌋, ⌊|V|/4⌋, ⌊|V|/3⌋} for our experiments. The computational results of the new TSPLIB instances are reported in Tables 5and 6. The performance of HpMP2 on these instances is similar to its performance on the instance set of Gollowitzer et al. (2014). We have successfully solved 100 instance out of 110, with the unsolved instances limited to |V| ≥ 76. Notably,p=⌊|V|/3⌋for 6 out of the 10 unsolved instances. The hardest instance was observed to be rat99, which is a “rattled grid” consisting of grid coordinates with minor perturbations. We attribute this to the high degree of symmetry inherent to this instance.

@&#CONCLUSIONS@&#
We have studied the HpMP, provided an exact algorithm, a giant tour heuristic, and an ILS algorithm. Our exact algorithm is a branch-and-cut algorithm based on an enhanced p-median formulation. We have provided two sets of valid inequalities which we prove to dominate the ones in the literature, and a third set of inequalities that have not been proposed before. The giant tour heuristic is based on a dynamic programming formulation that optimally splits a TSP tour into p cycles. We have performed computational experiments on HpMP instances from the literature and new instances from the TSPLIB, and showed that the performance and the computational reach of our branch-and-cut algorithm is better than that in the literature. We have observed the ILS algorithm to be capable of returning high quality solutions within a minute, with an average optimality gap of 0.64 percent.