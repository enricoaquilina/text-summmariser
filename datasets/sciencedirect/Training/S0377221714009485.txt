@&#MAIN-TITLE@&#
MILP formulations and an Iterated Local Search Algorithm with Tabu Thresholding for the Order Batching Problem

@&#HIGHLIGHTS@&#
We consider the Order Batching Problem (OBP).We propose MILP formulations for three OBP variants.We suggest an efficient local search procedure.We report computational experiments on randomly generated instances.

@&#KEYPHRASES@&#
Warehouse management,Order Batching Problem,Mixed Integer Linear Programming,Local search,

@&#ABSTRACT@&#
In this work we deal with the Order Batching Problem (OBP) considering traversal, return and midpoint routing policies. For the first time, we introduce Mixed Integer Linear Programming (MILP) formulations for these three variants of the OBP. We also suggest an efficient Iterated Local Search Algorithm with Tabu Thresholding (ILST). According to our extensive computational experiments on standard and randomly generated instances we can say that the proposed ILST yields an outstanding performance in terms of both accuracy and efficiency.

@&#INTRODUCTION@&#
We consider the Order Batching Problem (OBP) which is shown to beNP-hard by Gademann and Van de Velde (2005). Given both a list of customer orders and an order picking routing policy, the OBP deals with constructing batches of customer orders such that the total travel distance of all pickers is minimized. Order picking is the process of retrieving products from their storage locations in a warehouse in order to satisfy customer requests. Among several warehousing functions order picking is known to be the most labor intensive and costly one (Drury, 1988). Order picking costs are estimated to be as much as of 65 percent of the total warehouse operating expenses (Tompkins, White, Bozer, and Tanchoco, 2003).Broadly speaking, order-picking systems can be grouped in two categories according to the material handling equipments used: picker-to-parts systems and parts-to-picker systems. In picker-to-parts systems, order pickers travel along the warehouse and retrieve the requested items. On the other hand, in parts-to-picker systems the requested items are handled and transported by automatic storage and retrieval systems (AS/RSs) to order pickers (de Koster, Le-Duc, & Roodbergen, 2007; Wäscher, 2004). Particularly, there exist two types of picker-to-parts systems: low-level and high-level picking systems. In low-level picking systems, the pickers travel along the aisles in order to pick the requested items from the storage bins or racks. In high-level systems, the pickers drive a truck or crane to reach the pick locations. In this work, we address low-level picker-to-parts picking systems employing human pickers. de Koster et al. (2007) have claimed that 80 percent of all order-picking systems in Western Europe are of this type.In order picking systems, the service level basically consists of order delivery time, order integrity and accuracy. Order delivery time is closely related with the travel time of the picker. As pointed out by Tompkins et al. (2003) almost half of the order pickers’ time is wasted while traveling. Although other activities, such as order searching, picking and setup for the routes, require a considerable amount of the picker’s time (Hall, 1993; Petersen, 1997; Roodbergen and de Koster, 2001), the travel activity is seen as the most time consuming one (de Koster et al., 2007). Furthermore, the travel time has a substantial role in customer satisfaction since the shorter the travel time is; the sooner the requested items are ready for shipping. Hence, among several objective functions that can be taken into consideration the minimization of pickers’ total travel distance, which will be also addressed in this paper, is the most widely considered one (de Koster et al., 2007).In the literature, several order picking routing policies have been introduced: traversal (Goetschalckx and Ratliff, 1998), return, midpoint, largest gap (Hall, 1993), composite and optimal (Ratliff and Rosenthal, 1983) routing policies. Petersen (1997) has argued that the traversal, return and midpoint routing policies are simpler than the largest gap, composite and optimal routing policies. According to the experiments by Petersen (1997), the optimal routing policy is the winner at the expense of its disadvantages such as discernible pattern and the routes with backtracks. Indeed, complex routing policies may yield congestion problems when several pickers share long, narrow and two-way aisles. Simple routing policies may arise to be useful especially for complex order picking systems with many pickers.For the sake of clearness, Fig. 1presents an illustration of one of the warehouse layout types considered in this work. Here, we have totally three orders, i.e. order 1, order 2 and order 3 which include 4, 3 and 5 items, respectively. Note that, the location of these items are indicated with order numbers. The shape of the warehouse is assumed to be rectangular with parallel storage. L denotes the distance between the front aisle and the back aisle and w stands for the horizontal distance between aisles. The warehouse totally incorporates 10 parallel aisles which are numbered in increasing order starting from the leftmost aisle. In this configuration, the I/O point is situated in front of the leftmost aisle, i.e. the aisle number 1. The picking area has the capacity to store 200 items. Each order must be assigned into a batch and each order consists of at least one item. We assume that the locations of items are known a priori and a sufficient number of pickers with homogenous capacities and constant travel speeds are available at the I/O point. The amount of items which belong to the orders assigned into a batch should not exceed the picker’s capacity. We assume that order splitting is not allowed and the quantity to be picked up of each item is one unit. Lastly, we assume that the horizontal distance within stocking aisles is negligible and the picker does not need an additional time for entering and leaving the aisles.We concentrate on the OBP considering traversal, return and midpoint routing policies. In the traversal routing policy the picker starts from the I/O point, traverses each aisle entirely where an item is required to be picked up and returns the I/O point. The picker enters an aisle from one end and leaves from the opposite end. In case the number of aisles that must be visited is odd then the picker enters the rightmost aisle which must be visited and returns whenever it retrieves the item situated in the deepest location. Note that, only in that case the picker does not need to traverse the aisle entirely. In the return routing policy, a picker starts from the I/O point and proceeds along the front aisle. The picker enters each aisle where an item has to be picked up and travels along that aisle as far as the deepest location where an item must be retrieved, then turns back and leaves that aisle from the same end. The midpoint method divides the warehouse into two areas by drawing a horizontal line. The order picker traverses entirely the leftmost aisle which it has to pick up an item and then reaches the back aisle. The items which are located in the back half of the warehouse are accessed from the back aisle. Next, the picker traverses the rightmost aisle entirely and enters the front aisle. Then all items situated in the front half of the warehouse are reached from the front aisle before the picker returns the I/O point. Figs. 2–4depict the routes of a picker serving all three orders considering traversal, return and midpoint policies, respectively.The motivation of this study is two-fold. First, we develop Mixed Integer Linear Programming (MILP) formulations for the OBP considering traversal, return and midpoint routing policies. To the best of our knowledge, these are the first MILP formulations for these three variants of the OBP. Second, we suggest an efficient Iterated Local Search Algorithm with Tabu Thresholding (ILST) for the OBP. We compare the performance of the MILP formulations and the ILST with the savings algorithm, named as C&W(ii) in the work by de Koster, Van Der Poort, and Wolters (1999) and the iterated local search heuristic, namely the ILS-2, devised by Henn and Wäscher (2012). We have also adopted the parametric enhancement of the saving algorithm proposed by Paessens (1988) in the context of the Vehicle Routing Problem. According to our computational experiments, we have observed that the proposed ILST outperforms the ILS-2 in terms of both accuracy and efficiency.The rest of this paper is organized as follows. Section 2 introduces a brief literature survey on the OBP. Next, in Section 3 we give three MILP formulations of the OBP considering traversal, return and midpoint routing policies, respectively. The ILST approach is presented in Section 4, followed by the computational results in Section 5. Finally, concluding remarks are given in Section 6.To the best of our knowledge, there are a few studies addressing the exact solution of the OBP. In their early work, Gademann, Van den Berg, and Van der Hoff (2001) have designed a branch and bound algorithm for the order batching with the objective of minimizing the maximum travel time of the pickers. The OBP has been formulated as a Set Partitioning Problem (SPP) by Gademann and Van de Velde (2005) where the authors have devised a branch and price algorithm and they have reported the optimum solution of problems with up to 32 customer orders. Recently, Henn and Wäscher (2012) have claimed that after generating all feasible batches they were able to solve OBP instances with up to 40 customer orders by solving the SPP formulated by Gademann and Van de Velde (2005). We should point out that a disadvantage of this approach is that it requires extensive efforts in the preprocessing phase to generate all feasible batches.For a revised version of the OBP considering the traversal routing policy, Bozer and Kile (2008) have proposed a Mixed Integer Programming (MIP) formulation and they have reported that they could solve small size instances, i.e. instances with up to 25 customers, to optimality. The problem addressed by Bozer and Kile (2008) is quite different from the original OBP considering the traversal routing policy. The authors deal with the traversal routing policy when the number of traversals is even. Their formulation does not compromise the case when the number of traversals is odd and hence the picker turns back from the deepest location in the rightmost aisle where it retrieves a requested item.Several heuristic algorithms have also been developed for the OBP. Among them we can mention the first fit-envelope based batching heuristic (Ruben and Jacobs, 1999), the priority rule based algorithms (Gibson and Sharp, 1992), the seed algorithms (Elsayed, 1981) and the savings algorithm (Clarke and Wright, 1964; de Koster et al., 1999). Hwang and Kim (2005) have proposed an order batching algorithm based on cluster analysis. Data mining approaches have been developed by Chen and Wu (2005) and Chen, Huang, Chen, and Wu (2005). de Koster et al. (1999) have computationally analyzed several construction heuristic procedures and have concluded that among them the seed algorithms and the savings algorithm yield the best performance.As meta-heuristic algorithms designed for the OBP, we can mention the Genetic Algorithm (GA) proposed by Hsu, Chen, and Chen (2005), Tabu Search (TS) and Attribute Based Hill Climber (ABHC) algorithms by Henn and Wäscher (2012), the Variable Neighborhood Search (VNS) algorithm by Albareda-Sambola, Alonso-Ayuso, Molina, and Simon de Blas (2009), the Iterated Local Search (ILS) and Ant Colony Optimization (ACO) algorithms by Henn, Koch, Doerner, Strauss, and Wäscher (2010).Variants of the OBP have also been addressed in the literature. As for instance, we can mention the On-line OBP by Henn (2012), the Order Batching and Sequencing Problem by Henn and Schmid (2013), the combined Precedence Constrained Picker Routing and Order Batching Problem by Matusiak, de Koster, Kroon, and Saarinen (2014), the Integrated Batching and Batch Sequencing Problem by Hong, Johnson, and Peters (2012) and, the Integrated Order Batching and Vehicle Routing Problem with Time Windows by Schmid, Doerner, and Laporte (2013). For an interested reader, we refer to Gu, Goetschalckx, and McGinnis (2007, 2010) and Baker and Canessa (2009) for a review of several warehousing issues and, Gong and de Koster (2013) for a comparative discussion of stochastic warehouse models.In this section, we develop three MILP formulations for the OBP considering traversal, return and midpoint routing policies, respectively.The proposed MILP formulations are inspired from the grouping model used by Islam and Sarker (2000) for the machine-cell or part-families grouping problem. Their grouping model has been later adopted by Hwang and Kim (2005) to analyze several similarity measures for the batching of customer orders in the OBP context. Note that, in the proposed MILP formulations, we assume that the I/O point is situated in front of an aisle number κ for κ = 1, …, K. Now, we introduce a basic model for the OBP which is originally devised by Islam and Sarker (2000).Given a set of orders, i = 1, …, n and aisles k = 1, …, K, let Q indicate the capacity of each picker and mibe the number of items in order i. Let xijequal to 1 if and only if order i is assigned into batch j. Moreover, xjj= 1 holds if and only if order j is assigned into batch j and that batch is indicated by order j.(1)∑j=1nxij=1fori=1,…,n(2)xij≤xjjfori,j=1,…,n(3)∑ni=1mixij≤Qforj=1,…,n(4)xij∈{0,1}fori,j=1,…,nConstraints (1) assert that each order should be assigned into exactly one batch. Constraints (2) guarantee that order i is assigned into batch j only when there is a batch j which is represented with order j. Constraints (3) ensure that the items of all orders assigned into batch j satisfy the capacity of the picker. Finally, constraints (4) state that the decision variables are binary.Now, we present an MILP formulation for the OBP considering the traversal policy. For that purpose we define the following parameters and decision variables. Parameter dikstands for the maximum vertical distance that the picker serving order i should travel along aisle k starting from the front aisle. Note that dikis set to zero when order i has no item which is required to be picked up in aisle k. Binary variable yjkequals to 1 if and only if the picker serving batch j visits aisle k. Binary variable cjequals to 1 if and only if the number of aisles that must be visited by the picker serving batch j is odd. Binary variable pjkequals to 1 if and only if aisle k is the rightmost aisle that is visited by the picker serving batch j. Integer variable vjdenotes the number of times the picker serving batch j performs two-way traversals. Continuous variablehjR(hjL) stands for the one way horizontal distance traveled by the picker serving batch j starting from I/O point and traveling along the front aisle to the right (to the left) of the I/O point which is located in front of the aisle number κ for κ = 1, …, K. Continuous variable ujkindicates the vertical one-way distance traveled in the rightmost aisle k, by the picker serving batch j and visiting totally an odd number of aisles.(5)Minz=2∑nj=1∑Kk=1ujk+2∑nj=1(hjL+hjR)+2L∑nj=1(vj−cj)subject to(6)(1)--(4)(7)yjk≤∑ni=1dikxij≤Myjkforj=1,…,n;k=1,…,K(8)(k−κ)wyjk≤hjRforj=1,…,n;k=κ+1,…,K(9)(κ−k)wyjk≤hjLforj=1,…,n;k=1,…,κ−1(10)∑k=1Kyjk+cj=2vjforj=1,…,n(11)dikxij≤ujk+M(1−pjk)+M(1−cj)fori,j=1,…,n;k=2,…,K(12)yjk−∑l=k+1Kyjl≤pjk≤yjkforj=1,…,n;k=1,…,K(13)vjintegerforj=1,…,n(14)pjk,yjk∈{0,1}forj=1,…,n;k=1,…,K(15)cj∈{0,1}forj=1,…,n(16)hjL,hjR≥0forj=1,…,n(17)ujk≥0forj=1,…,n;k=1,…,KIn the objective function (5) the first term gives the distance in the rightmost aisle when a picker totally visits an odd number of aisles. The second one is for the horizontal distance traveled by all pickers. The third term stands for the total distance traveled by the pickers which perform two-way entire traversals from the front aisle to the back aisle and from the back aisle to the front aisle. Constraints (7) state that when there exists at least one item which belongs to order i and which is located in aisle k, then the picker serving batch j which includes order i, must enter into aisle k. Note that M is a sufficiently large number. Furthermore, constraints (7) guarantee also that when none of the orders belonging to batch j visits aisle k then yjkis set to zero. Constraints (8) (constraints (9)) calculate the maximum horizontal distance traveled by the picker serving batch j starting from the I/O point and traveling along the front aisle to the right (to the left) of the I/O point which is situated in front of aisle number κ. Constraints (10) make sure that when the number of aisles traversed by the picker serving batch j is odd then cjis set to 1. Constraints (11) compute the one-way vertical distance traveled in the rightmost aisle by the picker serving batch j when the number of aisles visited by that picker is odd. Constraints (12) ensure that pjkis equal to 1 if and only if aisle k visited by the picker serving batch j is the rightmost aisle visited by that picker. Finally, constraints (13)–(17) state the domain definition for the decision variables.In addition to the parameters and variables defined so far, the MILP formulation for the OBP considering return policy employs the continuous decision variable sjkwhich indicates one way maximum vertical distance traveled in aisle k starting from the front aisle to the location of an item which belongs to an order assigned into batch j.(18)Minz=2∑j=1n(hjL+hjR)+2∑j=1n∑k=1Ksjksubject to(19)(1)--(4),(7)--(9)(20)dikxij≤sjkfori,j=1,…,n;k=1,…,K(21)yij∈{0,1}fori,j=1,…,n(22)sjk≥0forj=1,…,n;k=1,…,K(23)hjL,hjR≥0forj=1,…,nIn the objective function (18) the first term stands for the horizontal distance and the second term is for the vertical distance traveled by all pickers. Constraints (20) compute the maximum vertical distance traveled in each aisle k by the picker serving batch j. Constraints (21)–(23) are for the domain definition of the decision variables.In addition to the above defined parameters and variables, the MILP formulation devised for the OBP considering midpoint routing policy employs the followings. Let the parametersdikBanddikFstand for the vertical travel distance in aisle k from the back and front aisles to the location of an item in batch i, respectively. WhendikBanddikFare larger than L/2 then they are set to zero. Furthermore, these parameters are assumed to be zero when order i has no item which is required to be picked up in aisle k. Binary variablesyjkBandyjkFequal to 1 if and only if the picker serving batch j visits aisle k from the back and front aisles, respectively. The binary variable vjkequals to 1 if and only if the picker serving batch j visits aisle k which is not the leftmost or the rightmost visited aisle. The continuous decision variablesujkBandujkFstate one way maximum vertical distance traveled by the picker serving batch j at the rightmost aisle from the back and front aisles to the location of an item assigned into batch j, respectively. Binary variables pjkand qjkequal to 1 if and only if there exists at least one aisle to be visited in the left hand side and right hand side of aisle k which is visited by the picker serving batch j, respectively.(24)Minz=2∑nj=1(Lxjj+hjL+hjR)+2∑j=1n∑k=1K(ujkB+ujkF)subject to(25)(1)--(4)(26)yjkB≤∑ni=1dikBxij≤MyjkBforj=1,…,n;k=1,…,K(27)yjkF≤∑ni=1dikFxij≤MyjkFforj=1,…,n;k=1,…,K(28)(k−κ)wyjkB≤hjRforj=1,…,n;k=κ+1,…,K(29)(k−κ)wyjkF≤hjRforj=1,…,n;k=κ+1,…,K(30)(κ−k)wyjkB≤hjLforj=1,…,n;k=1,…,κ−1(31)(κ−k)wyjkF≤hjLforj=1,…,n;k=1,…,κ−1(32)dikBxij−M(1−vjk)≤ujkBfori,j=1,…,n;k=1,…,K(33)dikFxij−M(1−vjk)≤ujkFfori,j=1,…,n;k=1,…,K(34)∑k−1l=1(yjlB+yjlF)≤Mpjkforj=1,…,n;k=2,…,K(35)∑Kl=k+1(yjlB+yjlF)≤Mqjkforj=1,…,n;k=1,…,K−1(36)pjk+qjk≤vjk+1forj=1,…,n;k=2,…,K−2(37)yjkB,yjkF,pjk,qjk,vjk∈{0,1}forj=1,…,n;k=1,…,K(38)ujkB,ujkF≥0forj=1,…,n;k=1,…,K(39)hjL,hjR≥0forj=1,…,nIn the objective function (24) the first term computes the total distance traveled by the pickers which traverse entirely the first (last) aisle it has to pickup an item and then reaches the back (front) aisle and the horizontal distance traveled by all pickers. The second term gives the vertical distance traveled by all pickers. Constraints (26) (constraints (27)) state that when there exists at least one item belonging to order i which is located at the back (front) side of aisle k, then the picker serving batch j must enter aisle k from the back (front) aisle. Constraints (28) (constraints (30)) and constraints (29) (constraints (31)) compute the maximum horizontal distance traveled by the picker serving batch j starting from the I/O point to the right (to the left) of the I/O point which is situated in front of aisle number κ. Constraints (32) and (33) ensure that unless the visited aisles are not the rightmost or the leftmost ones then the distance traveled along aisle k of the picker serving batch j is computed with variablesujkBandujkF,respectively. Constraints (34) and (35) state that when aisle k is the leftmost and the rightmost aisle visited by the picker serving batch j then pjkand qjkare set to zero, respectively. Constraints (36) assert that when aisle k is neither the rightmost nor the leftmost aisle visited by the picker serving batch j, then vjkis set to 1. Constraints (37)–(39) define the domain of the decision variables.ILST is a variant of the ILS developed by Lourenço, Martin, and Stützle (2003). Different from the ILS, the ILST employs the Local Search Algorithm with Tabu Thresholding (LST) as the intensification procedure. The LST, which is inspired from the Tabu Thresholding idea proposed by Glover (1995), has first been proposed by Kaveh and Punnen (2008) in the context of the Quadratic Assignment Problem. Later on the LST has been implemented for the Quadratic Minimum Spanning Tree Problem by Öncan and Punnen (2010) who have reported its outstanding performance.Given an initial solutions˜,the ILST performs both diversification and intensification steps consecutively. In the diversification step, the ILST applies a perturbation mechanism tos˜and yields a new solution s1. Then, in the intensification step, the ILST performs the LST which improves s1and outputs s2. In case s2satisfies the acceptance criterion, then s2replacess˜. For the other case, namely when s2does not satisfy the acceptance criterion, the ILST continues to run considering the previouss˜. All these operations are performed from scratch until a termination condition is satisfied and finally the best solution found, i.e. sbest, is output. Let f(s) be the cost function associated with solution s. A formal outline of the ILST is summarized with Algorithm 1.Now we introduce a detailed explanation of the ILST. First of all, we present the initial solution construction step, then we give a pseudocode of the LST. Next, we explain the perturbation and acceptance criterion steps. Finally, we expose the termination condition used.In order to find an initial solution s0for the ILST we perform the savings algorithm which constructs a good feasible solution in very short CPU time and which is one of the best performing heuristics for the OBP (de Koster et al., 1999).The LST mainly consists of two phases: neighborhood search and random move phases. The algorithm alternately runs these two phases until a predefined iteration limit is reached. Before introducing a pseudocode of the LST, we define the cost function and neighborhoods used in the LST.During the run of the ILST we allow infeasible OBP solutions namely the solutions which violate the capacity constraints (3). To measure the magnitude of the violations of capacity constraints, we employ the formulaet(s)=∑j=1nmax{0,∑i=1nmixij−Q}. Then, given a solution s, its penalized cost function value is computed as f(s) = z(s) + ζ × t(s) where z(s) is the objective function value of the corresponding OBP variant and ζ is a self-adjusting parameter which is either increased or decreased at each iteration of the ILST according to the feasibility of solution s. Namely, ζ is multiplied by 1 + ε in case solution s violates the capacity constraints. For the other case, when solution s satisfies the capacity constraints, ζ is divided by 1 + ε. Note that, both ζ and ε are positive parameters.The choice of a suitable neighborhood search scheme is a critical issue which affects both efficiency and accuracy of the LST. To this end, we employ the N(ω, ν) neighborhood which considers each pair of batches and tries to exchange orders between selected batches. The N(ω, ν) neighborhood first selects ω and ν orders where each of which are assigned into different batches and tries to exchange ω orders in one batch with other ν orders assigned into another batch. The basic idea of the definition of N(ω, ν), which is well known and used by various researchers in developing local search algorithms for hard combinatorial optimization problems, is classified as the (ω, ν)-exchange neighborhoods. N(ω, ν) is our adaptation of the (ω, ν)-exchange neighborhood for the OBP. Note that, the N(1, 0) and N(0, 1) neighborhoods try to remove one order from its batch and re-assign it into another batch. The N(1, 1) operation considers pairwise interchange of orders in different batches. Clearly, the larger the number of removed orders from their batches, the wider the search space. For the sake of efficiency, in our LST implementation we confined ourselves to employ a neighborhood search schemeNwhich consists of the neighborhoods N(1, 0), N(0, 1), and N(1, 1), that is to sayN=N(1,0)∪N(0,1)∪N(1,1).Furthermore, since the LST is run several times as the intensification step of the ILST we make use of the neighborhood search schemeNϕ(s)which considers only 100 × ϕ percent of the neighbor solutions which are searched byN. Here, ϕ is a positive parameter selected from (0, 1). To perform the accelerated search schemeNϕ(s),given a solutionAPTARABOLDs˘∈Nϕ(s),we associate a random number0≤rs˘≤1toAPTARABOLDs˘and the neighbor solutionAPTARABOLDs˘is evaluated byNϕ(s)if and only ifrs˘≤ϕholds. Otherwise, the neighbor solutionAPTARABOLDs˘is not considered for evaluation. Now, we present a formal outline of the LST with Algorithm 2.In order to have a diversified search scheme, the ILST performs random perturbation operations. Given a solutionAPTARABOLDs˜we apply one of the following perturbation operations with equal probabilities and we allow to output only feasible OBP solutions.1.Addition of a new batch: A new batch is constructed by randomly choosing an order, removing from its batch and assigning it into a new batch. Then, considering the decreasing order of savings costs Cij= ei+ ej− eij, orders are removed from their batches and assigned into the new batch without exceeding its capacity Q. Here, ei(ej) stands for the distance required to travel in order to pick all items of order i (j) and eijdenotes the total distance that must be traveled by a picker which collects all items belonging to both orders i and j.Removal of a batch: In case the number of batches is not equal to its lower bound, i.e.⌈(∑i=1nmi)/Q⌉where ⌈Δ⌉ is the smallest integer not less than Δ, a randomly selected batch is destructed. All orders in that batch are assigned into other batches considering the savings formulae Cij. Namely, order i in the removed batch is assigned into another batch which includes order j such that Cijis maximum.Random re-assignment of orders: All orders are randomly re-assigned into available pickers by making use of the matching neighborhood scheme devised by Öncan, Kabadi, Nair, and Punnen (2008). For that purpose, we construct a Weighted Bipartite Perfect Matching Problem (WBPMP) and solve it using the FORTRAN code by Carpaneto and Toth (1988). The weighted bipartite perfect graph is constructed as follows. Given an OBP solution, let S = {1, 2, …, n} be the set of orders andA=(A1,A2,…,AI)be an ordered partition of S which consists of I sets, i.e. batches, such that∪i=1IAi=Sand Ai∩Aj= ∅ for i ≠ j, i, j = 1, …, I. Next, for each set AiinA,we choose a subset Bi. The ordered collectionB=(B1,B2,…,BI)is called an ejection vector ofA. GivenAand an ejection vectorB,a bipartite graphG˜,called as the construction graph, is obtained. The generic bipartition of its vertex set isV˜1∪V˜2whereV˜1={l1,l2,…,lI}andV˜2={r1,r2,…,rI}. Node liinV˜1represents the subset Aiand node rjinV˜2indicates the subset Bj. Furthermore, the cost of edge (li, rj), which signifies adding Bjto Aiwhile Bjis ejected from Ai, is defined asϱij=max{0,(m(Ai∖Bi)+m(Aj)−Q)}where, m(Ai) and m(Bi) denote the total number of items included by the orders in sets Aiand Bi, respectively. To perform a random re-assignment of the orders in the current OBP solution, it suffices to randomly construct an ejection vectorBand then to solve the WBMMP on the bipartite graphG˜. To this end, we consider two parameters η and γ which stand for the minimum and maximum number of orders to be ejected from a set AiinAfor i = 1, …, I, respectively. The components of the ejection vectorBhave cardinalities between these parameters. In our experiments, we set η = 0 which implies some BiinBcould be the empty set and γ is set to |Ai|, for each set AiinA. The solution of the WBPMP yields an ordered partitionA¯=(A¯1,A¯2,…,A¯I)whereAi¯=Bj∪Ai∖Bifor i, j = 1, 2, …, I. Note that, the ordered partitionA¯of S is feasible for the OBP if{Ai¯:Ai¯⊆S;∑j∈Ai¯mj≤Q}holds for i = 1, …, I.A solution s* output by the LST is accepted only if it satisfies the capacity constraints (3) and f(s*) is less than equal to (1 + ρ)f(sbest). Here, sbestis the best found solution during the run of the ILST and ρ is a non-negative parameter.When χ number of consecutive ILST iterations are performed without improving the best solution sbestwe stop the algorithm.In this section, we present the details of our computational experiments. The algorithms are coded in C + + and tested on a Dell Server PE2900 with two 3.16 gigahertz Quad Core Processors and 32 gigabyte RAM with Microsoft Windows Server 2003 operating system. MILP problems are solved by CPLEX 11.0 solver with default options.In order to expose the performance of the MILP models and the ILST algorithm, we have considered three classes of OBP test instances, i.e. Class I, Class II and Class III. The instances in Class I have been produced by Henn and Wäscher (2012) and they are downloadable in Henn (2014). We have generated test instances in Class II by following the footsteps of Hwang and Kim (2005). Finally, the test instances in Class III have been created using the parameter values and structure suggested by Bozer and Kile (2008).Class I consists of test instances with the number of orders between 20 and 100 with increment of 20. For each number of order there are 40 instances. Henn and Wäscher (2012) have generated two categories of instances considering both traversal and largest gap routing policies. In our experiments we have only employed their OBP instances considering the traversal routing policy. Furthermore, Henn and Wäscher (2012) have taken into account the class-based demands (CBD) and uniform distributed demands (UDD) scenarios. For both scenarios there are 200 test instances, which sum up to 400 test instances in Class I. For each instance four different capacities have been addressed, i.e. Q = 30, Q = 45, Q = 60 and Q = 75. The layout, considered by OBP test instances in Class I, consists of 10 aisles and each aisle includes 90 storage locations (45 storage locations on each side of an aisle). The horizontal distance between aisles, w, is 5 meter. The distance between the front aisle and the back aisle, L, is 46 meter. The length of each storage location is 1 meter. The I/O point is situated 1.5 meter away from the first storage in the leftmost aisle.Class II contains test instances with the number of orders selected between 10 and 100 with increment of 10. For each number of orders we have generated 50 instances which totally makes 500 test problems. The number of items for each order is randomly chosen between 2 and 10. The items are randomly assigned to locations. According to the capacity of the order picker we have three sets of test instances, which assume picker capacities Q=24, Q = 36, and Q = 48, respectively. Note that the OBP test instances in this class consider a layout which is illustrated with Figs. 1–4. For these instances, the distance between the front aisle and the back aisle, L, is 10 meter and the horizontal distance between aisles, w, is 2.4 meter. In this type of warehouses, the I/O point is located in front of the leftmost aisle.Class III includes four sets of test instances according to the number of orders and number of aisles considered. For these sets, the number of orders and the number of aisles are (20, 11), (20, 16), (20, 22) and (25, 16), respectively. For each set of test instances, the picker’s capacity is set to 25 according to the setting suggested by Bozer and Kile (2008). Furthermore, for each set we have produced 20 instances, which makes 80 test instances. The layout considered for the Class III instances is different from the layouts addressed for the Class I and Class II instances. In the warehouse layout considered for the Class III instances, we assume that the I/O point is located at the midpoint of the front aisle. In Class III instances four layout configurations are taken into account according to the number of parallel aisles K, the number of orders n and the distance between the front aisle and the back aisle, L. In these layouts, (K, n, L) values are set to (K = 11, n = 20, L = 237.27 meter), (K = 16, n = 20, L = 166.25 meter), (K = 22, n = 20, L = 123.65 meter) and (K = 16, n = 25, L = 166.25 meter), respectively. The horizontal distance between aisles, w, is 10 meter and the capacity is set to Q = 25 for all instances in Class III. In summary, we have totally considered 980 OBP test instances to perform our computational experiments.The fine tuning of parameters must be carefully handled in order to obtain good results. We have calibrated the parameters considering five Class I instances with the number of orders n from 20 to 100 with increment of 20 and 10 Class II instances where each of which is selected with different number of orders i.e. 10 ≤ n ≤ 100. Then considering different picker capacities Q = 30, Q = 45, Q = 60 and Q = 75 for Class I instances and picker capacities Q = 24, Q = 36, and Q = 48 for Class II instances, we have performed the ILST on 20 + 30 = 50 different instances which forms our preliminary test set.First of all, we have concentrated on the LST which serves as the intensification step of the ILST. We should claim that choosing suitable parameters, i.e. θ, α and iter(α), is crucial for the performance of the LST. According to our preliminary experiments, we have observed that proper values for these parameters seem to depend on instance size. Hence, after a careful experimentation and fine-tuning process, we have decided to stop the LST when τ reaches θ = 5 × n and we have preferred to set α = n/2 and iter(α) = 2 × n.In our initial experiments, we have observed that parameter χ, which is used as the stopping condition, plays an important role in the efficiency of the ILST. To determine the most appropriate value for χ we have performed experiments when χ ∈ {250; 750; 1500} by fixing other parameters (i.e. θ, α and iter(α)). We have found that setting χ to 750 seems to be appropriate for most of the test instances.Next, by fixing χ = 750, we have performed experiments when ρ ∈ {0.025; 0.050; 0.075; 0.10}. The best results are obtained with ρ = 0.05. Then, by letting the value of ε vary within the interval [0.1, 0.5] with increments of 0.1 and when ζ ∈ {1000; 5000; 10, 000; 20, 000} we have run the ILST on our preliminary test set, while setting ρ = 0.05 and χ = 750. We have noticed that the best performance of the ILST is obtained with ε = 0.3 and ζ = 10, 000. Hence, we have kept these values for further experiments.Finally, we have fixed ρ = 0.05, χ = 750, ε = 0.3 and ζ = 10, 000 and, performed tests on our selected instances choosing different values of parameter ϕ within the interval [0.25, 1] with increments of 0.25. We have observed that for most of the instances the best value of the parameter ϕ is fixed to 0.5 as the most appropriate value.Recall that in the initialization phase of the ILST algorithm we run the savings algorithm to reach a feasible OBP solution. Hence, in this section, we will report the results obtained with the savings algorithm which will be named as the SAVINGS, in the sequel. Two variants of the SAVINGS are also analyzed. The first variant is the normalized time savings heuristic proposed by Bozer and Kile (2008). The second one is the parametric enhancement of the savings heuristic suggested by Paessens (1988) in the context of the well-known Vehicle Routing Problem. The former variant of the SAVINGS is named as SAVINGS-BK and the latter one is called as SAVINGS-P.Recall that in the SAVINGS algorithm, initially each order is considered as a separate batch and hence each order is picked up by a separate picker. Then, the batches are combined repeatedly by considering the saving formula Cij= ei+ ej− eij. At each iteration the feasible combination of two batches which yields the largest saving in the pickers’ travel length is performed. The algorithm stops whenever a feasible combination of two batches which outputs a positive saving is no longer possible. The SAVINGS-BK algorithm considers the following modified savings formula Cij= (ei+ ej− eij)/(ei+ ej). On the other hand, the SAVINGS-P heuristic employs the parametric savings formula Cij= ei+ ej− αeij+ β|ei− ej| where α and β are nonnegative parameters. In our experiments, α changes within [0.1, 2] and β is selected within [0, 2], both with an increment of 0.1. Hence, SAVINGS-P outputs the best of 20 × 21 = 420 values obtained with the SAVINGS algorithm run with different values of α and β.Tables 1–3(Tables 4–6) present computational experiments on the Class I instances with CBD (UDD) scenario for the OBP considering traversal, return and midpoint routing policies, respectively. In Tables 7–9, we report the computational results on the Class II instances for the OBP considering the traversal, return and midpoint routing policies, respectively. Table 10includes computational results on the Class III instances for the OBP considering traversal, return and midpoint routing policies.The first columns in all tables but Table 10 denote the number of orders n which is followed by the picker’s capacity Q. The last row of all tables include the overall column averages. For example, the row n = 20, Q = 36 in Table 7 stands for the computational experiments obtained with 50 test instances with 20 orders and picker’s capacity Q = 36 for the OBP considering traversal routing policy. In all tables except Table 10, the second columns include the results obtained with the ILST. In the next two columns, we report the experimental results obtained with MILP models and the SAVINGS, the fifth columns include the SAVINGS-P. The last columns are for the computational results obtained with our implementation of the ILS-2 heuristic by Henn and Wäscher (2012). Note that we have employed the parameter settings suggested by the authors.Considering the results reported in Table 1 we can observe that the upper bounds obtained with our implementation of the ILS-2 algorithm are close to the ones output by the ILS algorithm in Henn et al. (2010) for the OBP instances with CBD storage scenario and traversal routing policy. The ILS algorithm differs from the ILS-2 heuristic by Henn and Wäscher (2012) only in the construction method used at the initialization phase. The ILS algorithm uses the First Come First Served priority rule based algorithm (Gibson and Sharp, 1992) while the ILS-2 heuristic employs the SAVINGS, as the initial solution construction procedure. According to the computational experiments by Henn and Wäscher (2012), ILS and ILS-2 yield quite similar performances in terms of both accuracy and efficiency. Therefore, we can argue that our implementation of the ILS-2 heuristic is valid.At this stage, we should state that the ILST algorithm developed in this work is different from the ILS-2 algorithm devised by Henn and Wäscher (2012) in several respects. First of all, note that the ILST allows infeasible solutions while the ILS-2 considers only feasible solutions. Next, in the intensification phase of the ILS-2 by Henn and Wäscher (2012) the authors have employedN=N(1,0)∪N(0,1)∪N(1,1)as a straightforward local search procedure. On the other hand, the ILST runs the LST algorithm in the intensification phase. Finally, we should point out that the diversification phase of the ILST is completely different from the one of the ILS-2. In the perturbation step of the latter heuristic, two different batches are randomly selected then two randomly chosen sets of orders belonging to these batches, are exchanged as long as the capacity constraints are not violated. Besides, the perturbation step of the ILST allows random re-assignment of orders to available batches, addition and removal of new batches. Hence, the perturbation step used in the ILST can be considered to be stronger than the one employed in the ILS-2.In Table 10, the first column indicates the routing policy and the second column includes the number of orders n and the number of aisles K. The third column includes the results obtained with the ILST. The next column incorporates the output by the MILP models. The fifth column is for the SAVINGS. The sixth column presents our implementation of the normalized time savings heuristic, i.e. SAVINGS-BK, proposed by Bozer and Kile (2008). In the seventh column we report the output of the SAVINGS-P. The last column gives the results obtained with our implementation of the ILS-2 heuristic by Henn and Wäscher (2012).In all tables the CPU times reported are in seconds and UB stands for the solution value obtained with the ILST algorithm. %Dev deviation stands for the average percent deviation from the solution value obtained with the ILST algorithm. The formulae used to calculate the average percent improvements is(40)100×(Z−UB)UBwhere UB and Z are respectively the solution values obtained with the ILST algorithm and the solution procedures such as the MILP solver, the SAVINGS, the SAVINGS-P, the SAVINGS-BK and the ILS-2.We assess the performance of the proposed MILP models in terms of solution accuracy within a CPU time limit of 10,800 seconds. Therefore, the percent deviations reported are obtained with the feasible solutions output by CPLEX. Note that, when CPLEX returns a solution value in less than the imposed CPU time limits, we report the optimal solution. In 371 cases out of 4800 Class I test problems, we have reached the optimum solutions with CPLEX MILP solver. Broadly speaking, we can state that for 7.72 percent of the Class I cases we can get optimum solutions via MILP formulations. On the other hand, we have obtained optimum solutions with CPLEX MILP solver, for 350 cases out of 4500 Class II test instances. This implies that for 7.29 percent of the Class II cases we can obtain optimum solutions via MILP formulations. Moreover, notice that for none of the Class III test instances we obtained the optimum solutions within 3 hours run of CPLEX MILP solver. Although, we could only reach optimal solutions of the small size OBP instances within 3 hours of CPU time limit, we believe the attempts to obtain the exact solution of the OBP are worthwhile.In all tables, we can see that the ILST outperforms the ILS-2 in terms of both accuracy and efficiency. To be more precise, note that the overall average of solution values obtained with ILS-2 deviates from the one obtained with the ILST by 1.39 percent. On the other hand, the overall average of computation time spent by the ILS-2 is 71.38 seconds. while the overall average CPU time requirement of the ILST is 58.88 seconds. In terms of CPU time, the SAVINGS algorithm is the winner with an overall average of 2.44 seconds. Evidently, the SAVINGS algorithm suffers from the solution quality. In our experiments, we have observed that the overall average of percent deviation obtained with the SAVINGS algorithm from the ILST is 7.14 percent. Finally, for the SAVINGS-P algorithm the overall average of percent deviation from the ILST becomes 3.14 percent with an overall average of CPU time requirement of 21.04 seconds.Taking into consideration the results reported in Table 10 we can observe that the computation time requirement of OBP algorithms grows when we keep the number of aisles, K, fixed but we increase the number of orders, n. Namely, when we compare the CPU times reported in rows corresponding to (K = 16, n = 20, L = 166.25 meter) and (K = 16, n = 25, L = 166.25 meter), i.e. the CPU times in the second and in the fourth rows of Table 10, we can see that the OBP algorithms require more computation time for the instances with n = 25 comparing to the instances with n = 20.In order to better expose the strength of the ILST we have considered the conjecture by Hoos and Stützle (1998). Following this conjecture, one can assume that the random variable Time-To-Target (TTT) solution value required by the ILST fits a two-parameter shifted exponential distribution. Hence, Fig. 5depicts the Quantile–Quantile (QQ) plot where the quantiles of a two-parameter shifted exponential distribution are shown on abscissa axis and measured CPU times are indicated in the ordinate axis. Fig. 6illustrates the TTT plot for the ILST. This plot indicates the TTT value on the abscissa axis and the probability that the algorithm reaches the target solution value is shown on the ordinate axis. Both Figs. 5 and 6 are prepared using the data obtained by running the perl program by Aiex, Resende, and Ribeiro (2007). We should state that the plots illustrated with Figs. 5 and 6 are drawn for a single Class II OBP instance considering the midpoint routing policy, with n = 30 and Q = 24. The ILST is repeatedly run 200 times on this OBP instance. First of all, we fix a target value which is the best known solution value for this instance. Then we measure the CPU times required to reach this target value of each of 200 runs for the ILST. As it can be observed, the probability that ILST finds a solution at least as good as the target value in at most 3.8 seconds is approximately 60 percent, in at most 4 seconds is approximately 80 percent and in at most 4.6 seconds is approximately 90 percent.

@&#CONCLUSIONS@&#
