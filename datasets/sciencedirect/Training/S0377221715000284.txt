@&#MAIN-TITLE@&#
An exact algorithm for the reliability redundancy allocation problem

@&#HIGHLIGHTS@&#
New exact algorithm for the redundancy allocation problem.Applying a two-step problem transformation to the multiple choice knapsack problem.Considerable improvements in running time and solution quality over earlier methods.

@&#KEYPHRASES@&#
Redundancy allocation problem,Multiple choice knapsack problem,Branch and cut,

@&#ABSTRACT@&#
The redundancy allocation problem is the problem of finding an optimal allocation of redundant components subject to a set of resource constraints. The problem studied in this paper refers to a series-parallel system configuration and allows for component mixing. We propose a new modeling/solution approach, in which the problem is transformed into a multiple choice knapsack problem and solved to optimality via a branch and cut algorithm. The algorithm is tested on well-known sets of benchmark instances. All instances have been solved to optimality in milliseconds or very few seconds on a normal workstation.

@&#INTRODUCTION@&#
This paper is concerned with the reliability Redundancy Allocation Problem (RAP), whose objective is the optimal allocation of redundant components within a series-parallel system with n different subsystems in series and miparallel components within each subsystem i, with i = 1, …, n. The problem is complicated by the existence of knapsack-type resource constraints, typically describing limitations in terms of volume, weight, and cost.The RAP is motivated by means of reliability requirements in practical applications of system design. To achieve reliability one may resume to one or both of two different approaches focusing on adding redundant components and/or increasing the reliability of the individual components. The goal is to maximize the overall system reliability. Let us consider a series-parallel system with the following characteristics:•The system is made up by n components in series, i.e., N = {1, …, n}.Each subsystem i consists of siparallel components, indicated by k = 1, …, si.There exist Q capacity or resource constraints, each defined by a maximum availability bq, q = 1, …, Q.Each component k within subsystem i is defined by:•A discrete decision variable yik, indicating how many times component k is replicated within subsystem i.A reliability value Rik∈ [0, 1].A set of Q coefficient constraintsgikq.Fig. 1exemplifies the RAP, where n different subsystems are placed in series and, within each system, siparallel components are available. The objective of the problem is to determine which components and how many replications of each available component should be selected to maximize the overall system reliability.A nonlinear integer formulation for the RAP is:RAP:|maxR=∏i=1n(1−∏k=1si(1−Rik)yik)s.t.∑i=1n∑k=1sigikqyik≤bq,q=1,…,Qyik∈N,i=1,…,n,k=1,…,siwhere Rik∈ [0, 1] is the reliability of component k within subsystem i, with i = 1, …, n and k = 1, …, si,gikq>0accounts for the usage of resource q of component k within subsystem i (e.g., volume, cost, etc.), andbq∈R+provides the maximum availability of resource q, with q = 1, …, Q. It is easy to see that, in order to achieve a non-null system reliability, constraint ∑kyik≥ 1 must be implicitly satisfied for each subsystem i. The symbols and notation used in this formulation and throughout the paper are summarized in Table 1.The RAP isNP-hard (Chern, 1992) and is generally formulated as a non-convex integer nonlinear programming problem. It finds a wide range of applications, for example, in computer network design (Altiparmak, Dengiz, and Smith, 2003), consumer electronics (Painton and Campbell, 1995), software systems design (Berman and Ashrafi, 1994), network design (Deeter and Smith, 1998), and airport security systems design (Ramirez-Marquez, Coit, and Konak, 2004). See Kuo and Prasad (2000), Kuo, Prasad, Tillman, and Hwang (2001), and Kuo and Wan (2007) for an extensive overview of applications of the RAP.The problem has been tackled using exact approaches, e.g., dynamic programming (Ng and Sancho, 2001; Yalaoui, Châtelet, and Chu, 2005), branch and bound (Ha and Kuo, 2006) as well as heuristic and metaheuristic approaches, e.g., multi-objective heuristic (Coit and Konak, 2006), simulated annealing (Kim, Bae, and Park, 2006), tabu search (Caserta and Márquez, 2009; Kulturel-Konak, Smith, and Coit, 2003), ant colony optimization (Liang and Smith, 2004; Nahas, Nourelfath, and Ait-Kadi, 2007), genetic algorithms (Coit and Smith, 1996b; Tavakkoli-Moghaddam, Safari, and Sassani, 2008), variable neighborhood search (Liang and Chen, 2007), particle swarm optimization (Tan, Tan, and Deng, 2013), cuckoo search (Kanagaraj, Ponnambalam, and Jawahar, 2013; Valian and Valian, 2013), differential evolution algorithm (Beji, Jarboui, Siarry, and Chabchoub, 2012), and hybrid algorithms (Billionnet, 2008; Caserta and Voß, in press; Ouzineb, Nourelfath, and Gendreau, 2010; Sadjani and Soltani, 2009; You and Chen, 2005). A heuristic based on column generation decomposition is presented by Zia and Coit (2010).Kuo and Prasad (2000), Kuo and Wan (2007) and, more recently, Twum and Aspinwall (2013), Soltani (2014) offer a comprehensive classification and survey of reliability optimization models and methods. The area of reliability redundancy allocation and the consideration of the RAP is still a lively field which is also reflected by the option to consider extended and modified versions of the problem. Examples include the consideration of multi-objective versions of the problem (Cao, Murat, and Chinnam, 2013) and the inclusion of budgeted or unbudgeted uncertainty in component reliabilities (Feizollahi, Ahmed, and Modarres, 2014; Feizollahi and Modarres, 2012). In standby redundancy one assumes modules being on-line and operational with additional modules serving as standby units. When an on-line unit fails it is removed and replaced by a standby unit. Standby redundancy can be classified as hot and cold. In the first case elements in the standby mode operate in synchrony with the on-line primary unit being ready to take over immediately. In the latter, elements in the standby mode are unpowered until needed. Recent results on hot and cold redundancy problems are presented, e.g., in Levitin, Xing, and Dai (2014). As a final comment regarding the timeliness of work on the RAP, we like to refer to a recent scientometric analysis of literature for this problem domain by Heilig and Voß (2014). Scopus was used as database with a search query within the titles, the abstracts and the keywords of any references on “reliability optimization,” “redundancy-optimization,” as well as “redundancy allocation” for the years 1969–2013. After some necessary data cleaning there were 1325 entries/references which were distributed over the years with a considerable increase throughout the last decade with a maximum of 132 papers in 2013. That is, there is an increasing interest in this problem domain.This paper presents an exact algorithm for the series-parallel RAP. The key idea of the proposed approach lies on the transformation of the RAP into a multiple choice knapsack problem. The RAP can be seen as the problem of finding an optimal distribution of resources among subsystems. We show that, given a fixed amount of resources allocated to a specific subsystem, finding the allocation of redundant components within the subsystem is equivalent to solving a multi-constraint knapsack problem. Based on that, the proposed algorithm consists of two steps: (i) solve each individual subsystem problem with respect to any possible allocation of resources, i.e., solve the multi-constraint knapsack problem associated to each subsystem in pseudo-polynomial time; (ii) find an optimal distribution of resources among subsystems, i.e., solve the associated multiple choice knapsack problem by selecting the specific amount of resources to be assigned to each subsystem. We will prove that solving the multiple choice knapsack problem to optimality corresponds to finding an optimal solution to the original RAP.The proposed exact algorithm is tested on two sets of well-known benchmark instances from the literature, namely the 33 instances of Nakagawa and Miyazaki (1981) and the 108 instances from Coit and Konak (2006). To the best of the authors’ knowledge, the paper presents contributions with respect to at least two points: (i) it is the first time that the multiple choice knapsack problem together with a discrete-binary transformation is used to model and solve the RAP; and (ii) it is the first time that a well-known set of benchmark instances from the literature (Coit and Konak, 2006) is solved to optimality within seconds. With respect to this testbed, for 21 instances a new best value, i.e., a global optimum, which was previously unknown to other authors, has now been found.Regarding the relation of the RAP to the multiple choice knapsack problem we should mention Bulfin and Liu (1985) and Chern and Jan (1986). These are important references from the 1980s which have already pointed out the relation to problems within the knapsack problem family as well as (in the case of Chern and Jan, 1986) the multiple choice knapsack problem. These relations have been reused later (e.g., in Kim, Kim, Bae, and Yun (2008)) but still without actually being able to solve those mentioned benchmark instances to optimality once they were available.The paper has the following structure: Section 2 illustrates how the RAP is transformed into a multiple choice knapsack problem and solved via a branch-and-cut scheme. Section 3 presents computational results on two well-known sets of benchmark instances and, finally, Section 4 concludes with some remarks.In the remainder of the paper, we always work with the binary version of the RAP. We direct the reader to Caserta and Voß (2009) for a detailed explanation of the discrete-binary transformation of the RAP into its corresponding binary version. A binary formulation for the RAP is:RAP-B:|maxR=∏i=1n(1−∏j=1mi(1−rij)xij)s.t.∑i=1n∑j=1miaijqxij≤bq,q=1,…,Qxij∈{0,1},i=1,…,n,j=1,…,miwhere uikis an upper bound on the number of replications of each component k within subsystem i and each discrete variable yik, with 0 ≤ yik≤ uik, is substituted by a set ofn^ik=⌈log2(uik+1)⌉binary variables and each subsystem i is defined bymi=∑k=1sin^ikbinary variables. Each of the ⌈log2(uik+ 1)⌉ binary “components” corresponds tonkhreplications of component k, where:xikh={1,ifnkhreplicationsofkaretaken;0otherwise.with:nkh={2h−1,ifh<n^ik;uik−∑h=1n^ik−12h−1,ifh=n^ik.Finally, coefficients rij, andaijqare defined as:aikhq=nkhgikqrikh=1−(1−Rik)nkhNote that the relation between the y-variables and the x-variables may be expressed as follows:yik=∑h=1n^iknikhxikhIn this section we present an exact algorithm for the RAP based upon an analogy between the RAP and the Multiple Choice Knapsack Problem (MCKP). The MCKP is a binary knapsack problem in which a partition N1, …, Nnof the item set is given, and a solution that maximizes profit while selecting exactly one item from each partition must be found. (See, e.g., Martello and Toth, 1990 for an introduction to the MCKP.)A 0-1 mathematical formulation of the MCKP is:MCKP:|maxπ=∑i=1n∑j=1nipijzijs.t.∑i=1n∑j=1niwijqzij≤bq,q=1,…,Q,∑j=1nizij=1,i=1,…,nzij∈{0,1}i=1,…,n,j=1,…,ni,where ni= |Ni| is the total number of items in group i, with i = 1, …, n, and the binary decision variable zijtakes value 1 if item j of group i is selected and 0 otherwise. The profit for item j of group i is denoted by pij. For each resource/capacity q we assume availability of bqwhilewijqis the weight or resource utilization of item j of group i.The RAP-B can be seen as the problem of finding the optimal allocation of scarce resources among different subsystems. In this spirit, let us define fi(d) as the optimal reliability value of subsystem i when d = (d1, …, dQ) units of resources are assigned to the subsystem.Let b = (b1, …, bQ) indicate the vector of the right-hand-side values of the knapsack constraints. Define Ni= {(fi(d), d) : fi(d) > 0, d = 0, …, b}, such that Nh∩Nk= ∅ for all h ≠ k. This means that the set of choices of any two subsystems are different; with this we can ensure that each variable in the MCKP is uniquely defined. Thus Niindicates the set of strategies available to subsystem i in terms of resource allocation d and maximum reliability attainable with the assigned resources fi(d). (Literally, the set Niis generated in a way such that any possible allocation is considered and this is precisely what makes the algorithm “exact;” the method to do so, can be e.g. dynamic programming.) If we associate an “item” to each possible allocation strategy, defined as a tuple (pij, wij), where pij= fi(d) stands for the “profit” of item (i, j) andwij=(wij1,…,wijQ)=dstands for the set of weights of the same item, then Niindicates all the items belonging to group i, with i = 1, …, n. Thus, the RAP can be seen as the problem of selecting the subset of items that maximizes the overall system reliability, in such a way that only one item per group, i.e., only one resource assignment strategy per subsystem, is selected and that the overall resource availability is taken into account.Given a resource assignment strategy d for a subsystem i, the optimal reliability value can be computed in pseudo-polynomial time, i.e.,O(mid¯),whered¯=∏qdq,using dynamic programming (Fréville, 2004). Note that this bound on the time of computing optimal reliability holds if all values dqandgikqare integer. In a fashion similar to what is done by other authors (e.g., Elegbede, Chu, Adjallah, & Yaloui, 2003; Yalaoui et al., 2005), we first transform the original problem RAP-B into n “independent” knapsack problems, by settingrij′=−ln(1−rij).Let us then indicate with fi(j, d) the logarithm of the optimal objective function value of the RAP-Biwhen only the first j components are considered, with j = 1, …, mi, and dT= (d1, …, dQ) such that dq= 0, …, bq. A forward recursion formula for this problem is:(1)fi(j,d)={{0,ifd<aijrij′,otherwiseforj=1,max{rij′+fi(j−1,d−aij),fi(j−1,d)}forj=2,⋯,mi,whereaijT=(aij1,…,aijQ)indicates the resource consumption of component j, with j = 1, …, mi. Thus, fi(d) = ln fi(mi, d) indicates the optimal objective function value of subsystem i when d units of resources are used.We create a table of fi(d) values considering each possible value of d ∈ [0, b]. This corresponds to finding an optimal solution of RAP-Biwhen d units of resources are allocated to subsystem i, i.e., the profit value pijassociated to a given resource allocation strategy dij(where RAP-Biis the binary problem corresponding to subsystem i).We make the following claim.Proposition 1An optimal solution of the MCKP induces an optimal solution of the RAP.Let us assume that z* is an optimal solution of the MCKP and thatπ(z*)=e(∑i=1n∑j=1nipijzij)is the corresponding optimal reliability value. The optimal solution z* induces an allocation strategy as follows: for each subsystem i, the amount of resources used is given bywi*=wijfor whichzij*=1.Let us indicate withx*=(x1*,…,xi*,…,xn*)the solution to RAP-B induced by z*, with eachxi*obtained from the recursion of Eq. (1) when d = wi. Furthermore, let R(x*) be the objective function value of RAP-B associated to such solution. Note that such x* must be feasible to RAP-B and that the following equalities hold:π(z*)=πz*(w*)=e(∑i=1n∑j=1nizijlogfi(wi*))=∏i=1n∏j=1nifi(wi*)zij*=∏i=1n(1−∏j=1mi(1−rij)xij*)=R(x*)Let us now assume that the solution x* induced by z* is not optimal to RAP-B, i.e., there exists a solution x′ feasible to RAP-B such that R(x′) > R(x*). That is, let us indicate with d′ = (d1, …, dq, …, dQ) the allocation strategy induced by x′, wheredq=∑i=1n∑k=1miaikqxik′≤bq,q=1,…,Q,and with Ri(x′) the reliability value of subsystem i, i.e.:Ri(x′)=1−∏k=1mi(1−rik)xik′Finally, if we set R(x′) = ∏iRi(x′) and, sinceR(x′)=πz*(d′)holds, we have that:R(x′)>R(x*)⇒πz*(d′)>πz*(w*),which is a contradiction since z* is optimal for the MCKP.□Problem MCKP can be solved, e.g., via dynamic programming as well as by applying a branch-and-cut algorithm. In the remainder of this section we present a branch-and-cut algorithm for the MCKP, in which either the lower bound or the upper bound, or possibly both bounds, are tightened to foster pruning of branches of the tree (see, e.g., Dyer, Riha, and Walker, 1995). The proposed branch-and-cut scheme is based upon the use of lifted cover inequalities, to get tighter upper bounds.Let us consider the qth constraint associated with the MCKP and the associated 0-1 knapsack polytopeQq=conv{zij∈{0,1}:∑i=1n∑j=1niwijqzij≤bq}.We say that the set C⊆N, withN=∪i=1nNi,is a cover if∑(i,j)∈Cwijq>bq. Obviously the cover inequality ∑(i, j) ∈ Czij≤ |C| − 1 is valid forQq. As indicated in Balas (1975) and Balas and Zemel (1978), such cover inequality can be uplifted by computing appropriate coefficients for a subset of variables in N∖C. The lifted cover inequality is of the form∑(i,j)∈Czij+∑(i,j)∈N∖Cαijzij≤|C|−1,where the αijcoefficients are computed in linear time as indicated in Balas and Zemel (1978). We generate lifted cover inequalities for each constraint of the MCKP at each node of the branch and bound tree. At each node, we first solve the LP relaxation of the MCKP and use the LP solution zLPto identify a cover C by adding items in non-increasing order ofzijLPuntil∑(i,j)∈Cwijq>bq. Next, we define the lifted cover inequality, add such inequality to the problem, and re-solve the LP relaxation. The process is repeated until no improvement in the LP solution is observed. We summarize the lifting scheme in Procedure 1.The complexity of our algorithm may be analyzed as follows. First, as stated above, given a resource assignment strategy for a subsystem i, the optimal reliability value can be computed in pseudo-polynomial time, i.e.,O(mib¯),whereb¯=∏qbq,using dynamic programming (Fréville, 2004). Considering that we need to solve n related knapsack problems, the overall complexity of phase (i) of the algorithm isO(m¯b¯n)withm¯giving the average number of components per subsystem and n being the number of subsystems. With respect to the MCKP, as stated in Martello and Toth (1990, p. 78), the MCKP can be solved inO(∑inib¯),where ∑iniis the total number of choices available in step (ii), and depends on the size of the sets Ni. Thus, the overall complexity of the algorithm isO(m¯b¯n)+O(∑inib¯).All the tests presented in this section have been carried out on a Pentium IV Linux Workstation 2.26 gigahertz with 512 megabytes of RAM. The algorithm has been coded in C++ and compiled with the GNU C++ compiler using the -O option. The branch-and-cut algorithm uses the Cbc module of the COIN-OR Library (Lougee-Heimer, 2003). Two benchmark sets from the literature have been used to test the effectiveness of the proposed algorithm.The first testbed is made up of 33 instances originally proposed by Nakagawa and Miyazaki (1981), but also used by a number of researchers, such as Coit and Smith (1996a), Coit and Smith (1996b), Hsieh (2002), Liang and Smith (2004), and You and Chen (2005). These instances have been solved to optimality by a number of authors, e.g., You and Chen (2005), Onishi, Kimura, James, and Nakagawa (2007), Billionnet (2008), and Caserta and Voß (in press). Therefore, we will compare the results of the proposed algorithm with those reported by these authors.The 33 variations of the RAP are series-parallel systems with two knapsack-type constraints, representing weight and cost, and 14 different links. For each subsystem, up to four different component types can be chosen, each one with its own characteristics in terms of reliability, cost and weight. Many authors, including ourselves, allow component mixing for this class of problems.The system characteristics are: n = 14, Q = 2, and sieither 3 or 4, depending on the value of i. While the total cost is kept fixed to C = 130, what changes among instances is the total weight W available, varying in the range W ∈ [159, 191] (see Table 2).In Table 2 we report our results on these benchmark instances. The first column provides the instance number, the second and third columns give the total weight W and cost C allowed, the fourth column presents the best result obtained, which always matches the global optimum, as found by You and Chen (2005) (although they were not aware of having found optimal solutions), Onishi et al. (2007), and Billionnet (2008). Finally, the last column gives the wall clock time required by the algorithm to find the solution. (Note that the time includes both the time it takes to generate the sets Nias well as the time needed to solve the MCKP.)While a comparison of running times among different machines is not entirely accurate, what can be observed is that each instance is solved in less than 1 wall clock second, comparable to the running times reported in Onishi et al. (2007), and at least an order of magnitude smaller than those reported in Billionnet (2008) on a similar machine.As reported in Coit and Konak (2006), the test bed from Nakagawa and Miyazaki (1981) presents some drawbacks, since some component options dominate others and, therefore, many component options could be eliminated through a pre-processing phase. Therefore, Coit and Konak (2006) propose a new testbed made up of 108 instances, divided in three classes. Each instance is defined by 20 series systems, each of them with four components. Each component can be replicated a maximum of 8 times. Component mixing is allowed. Each class defines 36 different instances, by varying the available costs and weights, in a fashion similar to what is done by Nakagawa and Miyazaki (1981).In Table 3, we report the results of the proposed algorithm. As best known results from other authors we refer to those presented in Billionnet (2008). Moreover, we consider results from Zia and Coit (2010) who provide a few improvements.However, no claim of optimality with respect to these values is made by the authors. On the other hand, it is worth noting that, since our algorithm is exact, all reported values are global optima. In boldface, we indicate those instances for which a solution is found which is better than those in Billionnet (2008). In all the other cases, the solution found by the proposed algorithm is the same as the one presented by Billionnet (2008), at least in terms of objective function value. In the table, the first two columns characterize the instance, in terms of cost and weight. Columns 3 and 4 present the reliability value and the computational time for each instance of problem class 2, respectively. Similarly, columns 5, 6 and 7, 8 report the same type of information referring to problem classes 3 and 4, respectively. Problem classes are the same as in Coit and Konak (2006).To summarize:•These instances have been used by, e.g., Coit and Konak (2006), Billionnet (2008) and Zia and Coit (2010). However, no claim of optimality was made by any of the authors.For 84 out of 108 instances, the proposed algorithm matches the best known solution of Billionnet (2008), hence proving optimality for such solutions.For 24 out of 108 instances, the best known solutions in Billionnet (2008) were not optimal. Our algorithm improves these solutions by finding an optimal solution for those instances. For three of these 24 instances, Zia and Coit (2010) had found the optimal solutions (though without claiming optimality, i.e., we prove their optimality).The running times of the proposed algorithm, in terms of average, minimum and maximum times, are summarized in Table 4, indicating that our approach is really efficient.

@&#CONCLUSIONS@&#
In this paper we have presented an exact algorithm for the series-parallel redundancy allocation problem (RAP). The approach exploits the idea of transforming the RAP into a multiple choice knapsack problem, in which one wants to determine an optimal distribution of scarce resources among subsystems. Since a unique assignment of resources per subsystem must be made, we have proved that solving the RAP corresponds to selecting a unique assignment of resources for each subsystem such that the overall system reliability is maximized. We finally solved the multiple choice knapsack problem via a branch-and-cut scheme, using a free MIP solver.The effectiveness of the algorithm has been illustrated by solving instances taken from two sets of well-known benchmark instances. We first solved to optimality the 33 instances of Nakagawa and Miyazaki (1981). All these instances have been solved to optimality in less than 1 second on a normal workstation. In addition, we solved the 108 instances of Coit and Konak (2006) to optimality. Out of 108 instances, the best value available from the published literature was already the global optimum for 87 of them, even though no claim of optimality was made so far. For 21 instances we did improve the best known solutions by finding the global optimum. The average computational time per instance is 1.6 seconds on a relatively slow computer for this class of problem instances, being faster by orders of magnitude when compared to conventional dynamic programming.To summarize, we have closed a research gap in pointing out that well-known benchmark instances for the RAP which are still considered in recent literature are actually easily solved to optimality within very short computational time (using our transformation ideas plus the specific algorithmic exposition). For our future research we propose to work in the following direction. While the RAP is a basic problem within the area of reliability redundancy allocation, there are quite a few generalizations as we have mentioned them in the introduction of this paper. This incorporates the investigation of multi-objective problems, the inclusion of budgeted or unbudgeted uncertainty in component reliabilities or the consideration of hot or cold standby redundancy. It should be worthwhile to extend our algorithmic settings towards these general problem settings. Moreover, if necessary in one or the other generalization, we might also consider to replace the use of the COIN-OR Library with some other solvers like Gurobi or CPLEX. In the light of recent ideas on randomizing the sequence of constraints of MIP models it could be worth comparing different reformulations of the multiple choice knapsack problem on different solvers.