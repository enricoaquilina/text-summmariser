@&#MAIN-TITLE@&#
The maximum balanced subgraph of a signed graph: Applications and solution approaches

@&#HIGHLIGHTS@&#
We discussed three applications that can be solved as instances of the MBSP.We discussed reduction rules to the problem and implemented a pre-processing procedure.We developed an improved version of an existing greedy solution ap-proache.We developed an efficient GRASP procedure.We introduced a set of more difficult instances for one application.

@&#KEYPHRASES@&#
Combinatorial optimization,Balanced signed graph,Heuristics,Portfolio analysis,Community structure,

@&#ABSTRACT@&#
The Maximum Balanced Subgraph Problem (MBSP) is the problem of finding a subgraph of a signed graph that is balanced and maximizes the cardinality of its vertex set. This paper is the first one to discuss applications of the MBSP arising in three different research areas: the detection of embedded structures, portfolio analysis in risk management and community structure. The efficient solution of the MBSP is also in the focus of this paper. We discuss pre-processing routines and heuristic solution approaches to the problem. a GRASP metaheuristic is developed and improved versions of a greedy heuristic are discussed. Extensive computational experiments are carried out on a set of instances from the applications previously mentioned as well as on a set of random instances.

@&#INTRODUCTION@&#
LetG=(V,E)be an undirected graph whereV={1,2,…,n}is the set of vertices and E is the set of edges connecting pairs of vertices. Consider a functions:E→{+,-}that assigns a sign to each edge in E. An undirected graph G together with a function s is called a signed graph. An edgee∈Eis called negative ifs(e)=-and positive ifs(e)=+.Signed graphs were introduced by Heider (1946) with the purpose of describing sentiment relations between people pertaining to a same social group and to provide a systematic statement of social balance theory. Cartwright and Harary (1956) formalized Heider’s theory stating that a balanced social group, i.e., a balanced signed graph, could be partitioned into two mutually hostile subgroups each having internal solidarity. In the last decades, signed graphs continued to be a very attractive discrete structure for social network researchers (Abell & Ludwig, 2009; Doreian & Mrvar, 1996, 2009; Inohara, 1998; Yang, Cheung, & Liu, 2007) but also for researchers in other scientific areas, including portfolio analysis in risk management (Harary, Lim, & Wunsch, 2003; Huffner, Betzler, & Niedermeier, 2010), biological systems (DasGupta, Encisob, Sontag, & Zhanga, 2007; Huffner et al., 2010, efficient document classification Bansal, Blum, & Chawla, 2002), detection of embedded matrix structures (Gülpinar, Gutin, Mitra, & Zverovitch, 2004) and community structure (Macon, Mucha, & Porter, 2012; Traag & Bruggeman, 2009), a very prominent area of network science (Porter, Onnela, & Mucha, 2009). The common element among these applications is the fact that all of them are defined in a collaborative vs. conflicting environment that can be modeled over a signed graph.LetG=(V,E,s)denote a signed graph and letE-andE+denote, respectively, the set of negative and positive edges in G. Also, for a vertex setS⊆V, letE[S]={(i,j)∈E|i,j∈S}denote the subset of edges induced by S. A signed graphG=(V,E,s)is balanced if its vertex set can be partitioned into sets W (possibly empty) andV⧹Win such a way thatE[W]∪E[V⧹W]=E+. The problem that is studied herein can be stated as follows.Problem 1.1MBSPLetG=(V,E,s)be a signed graph. The Maximum balanced subgraph problem is the problem of finding a subgraphH=(V′,E′,s)of G such that H is balanced and maximizes the cardinality ofV′.The MBSP is known to be an NP-hard problem (Barthold, 1982) although the problem of detecting balance in signed graphs can be solved in polynomial time (Harary & Kabell, 1980). In the literature, the MBSP has already been applied in the detection of embedded matrix structures (Figueiredo, Labbé, & de Souza, 2011; Gülpinar et al., 2004) and in portfolio analysis in risk management (Harary et al., 2003).Gülpinar et al. (2004) showed that the problem of detecting a maximum embedded reflected network (DMERN) can be reduced to the MBSP. The existing solution approaches to the MBSP were in fact proposed for the solution of the DMERN problem. The literature proposes various heuristics for the solution of the DMERN problem (for references see (Gülpinar et al., 2004)). In Gülpinar et al. (2004), the first signed graph solution approach was proposed for this problem: a greedy heuristic which is able to find the optimal solution whenever the whole matrix is a reflected network matrix. Lately, Figueiredo et al. (2011) developed the first exact approach for the DMERN problem based on the signed graph reformulation of Gulpinar et al. Computational experiments were carried out over a set of instances found in the literature as a test set for the DMERN problem. Almost all these instances were solved to optimality in a few seconds showing that they were not appropriate for assessing the quality of a heuristic approach to the problem and that more difficult benchmark instances should be provided.The notion of balance for signed graphs in the context of portfolio analysis was introduced by Harary et al. (2003). They showed that a portfolio characterized by a signed graph that is balanced is predictable, in the sense that the structure of the balanced signed graph allows investors to predict the risk of the associated portfolio. These authors used small samples of signed graph structures (up to five vertices) to illustrate how the structural balance and portfolio risk management are linked. Their conclusions were only illustrated by a small real example with four assets.Another balance subgraph problem defined on signed graphs is studied in Huffner et al. (2010) from the point of view of edge deletions. The authors proposed a new data reduction scheme and a fixed-parameter algorithm for this problem. Computational experiments were carried out over randomly generated signed graphs and over signed graphs representing financial networks and gene regulatory networks. Their algorithms were used over signed graphs of up to several hundred vertices.Our contributions are twofold. First, we group and discuss three applications, coming from different research areas, that can be solved as instances of the MBSP. In doing so we provide a new set of benchmark instances of the MBSP, including a set of difficult instances for the DMERN problem. Second, we contribute to the efficient solution of the MBSP by developing a pre-processing routine, an efficient GRASP metaheuristic, and improved versions of the greedy heuristic proposed in Gülpinar et al. (2004).The remainder of the paper is structured as follows. In Section 2 we discuss three applications of the MBSP arising in different research areas. The reduction rules that compose the pre-processing procedure are described in Section 3. The integer programming formulation and the branch-and-cut algorithm presented in Figueiredo and Frota (2013); Figueiredo et al. (2011) to the MBSP is outlined in Section 4. In Section 5, we present two heuristic approaches to solve the MBSP. First, we describe the greedy heuristic proposed in Gülpinar et al. (2004) for the MBSP and propose new strategies to be used in the first step of this heuristic. Then, we develop a GRASP heuristic for the problem. In Section 6, computational results are reported for random instances as well as for instances of the three applications previously described. In Section 7 we present concluding remarks.We next give some notations and definitions to be used throughout the paper. For an edge setB⊆E, letG[B]denote the subgraph of G induced by B. Also, for a vertex setS⊆V, we defineδ(S)={(i,j)∈E|i∈S,j∈V⧹S}andN(S)={j∈V|(i,j)∈δ(S)}. A setI⊆Vis called a stable set if no pair of vertices in I is joined by an edge. We represent a cycle by its vertex setC⊆V. In this text, a signed graph is allowed to have parallel edges but no loops. Also, we assume that parallel edges have always opposite signs. We defineG-=(V,E-)and, for a vertex setS⊆V, we defineN-(S)={j∈V|(i,j)∈δ(S)∩E-},N+(S)={j∈V|(i,j)∈δ(S)∩E+}andGSthe signed graph obtained from G by changing the signs of each edge inδ(S). We refer the reader to Zaslavsky (1998) for a bibliography of signed graphs.The knowledge of a special structure in a matrix defining a linear or an integer programming problem can be used to solve it in an efficient way. One of these special structures is a network matrix. It is well known (Bazaraa, Jarvis, & Sherali, 2009) that if the constraint matrix of a linear programming problem is a network matrix, then we can use the network simplex algorithm to solve this problem more efficiently.A matrix B is called a network matrix if the elements of B belong to the set {−1, 0, +1} and, additionally, if every column of B contains at most one element +1 and at most one element −1. Given a row of matrix B, the operation of changing the signs of all non-zero row elements is called a reflection of this row. A matrix B is called a reflected network matrix if there exists a set of row reflections that transforms matrix B into a network matrix.Consider a{-1,0,+1}-matrixA=[aik]with n rows. Two rows of matrix A are said to be in conflict if they both have a +1 or they both have a −1 in the same column. A signed graphG(A)can be used to represent existing conflicts in A (Gülpinar et al., 2004). The vertex set ofG(A)is defined asV={1,…,n}and the set of negative and positive edges ofG(A)are defined as follows: an edge(i,j)∈E-if and only ifaik=ajk≠0for some column k of matrix A; an edge(i,j)∈E+if and only ifaik=-ajk≠0for some column k of matrix A. In Gülpinar et al. (2004), Gulpinar et al. showed that the problem of detecting a maximum embedded reflected network (DMENR) of A is equivalent of finding the maximum balanced subgraph ofG(A). Fig. 1illustrates this result.Notice that, according to the definition ofG(A), matrices of different dimensions can yield the same signed graph and very large matrices can define very sparse signed graphs. Thus, signed graphs are an appropriate discrete structure to model and to solve the DMERN problem. The first signed graph based solution approach to the DMERN problem was described in Gülpinar et al. (2004). This greedy heuristic approach is described in Section 5. In Figueiredo et al. (2011), Figueiredo et al. introduced an integer programming formulation to this problem in which they explore the relations between network matrices and signed graphs. Based on this formulation, they proposed a branch-and-cut method to solve the MBSP to optimality. An improved version of this algorithm is described in Section 4. In the computational experiments presented in Figueiredo et al. (2011), most of the instances found in the literature were solved to optimality in a few seconds attesting that the instances commonly used as benchmark for the DMERN problem are not appropriate for assessing the quality of a heuristic approach to the problem.A portfolio is a collection of securities (assets) held by an investor. Balancing on signed graphs is used in Harary et al. (2003) to define a risk-limiting strategy for portfolio definition. In this context, each security is represented by a vertex in the signed graph while the correlation between securities is represented by the set of signed edges. A balanced signed graph with only positive edges represents a speculative portfolio since all its securities tend to move in the same direction, either on the upside or on the downside. On the other hand, a balanced signed graph with at least one negative edge is associated with a limited risk portfolio. Such a portfolio is defined by two sets of securities, each set with a tendency to move in tandem, while some pair of assets (connected by negative edges) tend to move in opposite directions providing the investors with a hedging guarantee. According to Harary et al. (2003), an unbalanced signed graph represents an unpredictable portfolio.With the purpose to illustrate this signed graph approach to portfolio analysis, the authors described a simplistic procedure that involves only complete graphs. The procedure is a constructive one, starting with two securities. Roughly speaking, at each iteration two possible actions could be followed: to switch at least one of the securities or to add a new security to the graph. A small case study with only four vertices was presented and discussed.In Huffner et al. (2010), another version of the MBSP is studied where edge-deletions rather than vertex deletions are considered. The authors proposed and implemented a very efficient pre-processing routine as well as a fixed-parameter algorithm to solve this edge-deletion variant of the MBSP. They showed that their algorithms can be used to compute the balancedness of financial networks of up to several hundred vertices. However, we question the meaning of edge deletions in the portfolio analysis application since the correlation between securities cannot be controlled by an investor. On the other hand, the efficient solution of the MBSP defined over a signed graph representing a big set of securities would give a more efficient way to define a limited risk portfolio.As we have mentioned before, signed graphs have shown to be a very attractive structure for social network researchers (Abell & Ludwig, 2009; Doreian & Mrvar, 1996, 2009; Inohara, 1998; Yang et al., 2007). Balancing and clustering problems defined on signed graphs arise naturally in the study of community structures (Agarwal & Kempe, 2008; Macon et al., 2012; Porter et al., 2009; Traag & Bruggeman, 2009; Yang et al., 2007). In this context, each vertex in the signed graph represents a person in a social group while an edge represents a sentiment relation between two people (mutual liking or disliking, friendship or enmity, cooperation or defection, interaction or avoidance) or says if their attitudes toward an object match.No matter the measure of balance, social groups are rarely balanced. One big challenge in this area is to evaluate balance in a social network. Once a measure of balance is defined, it can be used as a tool to study whether and how the network evolves to a possible balance state. Interesting questions arise: Could we cluster a social group according their preferences? Which is the minimum number of relations that should change in a group in order to obtain a balanced network? The first question was extensively studied in the literature and continue to be an interesting research topic (see Porter et al., 2009 for references). The identified clusters, or communities, are cohesive groups corresponding to circles of friends, business partners or groups playing a similar role or having a similar political position.The solution of the MBSP is related with another relevant question: Which is the biggest balanced subgroup in a social network? In answering this question, we identify two dominant and opposite communities in the network. This topic has already appeared in the investigation of community structure of networks determined by common voting (Macon et al., 2012), where different representations of the United Nations General Assembly (UNGA) voting records was proposed. For each network representation, the authors looked for the network partition that better defined the main voting groups, which allowed the identification of the majority ones. The next three sections are dedicated to the description of solution approaches to the MBSP.Polynomial-time data reduction is a strategy extensively used to deal with very large instances of difficult problems (Huffner et al., 2010; Valls, Angeles Perez, & Sacramento Quintanilla, 1998). In the following, we describe very simple reduction rules to the MBSP similar to the ones that have been used in the solution of vertex coloring problems. Consider a signed graphG=(V,E,s).(1) Leti∈Vbe a vertex such thatN(i)=∅. DefineG′=(V⧹{i},E,s), solve the problem overG′and let subgraphH′=(V′,E′,s)be the obtained optimal solution. An optimal solution for G is given byH=(V′∪{i},E′,s).(2) Leti∈Vbe a vertex such thatN-(i)=∅,N+(i)≠∅and, for each pairu,v∈N+(i),(u,v)∈E+. DefineG′=[V⧹{i}]and solve the problem overG′. LetH′=(V′,E′,s)be the obtained optimal solution. An optimal solution for the problem defined over G is given byH=(V′∪{i},E[V′∪{i}],s).(3) LetG=(V,E,s)be a graph such thatV=V1∪V2andE=E[V1]∪E[V2]∪{(i,j)}, withi∈V1,j∈V2and(i,j)∉E+∩E-. DefineG1=(V1,E[V1])andG2=(V2,E[V2]). Solve the problem, independently, over graphsG1andG2. LetH′=(V′,E′,s)andH″=(V″,E″,s)be the obtained optimal solutions. An optimal solution for the problem defined over G is given by the subgraphH=(V′∪V″,E′∪E″,s).(4) Leti,j∈Vbe two vertices in G such thatN+(i)=N+(j),N-(i)=N-(j)and(i,j)∈E-∩E+. DefineG′=G[V⧹{j}]. Solve the problem overG′and letH′=(V′,E′,s)be the optimal solution. This subgraph is also an optimal solution for the problem defined over G.Reduction rules (1), (2), (3) and (4) can be applied repeatedly until we obtain a graph G that cannot be reduced by any of them.Besides the rules mentioned above, we implemented a general reduction procedure based on the work of Huffner et al. (2010) for the edge-deletion version of the MBSP. The procedure proposed in Huffner et al. (2010) looks for a small set of vertices S such that removing S from G cuts off a small vertex set C from the rest of the graph. The vertex set S is called a separator. The main idea is to enumerate all the possible states concerning the vertices in S and, for each possible state, to determine the size of an optimal solution for the induced subgraphG[S∪C]. Finally, the subgraphG[S∪C]is replaced in G by a smaller equivalent subgraph such that the value of the optimal solution for the original graph is kept. The definition of this equivalent subgraph depends on the problem definition. In Huffner et al. (2010), separators with|S|⩽4and|C|⩽32were heuristically generated. This reduction procedure applied to the MBSP is illustrated in Fig. 2and explained in the following.We generate separators for the MBSP such that|S|=1and|C|⩽15. A separator with|S|=1can be generated polynomially by searching for a 1-cut (articulation vertex) in the graph. Next, we describe how the equivalent subgraph is defined in our case.LetS={i}be an articulation vertex. For any feasible solution of the MBSP, we can have two possibilities concerning vertex i: (a) vertex i does not belong to the solution; (b) vertex i belongs to the solution. Letnaandnbbe the number of vertices from C in an optimal solution forG[S∪C]if case (a), respectively, case (b), happens. Notice thatna⩾nband that, no matter if vertex i belongs or not to the optimal solution, the vertex set C contributes with at leastnbvertices to the value of an optimal solution for G. Then, we proceed in the following way. Record valuenb; define a vertex setV′={i,v1,…,vna-nb}; define a set of parallel edgesE′={(i,v)|∀v∈V′⧹{i}}; and define a new graphG′by replacingG[S∪C]in G by(V′,E′). Letv(G)be the value of the optimal solution of the MBSP defined over a signed graph G. Then,v(G)=v(G′)+nb. Henceforth, we will denote this reduction rule as S1.In this section, we describe briefly an integer linear programming formulation and a branch-and-cut algorithm recently proposed for the MBSP (Figueiredo & Frota, 2013; Figueiredo et al., 2011). This exact algorithm was used in the computational experiments presented in Section 6.A signed graph is balanced if and only if it does not contain a parallel edge or a cycle with an odd number of negative edges (Barahona & Mahjoub, 1989). LetCo(E)be the set of all odd negative cycles in G, i.e., cycles with no parallel edges and with an odd number of negative edges. From now on, a cycleC∈Co(E)is called an odd negative cycle. The formulation uses binary decision variablesy∈{0,1}|V|defined in the following way. For alli∈V,yiis equal to 1 if vertexi∈Vbelongs to the balanced subgraph, and is equal to 0 otherwise. We use the vector notationy=(yi),i∈V, and the notationy(V′)=∑i∈V′yiforV′⊆V. The formulation follows.(1)Maximizey(V)(2)subjecttoyi+yj⩽1,∀(i,j)∈E-∩E+,(3)y(C)⩽|C|-1,∀C∈Co(E),(4)yi∈{0,1},∀i∈V.Consider a parallel edge(i,j)∈E-∩E+. Constraints (2) ensure vertices i and j cannot belong together to the balanced subgraph. Constraints (3), called odd negative cycle inequalities, forbid cycles with an odd number of negative edges in the subgraph described by variables y. These constraints force variables y to define a balanced subgraph while the objective function (1) looks for a maximum balanced subgraph. The formulation has n variables and, due to constraints (3), might have an exponential number of constraints.The branch-and-cut algorithm developed in Figueiredo and Frota (2013); Figueiredo et al. (2011) has three basic components: the initial formulation, the cut generation and the primal heuristic. The following improvements were added to the version discussed in Figueiredo and Frota (2013): a new branching rule and new separation routines. Next, we describe the main ingredients of this improved version, used in the computational experiments described in Section 6. For a detailed description we refer the reader to the original works (Figueiredo & Frota, 2013; Figueiredo et al., 2011).The initial formulation is composed by a set of clique inequalities that dominate constraints (2), a subset of odd negative cycle inequalities (3), a subset of clique inequalities introduced in Figueiredo et al. (2011) and by all the trivial inequalities0⩽yi⩽1. A simple rounding heuristic is used every time a fractional solution is found in the branch-and-cut tree.The cut generation component described in Figueiredo et al. (2011) has two separation procedures: an exact separation procedure for odd negative cycle inequalities (3) and a heuristic separation procedure for a family of clique inequalities introduced in Figueiredo et al. (2011). These two separation procedures were also implemented in the improved version presented in Figueiredo and Frota (2013). Two new procedures were added to the cut generation component of the improved version. The authors in Figueiredo and Frota (2013) have implemented the separation procedure described in Padberg (1973) to the lifted odd hole inequalities defined over the set of parallel edges. Moreover, as indicated in Figueiredo et al. (2011), in order to strengthen constraints (3), they have implemented a lifting procedure to the odd negative cycle inequalities with|C|⩽20. In both cases, the subproblems appearing in each iteration of the lifting procedure were solved by simple enumerative algorithms.A standard0-1branching rule was implemented in the original version of the branch-and-cut algorithm (Figueiredo et al., 2011). The authors reported that a version of the branching rule proposed in Balas and Yu (1986) was also implemented but, although it has been successfully applied to the stable set problem (Rebennack et al., 2011; Rossi & Smriglio, 2001), better results were obtained to the MBSP with the standard0-1branching rule. A branching rule based on the odd negative cycle inequalities (3) was implemented in Figueiredo and Frota (2013) and has shown to be more efficient than the standard one. The intuition behind the cycle based branching rule proposed in Figueiredo and Frota (2013) is the attempt to generate more balanced enumerative trees. The standard0-1branching rule is very asymmetrical and produces unbalanced enumerative trees. The authors in Figueiredo and Frota (2013) tried to reduce this effect by branching on odd negative cycles and got better computational results with this new branching rule.In this section, we describe two heuristic approaches to the MBSP: a greedy heuristic proposed in Gülpinar et al. (2004) for the DMERN problem and a GRASP metaheuristic introduced in this work.The heuristic proposed by Gülpinar et al. (2004) is described in Algorithm 1 and is motivated by the following basic result.Lemma 5.1Gülpinar et al., 2004Every signed treeT=(VT,ET)is a balanced graph.GGMZ greedy heuristic.Input: signed graphG=(V,E,s)Output: stable set I1Find a spanning tree T in G2Compute a subsetW⊆Vsuch thatTWhas no negative edges3Find a maximal stable set I in the graph(GW)-4return IIt is not difficult to see that there always exists a partition of set I into two subsets that represents a feasible solution for the MBSP. The greedy heuristic proposed by Gulpinar et al. has the advantage to find the optimal solution of the MBSP whenever G is a balanced graph.The first step of Algorithm 1 could be implemented in a number of different ways. In Gutin, Karapetyan, and Razgon (2009), the authors tried three well known strategies to construct a spanning tree: Breadth First Search (BFS), Depth First Search (DFS) and a random method. Following similar ideas, the Step 1 is implemented in this work as a BFS, a DFS and by using other five different spanning tree strategies. In these additional strategies, we calculate a minimum spanning tree based on costs generated for each edge e of the graph. The Kruskal algorithm (Cormen, Leiserson, Rivest, & Stein, 2009) is used to calculate the minimum spanning tree and the following cost functions were designed:•(-,+-,+):f1(e)={3ife∈E+⧹E-;1ife∈E-⧹E+;2ife∈(E-∩E+)};(+,-,+-):f2(e)={1ife∈E+⧹E-;2ife∈E-⧹E+;3ife∈(E-∩E+)};(-,+,+-):f3(e)={2ife∈E+⧹E-;1ife∈E-⧹E+;3ife∈(E-∩E+)};Random: a random functionfrandom(e)∈[0,1000];Adaptive: an adaptive functionfAdapt(e)={f1(e)if|E-|/|E+|<1;f2(e)otherwise}.In Step 2, the subset W is found by using a recursive procedure based on the inductive proof of Lemma 5.1 (see Gülpinar et al., 2004 for more details). Finally, in Step 3, we replaced the degree-greedy algorithm (Paschos, 1992) used in Gülpinar et al. (2004) and Gutin et al. (2009) by an efficient stable set GRASP (Feo, Resende, & Smith, 1994). We set the GRASP to halt after 100 iterations have been performed since the last time the best solution was updated or when a time limit of 300s is reached.GRASP heuristics have been successfully applied to a large number of combinatorial optimization problems (Martí, Resende, & Ribeiro, 2013); see (Festa & Resende, 2002) for a detailed annotated bibliography. In order to generate better heuristic solutions for the MBSP, a GRASP heuristic is developed in this section. The GRASP heuristic is an iterative procedure that has two phases associated with each iteration: a construction phase and a local search phase. The construction phase finds an initial solution that later might be improved by the local search phase. Both phases are repeated until a termination criterion is satisfied. In the remainder of this section, we describe these two phases.The input for the heuristic is the signed graphG=(V,E,s). We assume that a feasible solution for the MBSP is defined as a pair of disjoint sets(V1,V2)such thatV1,V2⊆V,E[V1]∪E[V2]⊆E+and(E[V1∪V2]⧹(E[V1]∪E[V2]))⊆E-.The overall method attempts to find a maximal feasible solution(V1,V2). The construction phase begins withV1=V2=∅and enlarges these sets in a greedy way by adding one new vertex to the solution (toV1or toV2) at a time. Let(V1,V2)be a feasible solution. We defineCand(V1)={i∈V⧹(V1∪V2)|(V1∪{i},V2)isafeasiblesolutionfortheMBSP}, as the set of vertices that are candidate to enter the setV1. Similarly, we defineCand(V2)={i∈V⧹(V1∪V2)|(V1,V2∪{i})isafeasiblesolutionfortheMBSP}. At each iteration, a vertexi∈Cand(Vw)(forw=1,2) is randomly selected and a new setVw′is reached by inserting vertex i into the setVw. The procedure is repeated untilCand(V1)=Cand(V2)=∅.Obviously, there is no guarantee that the construction phase returns a global optimal solution. Therefore, the solution(V1,V2)may be improved by a local search procedure. The neighborhood of the current solution(V1,V2)is defined as the family of all pairs(V1′,V2′)obtained by applying one of the following operations forw∈{1,2}:(i) removing a vertex i fromVwand inserting a vertexj∈(Cand(Vw⧹{i})∪Cand(Vwmod2))into the corresponding subset (i.e.Vwifj∈Cand(Vw⧹{i})andVwmod2otherwise).(ii) removing two verticesi1andi2fromVwand inserting verticesj1andj2belonging to(Cand(Vw⧹{i1,i2})∪Cand(Vwmod2))into the corresponding subsets.The procedure starts with the solution provided by the construction phase and iteratively replaces the current solution by the one with maximum cardinality within its neighborhood, halting when no better solution is found in that way. Similar to the stable set GRASP of Feo et al. (1994), the method stops after 100 iterations have been performed or when a time limit of 300s is reached.In this section, we report the results of extensive computational experiments carried out with the different procedures described in the previous sections. Our intention is to evaluate the performance of our heuristics and to provide the interested reader with a set of benchmark instances of each application described in Section 2. We also present numerical results obtained with a set of random instances. Specifically, for the DMERN problem, we intend to fill a gap pointed in the work of Figueiredo et al. (2011): we introduce a set of more difficult instances that we believe are more appropriate for assessing the quality of heuristic approaches to this problem. All the instances used here and all the numerical results obtained can be downloaded from http://www.ic.uff.br/∼yuri/mbsp.html.The heuristics are coded in C++ and tested on an Intel Core 2 Duo Computer with a 2.93GHz and 2GB of RAM memory. The branch-and-cut (BC) algorithm from Figueiredo and Frota (2013), described in Section 4, is coded in C++, running on a Intel (R) Pentium (R) 4 CPU 3.06GHz, equipped with 3GB of RAM. We use Xpress-Optimizer 20.00.21 (FICO Xpress Optimization Suite, 2009) to implement the components of this enumerative algorithm. All results reported for heuristic procedures and the BC code were obtained over pre-processed instances. Time reported for these procedures does not include pre-processing time. The CPU time limit is set to 1h for the BC and to 300s for the heuristics. We remember the reader that a second termination criterion have been defined in Section 5 for each heuristic procedure.Pre-processed instances are generated by the following procedure. First, reduction rules (1), (2), (3) and (4) are applied repeatedly until we obtain a graph G that cannot be reduced by any of them. LetB⊆Vbe a subset of vertices in G such that, for eachi∈B,S={i}is a separator such that|C|⩽15. Thus, for each vertexi∈B, we apply the reduction rule S1. Results obtained with this pre-processing procedure are reported in the last row (All rules) of Tables 1–3. The other rows on these tables present numerical results when only one rule is applied repeatedly. Notice that rule 3, as defined in Section 3, eliminates only edges. However, isolated vertices can arise in the graph when only this rule is applied. In that case, we also eliminate them and that explains why non-zero values are reported in row Rule 3 for vertex reductions. The pre-processing of any of our instances lasted at most 5 s, so that pre-processing times are not reported in the next subsections.We generated two sets of random instances. Group 1 is the set of random signed graphs without parallel (E-∩E+=∅). For this group, we generated graphs by varying the number of vertices|V|, the graph densityd=2*|E|/(|V|2-|V|)and the rate|E-|/|E+|. For this group, we considered a set of 108 random signed graphs having|V|ranging in the set {50, 100, 150, 200}, d varying in the set {0.25, 0.50, 0.75} and having|E-|/|E+|varying in the set {0.5, 1.0, 2.0}. For each combination of these values, three different signed graphs were generated. Group 2 is the set of random signed graphs with parallel edges (E-∩E+≠∅). For this group, we generated graphs by varying|V|,dand the rate|E+∩E-|/|E|with|V|and d varying as in Group 1 and having|E+∩E-|/|E|varying in the set {0.25, 0.50, 0.75}. Again, three different signed graphs were generated for each combination of these values which also totalizes 108 random instances in Group 2.The pre-processing procedure had almost no effect over the random instances, so numerical results are not reported for this procedure. Now we present the results obtained with the heuristic methods over the sets of random instances. For each random instance, the heuristic procedures terminated because the maximum number of iterations was achieved in less than 20 s. Tables 4 and 5show the results obtained with the seven different versions of GGMZ greedy heuristic discussed in Section 5. Average values are presented per|V|,dand rates|E-|/|E+|and|E+∩E-|/|E|. For heuristic results, the percentage gap of each instance is100×(B∗-BS)/B∗where BS is the value of the solution found by the heuristic procedure andB∗is the best feasible solution we got from all solution procedures (heuristics and BC). The bold value in each column shows the best average result obtained. From Table 4, we conclude that, in average, the Adaptive version of GGMZ algorithm is the best version for instances in Group 1 followed by the DFS version. Results on Table 5 shows that the Adaptive version is also the best one for instances in Group 2. It is not clear which heuristic version has the second place for Group 2. The authors in Gutin et al. (2009) have concluded that building the spanning tree is the crucial step of GGMZ heuristic and we agree with them. However, they have also reported that DFS is the best strategy for implementing Step 1 of Algorithm 1 among DFS, BFS and a random procedure. Results on Table 5 show that it is not always the case.Figs. 3 and 4compare the percentage gaps obtained with the Adaptive version and with our GRASP metaheuristic. In these graphics, the x-axis exhibits instances ordered primarily by number of vertices and secondly by number of edges while the y-axis exhibits percentage gaps. Clearly the GRASP achieved small gaps, reaching optimal values for many instances. Fig. 4 also shows the percentage gaps obtained with the Adaptive version decreases with the number of edges in the signed graph.As we have mentioned before, some solution approaches based on signed graphs have been proposed in the literature for the solution of the DMERN problem in Figueiredo et al. (2011); Gülpinar et al. (2004); Gutin et al. (2009). These works reported the computational performance of their methods over a set of instances available in the literature. We refer to this set of instances as the GGMZ instances. Before solving each instance of this set, Gulpinar et al. applied a pre-processing procedure in order to reduce the size of the coefficient matrix and a scaling procedure in order to increase the dimension of the{-1,0,+1}-matrix. This set has around hundred matrices of various sizes. Detailed results were reported by Gulpinar et al. for the subset of 44 matrices which have at least 500 rows. Figueiredo et al. (2011) reported their computational results over the 34 more difficult instances that were made available by Gulpinar et al. already pre-processed and scaled. The results obtained with the exact algorithm developed in Figueiredo et al. (2011) showed that GGMZ instances are easy instances except for one. The BC algorithm was able to solve almost all instances in just a few seconds with most of them solved to optimality at the root of the BC tree.Since this is a set of easy instances, unable to capture the complexity of the MBSP, we do not run computational experiments neither with the improved BC code nor with the heuristic methods. However, we run our pre-processing procedure on this set of instances. We can see from Table 1 that these instances were greatly reduced in the set of vertices as well as in the set of edges. After the application of all the reduction rules, almost all the remaining graphs are highly disconnected. Next, we introduce a set of more difficult instances of the DMERN problem that are more suitable for assessing the quality of heuristic approaches to this problem.In Achterberg and Raack (2010), a large set of general mixed integer programs (MIP) coming from network design problems were used to detect block structures in matrices. In order to compose new DMERN instances, a subset of constraint matrices was selected from these problems (some MIPs had the same constraint matrix only differing in the right-hand side of the inequalities) and the scaling procedure described in Gutin et al. (2009) was applied. Here, we denote this set of instances as the new DMERN instances. This set is composed by 316 instances having|V|varying from 19 to 8317. Table 3 presents the reductions obtained by running our pre-processing routine over the new DMERN instances. Only reduction rules (1) and (2) were able to reduce instances in this set and together these rules were responsible for halving the number of vertices in this set.Fig. 5shows the number of instances solved to optimality by the BC code. Graphic (a) gives this information as a function of the graph density while graphic (b) as a function of the number of vertices. We can see that many instances were solved to optimality. Table 9 shows results obtained for the instances remaining unsolved and for the instances solved to optimality in more than one minute. The first three columns give us information about the instances: the Netlib instance name, the number of vertices and the number of edges. The next five columns give us information about the pre-processed signed graphs: the number of vertices, the number of edges and the number of negative, positive and parallel edges. Finally, the last set of columns gives us information about the solution obtained with the BC code: the time (in seconds) spent to solve the instances to optimality (“-” means the instance was not solved within the time limit), the percentage final gap, the percentage gap obtained for the initial formulation, the value of the optimal solution (whenever the time limit is reached, this column reports the value of the best integer solution found) and the total number of nodes in the branch-and-bound tree. Information on this table shows us that these instances were the less affected by pre-processing routines. From this set of instances, we can extract 21 instances not solved to optimality by the BC code, some of them with final gap above20%.Figs. 6–8present the results obtained with the heuristic approaches for all the 316 new DMERN instances. Again, the x-axis exhibits instances ordered primarily by number of vertices and secondly by number of edges while the y-axis exhibits the percentage gaps. Clearly, the GRASP metaheuristic has found the best heuristic solution for almost all new DMERN instances. With respect to the different versions of the GGMZ heuristic, the percentage gaps varied substantially for a same version of this heuristic approach which makes difficult to establish which version has found the better order to include edges in the spanning tree. The DFS version was the one with less variation on the gaps. Considering only the gaps, from Fig. 6, we can conclude that the DFS version got slightly better results than the BFS version (DFS and BFS versions outperformed each other by at least5%in, respectively,51%and34%of the instances). On the other hand, we can see that the three GGMZ heuristics in Fig. 7 reached almost the same gaps ((-,+,+-),(+,-,+-)and(-,+-,+)versions outperformed each other by at least5%in, respectively,5%,2.5%and1%of the instances). From Fig. 8, we can conclude that the Adaptive version got better results than the Random version (Adaptive and Random versions outperformed each other by at least5%in, respectively,58%and32%of the instances). From Table 8, we can see that versions(-,+-,+)and(-,+,+-)solved more instances to optimality. Table 8 informs us the number of instances (for each instance set) for which each heuristic method has found the optimal value. The last row on this table informs us how many instances were solved to optimality by the BC code. For the new DMERN instances, the time spent and the termination criteria achieved by the heuristic procedures seems not to be related with the size of the instance to be solved. As we could expect, in general, the GRASP procedure spent more time than the GGMZ heuristics. Average times (in seconds; calculated over the set of all new DMERN instances) spent by the heuristic procedures are shown in Table 6. For 56 instances in this set, each heuristic procedure terminated because the maximum number of iterations was achieved in less than 10s. We run additional experiments on the set defined by the other 260 instances: with time limit set to 10s and set to 30s. Fig. 9(a) and (b) exhibits, respectively, the obtained results. Results obtained by the GRASP procedure are compared with results obtained by the DFS and(-,+,+-)versions. We can see that, after 10s of computation, the GRASP procedure has already found the best results for many instances in this subset extending its advantage as time limit is increased to 30s.For this application, we considered the market graphs generated by Hüffner et al. in Huffner et al. (2010). These authors used publicly available historical data (for 2003 and 2004) of 5216 stocks to generate this test set. For each pair of stocks, the correlation coefficient was calculated by using, in a given time range, the corresponding stock price fluctuations. Two stocks are positively correlated if they have similar daily fluctuation; otherwise, they are negatively correlated. So, as it was done in Harary et al. (2003), from the correlation coefficients computed, they applied a simple threshold transformation to create a signed graph. Consider a threshold value t. If a correlation coefficient was bigger (smaller) than t (-t), then a positive (negative) edge was added. Different signed graphs were generated by using different threshold values0.3⩽t⩽0.4. To avoid the generation of trivial instances (with mostly negative edges) and motivated by a study of Boginski, Butenko, and Pardalos (2006), they added an offset of 0.05 to all correlation coefficients. Notice that a signed graph generated over the set of 5216 stocks would be a very large graph. Thus, to compose this test set, they randomly chose subgraphs whose sizes range from 30 to 510 vertices in steps of 30. For more details, we refer the reader to the work of Huffner et al. (2010).This test set is composed by instances with the number of vertices|V|varying in the set{30,60,90,…,510}and the threshold value t varying in the set{0.300,0.325,0.350,0.375,0.400}. For each combination of these values, 10 different signed graphs were randomly chosen, which means that each signed graph represents a different subset of stocks and totalize 850 instances. We call this set of instances the portfolio instances. From Table 2 we can see that almost all the instances in this set were reduced by at least one reduction rule and that rule 4 was useless for them. If we compare these results with the results obtained for the new DMERN instances, in total, more portfolio instances were reduced but the percentage of eliminated vertices and eliminated edges were higher for the new DMERN instances. The graphics plotted in Fig. 10exhibits the number of instances solved to optimality by the BC code: graphic (a) gives this information as a function of|V|while (b) as a function of t. We can see these instances become more difficult as the number of vertices increases and the threshold value decreases. Remember that, as defined in Harary et al. (2003), signed graphs generated for a set of securities in a given time period have more edges as the threshold value decreases. All the instances with up to 210 vertices were easily solved in a few seconds. Table 7shows average results for signed graphs with|V|∈{390,420,450,480,510}. The notations in this table are the same as in Table 9 except for the fact that Table 7 exhibits average values. The entries in column%Gap are calculated over the instances not solved within the time limit while the entries in columns Time and Nodes are calculated over the instances solved to optimality. We can see that, in general, the gap increases with the number of vertices and as the threshold value decreases. Also, Time and Nodes decreases as the threshold value increases.Now, we turn our attention to the results obtained with the heuristic approaches on the portfolio instances. In Figs. 11–13, the x-axis exhibits instances ordered primarily by number of vertices and secondly by the threshold value while the y-axis exhibits the percentage gaps. Our GRASP heuristic is the best heuristic also for the portfolio instances. The performance of the GRASP heuristic degrades as the number of vertices exceeds 450 and the performance of GGMZ heuristics degrade as the threshold value decreases. Again, it is difficult to answer which is the best or worst version of GGMZ heuristic for the portfolio instances. Although(-,+-,+)and(-,+,+-)solved more instances in this set to optimality (see Table 8), they were the versions that presented the biggest variations on the gaps (see Figs. 11–13). Results in Fig. 11 demonstrate that there was less variation in the gaps obtained with the BFS and the DFS version on portfolio instances than the ones observed on the DMERN instances and, for many instances, the BFS version has found a better solution than the DFS version (DFS and BFS versions outperformed each other by at least5%in, respectively,13%and60%of the instances). Comparing the gaps in Fig. 12, we can conclude that the(+,-,+-)version got better results than the other two versions ((-,+,+-),(+,-,+-)and(-,+-,+)versions outperformed each other by at least5%in, respectively,0%,58%and0.1%of the instances). From results in Fig. 13 and in Table 8, we can conclude that the Adaptive and Random versions got very similar performance (Adaptive and Random versions outperformed each other by at least5%in, respectively,27%and36%of the instances and solved, respectively, 173 and 187 instances to optimality). For most portfolio instances with up to 210 vertices, all heuristics stop because the maximum number of iterations was achieved in less than 50 s. For instances with more than 240 vertices, the heuristics took more time as the threshold value decreased and the number of vertices increased. For most instances with more than 240 vertices, the GRASP heuristic stop because the time limit of 300s was achieved. On the other hand, for most of these instances, the GGMZ heuristics terminated because the maximum number of iterations was achieved in less than 300s (most of them from 50 to 250s). Again, with the aim to detect the preferable heuristic procedure when a quick solution is needed, we run additional computational experiments on a subset of portfolio instances, with number of vertices from 240, considering different time limits (10 and 30s). Fig. 14exhibits the obtained results. We can conclude from Fig. 14(a) that the GRASP procedure is no longer the best option if a quick solution is needed. The Random version of the GGMZ heuristic is the best option followed closely by the(+,-,+/-)GGMZ version. In Fig. 14(b) we see that the results obtained by the GRASP procedure had improved when the time limit was increased from 10 to 30s but the GGMZ heuristic continued to be the best option. From results in column Best Sol of Table 7, we noticed that signed graphs associated with portfolio instances contains big balanced subgraphs and that for threshold value equal to 0.400 the signed graphs are almost balanced. We believe this explains the results shown in Fig. 14 since the GGMZ heuristic has the great advantage of finding the optimal solution of the MBSP whenever the signed digraph is balanced.In Macon et al. (2012), the community structure of networks representing voting on resolutions in the United Nations General Assembly (UNGA) was investigated. The authors constructed networks from the UNGA voting records of the 63 separate annual sessions between 1946 and 2008 in three different ways. The 19th session was not considered since voting occurred on only one resolution in this session. We refer the interested reader to Macon et al. (2012) for an introduction to the United Nations General Assembly voting data including an interesting discussion of different ways to represent this data in the form of networks. The records for sessions between 1946 and 2008 are available in Voeten’s organization of the UNGA voting data.1United Nations General Assembly Voting Data, by Anton Strezhnev and Erik Voeten, http://hdl.handle.net/1902.1/12379. Accessed in June 2012.1In this work, we represent these UNGA voting data records by a set of signed graphs. The optimal solution of the MBSP over this set of signed graphs allows the identification of majority voting groups in each voting session.Next, we describe how the set of signed graphs is generated. Consider two parametersα,β∈[0,1]. The signed graphs are constructed following the steps of Algorithm 2. The sets of positive and negative edges are defined by the number of agreements and disagreements on resolutions. Parameterαspecifies the level of agreement and disagreement between two countries that gives rise to positive or negative edges in the signed graph. Parameterβdetermines if the sum of agreements and disagreements between two countries is sufficient to establish that they cannot be considered as in the same voting group. Following an observation from Macon et al. (2012), we treat differently the disagreement between two countries in a yes–no pair of votes on a same resolution from a yes-abstain pair or a no-abstain pair. Also, we normalize counts of agreement and disagreement by the total number of resolutions voted in the session.Algorithm 2Algorithm to create a signed graph representing a UNGA voting session.Input: Voting records {yes, no, abstention} for the set of resolutions and countries in a sessionOutput: Signed graphG=(V,E,s)1V={i|iisacountryvotinginthesection};2forEach pair of countries i and jdo3agree=disagree=0;4forEach resolutiondo5ifi and j abstainthenagree=agree+0.5;6ifi and j vote equalanddo not abstainthenagree=agree+1;7ifi and j vote differentlyanddo not abstainthendisagree=disagree+ 1;8ifexactly one of them abstainthendisagree=disagree+0.5;9end10%agree=agree/total_of_resolutions;11%disagree=disagree/total_of_resolutions;12if(%agree-%disagree)⩾αthen13Create a positive edge(i,j);14if(%agree-%disagree)⩽-αthen15Create a negative edge(i,j);16if-α<(%agree+%disagree)<αand(%agree+%disagree)⩾βthen17Create a parallel edge(i,j);18endWe generated the set of UNGA instances varying parametersαandβ, respectively, in sets{0.1,0.2,0.3}and{0.5,0.8}. Signed graphs generated have the number of vertices varying from 54 to 192. For each of the 6 combinations of parametersαandβ, a set of instances was generated.The pre-processing procedure had almost no effect on this set of instances that is composed by dense signed graphs. The mean graph density for each of the 6 sets varies from 0.72 to 0.97. On the other hand, UNGA instances were easily solved to optimality by the BC code. This set of instances is composed by signed graphs with at most 192 vertices and that contains large balanced subgraphs. Fig. 15shows the optimal solutions obtained with all the UNGA instances. In this figure the x-axis represents all the sections from 1946 to 2008 numbered from 1 to 63. The dotted dark line in this graphic gives us the number of countries in the session. The other lines shows the optimal solution of the MBSP defined over the associated signed graph. As we could expect, the optimal value increases as parameterαincreases and it decreases as parameterβincreases. Fig. 16shows the majority groups in the optimal solutions obtained for the UNGA instances generated withα=0.3and with (a)β=0.5and with (b)β=0.8. Interpreting the results in the context of each application is not in the scope of this paper, specially for the UNGA voting records since these data have been widely investigated in the literature. However, it is clear that these voting sessions are characterized by the existence of a majority agreement group that changes whenever we fix one parameter and vary the other. This can explain why these instances are always so easy to solve. Certainly, in other voting contexts, this is not the case and more difficult instances would be generated making the heuristic approaches useful also for this application.The MBSP is a combinatorial problem with applications arising in collaborative vs. conflicting environments that can be modeled over a signed graph. We discussed two applications (Gülpinar et al., 2004; Harary et al., 2003) from the literature and introduced a new application of the problem in community structure. Despite its interesting applications only two solution methods had been proposed in the literature for the MBSP: a greedy heuristic (Gülpinar et al., 2004) and a BC algorithm (Figueiredo & Frota, 2013; Figueiredo et al., 2011). We proposed improved versions for the greedy heuristic and developed a GRASP based algorithm for improving the quality of heuristic solutions obtained for difficult instances. In addition, we discussed simple data reduction rules and implemented a pre-processing procedure for the problem. Numerical experiments were performed over a set of benchmark instances of each application as well as over a set of random instances. A side contribution of this work is the introduction of a set of difficult instances for the DMERN problem filling a gap pointed in the work of Figueiredo et al. (2011).The pre-processing procedure had almost no effect over random and UNGA instances. DMERN and portfolio instances were greatly reduced both in the set of vertices and in the set of edges. No reduction rule was useless but their individual efficiency depends on the set of instances being solved. More portfolio instances were reduced than DMERN instances, however the percentage of eliminated vertices and eliminated edges were higher for the DMERN instances.All random instances with 50 vertices and all UNGA instances were solved to optimality by the BC algorithm. Most new DMERN instances and portfolio instances were also solved to optimality by this algorithm with a group remaining unsolved. It shows that there is a great number of real applications that can be solved to optimality. This is important since for many problems, the representation of the conflict environment as a signed graph is already an approximation of the real problem where many simplifications were done. In such a scenario, solving the problem heuristically can raise the distance from the obtained solution and the reality.The GRASP procedure was the best heuristic solution approach when time limit was not a constraint in the solution process. However, when a solution is required in a few seconds, for signed graphs that contains big balanced subgraphs the GGMZ heuristic was the best option. Our computational results also attested that building the spanning tree is an important step in the GGMZ greedy heuristic. The gap associated to the obtained heuristic solution can double depending on the spanning tree used (see Table 4). Moreover, the definition of the best strategy for the implementation of this step depends on the instance being solved. Even if the quality of the heuristic solution was improved by using different strategies in this first step, our GRASP procedure achieved better results for almost all the instances and was able to reach optimal values for many of them. Table 8 shows for how many instances each heuristic procedure has found the optimal value. The last line in this table exhibits the total number of instances for which the optimal solution is known. The GRASP procedure reached optimal values for 65% of the instances the optimal solution is known.

@&#CONCLUSIONS@&#
