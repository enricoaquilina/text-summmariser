@&#MAIN-TITLE@&#
Mining frequent biological sequences based on bitmap without candidate sequence generation

@&#HIGHLIGHTS@&#
Frequent sequence mining is used to discover genetic laws from biological sequence.Less memory is required because bitmap is used for sequence record and joining.Quicksort list makes the tested sequence real ones instead of excessive candidates.Joining operation is simplified by subtraction and efficient for runtime saving.All frequent sequences can be mined without any loss, so the error rate is 0.

@&#KEYPHRASES@&#
Biological sequence,Frequent pattern,Bitmap,Quicksort list,

@&#ABSTRACT@&#
Biological sequences carry a lot of important genetic information of organisms. Furthermore, there is an inheritance law related to protein function and structure which is useful for applications such as disease prediction. Frequent sequence mining is a core technique for association rule discovery, but existing algorithms suffer from low efficiency or poor error rate because biological sequences differ from general sequences with more characteristics. In this paper, an algorithm for mining Frequent Biological Sequence based on Bitmap, FBSB, is proposed. FBSB uses bitmaps as the simple data structure and transforms each row into a quicksort list QS-list for sequence growth. For the continuity and accuracy requirement of biological sequence mining, tested sequences used during the mining process of FBSB are real ones instead of generated candidates, and all the frequent sequences can be mined without any errors. Comparing with other algorithms, the experimental results show that FBSB can achieve a better performance on both run time and scalability.

@&#INTRODUCTION@&#
Biosequence mining can help people recognize interesting and important relationships between biological sequences for human genome research. There are usually different functions in the sequences, some of them are because of a special element, and some of them are the result of the interaction of a few elements. Biosequence mining is one of the key technologies to discover the single and mutual functions of the elements or the sequences. It can give reasonable prediction and guidance for making human nucleic acid, protein and other biological data. By identifying the protein-coding genes from DNA sequences, it can be found that some gene combination mode is related to drug allergy or appears frequently in some disease.Bioinformatics refers to several subjects such as computer science, information science, and mathematics. Computer processing is a major part in the analyzing of biological data [1]. Even at the beginning of the biological research and development, many pattern mining algorithms for biosequence were proposed. Brazma [2] surveyed approaches to the pattern discovery in biosequences and placed these approaches within a formal framework that systematizes the types for algorithm comparison. It is found that most of the algorithms face efficiency problems when the pattern space grows rapidly.Mining frequent patterns is an indispensable component in many data mining tasks such as association rule mining. These association rule mining algorithms can be partitioned into different categories. Apriori [3] and FP-growth [4] are two classic algorithms. Apriori uses candidate generate-test technique and FP-growth is based on a tree structure which records the sequence paths without candidate generation. The algorithms based on them can be classified in terms of whether there is candidate generation. Another classic algorithm is Eclat [5]. It is different because it expresses the dataset vertically. Algorithms can also be classified by horizontal or vertical dataset expression forms. BitTableFI [6] is BitTable-based and the BitTable is horizontally and vertically indexed. Although efficient bit wise operations are used, candidate generation and test ensure that BitTableFI suffers with high computational costs. Index-BitTableFI [7] is proposed to solve this problem. Index array and the correlative calculate method are applied in using BitTable horizontally. A breadth-first search strategy is used for quick identification of the co-occurrence items and depth-first search is for mining all the frequent itemsets in different levels. DBV-Miner [8] is presented by Bay et al. and developed for mining frequent closed itemsets. Dynamic Bit-Vector(DBV) and a lookup table are used, and the support of itemsets can be quickly computed by the intersection between two DBVs. Bay et al. presented more algorithms based on various data structures, like lattice-based algorithms [9–11] and N-list based algorithm [12]. Sequential pattern mining is originally put forward by Agrawal et al. [13], who also presented three sequential mining algorithms. Afshar formally defined the maximal frequent sequence and proposed the corresponding algorithm MaxSequence [14]. MaxSequence needs to generate and test candidate maximal sequences, and a compressed prefix tree is used to store maximal frequent sequences. When the database is larger, the overhead for maintaining and storing the prefix tree compromises the scalability of the algorithm. A highly compressed lattice storage structure and a breadth-first approach are used by FMMSP [15], and maximal frequent sequences and closed frequent sequences are mined quickly without candidate generation.Because of the nature of biology data, the above algorithms are not necessarily suitable for biological data mining. There are more algorithms designed for biosequences these days. TRFinder [16] algorithm seeks tandem repeats which can cause human disease and consist of two or more copies of nucleotide patterns. A probabilistic model and a statistical criteria collection are used to detect tandem repeats. REPuter [17] is based on a suffix tree and a sequence alignment technique for detecting various types of repeats in DNA, it circumscribes the wide scope of repeat analysis, but it is not efficient for mining frequent repeats. BioPM algorithm [18] was developed for protein sequence mining and it introduces the concept of multiple supports so as to improve performance and efficiency. The mMbioPM [19] algorithm optimizes the structure of hash lists to improve the efficiency of BioPM and reduces the run time. However, the efficiency of the BioPM algorithm and its improvements are not quite ideal because of the large scale of the projected database when the minimal support is lower. MSPM [20] is based on the prefix-tree structure, and it presents the concept of primary pattern which makes the degree of the prefix tree a constant. By avoiding too many short patterns generations, the scale of the prefix-tree will not be too large. Its efficiency is much better but it may miss frequent sequences. An index-based approach [21] proposes an interesting measure for meaningful biological information. Each leaf node in the tree structure is an array whose length is variable. The transaction ID and starting position of each sequence are stored in the arrays for memory reduction. CBFMM [22] mines nucleotide and protein sequence with a variety of FP-tree-based model definitions. Repetition detection in biological data is required for potential malfunction and disease identification. DPMine [23] is designed for colossal sequence discovery from biological dataset. It integrates a DPT+ tree, a doubleton data matrix and a one-dimensional array to find doubleton patterns which may further generate colossal sequences. For irrelevant regions in biological sequence evolution such as mutations, gap constraints need to be considered. DFSG [24] is designed for the sequences which are not conserved. For biological network analysis, graph simplification technology is used, aiming to reduce the graph size [25]. An overview is given in [26] to illustrate how the various frequent pattern mining algorithms can be used for human bioinformatic applications.The FBSB algorithm, reported here, is proposed to mine frequent biosequences with a high efficiency and less memory space requirements. It first calculates the supports of the items for frequency mining and records the end position value of each 2-sequence to form a bitmap which is further used for frequent 2-sequence mining and pattern growth. A quicksort list is created for fast connecting sequences in the same biosequence. Two sequences in the quicksort with the position values next to each other in an ascending order can be connected easily by adding the last item of the second sequence to the first sequence, and the position value of the second sequence is used as the position value of the new sequence. The bitmap is updated and the storage space is released constantly. There is no candidate generation and every frequent sequence can be obtained. The algorithm can satisfy the requirements of biological data mining because of its good efficiency and high quality results. Experimental results show that FBSB is much better when compared with other methods.The remainder of the paper is organized as follows. Section 2 introduces the problem definition about biological sequences and bitmap formation. Section 3 develops the FBSB algorithm and gives some examples. Section 4 presents the performance study of FBSB algorithm. Section 5 contains the concluding remarks.DNA and protein sequences are two typical types of biosequences. It should be noted that there are differences between biosequences and general sequences, so some definitions are given as follows.Definition 1Let Ʃ be an alphabet, a sequence S=<s1s2…sm> with si∈Ʃ(i=1,…,m) is called a DNA sequence if Ʃ={A,C,G,T} consists of four nucleotides, or it is called a protein sequence if Ʃ consists of the 20 symbols for amino acids. A sequence can be called a k-sequence if it contains k nucleotides or amino acid symbols.Let Ʃ={a,b,c} and S=<bacaab>, S is a 6-sequence because there are six items in S.Let sequence S1=<a1,a2,…,am> and sequence S2=<b1,b2,…,bn> be two sequences (m<n) on the alphabet Ʃ. S1 is a subsequence of S2 if there exist integers i1, i2,…,im, such that 1≤i1<i2<…<im≤n and a1=bi1, a2=bi2, …, am=bim. It can also be said that S2 is a super sequence of S1.Let S1=<bacaab>, S2=<aca>, S3=<bab>. S2 is a subsequence of S1, but S3 is not a subsequence of S1. This is different from general sequences; as the items of the subsequence must occur contiguously in the super sequence.Given a database of biosequences D and a biosequence S. The support of the biosequence S in D, denoted as sup(S), is the number of the sequences in D which contains S as its subsequence.Given a biosequence database D={S1,S2,S3,…,S|D|} and a user-defined threshold ζ, where |D| is the number of sequences in D. The minimal support min-sup can be calculated as min-sup=ζ*|D|. If the support of a biosequence S satisfies sup(S)≥min-sup, S is called a frequent sequence in D. If S is a k-sequence, it can be called a frequent k-sequence.For a sequence S, if S is an infrequent sequence, then any of its super sequences are also infrequent.For efficient mining process, all the position values of the 2-sequence occurrences are recorded. A bitmap is constructed to store the values and can be updated as the frequent sequences grow. A sequence may occur several times in the same database transaction, and all its occurrence positions should be put into a position array.Definition 5A bitmap is a two-dimensional table, where each row represents the ID of a sequence in the database and each column represents a sequence. A bitmap cell is denoted as Posi(S), where i is the corresponding row number and S is the corresponding column sequence. Posi(S) is an array of position values for the occurrences of S in the ith sequence.If a subsequence does not occur in a database transaction, its position array is not established, but here ‘∅’ is used to indicate that no occurrence.Example 3Table 1 shows a sequential database andTable 2 is the corresponding bitmap.Taking Pos3(bc)={2,6} for example, sequence bc occurs twice in the third database transaction, and the position values are 2 and 6. Sequence bc occurs in all the 4 transactions, so sup(bc) is 4. If ζ is set to be 50%, the min-sup can be calculated by ζ*|D|, and min-sup=50%*2=1. Then sequence bc is a frequent 2-sequence.Definition 6QS-list is a quicksort list of all the SP-codes for a row of the bitmap. In a QS-list, SP-codes are arranged in position value ascending order. Each SP-code is denoted by SP=<seq,pos>, where seq is the sequence name and pos is the position value of seq. QS-list of a bitmap row is denoted by {SP1,SP2,…,SPn}, and SP1.pos< SP2.pos< …< SPn.pos.(Ancestor-descendant relationship of SP-codes). Given SPiand SPjare two SP-codes, SPiis an ancestor of SPjif and only if SPi.pos+1 are equal to SPj.pos.QS-list for the third row of the bitmap in Table 2 is shown inFig. 1.There are 5 SP-codes. Pos3(bc)={2,6} can produce two SP-codes as <bc,2> and <bc,6>. SP[1]=<bc,2>, so SP[1].seq=bc and SP[1].pos=2. All the SP-codes are in a pos ascending order, SP[1].pos=2<SP[2].pos=3<…<SP[5].pos=6.SP[1] is the ancestor of SP[2] for SP[1].pos+1=2+1=3 is equal to SP[2].pos=3. And it can also be said that SP[2] is the descendant of SP[1]. SP[1] is not the ancestor of SP[3] or others; the descendant must be next to its ancestor.To design an effective data structure and mine frequent biological sequences accurately, the FBSB algorithm can be executed based on the following observations. First, by scanning the database once, the supports of all the items are calculated, all the position values of the 2-sequences are put into arrays and the initial bitmap is formed. Frequent items are mined directly. Second, frequent k-sequences are mined and (k+1)-sequences are generated by connecting frequent k-sequences in the same transaction with a position value ascending order. The two k-sequences can be connected only when the position value of the second sequence is 1 more than the first one, then frequent (k+1)-sequences are obtained and bitmap is updated. Third, no candidate sequences are generated, all the sequences really do occur and the precision is 100%.Algorithm 1Bitmap initiation and frequent items generationLine 1 gives the minimal support min-sup. Line 2 initiates the null bitmap Pos. Lines 3–8 are to calculate the supports of the items, even if an item occurs several time in one transaction, its support can be added at most 1 for one transaction. Lines 9–13 form the bitmap for all the 2-sequences, the position value of the last item of a sequence is used as the position value of the sequence. Lines 14–16 mine frequent items whose supports are no less than the minimal support min-sup and insert the frequent items into frequent itemset L1. Line 17 outputs the bitmap Pos and the frequent 1-item set L1.Algorithm 2Frequent k-sequence mining and (k+1)-sequence generationLines 1–5 mine the frequent k-sequences whose support are no less than minimal support min-sup. Lines 6–15 form the QS-list for the ith row in Pos. If the QS-list is null or its length |QS-list| is 1, delete the ith row of the Pos and form the QS-list for the next row in Pos. Lines 16–23 connect frequent k-sequences to generate (k+1)-sequences, the two sequences can be connected only when the position value of the second sequence is 1 more than the position value of the first sequence. The new connected (k+1)-sequence Newseq can be generated by adding the last item of the second sequence to the first sequence. Line 24 outputs the updated bitmap for (k+1)-sequences and the frequent k-sequence set Lk.The process of mining frequent biosequences from the database D in Table 1 is as follows. Let ζ=50%, then min-sup=ζ*|D|=50%*4=2.The initial bitmap for 2-sequences are first formed in Table 2. All the supports of the items can be calculated. sup(a)=4, sup(b)=4, sup(c)=4. Items a, b, c are all frequent items.Frequent 2-sequences are mined, as sup(ab)=4, sup(bc)=4, sup(cb)=4, sup(ba)=3, sup(ac)=3 and sup(ca)=1. 2-sequence ca and Pos(ca) are deleted because Sup(ca) is smaller than min-sup. Frequent 2-sequences are ab, bc, cb, ba, ac.Fig. 2 shows the QS-list of the frequent 2-sequences in the second transaction(ac has been removed). 3-sequences are easy to be obtained. Just add the last item of cb to ac, and add the last item of bc to cb. Then Pos2(acb)=3, Pos2(cbc)=4, ab cannot be connected because the position value of ab is not next to bc, and connection stops for there are no more sequences after ab. The new bitmap for 3-sequences are shown inTable 3.sup(abc)=3, sup(bcb)=2, sup(cba)=3, sup(bac)=1, sup(acb)=2, sup(cbc)=1, sup(bab)=2. Frequent 3-sequences are abc, bcb, cba, acb, bab. The new bitmap for 4-sequences are shown inTable 4. The final results for all the frequent sequences are inTable 5.Experiments are performed on a PC with Intel(R) Core(TM) 3.6GHz CPU and 16G main memory, running on Windows 8. We evaluate the run time and scalability of the algorithm FBSB, and compare it with BioPM [18] and MSPM [20]. There is no comparison about precision or error rate because FBSB algorithm is always 100% accurate. To test the algorithms in the same coding environment, all the programs are written in C++ using Visual Studio 2013.Dataset used in the experiments has 10 protein families taken from the pfam database [27] as shown inTable 6. The sequence number and the sequence length are different in different families.To test the run time performance of the FBSB algorithm, we chose 2747 sequences from the protein families in the pfam database for the experiment; the average length is 245.50. The sequences are divided into three sets, each experiment is performed three times for different sets and the run time is the average value. In order to make the comparison fair for BioPM and MSPM, each algorithm is tested on the same biological sequence dataset and with the same minimal support threshold min-sup. The run time starts from inputting the dataset and ends with the outputted results, including the processing time.Fig. 3 shows the comparison of the average run time of the three algorithms with different minimal support thresholds.Under the same conditions, FBSB usually runs faster than the other two algorithms. When the minimal support threshold is small, the run time of BioSM and MSPM are much higher and BioPM seems less stable than MSPM and FBSB. This is because BioPM needs more time to continuously build projective databases, although MSPM significantly reduces time in the main mining section, it needs extra time to divide the original sequences to form primary patterns and the primary pattern tree. Also, after the main mining process, some of the leaves should be checked for further joining and sometimes it may miss a few frequent sequences. FBSB uses the QS-list which can ensure all the tested sequences during the mining process really do occur and all the subsequences of the growth sequences are frequent. It can avoid doing unnecessary connections which may generate candidate sequences, and this again saves in testing time.To test the scalability of the three algorithms, we use the same datasets as testing the run time of FBSB and there are 915 sequences in each datasets. We set the minimal support threshold as 15% when the sequence number grows from 100 to 600.Fig. 4 shows the comparison of the run time with different number of sequences.It can be observed that the run time of the three algorithms increase when there are more sequences. MSPM and FBSB are nearly linear increased. This indicates both MSPM and FBSB have a good scalability, but FBSB always runs faster and its run time increases more gently. Constructing projective database continuously is again the reason why BioPM needs more run time. Sometimes the run time increases significantly if there are more sequences with longer length, so the slope changes more at the point of 200 sequences. MSPM displays superior run time performance with longer sequences, because it usually uses primary patterns without producing lots of short ones. However, the more divisions it does, the greater the risk of frequent sequences being missed. FBSB also mines a lot of short sequences, but all the sequences really do occur and all their subsequences are frequent sequences. There are no candidate generation or useless connections. As sequence length grows, the length of the QS-list will become shorter and the number of QS-list will become smaller. That contributes significantly to the reduction of run time for FBSBS.

@&#CONCLUSIONS@&#
