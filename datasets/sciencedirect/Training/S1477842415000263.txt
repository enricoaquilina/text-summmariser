@&#MAIN-TITLE@&#
A DSL for modeling application-specific functionalities of business applications

@&#HIGHLIGHTS@&#
A DSL for specifying application-specific functionalities of business applications.Application-specific functionalities are specified at the PIM level.Complete program code is generated.We present the language editor.

@&#KEYPHRASES@&#
Domain-specific languages,IIS,⁎,CFuncLang,Application-specific functionalities,Model transformations,IIS,⁎,Case,

@&#ABSTRACT@&#
Models have been widely used in the information system development process. Models are not just means for system analysis and documentation. They may be also transformed into system implementation, primarily program code. Generated program code of screen forms and transaction programs mainly implements generic functionalities that can be expressed by simple retrieval, insertion, update, or deletion operations over database records. Besides the program code of generic functionalities, each application usually includes program code for specific business logic that represents application-specific functionalities, which may include complex calculations, as well as a series of database operations. There is a lack of domain-specific and tool-supported techniques for specification of such application-specific functionalities at the level of platform-independent models (PIMs). In this paper, we propose an approach and a domain-specific language (DSL), named IIS⁎CFuncLang, aimed at enabling a complete specification of application-specific functionalities at the PIM level. We have developed algorithms for transformation of IIS⁎CFuncLang specifications into executable program code, such as PL/SQL program code. In order to support specification of application-specific functionalities using IIS⁎CFuncLang, we have also developed appropriate tree-based and textual editors. The language, editors, and the transformations are embedded into a Model-Driven Software Development tool, named Integrated Information Systems CASE (IIS⁎Case). IIS⁎Case supports platform-independent design and automated prototyping of information systems, which allows us to verify and test our approach in practice.

@&#INTRODUCTION@&#
In the last few decades, significant efforts have been invested into the research of approaches and tools, aimed to facilitate the information system (IS) development process. In most of these approaches, models are considered as key components of the process [1]. A model is considered to be more than just an abstraction used for system analysis, design, and documentation. Models may also be used to generate system implementation. Such approaches are mainly devoted to generating program code of IS applications from models created by generic concepts, commonly using the Unified Modeling Language (UML). In a typical scenario, generated program code comprises implementation of generic functionalities such as simple retrieval, insertion, updating, or deletion operations over database records. Generic functionalities are common for various domains, where the program code may be generated from models created by generic and abstract concepts.Apart from program code of generic functionalities, each application may contain program code implementing specific business logic that represents application-specific functionalities. A similar classification of functionalities may be found in [2], where the authors claim that application program code may be classified as (i) generic; (ii) schematic; or (iii) individual. The generic program code is common for various applications, while schematic code has the same repetitive structure. Such program code is typical, easy to generalize, and easy to generate from a model created by generic concepts. On the other hand, individual code is application-specific, and cannot be generalized. Therefore, it is hard, or even impossible to generate such program code from a model created using generic and abstract concepts [2]. The program code of application-specific functionalities fits into this category.In the domain of business applications, application-specific functionalities correspond to specific business logic, which cannot be expressed by simple retrieve, insert, update, or delete operations. Such functionalities may comprise complex calculations, as well as a series of database operations. The use of generic concepts is mostly inappropriate for a detailed specification of functionalities that are specific for each application. As a consequence, it becomes difficult to generate complete program code for these functionalities. Program code generated from models typically does not cover application-specific functionalities and therefore it has to be amended with hand-written code. Hereafter, we use the notion of customization for the task of amending program code with hand-written code. The approach based on program code customization has several drawbacks. When application-specific functionalities are specified by means of a target programming language, a developer must possess knowledge of the target language, as well as target platform services. Also, portability between different platforms is difficult to achieve as the generated program code has to be customized with a programming language specific for the target platform. Finally, because of program code customization, a model and the generated program code may become unsynchronized. Thus, the operational maintenance of such systems becomes more difficult.Unfortunately, a simple approach based on customization of generated program code is the most commonly used for the specification of application-specific functionalities. Consequently, the abstraction level is only partially raised in the development of ISs. While generic functionalities are specified at the level of platform-independent models (PIMs), application-specific functionalities are specified at the lower abstraction level, using a target programming language. In this paper, we propose an approach aimed at enabling complete specification of application-specific functionalities at the PIM level. Our approach is based on the usage of specific concepts and a domain-specific language (DSL) named IIS⁎CFuncLang. Also, we have developed transformations that allow generation of executable code from IIS⁎CFuncLang specifications.A practical application of our approach may help in overcoming the problems discussed earlier in this section. Both application-specific and generic functionalities are completely specified in an early stage of the IS development process, at the level of PIMs. A model containing specification of both types of functionalities may serve as a basis for full program code generation. The generated code is complete and does not require any customization using a target language. Consequently, designers do not need to have knowledge of the target language. If a functionality needs to be revised, revisions are to be performed at the PIM level, and then a complete program code may be regenerated. In this approach, there is no need for an additional synchronization between generated and hand-written program code, which may improve productivity. Also, our approach may facilitate portability. The emergence of a new platform or a target language does not require yet another customization of the generated program code. Detailed discussion on the productivity and portability characteristic is given in Section 8. In general, usage of DSLs in this scope brings additional benefits as discussed in [3,4], and [5].The IIS⁎CFuncLang language is classified as a DSL because it is specially designed for the domain of database applications development. The IIS⁎CFuncLang concepts are abstract enough to be independent of any concrete programming language. Although such DSL abstractions are tailored toward a particular application domain, too much abstraction may lead to a loss of expressiveness. In order to enhance expressiveness, IIS⁎CFuncLang includes concepts commonly found in imperative programming languages, such as control flow statements and variable declarations. Therefore, if an application-specific functionality cannot be defined by using just high-level domain concepts, a designer may resort to using less abstract, but more expressive imperative concepts. In this way, the application-specific functionality is precisely specified using the third generation language (3GL) notions.Raising the abstraction level of IIS⁎CFuncLang would not be complete if adequate transformations into executable specifications are not provided. Therefore, we have also directed our research towards formulating and implementing algorithms that allow generation of executable specifications. We developed a compiler for IIS⁎CFuncLang that performs syntax analysis, semantic analysis, and code generation. Syntax and semantic analysis allow designers to perform early validation of application-specific functionality specifications. The compiler also generates executable program code from IIS⁎CFuncLang specifications. Currently, generation of intermediate code is provided by the compiler. The intermediate code is a specification similar to the Java byte-code, and it is aimed for interpretation. We have also developed an interpreter that executes intermediate code using a common fetch–decode–execute cycle. We have chosen an interpreter approach over a direct translation into an existing programming language, such as assembly or C language, as it offers a greater control over an execution environment, as well as an easier extension [6]. Apart from intermediate code, we provide a generation of PL/SQL program code from IIS⁎CFuncLang specifications. This approach is more suitable when some application-specific functionality has to be implemented at the level of a database management system. In this paper, we do not present our compiler and interpreter in detail, since they are based on well-known techniques of the compiler and interpreter engineering, which are described in [7,8], and [9]. Also, a description of the rather complex transformation algorithms that have been implemented is beyond the scope of this paper. More details about these transformations may be found in [10].For the purpose of verification and testing, we have also embedded the language, tools, and algorithms into the Integrated Information Systems CASE tool, or IIS⁎ase for short [11]. IIS⁎Case is a tool for platform-independent design of ISs and rapid generation of IS prototypes. At the time of the IIS⁎CFuncLang specification, starting from a PIM, this tool provided a generation of (i) SQL/DDL code for ANSI SQL-2003 standard and various relational database management systems (RDBMSs), and (ii) executable prototypes of business applications. IIS⁎Case is an open source tool. Its development spans a number of research projects lasting for several years, in which the authors of this paper are actively involved. Following these reasons, we have chosen this tool to test our approach.In order to support a convenient way for specification of application-specific functionalities by IIS⁎CFuncLang, an editor has been implemented. The editor is named Function Editor, and it provides two approaches for specification of IIS⁎CFuncLang code: (i) textual and (ii) tree-based. The textual approach is more suitable for experienced users in the grammar rules, wishing to specify application-specific functionalities as fast as possible. The tree-based approach, providing some graphical modeling capabilities, is more suitable for less experienced users, not knowing the precise grammar rules and therefore needing some assistance.Apart from Introduction and Conclusion, the paper is organized in nine sections. In Section 2, we present the IIS⁎Case tool. The main PIM concepts for specification of application-specific functionalities are presented in Section 3, while the IIS⁎Case run-time environment supporting these concepts is presented in Section 4. IIS⁎CFuncLang is presented in detail in Section 5. A development process of IIS⁎CFuncLang is presented in Section 6. A case study is presented in Section 7. In Section 8, the IIS⁎CFuncLang qualitative characteristics are discussed. The editor providing IIS⁎CFuncLang specifications is presented in Section 9. In Section 10, we present related work.We have selected the IIS⁎Case tool to implement and test our approach in practice. Therefore, this section contains a brief description of the main IIS⁎Case concepts and components.IIS⁎Case is a model-driven software development (MDSD) tool aimed at IS design and generating executable application prototypes. A model of an IS in IIS⁎Case may be classified as a PIM, since a designer creates it without specifying any implementation details. Besides, the IIS⁎Case tool provides a number of Model-To-Model (M2M) and Model-To-Code (M2C) transformations producing database schema specifications and IS executable code. Detailed information about the IIS⁎Case concepts and its methodological approach that this tool is based on may be found in [12,13], and [14]. Currently, the main IIS⁎Case features are the following:•conceptual modeling of database schemas, transaction programs, and business applications of an IS [11]automated generation of relational database subschemas in the 3rd normal form (3NF) [15];automated integration of independently designed subschemas into a unified database schema in the 3NF;automated generation of SQL/DDL code for ANSI SQL-2003 standard and various RDBMSs [16];conceptual design of common graphical user-interface (GUI) models;automated generation of executable prototypes of business applications; andreverse engineering of relational databases to a conceptual model based on form types [17].The IIS⁎Case meta-model includes an extensive number of high-level concepts, relationships, attributes, and constraints. Abstract syntax of the meta-model is specified using the Ecore and Eclipse Modeling Project (EMP) [18]. In order to use specified concepts, a concrete syntax is provided. IIS⁎Case provides numerous visually-oriented tools and components for modeling. For example, in Fig. 1the main form of the Business Application Designer tool is presented. This component is aimed at specifying the structures of business applications in a simple and visually oriented way. The Layout Editor tool, which is presented in Fig. 2, may be used for specification of visual properties of screen forms and transaction programs. Apart from graphical notations, a textual DSL has been developed. It is beyond the scope of this paper to present the IIS⁎Case meta-model and its components in detail. A reader may find detailed specifications in the references [12,19,15], and [18]. In the rest of this section, we present a brief overview of these concepts.The Form Type concept is the main modeling concept in IIS⁎Case. Each form type is an abstraction of a business document, mainly a screen or report form used by end-users to interact with an IS. In traditional IS design approaches, database schema design precedes specification of screen or report forms of transaction programs. However, in IIS⁎Case a designer specifies screen or report forms, and indirectly creates an initial set of attributes and constraints. Further, IIS⁎Case uses the set of specified form types to generate a relational database schema. Therefore, by creating form types, at the same time a designer specifies (i) a database schema; (ii) functional properties of transaction programs; and (iii) a GUI of business applications.A form type is a tree-structure of component types. Each component type is identified by its name within the scope of a form type. It has non-empty sets of attributes and keys, a possibly empty set of unique constraints, and a specification of check constraints. A set of allowed database operations must be associated with each component type. The set of allowed operations includes typical database operations: retrieve, insert, update, delete. These operations will be used for generation of database schema. By the Component Type concept a designer may also specify a number of display properties that will be used in the process of screen forms generation.Each attribute of a component type is selected from a global set of all IS attributes. Attributes are globally identified only by their names. Also, a set of allowed operations over an attribute in a component type is specified. It is a subset of the set of operations: query, insert, nullify, update. These operations are defined at the level of the component type. Similar to a component type specification, an attribute specification includes various display properties. In a generation process, attributes are mainly used as a source for generation of columns in database tables, as well as input and output fields in screen forms.Each attribute is associated with exactly one domain that defines a set of allowed values for the attribute. The domain concept in the IIS⁎Case meta-model is closely related to a notion of a domain commonly used in the area of databases. In IIS⁎Case, there are two types of domains: primitive and user-defined. Primitive domains correspond to the basic, built-in data types, while user-defined domains are derived from primitive or previously created user-defined domains. Domains may be used in IIS⁎CFuncLang specifications for declaration of parameters and local variables. This concept is described in detail in Section 5.One of the most important functionalities of IIS⁎Case is the SQL Generator tool [16]. The input specification for the generator is a platform-independent IS model specified by the aforementioned high-level concepts. From that model, SQL Generator generates scripts for implementing a new database schema or modifying the existing one. Also, generated scripts include various database constraints, such as check constraints [20]. A graphical tool for specifying these type of constraints is presented in Fig. 3. In Listing 1 we present an example of SQL code generated by the SQL Generator tool.Listing 1SQL code generated by the SQL generator tool.IIS⁎Case also includes the Application Generator tool that provides generation of executable application prototypes [21]. Starting from an IS model created by IIS⁎Case, this tool generates User Interface Markup Language (UIML) specifications that are transformed into the Java program code. Generated Java transaction programs provide generic application functionalities that include the following “standard” data operations: read, insert, update, and delete. An example of a generated application is presented in Fig. 4.In this section we have presented the existing IIS⁎Case concepts and tools that are predominantly used for specification of generic functionalities. The next section describes the new concepts used for specification of application-specific functionalities. Also, in the next section we present how these concepts are used in the code generation process.Generic functionalities that may be expressed by retrieve, insert, update and delete operations are common for various problem domains. These functionalities can be easily specified by means of the existing IIS⁎Case concepts. However, business applications from various problem domains often include specific functionalities. In this section we present concepts for specifying such application-specific functionalities. The following concepts are embedded in the IIS⁎Case meta-model:•Function;Event;Button; andCalculated attributes.Function is the main concept for specifying business logic of an application-specific functionality. In Section 5, we present the textual DSL that is used for specification of functions. However, for a complete specification of application-specific functionalities it is not enough to specify the appropriate business logic only. It is also important to specify the context in which such functionalities may occur. For that purpose, we have created the following concepts: Event, Button, and Calculated attribute. These concepts may be used to specify cases in which application-specific functionalities are executed upon an event occurrence or an explicit user request.The Function concept corresponds to a notion of a function in general-purpose languages (GPLs). A function specification models a particular task regarding data manipulation, calculations, or operations over screen forms. Once the function specification is completed, it may be referenced from various specifications of events, buttons, and calculated attributes. For example, each calculated attribute is linked to a function for calculating an attribute value. For each function the following attributes have to be specified:•function name;list of formal parameters (i.e., arguments);return value type; andfunction body.Frequently, an application-specific functionality is triggered when an event occurrence is detected within a system. In order to formally describe such a scenario, we created a concept named Event. For each Event, the following attributes have to be specified:•function;level that event is handled at;source; andtype.Each event is linked to exactly one function. The selected function defines business logic that needs to be executed when the event occurrence is detected.We differentiate between three levels of event handling: (i) database server level; (ii) application server level; and (iii) client application level. If an event is handled at the level of database server, then code of a database trigger will be generated from the function associated with the event. Currently, we provide generation of PL/SQL program code aimed to be executed by Oracle DBMS. A generation of program code for other DBMSs is a matter of further research. If an event is handled at the level of application server or client application, then intermediate code will be generated. Both generated intermediate code and the interpreter for its execution will be embedded into a generated business application. Upon an event occurrence, the business application invokes the interpreter for executing an associated function. The incorporation of the interpreter and intermediate code into business applications is presented in detail in Section 4.An event source is specified by selecting exactly one instance of the following concepts: (i) Form Type; (ii) Component Type; or (iii) Attribute in Component Type. Let us suppose that a component type is selected as an event source. In the code generation process, a database table and a screen form are generated using the component type specification. If the event is handed at the client application level or application server level, then it will be triggered by the appropriate actions performed over a screen form generated for the selected component type. On the other hand, if the event is handled at the level of a database server, then it will be triggered when the appropriate operation is performed over the database table generated for the selected component type.A set of allowed values for an event type includes typical software events from various programming environments. Such event types include mouse events, keyboard events, and events over database tables and columns. A complete set of event types has more than 30 elements. Just as an illustration, only the most frequent event types are presented in Table 1.Starting from the specification of attributes in component types, the Application Generator tool generates input/output fields in screen forms. Controls such as text fields, drop-down lists, and radio buttons are supported. As described in the previous section, a designer may associate various events to attributes, i.e., form fields. For each event, exactly one function must be selected to define business logic that will be executed implicitly, upon the event occurrence. Besides, application-specific functionalities may be triggered on an explicit user request. Usually, screen form buttons are used to trigger execution of such functionalities. A concept named Button is introduced for specifying such a scenario at the level of PIMs. Specification of a button includes specifying values for the following attributes:•function;label; andXY position.Similar to events, each button references exactly one function defining business logic that will be executed when the button is pressed. Properties Label and XY Position contain display attributes of the button itself.A component type attribute may be associated with a function for calculating its value. Such attributes are named Calculated attributes. These attributes do not participate in the generation of database schema. However, they are used for displaying computed values in generated screen forms. For each calculated attribute exactly one form field is generated to display the computed value.A function used for an attribute calculation may have an arbitrary number of formal parameters. A return value domain of a function must match the attribute׳s domain. Other attributes in the same component type, as well as constants, may be passed as actual parameters. The DSL for function specification includes a broad set of operators and built-in functions, such as mathematical functions, string functions, and date–time functions. Therefore, a designer may use operators, built-in functions, and values of other attributes to specify complex expressions for attribute calculation. In addition, IIS⁎CFuncLang supports aggregate functions that perform a calculation over a set of values and return a single value. Aggregate functions, such as functions for summarizing and counting, are commonly used for displaying cumulative values in master-detail forms.In this section, we present the IIS⁎Case run-time environment extended with the concepts and tools presented in Section 2. A simplified illustration of a model created by IIS⁎Case is presented in the top part of Fig. 5. In this illustration, specifications are grouped by the role they play in a code generation process. The group on the left side consists of specifications created using Form Type and the related PIM concepts. These specifications are devoted to generic functionalities. The group on the right consists of specifications devoted to application-specific functionalities. These specifications are created by the Function concept. In the bottom part of the figure, a code generation process is illustrated. Specifications of both generic and application-specific functionalities are used by the generators embedded into IIS⁎Case. The process of code generation is described in detail in the rest of the section.Using the Form Type concept, a designer simultaneously specifies a future database schema, as well as functional and display properties of future transaction programs. These specifications are used by both SQL Generator and Application Generator. SQL Generator generates SQL scripts for implementing a database schema. Application Generator generates business applications, screen forms and transaction programs. Generated transaction programs implement typical business logic, mainly retrieve, create, update, and delete operations over database records.Application-specific functionalities are specified using the Function concept. For example, each calculated attribute is associated with exactly one function that is used for computing its value. If a function is associated with an event that is handled at the level of database server, then PL/SQL program code will be generated using the function as a source. In all other cases, intermediate code is generated. Generated PL/SQL triggers and functions are embedded into scripts generated by SQL Generator, and then deployed to a target database server together with other objects. In Listing 2 we present an example of an IIS⁎CFuncLang function, which validates the input argument. If the length of the input string is less than two, then the function reports an error. In Listing 3 we present a PL/SQL program code for a trigger generated from the function. The trigger comprises PL/SQL commands and represents an implementation of business logic defined by the function.During the generation phase, the intermediate code is generated for each function. At the end of this phase, just one file for all generated codes is created. This file and the interpreter are embedded into a generated business application. During the business application startup, an instance of the interpreter is created to execute intermediate code. Specifications of calculated attributes, events, and buttons determine when the interpreter instance will be invoked.A process of computing the value of a calculated attribute is illustrated in Fig. 6. For example, let us suppose that calculated attribute A1 in component type C1 is associated with function F1. Program code of the screen form corresponding to component C1 includes program code for invoking the interpreter instance. The interpreter instance is invoked each time the attribute value is to be displayed, for example, when a new record is loaded from a database. After invocation, the interpreter instance executes intermediate code generated for function F1 and returns a result to the screen form. The returned result is then displayed in a form field generated for attribute A1.Listing 2An example of a IIS⁎CFuncLang function.Generated PL/SQL program code.In this section we present IIS⁎CFuncLang, a language for detailed specification of functions introduced in Section 3. IIS⁎CFuncLang is a textual DSL that allows a designer to formally specify complex business logic in a detailed way. The designer uses algorithmic concepts, such as control-flow commands. Moreover, this language provides high-level commands specific for the domain of business applications. For example, commands performing mathematical operations over a set of values, and updating properties of screen forms, are included in the language. As functions created by IIS⁎CFuncLang may be used for computing attribute values, numerous predefined mathematical and string functions are also provided by the language. IIS⁎CFuncLang includes the following concepts:•declaration of variables and arrays;control flow statements;assignment statement;various predefined functions for mathematical calculations and string manipulation;definition of expressions that include variables, operators, constants, and functions;commands for executing operations over database tables;commands for modifying properties of screen forms;commands and operators for performing operations over a set of values;aborting transactions; andfunction invocations.For each IIS⁎CFuncLang specification it is to be checked if the specification is in accordance with grammar rules of the language. For that purpose, we have developed the IISCFuncLangAnalyzer tool. This tool is also a compiler for IIS⁎CFuncLang and currently provides the following:•syntax and semantic analysis of IIS⁎CFuncLang specifications;generation of intermediate program code; andgeneration of PL/SQL program code.Semantic analysis includes various semantic checks that are usually supported by language compilers. For example, if a variable is part of an expression then the semantic analyzer checks whether the variable is previously declared. Semantic analysis also performs the following tasks:•testing if a name of a variable is unique;checking whether a used variable has been previously declared;type checking;checking if an operator can be applied to operands;checking if conditions in the context of IF, WHILE, and REPEAT-UNTIL commands are of boolean data type; andchecking if a function call is valid. The number of actual and formal parameters must match, as well as the data type for these parameters.IIS⁎CFuncLang specifications are organized through functions. A function is a main unit analyzed by the IISCFuncLangAnalyzer tool. Specification of a function begins with FUNCTION keyword, and ends with END_FUNCTION keyword. Each function specification consists of the following sections:•function header;declaration of local variables; andfunction body.In the rest of this section we present a selected subset of IIS⁎CFuncLang concepts. Due to readability reasons, we do not describe in detail well-known concepts that may be found in other programming languages, such as arithmetic and boolean operators. Also, for the sake of simplicity, only several key grammar rules specified in ENBF notation are presented in Listing 4.Listing 4IIS⁎CFuncLang grammar rules.Each function header contains (i) a name; (ii) list of formal parameters; and (iii) return value type. A name of a function has to be unique and it is used as an identifier in other specifications. For each function, an arbitrary number of formal parameters may be defined. A specification of a formal parameter includes the following properties: (i) a name; (ii) domain representing data type of the formal parameter; (iii) default value; and (iv) type. A parameter type may have one of the following values: input (In), output (Out), and input/output (InOut). A default value for the type parameter is In. The meaning of these types is the same as in other, commonly used programming languages. An example specification of a simple function is given in Listing 5. The function includes one parameter for each type, i.e., In, Out and InOut.Listing 5A function example specified by IIS⁎CFuncLang.Each local variable declaration includes a unique name, data type, and an optional default value. For the specification of a variable׳s data type, the following concepts may be used:•domain name;array specification; andITERATOR keyword.In contrast to GPLs, IIS⁎CFuncLang does not provide a fixed set of built-in data types for declarations of local variables and formal parameters. For this purpose, a designer may use the Domain concept, which is included in the IIS⁎Case meta-model. Domains are specified separately from functions, using a form presented in Fig. 7. A domain definition is global, and the domain may be used for the specification of variables and parameters in any function.There are two types of domains: primitive and user-defined domains. Primitive domains correspond to the basic, built-in data types such as boolean, integer, floating-point numbers, etc. User-defined domains are derived from primitive or previously created user-defined domains. There are four derivation rules that may be applied to create a user-defined domain from an existing domain: (i) inheritance rule; (ii) tuple rule; (iii) set rule; and (iv) choice rule. A domain created by one of the aforementioned rules is called inherited, tuple, set, or choice domain. If a domain A is created by the inheritance rule from the domain B, then B is called parent domain. Such domain specification inherits all properties from the parent domain. If the inheritance rule is applied, then a domain specification is created by inheriting all properties from the parent domain. A tuple domain represents tuples of values where each value belongs to one of the existing domains. The tuple domain notion is closely related to the structure notion from 3GLs. On the other hand, a choice domain represents value where each value belongs to exactly one of the existing domains. The choice domain notion is closely related to the union notion from the C language. A set of domain represents a set of values where each value belongs to the parent domain. For readability reasons, in the rest of the section we will use a notion of a complex domain for all of the tuple, set, and choice domains. It should be also noted that recursive multiple applications of the aforementioned rules are allowed.Specification of a domain is platform-independent, since it is not related to any data type from a concrete programming language. However, the primitive domain concept is amended with a property named domain type. This property allows a designer to specify whether the values from the domain are integer, decimal, boolean, string, or date–time values. Domain type to a certain extent corresponds to the primitive data types from GPLs. For user-defined domains it is not required to specify this property since it can be derived from the parent domain. The domain type property enables semantic analysis, particularly type checking in expressions.Beside domains, an array specification may be used as a variable data type. An array specification consists of the following: (i) a specification of dimensions and (ii) a source domain. One-dimensional, as well as multidimensional arrays are supported. Also, any primitive or user-defined domain may be specified as a source domain.If ITERATOR keyword is specified as a variable data type, then the variable cannot be used in expressions. Such a variable may be used only as an iterator in commands for selecting records from database tables. A description of the Iterator concept is presented in Section 5.4. The concept is devoted to commands for executing operations over a database.IIS⁎CFuncLang provides numerous operators and predefined functions that may be used for a specification of complex expressions. The following operators may be used:•arithmetic operators (+, −, %, ⁎, \);boolean operators (AND, OR, XOR,=>, NOT);comparison operators(>,>=,<,<=);equivalence operators(==,!=);string concatenation operator(∥)and pattern matching operator (LIKE);set operators (UNION, INTERSECT, IN); andoperators for referencing members of arrays and tuples ([], .).All operators and the parentheses are introduced with the common meaning and priorities as in most GPLs. In addition to providing our language with typical arithmetic, string, comparison, and logical operators, we have also provided operators LIKE and IN, which are common to various forms of SQL. In this way, IIS⁎CFuncLang becomes more problem-oriented. For example, an operator for pattern matching may be useful for specifying functions aimed at validating values of input form fields.A broad set of predefined functions is provided by IIS⁎CFuncLang. These functions may be used for various purposes, such as mathematical calculations, getting current date and time, and finding the first occurrence of a string in another string. A complete set of predefined functions has more than 50 elements [10]. For illustrative purpose, just a few of them are presented in Table 2.The predefined function ExecuteQuery is aimed at loading data from a database. This function accepts one string argument containing an SQL query, and returns an iterator object. Iterators are local variables that allow the sequential processing of a collection of rows. An iterator references one row at a time. It can move to the next row of the collection using the FETCH-INTO command. Also, this command transfers the data of the current row into local variables. Local variables should be listed after the INTO keyword. The value of the first column in the current row is transferred to the first variable in the list, etc. The predefined function HasNext checks if the iterator is referencing the last row of the collection.The predefined function Execute_NonQuery enables executing create, modify, and delete operations over database records. This function accepts one string argument in SQL form, and returns a count of affected rows. Examples of these commands are presented in Listing 6. The function counts table rows, and also updates fields in the table.Listing 6A function that executes operations over a database.IIS⁎CFuncLang was designed to provide specification of application-specific functionalities of screen forms and transaction programs. Therefore, this language includes the UPDATE command that provides the following:•execution of actions over screen forms andsetting values of screen form properties.The set of allowed actions over screen forms includes the following: Reload, Save, Show, Delete, Hide, Next_Rec, Prev_Rec, Activate, Deactivate. For example, if Reload action is executed, then data are loaded from an appropriate database table. Data in form fields may be saved using Save action. When Show action is executed over a form, then the form will become visible to a user. Similarly, if Hide action is executed over a form, then the form will be hidden from a user.The UPDATE command allows for a modification of display and functional properties of screen forms, e.g., background color and visibility. Also, a designer may modify the display property of an individual form field. In Listing 7, we present examples of commands for modifying properties of screen forms. In this example, FACULTY is a component type, and the UPDATE command is applied over a screen form generated for the component type. Also, FACID is an attribute from the FACULTY component type. The UPDATE command is executed over a form field generated for the FACID attribute. For example, the first command in the listing causes data to be reloaded from a database, and displayed in the screen form generated for the FACULTY component type. When the last command in the listing is executed, then the form field for the attribute FACID gains focus.Listing 7Commands for updating screen forms.IIS⁎CFuncLang provides the SELECT command for performing mathematical computations over a set of values, such as calculating average value of set elements. Currently, the following functions are supported: {sum, min, max, count, avg}. Examples of such calculations are presented in Listing 8.Listing 8Performing mathematical calculations over sets.Various approaches and techniques have been introduced for the development of DSLs, such as embedding, interpreter, preprocessing, and compiler/application generator approaches [4]. From the implementation perspective, the most demanding solution is to develop a DSL compiler, which provides a high degree of freedom in defining appropriate notations, custom error reporting, etc. Therefore, this approach to DSL development is the most suitable from the end-user perspective. On the other hand, development efforts may be substantially reduced using compiler generators, e.g., ANTRL [22] and VisualLISA [23,24].For the IIS⁎CFuncLang implementation we have opted to use the source-to-intermediate code transformation approach. In order to transform IIS⁎CFuncLang specifications into intermediate code we have developed a compiler. For the execution of intermediate code we have built an interpreter. We have opted for an interpreter approach over other alternatives, such as embedding and preprocessing, as it offers a greater control over an execution environment, as well as an easier extension [4]. Although the interpreter development may seem burdening, for this rather small language it is not the case. In addition, extending the interpreter to provide debugging features has proved to be a very simple task. The development of the interpreter is discussed in the end of the section.The implementation of the IIS⁎CFuncLang compiler is automated by the ANTLR tool [22]. This tool uses an EBNF-like language for a grammar specification and generates program code for a parser in a selected programming language. Using ANTLR, it is allowed to amend grammar rules with semantic actions. The IIS⁎CFuncLang grammar rules are amended with semantic actions in order to generate an output structure that is in fact an abstract syntax tree (AST). An example of a grammar rule is given in Listing 9. The AST is later used for the semantic analysis and code generation. Both tasks are performed in a single tree traversal. Also, this structure is used by the language editor to display the structure of a function. The semantic analysis includes various checks, and we estimate its development cost as 1.5 man-weeks. This was the most challenging task in the compiler development process. A transformation of the AST into the intermediate code is straightforward. It is based on the well-known algorithms, which are described in [22]. Our estimation for the transformations development cost is 1 man-week. Additionally, the interpreter uses the stack evaluation model, which is based on simple and compact intermediate code that is easier to generate and interpret than three-address intermediate code. This type of evaluation model may cause performance problems, but that is not the case with our DSL, as discussed in Section 8.Listing 9An example of the IIS⁎CFuncLang grammar rule in ANTRLR.In some cases it is convenient to implement application-specific functionality at the DBMS level, instead of the application level. In order to support such a feature, we provide a generation of PL/SQL program code from IIS⁎CFuncLang specifications. The translation into PL/SQL is performed by traversing the AST. During the traversal, IIS⁎CFuncLang concepts are translated into equivalent PL/SQL concepts. This process is illustrated in Fig. 8. If no PL/SQL counterpart exists for a command, such as the command for updating form fields, an error will be reported. Our estimate for the development cost is 2 man-weeks. We intend to provide program code generation for other extensions of the SQL language, such is Transact-SQL (T-SQL) aimed to execute over Microsoft SQL Server DBMS. According to our research, for a majority of PL/SQL concepts (even if not for all) used in the developed transformations, there are equivalent T-SQL concepts. For example, the cursor concept is supported in both languages, as well as if, while, and for commands. We expect that the development efforts for other SQL extensions will be considerably reduced, since we intend to reuse program code of transformations into PL/SQL.One of the important tasks was to implement an interpreter aimed at execution of intermediate code using a common fetch–decode–execute cycle. The task is not demanding because the instruction set of the IIS⁎CFuncLang intermediate code is not extensive. Also, the interpreter uses the stack evaluation model that simplifies its implementation, as well as the code generation. The instruction set includes 51 instructions, where a majority of the instructions (more than forty) are rather simple. These simple instructions include elementary mathematical operations, instructions for loading variable values in memory for storing intermediate results, and the jump instruction. We used Java as a host language for implementing the interpreter, and a simple instruction is implemented by no more than 10 lines of program code. The implementation of the IIS⁎CFuncLang predefined functions is facilitated by the host language libraries. For example, all the mathematical predefined functions are implemented using the java.lang.Math package. The instructions for executing commands over a database are implemented using the jdbc library. Complete implementation of the interpreter in Java comprises 3000 lines of program code. Our estimation for the interpreter development effort is 2 man-weeks.For the verification and testing purposes we have employed our approach and language for the implementation of application-specific functionalities of a commercial information system. It is the information system for public schools of the Republic of Montenegro, named Montenegrin Education Information System (MEIS). Some of the authors of the paper are actively involved in its development. We have included the designers working on the development of MEIS into the implementation of test cases by IIS⁎CFuncLang. In the following section we present their assessments from the end-user perspective. In this section we present the application subsystem aimed at storing information about classes, students, subjects, and grades. Also, we describe representative examples of application-specific functionalities in this application subsystem, and its implementation by means of IIS⁎CFuncLang.In order to specify the application subsystem, a form type is created with the following component types:•CLASS(ClassId, ClassName),STUDENT(SID, Name, DateOfBirth, Status),ENROLLMENT(SubjectName), andGRADE(GradeValue, GradeDate).A student is described by more than 20 attributes. For simplicity reasons, we present here only a few of them. Using the SQL Generator tool, and the Application Generator tool, which are presented in Section 2, we have generated scripts for implementing a database schema, as well as screen forms of transaction programs.Classes, students, and subjects are presented in the same master-detail form according to the user-requirements. Grades for a subject are displayed in a separate window, which may be activated using a menu item. The generated screen form is presented in Fig. 9. This form performs typical create, retrieve, update and delete operations over database records.Beside typical operations over database records, the user requirements also included four application-specific functionalities:•A derived attribute that contains the number of full-time students that must be displayed for each class. The function that calculates this number is presented in Listing 10. It iterates over a set of students׳ statuses, and counts students whose status is equal to ‘FT’. The function is invoked each time a new record is loaded from a database.For expelled students (when status is equal to ‘EX’) the related form field must be displayed in a different color (we have selected red color in the appropriate screen form of the tool for these purposes). The function that sets the color of the form field is presented in Listing 11. It is invoked each time a new record is loaded into the form fields.A student date of birth and SID must match. For example, if a student is born on 10 November 2005, then SID must start with 1011005. When these two attributes do not match, an operation, such as insert or update, must be aborted. Program code of the function performing such a validation is given in Listing 12. The function uses the predefined functions for string and date manipulation. It is invoked when a record is inserted or updated.The latest grade must be displayed for each subject a student is enrolled in. The function that calculates this number is presented in Listing 13. This function uses the predefined functions for executing queries over a database. It is invoked each time a new record is loaded from a database.Counting full-time students.Setting properties of a form input field.Checking if a SID and a date of birth match.Calculating the latest grade for a subject.In order to collect practical experiences and analyze the main characteristics of our DSL, we tested it on several examples (e.g., the education study presented in the previous section). A number of studies addressed theoretical aspects of the development of DSLs [3,19,25,4,5]. In this section we discuss some IIS⁎CFuncLang quality characteristics, presented in [25]. One of our main goals was to analyze our language from the end-user perspective. However, we have not been able to conduct formal interviews with questionnaires, as our language does not have a sufficient number of trained users, and the results being obtained would not be statistically valid. On the other hand, we have included potential users into to the implementation of test cases, so as to present some of their testimonials. Among others, special attention is paid to the productivity and portability characteristics, since the main goal of our DSL is to improve them in the IS development process. In addition, we present results of the interpreter performance testing, as the execution performance is one of the main concerns when the interpreter approach is used for the implementation of a DSL. The discussion presented in this section will be used as a starting point for a formal evaluation of the language. In Section 11 we present our future plans in regard to completing the formal evaluation of IIS⁎CFuncLang.Functional suitability refers to the degree to which a DSL is fully developed. This means that all necessary functionalities are present in the DSL [25]. According to the case study presented in the previous section, we may claim that IIS⁎CFuncLang is almost functionally complete. Using the language we have been able to specify all application-specific functionalities from the study, except one. The application-specific functionality that connects to a remote web-service cannot be described by IIS⁎CFuncLang. We plan to include such a command in the future versions. On the other hand, our language provides 3GL concepts, a vast set of operators, functions, and data types that provide specification of various application-specific functionalities in detail using less abstract, but still platform-independent concepts.In order to analyze the usability characteristic we have conducted informal interviews with members of our faculty, IS designers involved in the development of MEIS, and students. All the persons being interviewed have some experience in 3GL programming, and are familiar with the SQL language. We have asked them to assess general usability of the language, and to point out at least one strong point, as well as one shortcoming. Overall, a usability of the IIS⁎CFuncLang has been described as positive. The interviewed persons have point out two major strong points in this regard. First of all, the language syntax has been characterized as relatively easy to learn because similar keywords and commands are present in languages they are familiar with. Second, they have emphasized the editor features to be very useful, especially the auto-complete feature. Apart from the aforementioned advantages, two major shortcomings have been stressed out. The lack of user documentation for the language is a major problem, even though it may be compensated by the editor features. Also, embedding SQL commands into strings is highlighted as a serious drawback because programs are less readable, and there is no syntax and semantic checking. We plan to improve these functionalities in the next versions. Additionally, we have asked IS designers to assess functional suitability taking into consideration their own practical experience. They have assessed functional suitability as overall satisfactory, with minor improvements needed for the future versions.Many approaches and tools, as discussed in [26,21,27,28], provide modeling of the generic functionalities at the level of PIMs. Code generation is also supported. In practice, this approach has proven to be very successful and widely used in the developments of ISs. It greatly improves productivity because developers are relieved of tedious and error-prone work of manually programming numerous screen forms. These screen forms perform typical create, retrieve, update, and delete operations over database tables. After code is generated, the developers concentrate on implementing application-specific functionalities in a target language. The main goal of our language is to provide a platform-independent specification and code generation for application-specific functionalities. If program code is generated, then customization of generated code may be avoided. In an ideal case, complete program code of an IS may be generated, so a need to employ developers, skillful in a target language is reduced. Consequently, this approach may have positive impact on the amount of human resources needed in the development of ISs. Additionally, application-specific functionalities are specified by designers using the DSL concepts, instead of the target language concepts. Since the DSL concepts are platform-independent, designers are released from the burden of dealing with specificities of a target platform. Also, this approach may reduce a need to include experts on the target platform in the development process.Reliability is a language property that helps produce reliable programs. Our language has precisely defined semantics and the IIS⁎CFuncLang compiler performs various semantic checks in order to protect users from making errors. The language editor, described in the following section, provides features, such as auto-complete, aimed at assisting users to write correct programs. By means of the editor, a user may execute IIS⁎CFuncLang programs to check for run-time errors. The execution environment of IIS⁎CFuncLang is based on the interpreter approach. If a run-time error occurs, then it is handled by the interpreter and an appropriate message is displayed.As defined in [25], extendability refers to the degree to which a language has mechanisms for adding new features. Our language has a low degree of extendability because it does not provide mechanisms to users for extending the language with new functionalities. On the other hand, the IIS⁎CFuncLang functionalities may be extended by the language implementors.Our approach and language are primarily aimed at complete specification of application-specific functionalities at the PIM level, as well as complete code generation for these functionalities. When an IS model does not include specification of application-specific functionalities, then appropriate program code for these functionalities cannot be generated. In this case, the only option is to write program code using a target language and to merge it with generated program code of generic functionalities. Such an approach has negative impact on portability. When an IS is transferred to a different programming environment, program code for generic functionalities can be generated from the IS model, while program code for application-specific functionalities has to be written in a new target language, once again. We have similar experience with the aforementioned MEIS system, while migrating several application systems to the J2EE platform. All application-specific functionalities are implemented all over again using Java as a target language. Our approach and language facilitate portability, since the emergence of a new platform or programming environment does not require customization of the generated program code. Both generic and application-specific functionalities are specified at the PIM level, and complete program code may be generated. Moreover, transfer to a new platform does not require implementation of a transformation algorithm for that new platform. IIS⁎CFuncLang specification is transformed into an intermediate code that is platform-independent. In our approach, migration to a new platform potentially requires only implementation of the interpreter in a new target language. This is not a difficult task as discussed in Section 6.Integrability measures how easily a DSL can be integrated with other languages and modeling tools. We have developed our language independently from any modeling tool. In the end of the development process we have integrated it with the IIS⁎Case tool to verify our approach in practice. Integration with IIS⁎Case was a fairly simple task that included the repository extension in order to store IIS⁎CFuncLang functions and generated intermediate code. Also, the interpreter is easily incorporated into program code generated by IIS⁎Case.In order to assess the performance of the interpreter we have created several test programs and compared the execution time with the execution time of equivalent programs written in Java. In Table 3we present performance ratio between the execution time of IIS⁎CFuncLang programs and the execution time of the equivalent Java programs. Testing is conducted on a 32-bit machine with 2GHz double-core processor.Our tests showed a substantial overhead when it comes to the execution of programs including long loops and intensive mathematical calculations. In this case, the execution of IIS⁎CFuncLang intermediate code is up to 10 times slower compared to the execution of equivalent Java programs. It turns out that fetching and decoding of instructions consume significantly more time than execution of these simple instructions, for example, addition. On the other hand, the execution time of programs that include database operations is not significantly slower than the execution time of equivalent Java programs. Overhead for the fetching and decoding of instructions is minor compared to the time consumed for communication with a database. We assess the performance as satisfactory, since IIS⁎CFuncLang was designed for application in the domain of database applications, not for intensive mathematical calculations.DSLs offer notations and constructs from the application domain in order to provide substantial gain in expressiveness and ease of use compared to GPLs [4]. Apart from notations and constructs, it is important to provide adequate editors for creating specifications with these constructs. Recently, much attention has been directed towards the development of environments for automated generation of editors. For example, starting from a language grammar, the XText framework generates both a language parser and an Eclipse-based editor [29].In order to provide a convenient way for creating IIS⁎CFuncLang specifications, we have developed an editor named Function Editor, which is integrated with the IIS⁎Case tool. It provides two ways of creating IIS⁎CFuncLang specifications: (i) guided, by means of Tree-based Editor and (ii) textual, by means of Text Editor. The first option is more suitable for less experienced users, not knowing the precise language syntax and therefore needing assistance to specify functions. The latter is more suitable for experienced users who know the language syntax well. The main screen form of Function Editor is presented in Fig. 10. Text Editor is presented in the central part of the figure, while Tree-based Editor is presented on the right side of the figure. These two editors are synchronized. Each change of a specification performed by Tree-based Editor is automatically displayed in Text Editor, and vice versa.Text Editor provides features, commonly supported by source code editors, such as syntax highlighting. The editor also provides common text processing commands such as cut, copy, paste, undo, and redo. In Tree-based Editor, IIS⁎CFuncLang functions are represented in a form of a tree. Each node of the tree represents a statement, while the root node represents a complete function body. A designer is allowed to insert, modify, and delete nodes, as well as to perform cut, paste, undo, and redo actions. Besides, Function Editor provides the following functionalities:•syntax and semantic analysis of IIS⁎CFuncLang specifications;error reporting;generation of intermediate code and PL/SQL program code;execution of intermediate code;step by step execution of intermediate code (debugging);setting breakpoints; andinspecting variables and their values during the run-time (watching).Function Editor tool incorporates the IISCFuncLangAnalyzer component and intermediate code interpreter. These components allow early validation and verification of IIS⁎CFuncLang specifications. Program code of a function is validated by the IISCFuncLangAnalyzer component. If an error occurs, the appropriate message will be displayed in the bottom part of the editor׳s main form. Otherwise, the intermediate code and PL/SQL program code are generated. The intermediate code may be executed by the interpreter. A result of the execution is also displayed in the bottom part of the editor׳s main form. The execution of the intermediate code may be halted by setting breakpoints. Also, it is possible to define a watch list to inspect values of variables. After the execution is halted, it may be resumed in “step by step” regime executing one statement in each step.For the development of the IIS⁎CFuncLang editor we have not used an environment for automated generation of editors, such as xText. Since IIS⁎CFuncLang, among others, includes algorithmic concepts we find it important to provide “advanced” features like debugger, context-sensitive auto-completion of program code, and custom error reporting, which are commonly supported by the 3GL program code editors. These features have positive impact on the usability from the end-user perspective. From the implementation point of view this approach is more expensive, but we have reused existing components to minimize the development costs. Text Editor is not developed from scratch, but the jEdit text editor is used as a foundation for its development. jEdit provides standard features of program code editors such as syntax highlighting, line numbering, indentation, bracket matching and comments coloring. Usage of this component significantly reduced the development efforts. The development of the context-sensitive auto-complete feature is also facilitated because it uses the AST structure provided by the language parser. In order to provide debugging features, the interpreter is extended with additional functionalities for pausing execution after an instruction is interpreted. The instruction set is amended with an instruction bearing additional debugging information, such as a line number from source code. In addition, the interpreter is extended to provide a list of run-time errors that occurred during the debugging. This may be particularly useful when executing operations over database tables, since run-time errors are common in this context. For example, an operation may fail if a constraint is not satisfied. Implementation of the interpreter extensions required minimal development effort. Integration of these debugging functionalities with the editor was a fairly simple task. The jEdit component provided operations like the line positioning and caret coloring. Environments and tools, such as xText and MetaEdit+ [30], provide support for the rapid development of editors. On the other hand, these tools typically did not provide any options for the model debugging at the time of the IIS⁎CFuncLang development. These are the main reasons why we have opted for this hybrid development of editor, where existing components are reused to provide standard operations, and additional development effort is invested to provide other nonstandard features such as customized debugger, or context-sensitive auto-complete.

@&#CONCLUSIONS@&#
