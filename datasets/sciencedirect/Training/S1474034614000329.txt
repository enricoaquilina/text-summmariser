@&#MAIN-TITLE@&#
Describing the design space of mechanical computational design synthesis problems

@&#HIGHLIGHTS@&#
We provide the concepts to formally model the design space of mechanical architectures.We created a Domain Specific Language to support the creation of such models.The approach allows to model scenario-based user requirements.The approach allows to model complex topological constraints.We present a methodology to incrementally create these design space models.

@&#KEYPHRASES@&#
Gearbox architecture,Design Space Exploration,Configuration design,Variant design,Computational design synthesis,Embodiment design,

@&#ABSTRACT@&#
An important challenge in mechatronic system design is to select a feasible system architecture that satisfies all requirements. This article describes (i) the necessary concepts that a system architect needs to be able to formally and declaratively describe the design space of mechanical design synthesis problems, thereby minimizing accidental complexity; (ii) how a Domain Specific Language based on the SysML modeling language and the Object Constraint Language (OCL) can be used to create this model of the design space; and (iii) an iterative process to come up with a formal model of the design space. This model describes the design space independent of any (knowledge of a) particular solving technology for the Design Space Exploration. Furthermore, the information in the model allows to select the most appropriate solving strategy for a particular design synthesis problem. The different concepts are illustrated on the example of automated synthesis of a gearbox.

@&#INTRODUCTION@&#
It is generally accepted that a large fraction of the cost of the design of new system is originating from design decisions that are made in the early stages of the design [1]. One important phase of these early stages is the embodiment or configuration design[2–5], in which the architecture of the new system is synthesized and generally is not altered anymore during the later stages of the design. Whereas a topology fixes the number and type of components in the architecture, and how they are connected, the architecture itself is only fully defined if the key properties (size, material choice, etc.) of the different components are also specified.For some design problems, the choice of an architecture is rather trivial, however, for other cases, many components can be combined in numerous ways and lots of properties have to be specified. An example of the latter is the choice of a particular architecture for realizing a gearbox. Fig. 1shows a schematic representation of one particular gearbox topology, in which shafts, gear wheels and clutches are combined in a particular way to satisfy a number of discrete gear ratios as specified by some user requirements. An even more challenging problem is to find the single architecture that can satisfy both the user requirements and at the same time maximize the value of the designed system. This design strategy is often called value centric or value-driven design[6].Computational Design Synthesis (CDS) employs computing power to synthesize a system architecture from a set of instances of well-defined component types with properties by connecting them together into a topological network. Indeed, exploring the typically huge design space of possible system architectures in an (semi-)automated way, can help the designer to come up with innovative architectures, or confirm the current beliefs and design practices.This paper shows how a system architect can model the design space of all possible architectures formally and declaratively using a Domain Specific Language based on the multi-view Systems Modeling Language (SysML, [7]) and the Object Constraint Language (OCL, [8]). By describing the design space of an architecture synthesis problem in a formal (meta-)model, it is possible to employ computer algorithms to explore it by generating architectures which are consistent with the meta-model.The declarative nature of the approach allows the system architect to describe the design space explicitly, without worrying about how to explore it. Indeed, the domain of constraint optimization is a vast engineering discipline in itself, and system architects should be able to discuss about the nature of their CDS problem without knowing all the intricacies of constraint optimization. In other words, our approach tries to minimize the accidental complexity [9] for the system architect. This is illustrated in Fig. 2. Moreover, a declarative model-based representation is a first step to avoiding design fixation[10] since it encourages designers to think about what combinations of components are possible, and not how to come up with a sensible architecture.Creating a formal model of the design space of real-life synthesis problems is not an easy task. This paper also describes an iterative process and the necessary tool support that can be used to construct a model which is an accurate representation of the design space.The remainder of this paper is organized as follows. Section 2 shortly describes some related research in the area of computational design synthesis. Next, Section 3 describes the motivating example of gearbox synthesis which is used to illustrate the methodology throughout the remainder of this text. Section 4 describes the necessary concepts to be able to describe the design space of a mechatronic synthesis problem and how those concepts can be represented in the Domain Specific Language. Section 5 describes an iterative process and tooling that can be used to create declarative design space models for specific synthesis problems. Section 6 compares our approach to related work. Finally, the last Section presents some conclusions and pointers for future research.Wielinga and Schreiber [4] provide a classification of Design Space Exploration (DSE) problems based on three aspects, in casu (i) the characteristics of the components which are involved, (ii) how these components can be assembled, and (iii) the characteristics of the constraints on the mathematical variables. Depending on the value of these aspects, different task categories are identified. The complexity of the configuration design problem depends on the task category. A lot of research in the area of DSE deals with either parametric optimization [11,12] or topological optimization [13] only, or builds an system architecture based on a fixed skeleton [14–16]. The current paper presents an approach that is applicable to represent the design space of the most complex configuration design problem according to Wielinga: (i) component types are parameterised and can be instantiated multiple times in the architecture, (ii) the assembly of the components is free, but can be and typically is subject to constraints and (iii) the constraints are only globally applicable. Next to Wielinga’s criteria, one could consider an extra criterium: whether optimization is necessary amongst all feasible solutions. S-Comma [17] and Microsoft Formula [18] are both environments that allow the modeling of Constraint Satisfaction Problems in a object-oriented and model-based way, without having support for optimization.Computational design synthesis is not the only area in which Design Space Exploration techniques can be applied. One subdomain in mechatronics in which a lot of research on DSE is performed is the optimal deployment of software on a distributed set of ECUs [14], or more generally the (deployment) design of the embedded systems [15]. Others apply the techniques to the configuration of software product lines [16], design of electrical circuits [19]. [5] provides an overview. Our use case focuses on optimal synthesis of mechanical architectures [20–22]. Typical for this area is that there can be a lot of complex constraints on the assembly of components, and that the evaluation of some constraints requires an analysis (simulation) of the (dynamic) behavior of the system under design in a particular context. Often, these analyses need to be executed in custom simulation tools.DSE techniques can be applied during different phases of the design. Research areas range from the conceptual design phase where typically functional modeling concepts are used to describe the design space [23–31], over the configuration design phase (our research, and others), into the detailed design phase, where typically only parametric optimization is applied [11,12].A lot of research on computational design synthesis does not separate the representation of the DSE problem from its solving method, thereby representing the design space only implicitly and often non-declaratively. For instance, the research on the use of attributed graph grammars [32,20,33] represents the design space in a model-based but non-declarative way by using a graph to represent a particular system architecture, combined with some rules that transform one graph into another. However, it is not always clear how these rules emerge, what set of rules is sufficient to cover the whole design space, and if the resulting architecture of applying rule is consistent with all the constraints that are applicable to the synthesis problem. Knowledge-based engineering [34] methods try to support the designer by automating the steps that an expert designer would follow. Whereas this might help “junior” designers, it is unlikely that these techniques come up with innovative solutions. This effect is sometimes called design fixation[10].1One could also consider that this effect occurs if the rules of the graph grammar are not “sufficient” to generate new ideas.1We try to extend the approaches used by [16,35] to full mechanical configuration design, advocating the separation of representation and solving and using a model-based approach for the representation of the design space that minimizes accidental complexity for the system architect and is based as much as possible on existing languages without re-inventing the wheel, in order to foster industrial adoption.The motivating example used throughout this paper is the mechanical design of a gearbox as shown in Fig. 3. Typically gearboxes are manufactured by so-called TIER-1 suppliers to be used in a variety of OEM contexts, each of them coming with similar requirements. This similarity can be expressed by making the requirements parametric. For instance, the location of the ingoing and outgoing shaft will vary, depending on the specific vehicle the gearbox is designed for. Other varying requirements are the size of the bounding box, the maximal load and speed profiles that need to be dealth with on ingoing and outgoing shaft, the number of forward and reverse gears that need to be realized, their ratios, etc. In this paper, the components that can be used to populate the gearbox architecture are gear wheels, shafts and clutches. We assume that the addition of other components such as bearings will not significantly influence the optimal system architecture.When synthesizing the system architecture, several architectural constraints need to be taken into account in order to obtain a consistent architecture. Some of these are rather obvious, e.g. a gear wheel cannot be directly connected to a clutch, others are far less trivial. An example of the latter is the constraint that one should avoid tying the components together in such a way that a “mechanical loop” is created. An example of a gearbox topology that is infeasible due to the presence of a mechanical loop is shown in Fig. 4. Some user requirements imply the use of analyses (simulations) to check the (dynamic) behavior of the gearbox-under-design. Nowadays, the energetic efficiency of systems is an important requirement. Typically, a simulation is conducted to reveal whether a particular gearbox architecture is efficient enough with respect to energy consumption requirements. In such a simulation, the dynamic behavior of a particular gearbox architecture is modeled as a set of differential algebraic equations in dedicated software packages such as The Mathworks Simscape®2http://www.mathworks.nl/products/simscape/.2environment, LMS Imagine.Lab AMESim®,3http://www.lmsintl.com/LMS-Imagine-Lab-AMESim.3or tools based on the Modelica® modeling language such as Dymola®4http://www.3ds.com/products/catia/portfolio/dymola.4and Openmodelica.5https://openmodelica.ida.liu.se.5Last but not least, the gearbox should be as cheap as possible.The next section elaborates on the above aspects, classifying them explicitly into different criteria, and showing how they can be represented to achieve a formal declarative model of the design space, independent of a particular solving algorithm.This section discusses the different concepts we need to represent a design space for the synthesis of system architectures of mechanical systems, and how we choose to represent these concepts in a modeling language. The selection criteria for this language are.•The (combination of) language(s) should be able to represent all aspects of the design space in a declarative, formal and hence unambiguous way.The language should minimize the accidental complexity for the system architect when modeling the design space. This means that a system architect is able to formulate the different user requirements, architectural constraints an value criteria in a “natural” way, without being an expert in optimization theory and knowing all the intricacies of specific constraint programming languages.A maximal reuse of existing modeling languages will be beneficial for the adoption of the approach and reduce custom tooling development.Note that these criteria can be “conflicting”. For instance, a custom language developed from scratch might be able to reduce the accidental complexity to a maximum, but its customness will hinder adoption.We have chosen to combine the SysML modeling language [7], together with the Object Constraint Language (OCL, [8]), and extended with a custom profile [36] for computational design synthesis into a Domain Specific Language (DSL) that suits best the requirements above. The SysML modeling language adheres to the principles of multi-view modeling. This allows to express different parts of the design space model in different SysML diagrams, thereby reducing the modeling complexity, yet ensuring a consistent model.The following sections describe how to represent the three main aspects of the representation of the design space as shown in the “problem view” on Fig. 2, adhering to the above criteria. Section 4.1 deals with representing limitations on the architecture imposed either by the user (“user requirements” in Fig. 2) or by physical limitations on how different components can be tied together (“architectural constraints” in Fig. 2). Section 4.2 describes how we can represent “value criteria” for system architectures, such that we can express an ordering amongst the feasible architectures. Both sections illustrate the different concepts with an example from gearbox synthesis.In this section, we classify the constraints into some categories, and describe how constraints from a particular category can be represented in our Domain Specific Language. Firstly, we distinguish between white box constraints on the one hand, and black box constraints or user requirements on the other. We use the term white box constraints in this work to denote constraints that are related to how components of the machine can be combined together, i.e. looking at the machine from a white box perspective. These can be hard physical constraints (architectural constraints, Section 4.1.1), but also soft guidelines on how to glue components together. The latter are often called design rules, and described in Section 4.1.2.User requirements specify constraints that are to be considered as required properties of the machine as a whole (i.e. considering the machine as a black box). Some of these user requirements are merely requirements on emergent properties of the system-under-design, for instance its weight, size, etc. We call this type of constraints static user requirements and show some examples and how to represent them in Section 4.1.3. Other user requirements are more “complex” in the sense that they typically require the evaluation of an analysis scenario, in which the system-under-design is put into a particular context. We call these scenario based user requirements (Section 4.1.4).Architectural constraints are typically shown in a SysML Block Definition Diagram (BDD). Physical component types are represented by SysML Blocks, and the system that is being designed is represented using a block stereotyped with the «System-Under-Design» stereotype. Properties of the blocks are represented by SysML properties. A very simplified example of a part of the design space model of the gearbox, that will be used throughout the remainder of this section, is shown in Fig. 5.Architectural constraints can further be divided into.•Topological design constraints. Topological design constraints are limiting which component types can be connected together, how they can be connected together, and how many of them can be connected together. Fig. 5illustrates how an association is used to show that a clutch physically connects exactly 2 shafts together, and that each shaft can be attached to 0, 1 or 2 clutches. Similarly, the BDD also illustrates that you cannot attach a set of 2 connected gear wheels (denoted as GearWheelCombo in Fig. 5) directly to a clutch by a lack of assocation between the two. The composite association (indicated with the filled diamond) is used to denote physical decomposition. However, it is well known that only a limited set of constraints can be expressed graphically using associations in a BDD.6The network structure constraints in [13] show how a custom graphical concrete syntax can be used to represent more constraints, but not all of them.6For instance, the fact that gearboxes should not contain “mechanical loops” (cfr. Fig. 4) which we explained in Section 3 is a constraint which cannot be expressed using the graphical primitives of the BDD. We use OCL to express these additional well-formedness rules on the design space. SysML allows the use of OCL constraint via its Constraint element,7Reused from the UML language.7that allows to define constraints as “opaque expressions” in a language of choice. As such, the green squares in Fig. 5 that are annotated with an {?} icon illustrate the fact that a gearbox should have exactly one ingoing and one outgoing shaft8Note that these constraints are not necessarily valid in the case of the synthesis of gearboxes to be used in hybrid drivelines.8and that they should be different. The object-oriented character of the OCL language makes that the accidental complexity of formulating such constraints in OCL is a lot smaller than formulating it in a mathematical constraint language such as minizinc [37]. As an example, we noticed that expressing the different constraints for the gearbox design space required approximately 10 times less code than a similar representation of the design space in minizinc. Moreover, the designer did not have to worry about creating workarounds for minizinc specific limitations such as the fixed size requirement for arrays, which seriously sped up the formulation of constraints. To the best of our knowledge, no other computational design synthesis approach currently allows to define complex topological constraints in an object-oriented and declarative way.Mixed design constraints. Next to the constraints that validate whether the topology that is constructed can be built together in reality, other constraints depend on both the given topology and the value of the component properties. For instance, a gear wheel can realise a desired ratio, but it could collide with another shaft from the gearbox. These constraints are typically called geometric interference constraints. Our approach uses OCL to represent mixed design constraints. Fig. 6shows a naive way of expressing that shafts should not collide with clutches. Several things can be noted here. First, we can see that the OCL constraints are expressed in plain text. Indeed, the tooling that we use allows to combine both textual and concrete graphical syntaxes, allowing to choose the most appropriate one for the problem at hand. Second, this approach exploits the capability of OCL of defining helper operations, which can be very handy when constraints become a little more complex. Thirdly, neither the square, nor the square root operator are part of the OCL “standard library”, therefore workaround expressions such as x*x are used in the code. This means that expressing complex mathematical constraints will require the definition of new mathematical operators. More generally, OCL currently lacks standard a mathematical library.Apart from the “hard” architectural constraints that need to be satisfied by the system architecture, designers typically also use design rules. These are helpful to reduce the size of the design space, although this comes with the risk of over-constraining the design space and hence design rules need to be used with care. Also, they are typically hard to elicit from the designers’ heads, which is often referred to as tacit knowledge[38]. These two aspects also illustrate the requirement for an incremental process of specifying the design space in which the designer can experiment with the influence of particular constraints. How to provide support for such an incremental process is described in Section 5.One example of a design rule in the case of a gearbox is a lower and upper boundary on the total number of connections or components in a particular gearbox. Design rules can be represented either graphically in a block definition diagram, or using OCL statements.While architectural constraints and design rules consider the machine as a white box and as such are valid for each new design, user requirements consider the machine as a black box and will vary along the different designs. Hence, these constraints typically contain some parameters that need to be set for each new design. This section deals with static user requirements, by which we mean that the constraints can be evaluated without submitting the system-under-design to an analysis scenario in a particular context.A simple example of a static user requirement is that an OEM will impose a certain bounding box in which the gearbox should fit. This bounding box depends on both the topology and the sizing of the chosen component instances. To represent such static user requirements, we are using the notion of derived properties. In Fig. 5, the derived nature of properties is shown by prefixing their name with a slash (/). In this case, the «system-under-design» has 2 properties. First, the dimension property is declared as derived and read-only, and has an OCL constraint that expresses how its value can be derived from the properties of the individual building blocks. Second, the requiredBoundingBox property is non-derived and stereotyped as «requiredProperty».9The SysML tool we use does currently not allow to visualize this stereotype in a diagram though.9This stereotype indicates that its value should not be set by the solver, but this should be filled in by the system architect for each separate gearbox design. Finally, another OCL constraint, stereotyped as «staticUserRequirement» encodes the user requirement thatdimension<requiredBoundingBox.A more complex example of a static user requirement is the number of gears that need to be realized by the system-under-design. For instance, for a particular new gearbox, the OEM requires that the gearbox has 4 forward gears, and 3 reverse gears. To represent this requirement, we need to compare the number of available paths from the ingoing to the outgoing shaft, excluding loops, with the number of gears required by the stakeholders. To this end, we use OCL language elements that allow to express iterations and recursion.Scenario based user requirements express user requirements that can only be formulated by putting the «system-under-design» in a particular analysis context and submitting it to a particular analysis scenario. The example in Fig. 7shows an example of a requirement on the dynamic behavior of the «system-under-design». In order to represent scenario based user requirements, several things are necessary:•A model of the test context. Our approach uses the SysML Internal Block diagram for this model. A simplified example for the scenario based user requirement of the gearbox is shown in Fig. 8. SysML Context Specific Properties are used to assign values to the context blocks, for instance to assign a particular volume to the fuel tank (not shown in the IBD of Fig. 8).A behavioral model of the different components of which the machine is constituted, and the components in the analysis context. To this end, we created a «component» stereotype that has a libraryElement property which links a component to one or multiple simulation library models. This stereotype is also applied to the components of the gearbox, as can be seen in Fig. 5).A scenario based user requirement is represented by a block, stereotyped by the «scenarioBasedUserRequirement» stereotype. Typically, this block will have some derived properties, and will be associated with an OCL constraint. An example for the above sketched scenario based user requirement is shown in Fig. 9. In this case, the EnergyEfficiencyRequirement block links to a particular analysis context ClassicalVehicleContext, shown in Fig. 8). We express that the consumed fuel during the simulation should not exceed 10l by adding the consumedFuel derived property to the EnergyEfficiencyRequirement block, and assign it the «SimulationResult» stereotype. The requirement itself is then represented via the OCL constraint self.consumedFuel<10.0.Whereas the previous section described how to express the various constraints that limit the design space, it does not show how to represent ordering criteria for the different architectures that are part of the design space.In accordance with [6], we call these ordering criteria value criteria. As with the different constraint types, we can make a distinction between static and scenario based value criteria. Minimizing the total weight of the components, which happens to be also a good approximation of the cost in this use case, is an example of a static value criterium. An example of a dynamic criterium could be created by a slight modification of the scenario based user requirement. Instead of specifying that the amount of fuel consumed during a particular test scenario should be less than x liters, we could specify that the less fuel consumed, the better.Since neither SysML nor OCL natively offer language elements for expressing value criteria, we choose to represent these using a stereotyped version of the (UML) Constraint element, in casu the «ValueCriterium» stereotype. The specification of the constraint element itself happens via an OpaqueExpression, which will typically be a mathematical expression of derived properties. The context of this constraint should be set to the system-under-design. A simple example for a static value criterium is shown in Fig. 5. In this case, the expression is fairly simple: the derived property weight should be minimized. Note that in this way, multiple value criteria can be linked to the system-under-design, such that Pareto analyses can be conducted if appropriate.As stated earlier in this paper, it is not a trivial task to come up with the complete and accurate set of constraints and value criteria that form the design space for complex real-life mechanical synthesis. This section describes the methodology and tooling that we use in order to incrementally and iteratively build an accurate design space model for mechatronic design synthesis.One aspect of providing support for this task is by ensuring that the design space model is consistent with the syntax and semantics of SysML and OCL, and the additional semantics of the concepts defined in the custom profile for CDS. For instance, blocks that are stereotyped with «system-under-design» should only have properties that are either.•Derived, read-only and have the derivation expression set.Stereotyped with «required».Stereotyped with «component».Therefore, next to the consistency rules enforced by the SysML/OCL tools, our custom profile contains some OCL rules which are enforced upon modelers.On the other hand, having a model of the design space that is consistent with the meta-model of the custom DSL, does not imply yet that this model is an accurate representation of our design space. Moreover, experience learns that design space models will always be built incrementally and never be “first time right”. One approach to verify the accurateness of the design space model is to apply a “test driven approach”: creating both feasible and infeasible system architectures, which are instances of the design space model, and checking whether these architectures are consistent with the given design space model. As an example, consider the formulation of the “Required number of Gears” user requirement. Formally modeling this requirement requires building OCL derivation rules that iteratively construct the list of all possible “paths” from ingoing to outgoing shaft in the gearbox, and compare that list to the required number of paths. In order verify if all the OCL statements necessary for this requirement are correctly formulated, one can create a number of gearbox topologies with known properties, and check if these topologies are consistent with the design space model.Unfortunately, most UML/SysML tools are rather limited in their capabilities of creating domain specific instance models. Therefore, we chose a different path here, illustrated in Fig. 10. Indeed, the Eclipse Modeling Framework (EMF [39]) offers a way to easily create the tooling for creating instances of the static part of a particular design space model. Therefore, as shown in Fig. 10 we transform a part of our SysML model of the design space into an ecore meta-model that is fully equivalent with our SysML design space model. Then, by creating a basic graphical concrete syntax for that meta-model, the designer can quickly create specific gearbox architectures (denoted as “Gearbox Model” in Fig. 10) and use those to incrementally verify particular constraints in the design space model. An example of how this was realized for validating the gearbox design space model, is shown in Fig. 11.

@&#CONCLUSIONS@&#
An important first step in solving computational design synthesis problems for mechatronic systems is the representation of the design space in a formal, model-based and declarative manner. In this way, system architects can model the design space without having to be an expert in optimization theory. This paper presented the necessary concepts for describing the design space of mechatronic synthesis problems, and showed how a custom Domain Specific Language, based on the SysML and OCL, can be used to create such models. The different SysML diagrams are used to illustrate different aspects of the design space model. The design space model itself can also be considered as a meta-model, to which all feasible system architectures should be consistent with. Furthermore, an approach was described on how to create a consistent and accurate model of the design space incrementally.This work has mainly focused on describing the design space of mechanical synthesis problems. Future work will extend these models to take into account other disciplines such as control engineering. These design space models, together with an algorithm that can find the optimal solution within the design space, are the two main ingredients of the “mechatronic compiler” [46]. A second point of attention is the explicit representation of uncertainty in the different design space models, such that it can be taken into account during the decision making process. Finally, this research will also be extended to the earlier conceptual design phase, in which different concepts, such as functional modeling, are also necessary to represent the design space.