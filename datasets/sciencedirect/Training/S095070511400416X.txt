@&#MAIN-TITLE@&#
A bi-population EDA for solving the no-idle permutation flow-shop scheduling problem with the total tardiness criterion

@&#HIGHLIGHTS@&#
A novel bi-population EDA for NIFPSP.Suitable adjusting mechanisms for adjusting probability models.Insertion based local search procedure to enhance exploitation.Better results obtained than those by the existing meta-heuristics.

@&#KEYPHRASES@&#
No-idle permutation flow-shop scheduling problem,Total tardiness,Estimation of distribution algorithm,Bi-population,Probability model,

@&#ABSTRACT@&#
In this paper, an effective bi-population estimation of distribution algorithm (BEDA) is presented to solve the no-idle permutation flow-shop scheduling problem (NIPFSP) with the total tardiness criterion. To enhance the search efficiency and maintain the diversity of the whole population, two sub-populations are used in the BEDA. The two sub-populations are generated by sampling the probability models that are updated differently for the global exploration and the local exploitation, respectively. Meanwhile, the two sub-populations collaborate with each other to share search information for adjusting the models. To well adjust the models for generating promising solutions, the global probability model is updated during the evolution with the superior population and the local probability model is updated with the best solution that has been explored. To further enhance exploitation in the promising region, the insertion operator is used iteratively as the local search procedure. To investigate the influence of parameter setting, numerical study based on the Taguchi method of design-of-experiment is carried out. The effectiveness of the bi-population strategy and local search procedure is shown by numerical comparisons, and the comparisons with the recently published algorithms by using the benchmarking instances also demonstrate the effectiveness of the proposed BEDA.

@&#INTRODUCTION@&#
As a well-known combinational optimization problem, the permutation flow-shop scheduling problem (PFSP) [1] has been studied by many researchers [2–7] due to its academic and practical significance. In some real production environments, e.g. foundry production [8] and fiber glass processing [9], the idle running of machines is not allowed for certain economic or technical reasons. Thus, the no-idle version of the PFSP (NIPFSP) comes into being, which has been proved to be NP-hard [10]. Note that the no-idle condition is different from the no-wait case. For the no-idle case, each machine has to process jobs without any interruption from the start of processing the first job to the completion of the last job. For the no-wait case, the processing of all operations of each job should be done without any interruption either on or between any two consecutive machines. Compared with the traditional PFSP, research work about the NIPFSP is relatively limited. Relevant results in this area include the following.Adiri and Pohoryles [11] first developed a polynomial time algorithm for the two-machine NIPFSP with the total completion time criterion. Vachajitpan [12] proposed a linear programming model as well as a branch and bound algorithm for the NIPFSP with the makespan criterion. Kamburowski [13] provided a better insight into the NIPFSP by identifying a simple network representation of the makespan criterion. In [14], a heuristic was presented by modeling the NIPFSP as a traveling salesman problem (TSP). Kalczynski and Kamburowski [9] developed a constructive heuristic, which was more effective than the TSP-based approach [14] and the Nawaz–Enscore–Ham (NEH) heuristic [15]. In [16], Baraz and Mosheiov introduced an efficient O(n2) greedy algorithm consisting of a sequence construction and an improvement procedure. As for meta-heuristics, a discrete differential evolution (DDE) algorithm [17] and a discrete particle swarm optimization (DPSO) algorithm [18] were proposed for the NIPFSP with the makespan criterion, where a speed-up scheme for the insertion neighborhood was presented to reduce the computational complexity from O(mn3) to O(mn2). Later, Deng and Gu [19] proposed a hybrid DDE algorithm and Tasgetiren et al. [20] presented a variable iterated greedy algorithm with differential evolution for the NIPFSP with makespan criterion. Taking the due dates of jobs into account, it is of significance to real life situations by considering the minimization of the total tardiness [21,22] so as to satisfy the external due dates committed to the customers. Compared to the research work on makespan criterion, the related work about the total tardiness criterion is rather rare. In [21], some versions of differential evolution (DE) algorithms were developed; Very recently, a discrete artificial bee colony (DABC) algorithm [22] were developed. Clearly, it is very important to develop new effective and efficient solution approaches for solving the NIPFSP with total tardiness criterion.As a population-based evolutionary algorithm, estimation of distribution algorithm (EDA) [23] has gained increasing attention during recent years. Instead of using crossover and mutation operators of genetic algorithm (GA), the EDA produces offspring implicitly by using a probability model according to the knowledge of the obtained solution space during the search process. The EDA is of good ability in global exploration and has been applied to solve some types of scheduling problems, including flow-shop scheduling [24], job-shop scheduling [25], nurse scheduling [26], and resource-constrained project scheduling [27]. However, to the best of our knowledge, there is no reported work about the EDA for solving the NIPFSP. Inspired by the success of the EDA in solving scheduling problems, we will develop an effective bi-population EDA (BEDA) in this paper to solve the NIPFSP with the total tardiness criterion. To solve the problem effectively, two sub-populations are generated by sampling different probability models, i.e., the global model updated with the superior population, and the local probability model updated with the best solution that has been explored. In such a way, the search efficiency can be enhanced and the diversity of the whole population can be maintained to some extent. In addition to the sampling process based on the probability models, the insertion operator is adopted to further improve the local exploitation ability. To reflect the influence of parameter setting, we carry out the study by using the Taguchi method of design-of-experiment (DOE) [28]. The effectiveness of the bi-population strategy and local search procedure is experimentally demonstrated, and the comparisons between the BEDA and the very recent DABC and GA [22] are also presented to show the effectiveness of the BEDA.The remainder of the paper is organized as follows: In Section 2, the NIPFSP is described. In Section 3, the BEDA for the NIPFSP is presented in details. In Section 4, the influence of parameter setting is investigated, and the numerical results and comparisons are provided. Finally, we end the paper with some conclusions and future work in Section 5.nthe number of jobs to be processedmthe number of machinesJ{J1, J2,…,Jn}: the job set to be processedM{M1, M2,…,Mm}: the machine set{Oj,1, Oj,2,…,Oj,m}the operation sequence of job Jjtj,ithe processing time of job Jjon machine Midjdue date of job Jjπ=[π(1),π(2),…,π(n)]a sequence of all the job numbersCjthe completion time of job JjTTDjtardiness of job JjTTDtotal tardiness of a scheduleThe NIPFSP is described as follows: a job set J={J1, J2,…,Jn} is processed on m machines M={M1, M2,…,Mm}. Each job consists of m operations and the ith operation can only be performed on machine Mi. Each operation should be completed without interruption once it is started. Suppose all the jobs are available at time zero. Jobs are processed on each machine with the same order. Each machine can process at most one job at a time and each job can be processed on only one machine at a time. No idle time between any operations on the machines is permitted.For the NIPFSP with the total tardiness criterion, it needs to determine the optimal processing order of all the jobs at each machine to minimize the total tardiness. For a schedule π=[π(1),π(2),…,π(n)], let σk=[π(1),π(2),…,π(k)] denote a partial sequence of π, the total tardiness TTD can be calculated as follows [22]:(1)Dif(σ1,i,i+1)=tπ(1),ii=1,…,m-1(2)Dif(σk,i,i+1)=max{Dif(σk-1,i,i+1)-tπ(k),i,0}+tπ(k),i+1k=2,…,n;i=1,…,m-1(3)Cπ(n)=∑i=1m-1Dif(σn,i,i+1)+∑k=1ntπ(k),1(4)Cπ(k)=Cπ(k+1)-tπ(k),mk=1,…,n-1(5)TTDπ(k)=max{Cπ(k)-dπ(k),0}k=1,…,n(6)TTD=∑k=1nTTDπ(k)where Dif(σk,i, i+1) is the minimum difference between the completion time of the last job of σkon machine Miand Mi+1.In this section, a bi-population EDA (BEDA) will be presented to solve the NIPFSP with the total tardiness criterion. First, the basic EDA will be introduced. Then, the BEDA will be introduced in details, including initialization, probability model and updating mechanism, and local search. Finally, the flowchart of BEDA will be illustrated.Different from other well-known population-based meta-heuristics (e.g. GA), the EDA produces offspring in an implicit way by sampling the probability model, instead of using the crossover and mutation operators. At the beginning of each generation, the superior sub-population is determined and the obtained best solution is updated. Then, the probability model is updated based on the superior sub-population and the offspring is generated by sampling the probability model. The EDA repeats the above process until a stopping condition is met.The general framework of the EDA is illustrated in Fig. 1[25,29].From the framework, it can be seen that the probability model plays an important role in the EDA. Therefore, it should be well designed according to the characteristics of the considered problem. However, the EDA is often good at exploration but weak at exploitation relatively. An effective EDA should well balance the exploration and exploitation.In the initialization phase, a total of P_Size individuals will be generated. Each individual denotes a solution of the NIPFSP, which is represented by a sequence of all the job numbers, i.e., π=[π(1),π(2),…,π(n)]. For example, a solution π=[3,2,1,4] represents that job 3 is scheduled first, and then job 2 and job 1, and finally job 4 is the last one to be scheduled. To guarantee an initial population with certain quality and diversity, the population is initialized as follows: two solutions are constructed by the NEH heuristic [8] and the NEHEDD heuristic [30] respectively, and the rest solutions are generated randomly.To calculate the total tardiness as the schedule objective value, the speed-up method for insertion neighborhood [21,22] is employed. The idea of this method comes from the speed-up scheme proposed for the PFSP with makespan criterion. By means of recording some useful information about the partial sequences in advance, the method can reduce the computational complexity in evaluating the whole insertion neighborhood of a permutation from O(mn3) to O(mn2). For more details about the speed-up method, please refer to the literature [22].Usually, all individuals in the EDA are generated by sampling a single probability matrix. Differently, the BEDA contains two sub-populations (denoted as P1 and P2), which are generated by sampling a global probability matrixA1 and a local probability matrixA2, respectively. The element pkij(l) of probability matrixAk(k=1,2) represents the probability that job Jjappears before or in position i of the sequence at the l-th generation. To ensure that the whole solution space can be sampled uniformly, pkijis initialized as pkij=1/n for all i and j. To generate individuals according to probability matrixAk, the following steps are implemented.•Step 1. Set i=1.Step 2. Select a job for position i. Job Jjis selected with probability pkij.Step 3. If job Jjis selected, set the jth column of matrixAkto 0 and normalize the rows to ensure that the sum of each row is 1.Step 4. Set i=i+1 and go to step 2 until all the jobs have been selected.With the above steps, all individuals of the two sub-populations can be generated. The population sizes of P1 and P2 (denoted as P1_Size and P2_Size, respectively) are set as Eqs. (7) and (8), respectively.(7)P1_Size=(1-γ%)×P_Size(8)P2_Size=γ%×P_Sizewhere γ∈(0,100) is a parameter to control the rate of the two sub-populations. Obviously, when γ=0 or 100, the whole population is generated by sampling only one matrix and the BEDA is converted to a single-population based EDA. To share information, the two sub-populations collaborate with each other. To be specific, sub-populations P1 and P2 will be merged as a whole one with P_Size individuals. Then, the best SP_Size individuals are selected to construct a superior population for adjusting the probability matrixes, where SP_Size=η%×P_Size.In the BEDA, probability matrixesA1 andA2 are updated in different ways as Eqs. (9) and (10), respectively. In specific, the global probability matrixA1 is updated according to the superior population (stress global exploration), while the local probability matrixA2 is updated according to the best solution that has been explored (stress local exploitation). Thus, γ should be set carefully to balance the exploration and exploitation abilities.(9)pij1(l+1)=(1-α(l))pij1(l)+α(l)i×SP_Size∑k=1SP_SizeIijk(10)pij2(l+1)=(1-β(l))pij1(l)+β(l)iIijbestwhere Ikijis the indicator function of the kth individual in the superior population and Ibestijis the indicator function of the best individual:(11)Iijk=1ifjobjappearsbeforeorinpositioni0else(12)Iijbest=1ifjobjappearsbeforeorinpositioni0elseIn addition, α(l) and β(l) are the learning rates of the probability matrixesA1 andA2 at the lth generation, respectively. To speed up convergence, the adaptive learning rates are adopted as follows:(13)α(l)=max{α(0)×exp(-0.01×l),0.01}(14)β(l)=max{β(0)×exp(-0.01×l),0.01}where α(0) and β(0) are the initial learning rates. In such a way, learning rates may be relatively large at the earlier period of the search process to accelerate the speed of convergence. As the population evolves, the learning rates decrease exponentially so as to enhance the exploitation ability. To ensure certain learning efficiency, it sets the learning rates no less than 0.01 as the above equations.To further enhance the exploitation ability, the insertion operator [22] is used iteratively for local search. Let π denote the current solution. It tries to insert each job of π into all possible positions to obtain a new schedule with the smallest total tardiness. All the jobs of π are handled in a random generated sequence, denoted as πR. The procedure of the local search procedure is shown in Fig. 2.Note that, the above local search is performed only on the best solution of the superior population, which is also the best one of the whole population. By iteratively performing insertion, the neighborhood of the best solution can be deeply exploited. Meanwhile, by using the speed-up method for insertion neighborhood [22], it may not cost too much time in local search. After the local search, the best solution that has been explored should be updated if a better one is found by the local search procedure.With the above design, the flowchart of the BEDA is illustrated in Fig. 3.From the flowchart, it can be seen that two sub-populations work together in the algorithm. Since the sub-population P1 is generated by sampling the global probability matrixA1, which is updated according to the superior population, global exploration is stressed. Since the sub-population P2 is generated by sampling the local probability matrixA2, which is updated according to the best solution that has been explored, local exploitation is stressed. Merging the two sub-populations, it can share their information to determine the superior population of the whole population, which is helpful to adjust the two probability matrixes more reasonably. Via the local search on the best solution, deep local exploitation can be further enhanced. By balancing the global exploration and the local exploitation, the BEDA is expected to solve the NIPFSP effectively.To investigate the performance of the BEDA, numerical tests are carried out with the benchmarking set by Taillard [31]. The benchmarking set consists of 120 instances, ranging from 20 jobs/5 machines to 500 jobs/20 machines. The total work (TWK) rule [32] is used to determine the due dates. To be specific, the due date of job Jjis calculated bydj=τ×∑i=1mpij, where τ is the tightness factor and∑i=1mpijis the total processing time of job Jjon all machines. Same as the literature [22], τ is set as 1, 2 and 3 to make the job due date loose, medium and tight, respectively.The proposed BEDA is coded in C++ language and run on a 3.30GHz processor with 8G RAM in Visual Studio 2012. Same as the literature [22], the following relative percent deviation (Δ) from the NEH solution is used to evaluate the performance of an algorithm.(15)Δ=ALG-NEHNEH×100where ALG denotes the objective value of the solution obtained by an algorithm, and NEH denotes the objective value of the NEH solution modified for the NIPFSP [22]. If Δ is less than 0, a better solution is obtained than NEH. The smaller the value is, the better the solution is. As for the stopping criterion, the maximum computational time is set as Tmax=100×n milliseconds, which is only 1/1000 of that used in literature [22].The BEDA contains five key parameters: the population size (P_Size), the proportion of selected individuals to update the probability modelA1 (η), the proportion of sub-population P2 (γ) and the initial learning rates α(0) and β(0). To study the influence of these parameters on the performance of the BEDA, we implement the Taguchi method of design-of-experiment (DOE) [28] by using a set of instances with different problem scales. Clearly, the size of search space of the NIPFSP directly depends on the number of jobs. Thus, for each number of jobs n (n=20,50,100,200,500), we randomly choose an instance with the medium due date case. That is, a total of 5 instances with different scales will be tested using the DOE to investigate the influence of the parameters. Combinations of the tested values of those parameters are listed in Table 1.For each combination of the parameters, the BEDA is run 10 times independently with the stopping criterion mentioned above. The average value of the obtained total tardiness is regarded as the average response value (ARV). Due to the limitation of the pages, we only provide the DOE results with a moderate-scale instance Ta076 (n=100, m=10) as an example. The resulted ARV values are listed in Table 2and the significance rank of each parameter is listed in Table 3. According to Table 3, the trend of each factor level is illustrated in Fig. 4.From Table 3, it can be seen that β(0) is the most significant parameter for the moderate-scale instance, η ranks the second place, α(0) ranks the third place, P_Size ranks the fourth place, and γ ranks the last place. From Fig. 4, the influence of each parameter is clearly figured out. For the learning rate, usually a small value may lead to slow convergence, while a large value may result in premature convergence. Especially, in the BEDA the learning rate β(0) should be determined carefully, since it is related to the best solution that has been explored. A too large rate may cause the local model over-dominated by the best solution, which will produce a sub-population without diversity. Since η is the proportion of population to determine the superior population, a small value will lead to few elite solutions involved in updating the model while a large value will cause the use of some bad solutions to update the model. As for the population size P_Size, with a fixed computational effort, a large value may lead to insufficient generations of search, while a small value may cause the sampling insufficient at each generation. As for γ, a larger value will slightly deteriorate the performance because it may lose the diversity of population by over using the local model.Summarizing the results of all the five instances, we present the suggested values in Fig. 5for solving the problems with different numbers of jobs. It can be seen that the suggested population size P_Size is linear to job number; and the best choices of η and γ are consistently suggested as 20 and 5, respectively. In addition, the suggested values of α(0) and β(0) increase as n increases for the small-scale or moderate-scale problems, but they are both suggested as 0.5 for the large-scale problems.To sum up, we suggest the parameter setting according to the above discussion for the problems with different job numbers as follows: P_Size=n, η=20, γ=5, α(0)=min{0.005n,0.5}, and β(0)=min{0.005n,0.5}. Such a parameter setting will be used for the BEDA in the following tests and comparisons.Among the above five parameters, parameter γ determines the size of each sub-population. According to the above discussion, γ is fixed as 5. Obviously, when γ=0, the size of sub-population P2 becomes 0, and the BEDA is converted into a single-population EDA with P1 only. When γ=100, the size of sub-population P1 becomes 0, and the BEDA is converted into a single-population EDA with P2 only. Next, we compare the two single-population EDAs (γ=0,100) with the proposed BEDA (γ=5). We run the BEDA 5 independent times for each instance considering different τ, and the interval plot of the average relative percent deviation for each choice of γ = {0,5,100} is illustrated in Fig. 6.From Fig. 6, it can be seen that the performances are worse when γ=0 and γ=100 than that when γ=5. So, it can be concluded that the BEDA outperforms the single-population EDA. That is, the bi-population strategy is effective to improve the performance of the EDA.To intensify the local exploitation, the insertion operator is performed iteratively on the best solution at each generation. In order to show the effectiveness of local search, we compare the BEDA to that without the local search procedure (denoted as BEDA∗). In particular, the BEDA and BEDA∗ are run 5 independent times for all instances, respectively. The interval plot of the average relative percent deviation considering different τ is shown in Fig. 7.From Fig. 7, it can be clearly seen that the BEDA outperforms the BEDA∗ for all the cases. So, the local search procedure is useful to improve the performances by enhancing the exploitation of the EDA.To further evaluate the performances of the BEDA, we compare it with the existing GA and DABC recently published in [22]. Same as the literature [22], five independent runs are carried out for each instance, and the minimum (Best), average (Avg), maximum (Worst) and the standard deviation (Std) of the five runs are reported. For each case of due date tightness factor, the results are grouped by the combination of n and m. The comparative results are listed in Tables 4–6, where the results of the GA and DABC are directly from the literature [22] and the best results are highlighted in bold.From Tables 4–6, it can be seen that the BEDA outperforms GA and DABC in solving the NIPFSP for all the tight, medium and loose cases. With less computational time, the BEDA can obtain better solutions in terms of minimum, average and maximum results. As for the standard deviations, the results of the three algorithms are almost at the same level. In Fig. 8, the Gantt chart of the best solution obtained by the BEDA in solving instance Ta001 is shown.For further statistical analysis, we run the BEDA 20 times for each instance and use the student’s t-test to show the statistical significance of the BEDA over the GA and DABC. The results of statistical tests are listed in Table 7.When comparing the BEDA with GA, it can be seen from Table 7 that the p-values are 0.00<0.05 for the tight, medium and loose cases. So, the differences between BEDA and GA are statistically significant at 95% confidence level for all the cases. When comparing the BEDA with DABC, it can be seen from Table 7 that the p-values are 0.04, 0.03, respectively, for the medium and loose cases, showing the differences between BEDA and DABC are significant at 95% confidence level; Although the p-value is 0.06 for the tight case, the difference between BEDA and DABC is still significant at 90% confidence level. Considering the average value for all cases together, the p-value on average is 0.04<0.05, showing the BEDA is significantly better than DABC at 95% confidence level.From the above tests and comparisons, it can be concluded that the BEDA is a more effective and efficient approach for solving the NIPFSP with the total tardiness criterion. The superiority of the BEDA mainly owes to the following two aspects. (1) Using the bi-population strategy, two sub-populations with specific probability models cooperate with each other for balancing global exploration and local exploitation. (2) Using the insertion based local search, the search region around the best solution of the population can be well exploited.

@&#CONCLUSIONS@&#
This was the first reported work of using the EDA to solve the NIPFSP with the total tardiness criterion. A bi-population EDA was developed by using two sub-populations that evolve and collaborate together. Two probability models were adjusted in different ways, stressing the balance of global exploration and local exploitation. An insertion neighborhood based local search procedure was embedded to strengthen exploitation. The DOE based experimental investigation was carried out, showing the influence of parameter setting. The effectiveness of the bi-population strategy and local search procedure was demonstrated by numerical comparisons. The comparisons also showed that the BEDA outperformed the recently published algorithms in terms of solution quality and search efficiency. Further work could focus on the applications of the proposed algorithm to some real industrial problems. It is also interesting to develop the adaptive BEDA with new collaborating mechanisms between two sub-populations or knowledge based rules for adjusting models as well as to generalize the BEDA for solving the problems with other scheduling objectives and multiple objectives.