@&#MAIN-TITLE@&#
The multiple vehicle pickup and delivery problem with LIFO constraints

@&#HIGHLIGHTS@&#
Approach a new pickup and delivery problem with LIFO and time constraints.Propose two formulations for the problem, together with several set of valid inequalities to improve them.Design an efficient branch and cut solution method to solve the problem to optimality.Develop a fast tabu search heuristic to find feasible solutions within short running times.Evaluate the performance of the proposed solution methods through a comprehensive computational study.

@&#KEYPHRASES@&#
Vehicle routing,Pickup and delivery,LIFO constraints,Mixed-integer programming,Branch and cut,

@&#ABSTRACT@&#
This paper approaches a pickup and delivery problem with multiple vehicles in which LIFO conditions are imposed when performing loading and unloading operations and the route durations cannot exceed a given limit. We propose two mixed integer formulations of this problem and a heuristic procedure that uses tabu search in a multi-start framework. The first formulation is a compact one, that is, the number of variables and constraints is polynomial in the number of requests, while the second one contains an exponential number of constraints and is used as the basis of a branch-and-cut algorithm. The performances of the proposed solution methods are evaluated through an extensive computational study using instances of different types that were created by adapting existing benchmark instances. The proposed exact methods are able to optimally solve instances with up to 60 nodes.

@&#INTRODUCTION@&#
Vehicle routing problems play a very important role in logistics and transportation and have been widely studied during the last decades. Many variants with different characteristics have been considered and a variety of mathematical and computational techniques have been proposed to solve them (see, for example, Toth and Vigo, 2002 and Golden, Raghavan, and Wasil, 2008 for a survey on vehicle routing problems). The Capacitated Vehicle Routing Problem (CVRP) is the reference model for these problems and is defined as follows: given a set of customers, each one demanding a certain amount of a product, and a fleet of vehicles with limited capacity that are based at a given depot, the problem consists of finding a set of minimum cost routes for the vehicles so that all customers are visited exactly once, their demands are fulfilled and the capacity of the vehicles is not exceeded.The problem approached in this paper is a variant of the so called Vehicle Routing Problem with Pickups and Deliveries (VRPPD) in which the vehicles have to satisfy a set of customer requests where each request specifies the size of the load to be transported, the origin location and the destination location. According to the classification proposed by Berbeglia, Cordeau, Gribkovskaia, and Laporte (2007) this problem belongs to the one-to-one class of pickup and delivery problems.Note that the CVRP can be considered as a particular case of the VRPPD where all the requests have the depot as the origin location. The VRPPD has been extensively studied in the last three decades (see Berbeglia et al., 2007 and Parragh, Doerner, and Hartl, 2008a; 2008b), incorporating additional constraints that appear in practical situations. In this paper we consider a LIFO (Last-In-First-Out) rule of service, that means only the last pickup customer request that has been loaded can be delivered. Hence, the vehicle servicing an origin location must continue to the corresponding destination or visit another origin location. This condition arises naturally when the vehicles used for transportation are rear-loaded and they have a single access point to their container. The rearrangement of the load when performing deliveries may be possible, but if it is too time consuming, it could be simply forbidden. This is the case, for example, of hazardous materials or very heavy or fragile items. Moreover, we also require that the total duration of each route does not exceed a given limit, where route duration includes traveling times among different locations and service times at each origin/destination for loading and unloading operations. The objective is to find a set of routes with minimum total duration satisfying all the constraints. We refer to this problem as the Multiple Vehicle Pickup and Delivery Problem with LIFO constraints and Maximum Time but it will be abbreviated simply by PDPLT.To our knowledge, the PDPLT has not been previously studied. However, algorithms have been proposed for related problems. If the capacity and maximum time constraints are relaxed the resulting problem is known as the Traveling Salesman Problem with Pickup, Delivery and LIFO constraints (TSPPDL). Carrabs, Cerulli, and Cordeau (2007) develop a branch-and-bound algorithm for this problem and later Cordeau, Iori, Laporte, and Salazar (2010) propose a branch-and-cut algorithm which is able to solve instances with up to 25 requests within a reasonable computing time.Battarra, Erdogan, Laporte, and Vigo (2010) consider a version of the TSPPDL in which the LIFO rule can be violated, but in this case rehandling costs are incurred. They present models and exact algorithms based on branch-and-cut for this problem, while Erdogan, Battarra, Laporte, and Vigo (2012) have later developed a tabu search metaheuristic.Cheang, Gao, Lim, Qin, and Zhu (2012) propose several heuristics for a multi-vehicle case where the route length of each vehicle cannot exceed a predetermined limit and the vehicles have unlimited capacity (see also Gao, Lim, Qin, and Zhu, 2011). This problem is called Multiple Pickup and Delivery Traveling Salesman Problem with LIFO and Distance constraints (MTSPPD-LD). Their primary objective is minimizing the number of vehicles used, while the secondary objective is minimizing the total distance traveled. Note that the MTSPPD-LD can be solved as a PDPLT, since minimizing the total distance is equivalent to minimizing the total time, and minimizing the number of vehicles as the primary objective can be achieved by simply adding a big number to the travel times of the arcs leaving the depot.Another variant that is closely related to the PDPLT was introduced recently by Cherkesly, Desaulniers, and Laporte (2014). In that paper, in addition to imposing LIFO constraints, time windows are associated to every pickup and delivery location. However, they do not consider a maximum time duration for the routes. The authors develop three related branch-price-and-cut algorithms using a three-index formulation of the problem. Their exact solution procedures involve column generation techniques and constrained shortest path subproblems.The main purpose of this paper is to propose, for the first time, methods to solve the PDPLT. We have developed two mixed integer formulations of the PDPLT and a heuristic procedure that uses tabu search in a multi-start framework. The first formulation is a compact one, that is, the number of variables and constraints grows polynomially with the number of requests, while the second one contains an exponential number of constraints. Separation procedures for several families of the constraints of the non-compact formulation are implemented and embedded in a branch-and-cut algorithm. The compact formulation is easy to use because all the constraints can be included at once, but it is outperformed by the proposed branch-and-cut based on the non-compact formulation for larger instances. The proposed methods are able to solve medium size instances of the PDPLT and provide tight lower and upper bounds for larger instances.The remainder of the paper is organized as follows. Section 2 introduces the main notation that will be used through the paper. Section 3 presents the compact formulation and Section 4 is devoted to the non-compact formulation, separation algorithms for several families of valid inequalities and the associated branch-and-cut algorithm. Section 5 describes a fast tabu search heuristic for the PDPLT which is embedded into a multi-start framework. The performance of the proposed solution methods is evaluated and analyzed in Section 6, where an extensive computational study is presented. Finally, Section 7 concludes with some final remarks and ideas for future research.The PDPLT is defined on a directed graph G = (V, A).•V = P∪D∪{0} is the set of nodes, where P = {1, …, n} is the set of pickup locations, D = {n + 1, …, 2n} is the set of delivery locations and 0 is the depot. We assume that the delivery location of the load picked up at i ∈ P is i + n ∈ D.A is the set of arcs (i, j) between every pair of nodes i, j ∈ V, i ≠ j.The travel time to traverse each arc (i, j) is denoted by cij, for all (i, j) ∈ A. It is assumed that travel times satisfy the triangular inequality. Travel times will also be called costs throughout the paper.The service time (pickup or delivery) at each node i ∈ P∪D is si.The maximum duration of the route of any vehicle is T.For each i ∈ P, di> 0 is the load of the item that must be picked up at i and delivered at i + n. We define, for each i + n ∈ D, di + n= −di< 0.The number of available vehicles is denoted by m and their capacity by Q.The goal of the PDPLT is to find a set of routes with minimum total duration that services all the requests, that is, each requested item must be picked up at its origin and delivered at its destination. The duration of the routes include the traversing times among locations and service times and cannot exceed T. The routes must start and end at the depot, the capacity cannot be exceeded, and the LIFO rule must be respected.In this section we propose a compact formulation for our problem using three families of variables. Binary variables xijindicate if arc (i, j) is traversed by any vehicle, or not. Continuous variables αijare typical flow-like variables that in our case indicate the arrival time at node j when the vehicle travels from i to j. Binary variables uik, defined for any pair of nodes i ∈ V and k ∈ P, are equal to 1 if the item corresponding to node k is in the vehicle when it leaves node i. These variables are used to prevent subtours, to express the capacity constraints and to assure that the pickup and the delivery nodes associated to a given request belong to the same route. This last condition is not easy to impose because variables xijdo not allow to identify which vehicle is traveling from i to j.Variables uikand their corresponding constraints are inspired by the Miller–Tucker–Zemlin formulation for the Travelling Salesman Problem (see Miller, Tucker, and Zemlin, 1960) that were improved later and used for the Vehicle Routing Problem by Kara, Laporte, and Bektas (2004). Let us define coefficients βikas follows: βkk= 1 and βk + n, k= −1 for all k ∈ P, and βik= 0 for any i ∈ V, i ≠ k, n + k. Note that coefficients βikindicate that item k can only be picked up in node k (βkk= 1) and delivered in node k + n (βk + n, k= −1). For instance, if n = 3, it isβ=(100010001−1000−1000−1)Proposition 1Constraints (1) are valid for the PDPLT.(1)uik−ujk+xij+(1−βik−βjk)xji≤1−βjk∀(i,j)∈A,k∈PLet us first prove the validity of constraints (2).(2)uik−ujk+xij≤1−βjk∀(i,j)∈A,k∈PNote that the definition of variables uikimplies that ukk= 1 and un + k, k= 0 for all k ∈ P. If xij= 0, then the possible values of uik− ujkare − 1, 0, 1 and, since the RHS is always greater than or equal to zero, we only have to analyze the case where ujk= 0 and uik= 1, but then βjk≠ 1 and the constraint holds. If xij= 1, then uik− ujk≤ −βjk. If uik= 1, then either ujk= 1 and βjk= 0 or ujk= 0 and βjk= −1 (j = k + n). The case where xij= 1 and uik= 0 is proved similarly.These constraints can be improved by introducing an extra term, in a similar way as in Kara et al. (2004) : uik− ujk+ xij+ γjixji≤ 1 − βjk. It can be observed that the largest value that can be given to γjiis (1 − βik− βjk) ≥ 0.□Following the same lines as in Kara et al. (2004), Proposition 2 presents another set of lifted constraints.Proposition 2Constraints (3) are valid for the PDPLT.(3)uik−∑j≠iβjkxji≥βik∀i∈V,k∈PNote that in a feasible solution there is only one arc entering each node and therefore ∑j ≠ iβjkxjiis equal toβi′kwhere i′ is the node from which the vehicle enters node i. If uik= 1 then: either i = k andβi′kcannot be 1 or i ≠ k and therefore item k is already on the vehicle when it leaves node i′ (in the case that i′ = k the constraint still holds). The case when uik= 0 is proved similarly.□The following notation will be used. For any subsets S, S′⊆V, we denote (S: S′) = {(i, j) ∈ A: i ∈ S, j ∈ S′}, δ+(S) = (S: V\S), δ−(S) = (V\S: S), δ(S) = δ+(S)∪δ−(S), and γ(S) = (S: S). For simplicity, we will write i instead of {i} when using this notation. Finally, we denote x(F) = ∑(i, j) ∈ Fxij, for any F⊆A. Similar notation will be used with α-variables.Then, the basic formulation of our problem is:(4)min∑(i,j)∈A(cij+si)xij(5)s.t.uik−ujk+xij+(1−βik−βjk)xji≤1−βjk∀(i,j)∈A,k∈P(6)uik−∑j≠iβjkxji≥βik∀i∈V,k∈P(7)ukk=1,u0k=0∀k∈P(8)un+k,k=0∀k∈P(9)uik=ui+n,k∀i∈P,k∈P,i≠k(10)∑k∈Pdkuik≤Q∀i∈V(11)α0j=c0jx0j∀j∈P(12)α(δ+(i))−α(δ−(i))=∑j∈V:j≠i(cij+si)xij∀i∈P∪D(13)αij≤Txij∀(i,j)∈A(14)x(δ−(j))=1∀j∈P∪D(15)x(δ+(i))=1∀i∈P∪D(16)x(δ−(0))≤m(17)x(δ+(0))≤m(18)αij≥0∀(i,j)∈A(19)uik∈{0,1}∀i∈V,k∈P(20)xij∈{0,1}∀(i,j)∈AIt can be observed that constraints (5)–(8) avoid subtours disconnected from the depot and force any pair of nodes i ∈ P, i + n ∈ D to belong to the same route. Constraints (9) guarantee that the items loaded when leaving node i are the same that when leaving node i + n for all k ∈ P, i ≠ k because, as imposed by the LIFO requirement, any item loaded when traveling form i to n + i must be delivered before the item corresponding to i is delivered in node n + i.Constraints (10) assure that the total load on the vehicle when leaving a node cannot exceed the vehicle capacity Q.The values of the α variables (arrival time at each node) when departing from the depot are stated by constraints (11). Flow conservation constraints (12) define the values of the other α variables and constraints (13) introduce the route duration limit.Constraints (14) and (15) impose that any node different from the depot is visited exactly once, while constraints (16) and (17) set an upper bound on the number of vehicles used. Finally, (18)–(20) are the non-negativity and integrality constraints respectively.It can be observed that (4)–(20) define a valid formulation of the PDPLT.We now consider other sets of valid inequalities, that in some cases are improved versions of the above constraints. Capacity constraints are valid for any node i, but if we consider a pick-up node i ∈ P we can write:(21)∑k∈Pdkuik+(Q−di)x0i≤Q∀i∈Pbecause if x0i= 1 then ∑k ∈ Pdkuik= diand the inequality holds.In a similar way we can improve the trivial constraint uik≤ 1 ∀i ∈ V, k ∈ P obtaining:(22)uik+(1−βik)x0i≤1∀i,k∈PGiven a node i, ∑k ∈ Pdkuikcorresponds to the load in the vehicle leaving it and ∑j ≠ idjxjiis a lower bound of the load of the vehicle entering it. Therefore, the difference between these two quantities is an upper bound on the load picked up at node i, if i ∈ P, or minus the load delivered at i, if i ∈ D, so the following inequality is valid:(23)∑k∈Pdkuik−∑j≠idjxji≥di∀i∈VThe load of a vehicle when leaving node i cannot be greater than Q; on the other hand the load when leaving a node j is always at least equal to djand therefore, the difference cannot be greater than Q − dj, i.e.: ∑k ∈ Pdk(uik− ujk) ≤ Q − dj∀(i, j) ∈ A. These constraints can be improved and it can be observed the following constraints are also valid:(24)∑k∈Pdk(uik−ujk)+Qxij+(Q−di−dj)xji≤Q−dj∀(i,j)∈ABoth constraints (23) and (24) are obtained following the same lines as in Kara (2008). The following constraints ensure that node n + i is visited at least ci, n + i+ siunits of time after visiting node i, which also implies that n + i is always visited after i. Note that these constraints are valid since we assume that travel times satisfy the triangle inequality.(25)∑j∈V:j≠n+iαj,n+i−∑j∈V:j≠iαji≥ci,n+i+si∀i∈POn the other hand, the following x-variables can be fixed.(26)xi0=0∀i∈P(27)x0j=0∀j∈D(28)xij=0∀i∈P,j∈D:j≠i+n(29)xij=0∀i,j∈P:di+dj>Q(30)xij=0∀i,j∈D:di+dj<−Q(31)xij=0∀i,j∈V∖{0}:c0i+cij+cj0>TEquations (26) and (27) forbid, respectively, to travel from a pickup node to the depot and from the depot to a delivery node. Equation (28) are valid as a consequence of the LIFO strategy: if an item is picked up in a node, the next node visited cannot be the delivery node of a different item. Equations (29) and (30) state that two pickup or delivery nodes with a combined demand exceeding the capacity of the vehicle cannot be visited consecutively. Equation (31) indicate that if the total time required to go from the depot to a node i, from i to j and from j back to the depot exceeds the maximum driving time T, nodes i and j cannot be visited consecutively.Furthermore,(32)αij≥cijxij∀(i,j)∈Aare also valid.Finally, given that the objective function expresses the total time needed to visit all the pickup and delivery nodes, if LB is a valid lower bound on the optimal cost, ⌈ LB/T⌉ is a lower bound of the number of vehicles that have to be used, so the following constraint is valid:(33)x(δ+(0))≥⌈LB/T⌉The compact formulation that was finally implemented includes constraints (5)–(20), where constraints (10) were replaced by (21) for the pick-up nodes, and constraints (22)–(28). Furthermore, relationships (7)–(9) were used to reduce the number of variables ujk(see Appendix A for further details).In this section we present a formulation that uses only the integer variables xijto define the routes and the continuous variables αijto control the duration of the routes. These variables have been already defined in Section 3. The main drawback of this new formulation is that it contains an exponential number of constraints, so it has to be used in a cutting plane scheme that will be embedded in a branch-and-cut procedure in order to find the optimal solution. This formulation includes the same objective function (4) as the compact formulation, constraints (14)–(17) that control the node degrees with respect to x-variables, additional constraints (26)–(33), and constraints (11)–(13) that concern α-variables. Finally, constraints (18) and (20) are also included in this formulation.In what follows we will introduce several families of constraints that are necessary to complete the formulation. Additional constraints are also included to strengthen the formulation so that the linear relaxation provides a better lower bound on the optimal solution cost.Given a vector of binary x-variablesx¯,that represents a feasible solution of the PDPLT, we denote byGx¯the graph whose node set is V and contains the arcs (i, j) such thatx¯ij=1,for all (i, j) ∈ A.The vehicle capacity constraints are expressed in a similar way as it is done for other capacitated routing problems:(34)x(δ+(S))≥max{1,⌈D(S)/Q⌉}∀S∈V∖{0}where D(S) = |∑i ∈ Sdi| is the net demand of the nodes in S. These constraints can also be written as: x(δ(S)) ≥ 2max {1, ⌈D(S)/Q⌉} or, equivalently x(γ(S)) ≤ |S| − max {1, ⌈D(S)/Q⌉}. Note that if S = {i, j} and D({i, j}) ≤ Q the capacity constraint can be written as xij+ xji≤ 1.The condition that the pickup is an activity preceding the delivery can be imposed as follows:(35)x(γ(S))+x(S:i)≤|S|−1∀S⊂V∖{0},i∉S,n+i∈S,i∈PNote that a solution containing a path that visits node n + i before node i would violate this constraint for a set S containing all the nodes in the path between n + i and the node preceding i. The above precedence constraints can be strengthened because a path visiting every node in S cannot visit afterward any pickup node whose corresponding delivery node is in S.Proposition 3Constraints (36) are valid for the PDPLT.(36)x(γ(S))+x(S:S′)≤|S|−1∀S⊂V∖{0}S′={i∈P∖S:n+i∈S}≠∅Let us consider a feasible solutionx¯. Sincex¯(δ+(i))=1for all i ∈ V\{0}, we have that∑i∈Sx¯(δ+(i))=x¯(γ(S))+x¯(S:V∖S)=|S|. Note that the subgraph ofGx¯induced by S consists of a number of node-disjoint paths. Let t ≥ 1 be the number of paths, so thatx¯(γ(S))=|S|−t. Thereforex¯(S:S′)≤x¯(S:V∖S)=tand all we need to show is thatx¯(S:S′)<t. Note that for each arc (i, j) ∈ (S: S′) used by the solution, there should exist a path following that arc that returns to S without visiting the depot because the delivery node corresponding to node j is in S. Therefore, ifx¯(S:S′)=t,the solution would contain at least one cycle not visiting the depot, which is not allowed. Thus, the constraint is satisfied byx¯.□These constraints impose that the same vehicle services nodes i and n + i:(37)x(0:S)+x(γ(S))≤|S|−1∀S⊂V∖{0}suchthat∃n+i∈S∩Dwithi∉SIf a route contains node n + i but not node i, then define S as the set of nodes visited by the route from the depot, without including it, to node n + i, and the above constraint is violated.Proposition 4Constraints (37) are valid for the PDPLT.Let i* ∈ P∖S such that n + i* ∈ S, and let us consider a feasible solutionx¯. As in the proof of (36), note thatx¯(γ(S))=|S|−t,t ≥ 1 implies that there are t node-disjoint paths in S; given that there is no arc from the depot to the path in S containing node n + i*,x¯(0:S)≤t−1holds and the proof is complete.□There is a symmetric family to these inequalities that avoid routes visiting a pickup node and not visiting the corresponding delivery node. These constraints are not necessary for the integer formulation if (37) are present, but they may be useful to strengthen the linear relaxation and to cut fractional solutions.(38)x(γ(S))+x(S:0)≤|S|−1∀S⊂V∖{0}suchthat∃i∈S∩Pwithn+i∉SIf there is a route servicing node i ∈ S∩P but not node n + i, then considering S as the set of nodes in the route from i to the depot, without including it, the above constraint is violated. The proof of validity is similar to the one above.Cordeau et al. (2010) introduced the following constraints that assure the LIFO policy in the TSPPDL:(39)x(i:S)+x(γ(S))+x(S:n+i)≤|S|∀S∈Ω,∀i,n+i∉S,i∈Pwhere Ω is the family of all subsets S⊂P∪D such that there is j ∈ S∩P and n + j∉S or there is n + j ∈ S∩D and j∉S.Propositions 5 and 6 introduce new strengthened LIFO constraints that dominate and extend constraints (39).Proposition 5The following constraints are valid for the PDPLT,(40)x(γ(S))+x(S:S′)≤|S|−1where subset S⊂V\{0} is such that there exists k ∈ S∩P for which n + k∉S, and S′ = {n + j: n + j ∈ D\S and j∉S}∪{j: j ∈ P\S and n + j ∈ S}. Note that n + k∉S′.Let us consider a feasible solutionx¯. As in the proof of Proposition 3, we know thatx¯(γ(S))+x¯(S:V∖S)=|S|. Then, all we need to show is that there is at least one arc inGx¯from a node in S to a node not in S′. Note that the subgraph ofGx¯induced by S consists of a number of node-disjoint paths, let P1 be the path of the subgraph ofGx¯induced by S that contains node k. Let (l, y), l ∈ S, y ∈ V\S, be the arc leaving S that continues path P1. If y = n + k, we are done, since n + k∉S′. Otherwise, given that the corresponding vehicle has not yet visited node n + k, y cannot be a delivery node in S′. If y = j ∈ S′∩P, since n + j ∈ S, the vehicle must visit S again (without visiting n + k), in order to perform the delivery at node n + j, and leave again set S through a new arc, say (l′, y′). If y′ = j′ ∈ S′∩P, the same argument applies, and so on. Given that the number of arcs is finite, some arc leaving S will enter a node not in S′. This is illustrated in Fig. 1.□Note that constraints (40) dominate constraints (39) for the case where set S ∈ Ω is such that there exists j ∈ S∩P such that n + j∉S, because x(i: S) ≤ 1, and n + i ∈ S′ if i, n + i∉S.Proposition 6The following constraints are valid for the PDPLT,(41)x(i:S)+x(γ(S))+x(S:S′)≤|S|where sets S and S′ and node i ∈ P satisfy one of the following sets of conditions:C1.S⊂V\{0} is such that there exists k ∈ P\S for which n + k ∈ S∩D, and i ∈ P\S. S′ = {i, k} if n + i ∈ S, and S′ = {n + i} if n + i∉S.S∉Ω (this means that for all j ∈ P either j, n + j ∈ S or j, n + j∉S), i ∈ P\S, n + i ∈ D\S, and S′ = {i}∪{n + j: n + j∉S, j∉S, j ≠ i}C1.Let us consider a feasible solutionx¯. Again, we know thatx¯(γ(S))+x¯(S:V∖S)=|S|. Then, ifx¯(i:S)=0the constraint is obviously satisfied. Ifx¯(i:S)=1,all we need to show is that there is at least one arc inGx¯leaving set S and not entering S′. Note that the subgraph ofGx¯induced by S consists of a number of node-disjoint paths, let P1 be the path of the subgraph ofGx¯induced by S that follows the arc entering S from node i. We consider two cases:(a)n + i∉S. Then n + k cannot be in P1 because before delivering the item at n + k, the item corresponding to i must be delivered at n + i. Therefore,x¯(γ(S))≤|S|−2,sox¯(S:V∖S)≥2,and then given that S′ = {n + i} in this case, the constraint is satisfied.n + i ∈ S. Let (l, y) be the arc leaving S that continues path P1. If n + k is in the path P1, then obviously y∉S′ = {i, k}. On the other hand, if n + k is not in the path P1, it is clear that y ≠ i, and if y ≠ k, we are done. If y = k, the vehicle that follows path P1 must enter S again in order to deliver the item at node n + k, therefore it will have to leave S again, this time entering to a node different from nodes i and k, so the constraint is satisfied.Let us consider a feasible solutionx¯. Ifx¯(i:S)=0the constraint is obviously satisfied. Assumex¯(i:S)=1,and let P1 be the path of the subgraph ofGx¯induced by S that follows the arc entering S from node i. It is then clear that the arc that continues path P1 to leave S cannot enter any node in S′, so the constraint is also satisfied in this case.Note that constraints (39), for the case where set S ∈ Ω is such that there exists n + j ∈ S∩D so that j∉S, are exactly the same as constraints (41) with conditions C1, if n + i∉S. On the other hand, conditions C2 introduce new cases that were not considered by Cordeau et al. (2010).Any integer solution that satisfies constraints (11)–(18), (20), capacity constraints (34), precedence constraints (36), same-route constraints (37) and (38), and LIFO constraints (40) and (41) define a set of routes that are a feasible PDPL solution. Additional constraints (26)–(33) are also used in this formulation.The non-compact formulation is the base of a branch-and-cut algorithm that is described next. The initial linear programming (LP) relaxation at the root node of the branch-and-cut tree contains the objective function (4), constraints (11)–(18), (26)–(32), and xij≥ 0, ∀(i, j) ∈ A. At any node of the branch-and-cut tree a cutting plane algorithm is used that works as follows. At each iteration, the current LP is solved and several separation procedures are used to search for inequalities that are violated by the optimal LP solution. These inequalities belong to the families described in the previous section that contain an exponential number of constraints, namely (34), (36)–(38), and (40) and (41). After the addition of violated constraints, the LP is reoptimized using the dual simplex algorithm. The cycle of LP optimization and addition of violated constraints iterates until no more violated inequalities are found, in which case, the branch-and-cut node is branched. The strong branching strategy of CPLEX (IBM-ILOG, 2011) is used to explore the branch-and-cut tree. Inequality (33) is added to the LP after the first LP is solved and a valid lower bound on the total duration of the routes is known. The right-hand-side of (33) is checked at each iteration and updated whenever it is possible.In what follows we describe the separation procedures that have been used for each family of constraints. Let(x¯,α¯)be the solution of the linear relaxation of the current LP. We define the directed weighted graphG[x¯]as the graph induced by arcs (i, j) withx¯ij>0,which will be called the support graph. InG[x¯]the weight of an arc (i, j) ∈ A is given byx¯ij. Additionally, we consider the undirected graphGu[x¯]where each pair of arcs (i, j) and (j, i) are replaced by an edge e = {i, j} with weightx¯e=x¯ij+x¯ji.Most of the separation procedures work by generating “promising” sets of nodes that are used to check the violation of several types of constraints. Given a subset of nodes S⊂V\{0}, the capacity constraints (34) for subsets S and V\{0}\S are checked for possible violation. In the case that D(S) ≤ Q the precedence constraint is checked instead, because it is stronger than the capacity constraint. Concerning the LIFO constraints (40) and (41), each time a subset S⊆V\{0} is generated, we determine the type of LIFO constraint associated to it, and then, for each i ∈ P\S such thatx¯(i:S)>0,the appropriate subset S′ is generated and the corresponding LIFO constraint is checked. Precedence constraints (36) for a given S⊂V\{0} are checked if the corresponding subset S′ is not empty. Finally, same route constraints (37) and (38) are easily checked for a given S⊂V\{0} by first computingx¯(0:S)orx¯(S:0),respectively.Roughly speaking the “promising” sets S are those for whichx¯(γ(S))is as large as possible. They are generated by using the following procedures. First, we generate the node sets of the connected components ofGu[x¯]andGu[x¯]∖{0},respectively, and capacity constraints are checked. The shrinking procedure is then used. This procedure iteratively shrinks any edge ofGu[x¯]with weight 1, where shrinking an edge {i, j} means replacing nodes i and j by a new super-node, say vij, that is linked to any node u that was adjacent to i or j by an edge {vij, u} with weightx¯iu+x¯ju. Every time a new super-node is created, the corresponding subset of original nodes is used to check capacity, precedence, LIFO, and same route constraints.If no violated constraint is generated by the above procedures, two general checking algorithms that work on the directed graphG[x¯]are called. The first checking algorithm works by iteratively enlarging a path that goes out of the depot, say (i0 = 0, i1, …, ir) such thatx¯itit+1=1for all t = 0, …, r − 1. Each time a new arc, say (is − 1, is), is added to the path the set {i1, …, is} is used to check the capacity, LIFO and same route constraints. The second checking algorithm is similar but it uses paths entering the depot.Finally, if no violated constraint has been found, the growing sets procedure is called. This procedure starts with an initial subset S = {i}, i ∈ V\{0}, and iteratively adds to it a new node j∉S∪{0} such thatx¯(S:j)>0is as large as possible, until no node can be added. Every generated subset is used to check the capacity, precedence, LIFO and same route constraints. About 90 percent of the nodes are randomly chosen to be used as the initial subset in this procedure.In this section the heuristic approach used to find feasible solutions for the problem, and thus upper bounds, within a short computational time, will be described. It is based on a tabu search metaheuristic, following Glover (1989), that is embedded into a multi-start method. Several initial solutions are first built by different simple constructive methods, and then the tabu search improving heuristic is applied to each of them.The following three constructive algorithms are proposed:•Clarke and Wright.This method is an adaptation of the algorithm proposed in Clark and Wright (1964) for the Capacitated Vehicle Routing Problem. Initially, one vehicle is assigned to each request i, following a route of the form (0, i, n + i, 0). At each iteration, two routes are merged into one single route in order to improve the overall cost of the solution, meeting LIFO and maximum capacity and duration constraints at all times. The savings achieved by each possible merge are calculated to decide which pair of routes are merged in the next iteration.This process is iterated until no more routes can be merged. This algorithm generates one single solution with a reasonably good quality.Random solution with consecutive pickups and deliveries.Initially, all requests are unrouted and one route (the current one) is initialized with the depot node (0). At each iteration, one unrouted request i is selected at random. If feasible, the sequence (i, n + i) is added at the end of the current route; otherwise, the current route is closed, returning to the depot, and a new route is initialized with the sequence (0, i, n + i).This process is iterated until all requests are routed. If it is run several times, this algorithm may generate multiple solutions, where each solution contains routes of the form (0, i, n + i, j, n + j, …, k, n + k, 0).Random solution with pickups before deliveries.Initially, all requests are unrouted and one route (the current one) is initialized with the depot node (0). At each iteration, one unrouted request i is selected at random. If feasible, the sequence (i, n + i) is inserted on the current route after the last pickup node and before its corresponding delivery node; if this is not possible (due to capacity or maximum duration constraints), the sequence (i, n + i) is added at the end of the route, if feasible; otherwise, the current route is closed, returning to the depot, and a new route is initialized with the sequence (0, i, n + i).This process is iterated until all requests are routed. This algorithm may generate multiple solutions whose routes are of the form (0, i, j, k, …, n + k, n + j, n + i, …, 0).In order to improve the quality of the solutions built by the constructive algorithms proposed in the previous section, an improving heuristic based on a tabu search scheme will be applied to each initial solution generated. Tabu search has been previously applied successfully to similar problems. See, for example, Cordeau, Laporte, and Mercier (2001), where it is used to solve a vehicle routing problem with time windows, or Korsvik, Fagerholt, and Laporte (2010), where it is applied to a ship routing and scheduling problem.The tabu search framework is used to introduce diversification in the search, so that it is able to escape from local optima. Still, it includes a local search process that depends on the definition of a neighborhood for the solutions. In our case, the neighborhood of a solution S is formed by the solutions that can be obtained by removing the pickup and delivery nodes of one request from S and reinserting them at different positions, on the same or on a different route.The search is started from an initial solution built by using any of the procedures introduced in the previous section, and at each iteration a new solution belonging to the neighborhood of the current solution is selected. The move to be performed is chosen mostly based on the cost of the new solution obtained, but other indicators aimed to diversify the search and allow the escaping from local optima are also considered. Following this idea, when one request c is moved from one route r1 to another route r2, this move, together with the reverse move, are considered tabu during a certain number of iterations. As a result, none of these two moves can be implemented during the following iterations, unless one of them leads to a solution that improves the best solution found so far, in which case the tabu status is revoked. Furthermore, diversification is encouraged by adding a penalty to the evaluation function that is proportional to the number of times the considered move was performed in past iterations, thus penalizing frequently used moves.The tabu search process described above is based on removal and insertion moves, which usually lead to solutions in which one route visits two more nodes (the pickup and delivery nodes of the request that is moved). In situations where the maximum duration constraint is tight, there may exist very few moves (if any) verifying this constraint, so the search process is very restricted and it is very likely to get stuck in a local optimum. This could be solved by considering additional moves based on interchanges of two requests belonging to two different routes; however, the number of possible moves of this type is much higher, thus increasing too much the size of the neighborhood, and complicating the evaluation of the moves. As a result, we decided not to use interchange moves, and instead expand the search space by temporarily relaxing the maximum duration constraints and penalizing their violation when evaluating the candidate moves. In this way we introduce diversification by allowing intermediate infeasible solutions, but at the same time the search is guided toward feasible solutions.Candidate moves leading to a solution S are thus evaluated according to a function of the form C(S) + λV(S) + μD(S). C(S) is the cost of S. V(S) is a measure related to the violation of the maximum duration constraint, calculated as the sum of the amount of time exceeding the maximum duration limit over all routes. D(S) is the diversification penalty applied to the candidate move and is calculated as the number of times one insertion has been performed at the same position of the same route as in the candidate move during the execution of the algorithm divided by the number of iterations performed up to that moment. It represents the proportion of accepted moves that are similar to the candidate move, aiming to diversify the search by penalizing moves performed repeatedly.The diversification intensity μ is kept constant during the execution of the algorithm, but λ is dynamically updated during the search: if the current solution is unfeasible, λ is increased in order to give more importance to the verification of the maximum duration constraint; otherwise, it is decreased to increase diversification. This mechanism is aimed to guide the search toward feasible solutions but at the same time increase its flexibility by allowing certain constraint violations. Note also that the calculation of the cost of the new solution obtained after performing one move does not require the re-evaluation of the whole solution, because the cost saving achieved by the move can be calculated efficiently in constant time by performing a few additions and subtractions.As stated above, tabu search includes several mechanisms to diversify the search in order to escape from local optima. However, even using all these mechanisms, the search might get trapped inside a small neighborhood in which different solutions can actually be attained, but they are all very similar, not allowing other promising regions of the solution space to be visited. To avoid this, when the relative variation of the cost of the solutions generated during a certain number of iterations is less than a certain value ɛ, a perturbation operator is applied to move the search to a different region of the solution space. This perturbation operator consists on performing several random consecutive moves on the solution, probably increasing its cost but also diversifying the search. Furthermore, to avoid reversing them too early after the perturbation phase, the performed random moves are added to the tabu list, and their tabu status is maintained for twice as many iterations as for the moves performed during the standard tabu search.After some preliminary experiments, and also following Tirado, Hvattum, Fagerholt, and Cordeau (2013) and Korsvik et al. (2010), the values of the main parameters used for the tabu search are the following: the number of iterations that a move is considered tabu is ⌈7.5log10(n)⌉, where n is the number of customer requests; the diversification intensity is set to μ = 0.025; the weight λ related to the maximum duration violation is given initially value 1 and increased or decreased dynamically by a factor 0.5; finally, if for 300 consecutive iterations the cost of the solutions found has not varied at least ɛ = 0.01 percent, 10 perturbation moves are performed to further diversify the search.The heuristic proposed follows a multi-start framework in which several initial solutions generated using the methods introduced in Section 5.1 are improved by the Tabu Search procedure described in Section 5.2. A schematic pseudocode of this heuristic procedure is shown in Algorithm 1, where Tabu(S, t) represents a call to the Tabu Search method that performs t iterations using S as the initial solution.Some preliminary experiments were done to tune the parameters of the multi-start framework with the aim of achieving a trade-off between computational effort and solution quality. After those experiments, the following parameter values were selected: nsols = 100, itCW = itR = 3000 and itB = 20000.In this section the computational study aimed to analyze the performance of the solution methods proposed in previous sections is presented. The algorithms have been implemented in C++ and executed on a 2.66 GHz Core2Quad processor with 3Gb RAM running Windows XP.To the best of the authors knowledge, it does not exist any benchmark available in the literature for the PDPLT. Then, we created a new set of test instances for this problem based on the Li and Lim (2003) benchmark for the PDPTW that consists of 56 instances with about 50 customer requests each and 60 instances with about 200 customer requests each. Li & Lim instances were generated from the 56 Solomons’ benchmark instances for the Vehicle Routing Problem with Time Windows (Solomon, 1987). The instances are divided into six classes lc1, lc2, lr1, lr2, lrc1 and lrc2, where the nodes in lc instances are in clusters, in lr instances the nodes are randomly distributed, and in lrc instances the nodes are partially clustered and partially randomly distributed. The lc1, lr1 and lrc1 problems have a narrow time window associated to the depot, while lc2, lr2 and lrc2 have a wider time window. We modified the Li & Lim instances by setting the maximum route duration equal to the width of the time window associated to the depot and dropping all other time windows. Furthermore, since the smallest Li & Lim instances had about 50 customer requests, we have generated 5 additional sets of smaller instances by selecting randomly 10, 15, 20, 25 and 30 customer requests, respectively, from each Li & Lim instance with about 50 requests. The resulting instances have 20, 30, 40, 50 and 60 nodes (excluding the depot) respectively. Hence, for our experiments we have used a total of 396 instances. The original PDPTW instances are available at Li & Lim benchmark (2013) and the new PDPLT instances generated by us are available at Benavent, Mota, Landete and Tirado PDPLT benchmark (2014).This section is devoted to the analysis and comparison of the performance of the compact formulation, the branch-and-cut method based on the non-compact formulation and the heuristic procedure. Table 1summarizes the results obtained by these three approaches on the instances with 20–60 nodes (for a total of 280 instances). To simplify the presentation of the results and improve the readability of the table, only average results are presented for each group of instances according to their size (20, 30, 40, 50 and 60 nodes) and their type (lc1, lc2, lr1, lr2, lrc1 and lrc2), leading to a total of 30 groups. The first two columns show the name and the total number of instances of each group, respectively, and the rest of the table is divided in three parts, one associated to each solution method. The heuristic part contains five columns: the first one shows the average number of vehicles used in the heuristic solution (#veh), the average and maximum gaps are given in the following two columns (av. gap and max. gap), the number of instances for which the optimal solution was found (#opt) is given in the fourth column and the last column shows the running time in seconds. The gaps for the heuristic method are calculated as 100(UBH-UBB)/UBB , where UBH is the cost of the solution provided by the heuristic and UBB the cost of the best known feasible solution.The other two parts of the table (columns 8–15) show, for each exact method and for each group of instances, the average and maximum gap (columns av. gap and max. gap), the number of instances solved to optimality (#opt) and the average running time in seconds (time). Gaps for the exact methods are calculated as 100(UBB-LB)/UBB, where LB denotes the best lower bound provided by the respective exact method.The exact methods were run with a time limit of 3 hours. If this limit is reached before the branch-and-cut tree was completed when solving an instance, then the method provides a lower bound that is equal to the minimum of the lower bounds among all the open nodes and the best feasible solution found so far. The average running time was computed considering only those instances for which the exact method was completed. An ** indicates that no instance in the group could be solved to optimality. Since the compact formulation was not able to solve any of the lc instances with 50 nodes, nor any lr or lcr instances with 40 nodes, it was not applied to larger instances, which is indicated by — in the table.As it can be observed in Table 1, the heuristic method is able to obtain good quality solutions with short running times, quickly providing good upper bounds to be used by the exact methods. For the instances that were optimally solved by any of the exact methods, the heuristic procedure has reached a solution that is optimal or very close to the optimal. Concerning the exact methods, the branch-and-cut algorithm based on the non-compact formulation shows a better overall performance than the compact formulation, providing more exact solutions and smaller gaps with less computational effort. It is also noticeable how lr and lcr instances seem harder to solve than lc instances. All but one of the lc instances with up to 40 nodes were solved to optimality by the branch-and-cut procedure, as well as 7 instances with 50 nodes and 5 instances with 60 nodes. However, none of the lr or lcr instances with 60 nodes could be solved to optimality. In general, the average gaps for lr and lcr instances are significantly higher than the ones for lc instances, which shows that random instances seem to be harder than clustered ones. Recall that instances of groups lc1, lr1, lcr1 have tighter maximum route duration than instances of groups lc2, lr2, lcr2, which implies that a larger number of vehicles is used. The results shown in Table 1 seem to indicate that instances with more vehicles are harder.Since solving to optimality instances with more than 60 nodes was intractable, we decided to apply only the heuristic to the larger instances generated by Li & Lim and use the branch-and-cut method just to provide a valid lower bound. These instances are grouped in two sets: the ones belonging to the first set have between 100 and 110 nodes and the ones in the second set between 402 and 422 nodes (in both cases excluding the depot).The results for each instance are presented in Tables 2and 3, respectively. These tables show, for each instance, its name, the cost of the heuristic solution (ub), the number of vehicles (#veh), the gap with respect to the lower bound (gap), and the running time in seconds required by the heuristic (time). The average gap and time for each group of instances are given (in bold) in additional row.In Table 2 it can be observed that lc instances, with an average gap of 0.89 percent, seem to be easier than lr and lrc ones, with averagegaps of 10.51 percent and 13.41 percent, respectively. The results of this table show that instances with 100–110 nodes have been managed properly by the heuristic procedure within short computational times, and thanks to the branch-and-cut we have a guarantee of the quality of the solutions, that in the case of the lc instances are almost optimal. Note that for this set, instances with a larger number of vehicles show smaller running times and smaller gaps.The results presented in Table 3 for instances with more than 400 nodes exhibit a similar pattern, although the running times and gaps are obviously larger than those for the 100 nodes instances. Note that lc instances show gaps that are about 4 percent, which are quite small taking into account the large size of these instances.The closest variant to the PDPLT in the literature on pickup and delivery problems is the recent paper by Cherkesly et al. (2014) where time windows are associated to every pickup and delivery location, while no maximum duration time for the routes is explicitly considered. They succeeded in solving to optimality instances involving up to 75 requests (150 nodes) with a branch-price-and-cut algorithm based on solving constrained shortest path subproblems. The instances used in Cherkesly et al. (2014) are very different to the ones we have used because the existence of time windows drastically reduces the number of feasible routes, and thus a direct comparison of the performance of both methods is not possible.This paper deals with a particular version of the pickup and delivery problem with multiple vehicles that has not been considered up to now. In our problem, loading and unloading operations are subject to LIFO conditions and maximum duration constraints are applied to the routes. In this work we propose two mixed integer formulations for the problem: a compact formulation, in which the number of variables and constraints grows polynomially with the number of requests, and a non-compact formulation with an exponential number of constraints. Several sets of additional valid inequalities that improve the original formulations are proposed. New separation procedures were designed and implemented for those families of constraints with exponential size. These separation algorithms were used to implement an efficient branch-and-cut algorithm based on the non-compact formulation. Besides, a metaheuristic procedure based on a tabu search process embedded in a multi-start framework is also proposed. The performance of these solution methods was evaluated through extensive computational experiments performed on randomly generated instances with different characteristics and sizes. Overall, the branch-and-cut method based on the non-compact formulation exhibits a better performance than the method based on the compact one, and it was able to solve instances with up to 60 nodes (30 requests). The heuristic procedure reached the optimal solution in most of the instances for which it is known. When applied to larger instances (with more than 200 requests) the heuristic procedure requires relatively short running times and obtains good solutions, as it has been guaranteed by the lower bound given by the branch-and-cut method.Nevertheless, further research is needed to consistently solve medium size instances (with about 60 nodes). In order to achieve this, new valid cuts are needed to strengthen the non-compact formulation, as well as better branching strategies. The development of alternative exact methods, for example based on column generation techniques, could be also interesting ideas for future work in this problem, as well as the design of hybrid heuristics based on other metaheuristics that also worked successfully for other vehicle routing problems, such as variable neighborhood search or simulated annealing.

@&#CONCLUSIONS@&#
