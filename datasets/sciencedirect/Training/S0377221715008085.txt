@&#MAIN-TITLE@&#
Solving hard control problems in voting systems via integer programming

@&#HIGHLIGHTS@&#
We address various voting systems and types of control of elections.We show how hard control problems can be modeled as integer programs.We demonstrate that this allows to treat also larger elections successfully.We give a technique that adopts solutions of constructive control to destructive one.

@&#KEYPHRASES@&#
Voting system,Election model,Control problem,Integer programming,

@&#ABSTRACT@&#
Voting problems are central in the area of social choice. In this article, we investigate various voting systems and types of control of elections. We present integer linear programming (ILP) formulations for a wide range of NP-hard control problems. Our ILP formulations are flexible in the sense that they can work with an arbitrary number of candidates and voters. Using the off-the-shelf solver Cplex, we show that our approaches can manipulate elections with a large number of voters and candidates efficiently.

@&#INTRODUCTION@&#
When a group of people with individual preferences has to decide which alternative to choose from a given set of alternatives, an election is often carried out. The voting rule underlying the election can be regarded as an algorithm that computes from the individual preferences of the people (which in this context are called voters) those alternatives which are accepted as ‘best’ choices by the whole group. Ideally, there should be exactly one such alternative, the winning one.There are many different voting rules to determine the winners of elections, each coming with different advantages and drawbacks. For example, it is desirable to have a voting rule that can be computed efficiently and has exactly one winner. On the other hand, if it is easy to manipulate the election structure to get one’s favorite candidate to win, then this is regarded as negative in view of susceptibility to illegal influence. Walsh (2011) discusses the types of illegal influence. So, voting rules not only should be efficient, they also should be hard (ideally even impossible) to influence in an illegal way.Research on computational social choice applies techniques of computer science, mainly from algorithmic and complexity theory, to problems from social choice theory (see the overview papers of Brandt, Conitzer, and Endriss (2013) and Chevaleyre, Endriss, Lang, and Maudet (2007)). Central computational questions in the area of computational social choice are the efficiency of voting rules and their susceptibility to illegal influence. In this paper, we investigate a specific kind of illegal influence, called control. We investigate the case where an actor seeks to have a desired candidate winning the election by removing a set of voters (or candidates) from the election.Bartholdi, Tovey, and Trick (1992) have initiated a new line of research that investigates the susceptibility to control by techniques from complexity theory. The goal is to prevent attacks using certain types of control by showing that they lead to NP-hard decision problems. Following Bartholdi et al. (1992), numerous papers have investigated the complexity of control problems for elections (for example, Conitzer, Sandholm, and Lang (2007), Faliszewski, Hemaspaandra, and Hemaspaandra (2011), Faliszewski, Hemaspaandra, and Schnoor (2008), Hemaspaandra, Hemaspaandra, and Rothe (2007), and Rothe and Schend (2012)). For many voting systems it is shown that certain control problems are hard. From a theoretical point of view such voting systems can be regarded as secure against this attempt to illegal influence. The hardness results mentioned previously often assume a growing number of candidates and voters. It is known that many voting problems with few candidates are easy to manipulate (Conitzer et al., 2007; Walsh, 2007) as this restricts the number of choices the voters have.In the context of computational social choice, Walsh (2011) clearly demonstrates that NP-hardness is not a barrier to manipulations and illegal influences. Conitzer and Sandholm (2006) present a simple influence algorithm for elections that works fast and yields for most inputs (according to a suitably chosen probability distribution) the desired result. Another approach to solve hard control problems in practice is proposed by Berghammer, Danilenko, and Schnoor (2014), Berghammer and Schnoor (2014), and Berghammer (2014). It combines relation algebra and the BDD-based computer algebra system RelView and yields algorithms which are correct for all instances. Different problems from social choice have also been examined in the context of fixed-parameter tractability, and fixed parameter algorithms can be obtained in many cases by using integer programming formulations (see Hemaspaandra, Lavaee, and Menton (2012), Lindner and Rothe (2008)). For rules like Borda, Bucklin, and Copeland, it is fixed-parameter tractable with respect to the number of candidates to determine possible winners when given are incomplete votes (Betzler, Hemmann, & Niedermeier, 2009).We study voting problems in terms of the number of voters n and the number of candidates m, where both are variable. The present paper follows the line initiated by Gurski and Roos (2014) who used binary integer programming to solve some hard control problems for two closely related voting systems, known as Copeland voting and Llull voting, respectively. We show how the hard control problems of the (quite different) voting systems can be specified as integer programs, and present results of computational experiments. Our computational results show a good performances of the introduced approaches even if both the number of voters and the number of candidates is large.The remainder of the paper is organized as follows. In Section 2, we introduce the notion of a voting system and present the specific voting systems we will consider in this paper. Section 3 is devoted to several control problems in voting systems and their computational complexities. How to model the hard types of control for the voting systems of Section 2 as integer programs is shown in Section 4, which constitutes the core of the paper. Herein, we mainly concentrate on constructive control where the actor seeks to ensure his favorite alternative’s victory. Section 5 presents the results of our computational experiments, which we have performed on the test benchmark suite of the Preference Library (commonly referred to as PrefLib, Mattei and Walsh (2013)) using one of the well-known off-the-shelf solvers for integer programs. The results of our experiments show that our approach is able to solve all the test instances to optimality quite fast using an ordinary personal computer. Moreover, even the hard instances related to larger elections can be handled in reasonable time. Finally, Section 6 contains some concluding remarks and presents topics for future investigations in this area of work.In the following, we introduce the notions of a voting system and an election as generally used in social choice theory as well as the particular voting systems we will treat in this paper. For more details on voting in social choice theory and additional voting systems we refer to the studies of Brams and Fishburn (2007), Laslier (2012), Tideman (2007), and Brandt et al. (2013).In social choice theory, a voting system (also called a voting protocol) consists of a finite and non-empty set C of candidates (alternatives, proposals, options), a finite and non-empty set V of voters (players, agents, individuals), the individual preferences (choices, wishes) of the single voters, and a voting rule that aggregates the winners from the individual preferences. Usually the pair (C, V) is called an election. In such a definition the representation of the individual preferences remains out of consideration. Since it, however, will play a fundamental role in our approach, in this paper we use a slightly more general notion of elections and define them as triples (C, V, I), where the third component I is the specification of the individual preferences.To simplify presentation, in the remainder of the paper we assume that the two sets C and V are given asC={c1,…,cm}andV={v1,…,vn},wherem,n∈N>0are non-zero natural numbers.A well-known voting system is approval voting, introduced by Brams and Fishburn (2007) and, for example, presently used by several scientific organizations including the Mathematical Association of America and the Institute of Management Science. Here each voter may approve (that is, vote for) as many candidates as he wants and then the candidate with more approvals than all other candidates is declared as the winner. If we model the individual preferences by functions av: C → {0, 1} such thatav(c)=1iff voter v approves candidate c, for all v ∈ V and c ∈ C, then an approval election can be specified formally as a triple (C, V, (av)v ∈ V) and a candidate c* is then defined as the winner iff(1)∑v∈Vav(c*)>∑v∈Vav(c),for all c ∈ C∖{c*}. Note, that this specification of a winner implies winners to be unique. In case that inequality (1) holds, candidate c* is said to strictly dominate candidate c.The strict dominance relation D on the set C, for all c, d ∈ C defined by cDd iff ∑v ∈ Vav(c) > ∑v ∈ Vav(d), is asymmetric. But it may happen that there exist pairs of different candidates c and d such that neither cDd nor dDc. As a consequence, a candidate that strictly dominates all other ones (the winner) does not necessarily exist. For this reason, in the literature a variant of approval voting is also investigated, where dominance is weak. Here, candidate c* wins the election (C, V, (av)v ∈ V) iff for all c ∈ C it holds ∑v ∈ Vav(c*) ≥ ∑v ∈ Vav(c). The advantage of this variant is that winners always exist, while the disadvantage is that they may not to be unique. In this paper, we concentrate on voting systems with strict dominance and the unique-winner condition. It is not hard to translate all our results to the variants with weak dominance and possibly multiple winners.Approval voting can be regarded as a specific instance of a range voting system. (Unfortunately, the terminology is not unique in the literature on voting and instead of range voting various other names are used, e.g., scoring-based voting, average voting, utility voting, and ratings summation.) Elections of such voting systems are specified as triples (C, V, (sv)v ∈ V), where each scoring functionsv:C→Nspecifies how many points voter v gives to each of candidates, for all v ∈ V. A candidate with strictly more points than all other candidates is defined as the winner. Therefore, candidate c* wins the range election (C, V, (sv)v ∈ V) iff for all c ∈ C∖{c*} it holds(2)∑v∈Vsv(c*)>∑v∈Vsv(c).Another well-known voting system is the Borda voting system, also called Borda count and developed already in the 18th century by the French mathematician and political scientist J.-C. de Borda. Each single voter ranks all candidates from top to bottom without ties, i.e., in a strictly decreasing manner, under the simplest form of the Borda count by giving|C|−1points to the top candidate,|C|−2points to the next one and so on, with 0 points for the candidate being ranked last. The candidate with the most points is the winner. With regard to the specification of the voters’ preferences and the winner only, the Borda count can be interpreted as a specific instance of range voting, where all scoring functions svare injective and fulfill the range restrictionsv(C)={0,1,…,|C|−1}. But this similarity is rather simplistic. If additional features and properties are considered, then range voting and the Borda count show strong differences and these prevent such an interpretation in many cases. In view of the present paper it is important that such an interpretation makes it impossible to control Borda elections by changing the set of candidates – procedures, which are studied in the literature, e.g., in Eklind, Faliszewski, and Slinko (2011), Russell (2007) and Lorregia, Narodytska, Rossi, Venable, and Walsh (2015) – since a change of C usually destroys the range restrictionsv(C)={0,1,…,|C|−1}.The four voting systems we consider in the remainder of this section are preference-based. This means that, as in the case of Borda voting, each single voter ranks all candidates from top to bottom in a strictly decreasing manner. In contrast with Borda voting, however, now the individual preferences of the single voters v are modeled by means of linear strict orders >v(that is, asymmetric and transitive relations, where each pair of different elements is comparable) on the set C, which directly describes the strictly decreasing order of the candidates. For a given election (C, V, ( >v)v ∈ V) with a so-called preference profile( >v)v ∈ Vthe four following preference-based voting systems only differ in their voting rules.In the Condorcet voting system (named after the 18th-century French mathematician and philosopher N. de Condorcet) candidate c strictly dominates another candidate d iff the number of voters v with c >vd is strictly larger than the number of voters v with d >vc. As a consequence, candidate c* wins the Condorcet election (C, V, ( >v)v ∈ V) iff(3)|{v∈V:c*>vc}|>|{v∈V:c>vc*}|,for all c ∈ C∖{c*}. Already Condorcet noted a voting paradox that nowadays is called the Condorcet paradox. In our terminology it means that the strict dominance relation of a Condorcet election may contain cycles – even if it relates each pair of different candidates (i.e., is a so-called tournament relation). In such a case it may happen that there exists no winner.When the plurality voting system is used, the most common voting system in the Anglo-Saxon world, then candidate c strictly dominates another candidate d iff the number of voters with c as top preference is strictly larger than the number of voters with d as top preference. Thus, candidate c* wins the plurality election (C, V, ( >v)v ∈ V) iff(4)|{v∈V:c*=maxvC}|>|{v∈V:c=maxvC}|,for all c ∈ C∖{c*}. In (4) maxvC denotes the greatest element of the set C w.r.t. the linear strict order >v, i.e., that element c ∈ C for which c >vd for all d ∈ C∖{c}.The maximin voting system uses the maximin principle, originally formulated for two player zero-sum games, and also defines the winner by means of the cardinalities of the sets {v ∈ V: c >vd}. If we call |{v ∈ V: c >vd}| the advantage of candidate c over candidate d and define the functionΦ:C→NΦ(c)=min{|{v∈V:c>vd}|:d∈C∖{c}}that yields for each candidate the minimum of all its advantages over all other candidates, then candidate c* wins the maximin election (C, V, ( >v)v ∈ V) iff(5)Φ(c*)>Φ(c),for all c ∈ C∖{c*}, that is, iff it maximizes the minimum of all advantages over all other candidates and this maximum advantage is unique.Finally, we consider the Bucklin voting system, named after the American J.W. Bucklin but already proposed by Condorcet. Strictly speaking, we describe a rule that is known as simplified Bucklin rule. This rule is based on the candidates’ Bucklin scores, which are computed via the functionΨ:C→N>0Ψ(c)=min{k∈N>0:|{v∈V:c∈rankv,k}|>n2},where rankv, k≔ {c ∈ C: |{d ∈ C: d >vc}| < k} is the set of candidates which are ranked among the top k positions by voter v, for allk∈N>0and v ∈ V. In words, the Bucklin score Ψ(c) of candidate c is the least (positive) natural number k such that c is ranked among the top k positions by (strictly) more than half of the voters. By definition then, candidate c* wins the Bucklin election (C, V, ( >v)v ∈ V) iff(6)Φ(c*)<Φ(c),for all c ∈ C∖{c*}, that is, iff it minimizes the Bucklin scores and this minimum is unique.This section introduces the different types of control we consider in this paper and presents their computational complexities for the voting systems we have introduced in the previous section.If control problems in voting systems are modeled mathematically, then it is assumed that the authority conducting the election (the actor mentioned in the introduction, in the literature on voting systems is usually called the chair) knows all individual preferences of the single voters. His goal then is to achieve a specific result by a strategic change of the set of candidates or voters, respectively, but not of the individual preferences of the voters. To conceal his manipulations, the chair furthermore tries to change these sets as little as possible.The literature on voting systems investigates several types of strategic changes. In the present paper, we allow only deleting candidates and voters, respectively, as the chair’s possibilities. We mainly focus on constructive control as investigated for the first time by Bartholdi et al. (1992) in view of computational complexity. Using this type of control, the chair’s goal is to make his favourite candidate c* the winner. The counterpart of constructive control is destructive control. Here the chair tries to prevent a specific disliked candidate c* from being the winner. First results on the computational complexity of this type of control were given by Hemaspaandra et al. (2007).Usually, the problem of control of elections by deleting candidates or voters is specified as a minimization problem (Bartholdi et al., 1992; Hemaspaandra et al., 2007). If constructive control is done by deleting candidates, then the problem is as follows: Given an election (C, V, I) and the specific candidate c*, compute a minimum set of candidates M such that c* ∈ C∖M and the deletion of M from C and of its candidates from the individual preferences ensures that c* is the winner of the resulting election. To allow for an easier modeling in Section 4, we consider the dual maximization-problem and ask for(a)a maximum subset C* ⊆ C such that c* ∈ C* and c* wins the election (C*, V, I), in which the original individual preferences are restricted to C*.a maximum subset V* of V such that c* wins the election (C, V*, I), in which the original individual preferences are restricted to V*.In Section 2 we have explained by means of approval voting and the Condorcet paradox that in voting systems with strict dominance and the unique-winner condition it may happen that no candidate wins. This implies that also solutions of the control problems do not necessarily have to exist. When we later model control problems as integer programs, then the non-existence of a winner of a control problem will be expressed by the fact that the modeling program has no feasible solution.Given a voting system, some control problems may be easy, some may be hard, and in some cases it may even be impossible for the chair to reach his goal. If a control problem is easy, one says that the voting system is vulnerable to this type of control. In this case, there exists an efficient algorithm that solves the problem to optimality in polynomial time. If it is hard, one says that it is resistant to this type of control. This is formally specified by the NP-hardness of the decision problem corresponding to the original optimization problem with a bound for the size as an additional input. In case of constructive control by deleting candidates, an instance of the decision problem corresponding to the original minimization problem consists of an election (C, V, I), the specific candidate c*, and a natural number k. The question is whether it is possible to delete at most k candidates such that c* wins the resulting election. If a problem is unsolvable, one says that it is immune to this type of control. This means that it is never possible for the chair to reach his goal by the corresponding control action. In other words, no feasible solution exists for the unsolvable control problem.Inspired by the seminal paper of Bartholdi et al. (1992), scientists have investigated the hardness of control problems via the methods of complexity theory. See, e.g., the references given in the introduction or by Brandt et al. (2013) in Section 3.2 of their study. In the following, we summarize the results concerning the voting systems we have discussed in Section 2 and the four types of control we have considered above.Approval voting and Condorcet voting are vulnerable to destructive control by deleting voters and to constructive control by deleting candidates, resistant to constructive control by deleting voters, and immune to destructive control by deleting candidates. For the constructive control types these results are proved by Hemaspaandra et al. (2007) for approval voting and by Bartholdi et al. (1992) for Condorcet voting; for the destructive control types they are proved by Hemaspaandra et al. (2007). Since we have introduced approval voting as a specific instance of range voting, also the latter kind of voting is resistant to constructive control by deleting voters and immune to destructive control by deleting candidates. The Borda voting system is proved to be vulnerable to destructive control by deleting voters. The questions on complexity of constructive control types, as well as destructive control by deleting candidates are still open to the best of our knowledge. However, for elections of precisely three candidates the Borda voting system is vulnerable to constructive control by deleting voters, as shown by Russell (2007). We refer to the study of Eklind et al. (2011), Russell (2007) and Lorregia et al. (2015) for further discussions concerning the complexity of control of Borda elections. Plurality voting is vulnerable to constructive as well as destructive control by deleting voters and resistant to constructive as well as destructive control by deleting candidates. Here the proofs for the constructive control types are presented by Bartholdi et al. (1992) and those for the destructive control types again by Hemaspaandra et al. (2007). For maximin voting the situation is exactly contrary to plurality voting. The maximin voting system is vulnerable to constructive as well as destructive control by deleting candidates and resistant to constructive as well as destructive control by deleting voters. Concerning proofs of these facts we refer to the study of Faliszewski et al. (2011). Finally, Bucklin voting is vulnerable to destructive control by deleting voters and resistant to the three other types of control, i.e., destructive control by deleting candidates and constructive control by deleting candidates as well as voters. These facts are shown by Rothe and Schend (2012).Using Linear Programming (LP) has been shown to be successful for optimization problems in various fields (Chvátal (2007)). In the so-called standard form, an LP formulation consists of a linear objective functionf:R≥0n→R≥0given asf(x1,…,xn)=∑j=1ncjxjthat has to be maximized, and m linear inequality constraints∑j=1nai,jxj≤bi,1≤i≤m.Furthermore, there is the non-negative variables condition requiring thatxj∈R≥0.In many practical applications it is additionally required that the variables range over the setNonly. Restricting the variables to only non-negative integer values leads to an integer linear programming (ILP) formulation. In contrast to LP, the ILP problem is NP-hard as shown by Karp (1972) even for the special case of binary integer programming (abbreviated as BIP), where xj∈ {0, 1} is required. Nevertheless, there are tools available that also allow to solve larger instances of ILP and BIP by techniques like relaxation and branch-and-bound. Examples are the Mathlab LP solver, Xpress, Gurobi and the Cplex tool of IBM.In this section, we demonstrate how the hard control problems of the voting systems introduced in Section 3 can be specified as ILPs and BIPs, respectively. Without loss of generality, we work under the assumption thatc*=c1,i.e., that the chair’s goal is having the first candidate winning (loosing) for constructive (destructive) control. We consider the control problems as maximization problems as introduced in Section 3 via the specifications (a) and (b). We restrict us to constructive control and sketch in Section 4.6 how our models for constructive control can be adapted for destructive one.Since approval voting is the specific case of range voting where all scores are zero or one, we start our modeling with the constructive control of range voting by deleting voters. To this end, we assume a range election (C, V, (sv)v ∈ V) to be given. As a first step, we combine the list of scoring functions (sv)v ∈ Vinto a single matrixA∈Nm×nsuch thatAij=svj(ci),for alli∈{1,…,m}andj∈{1,…,n}. Next, we represent a solution of the control problem by the binary decision vector x ∈ {0, 1}nsuch thatxj=1iff voter vjis allowed to vote, for allj∈{1,…,n}. Consequently, we arrive at the binary integer program (RE) of Fig. 1that models the given problem.Because we ask for a maximum subset V* of V such that c1 wins the range election(C,V*,(sv)v∈V*),(7) describes the objective function as the maximum number of voters allowed to take part in voting. The set of constraints (8) supposes that candidate c1 is the unique winner of(C,V*,(sv)v∈V*)since it collects the largest total amount of scores. Finally, (9) states that variablesx1,…,xnare binary. Note that the solution of the proposed (RE) program is in the dual form respecting the initial problem statement given in Section 2.2. In fact, each value xj, wherej∈{1,…,n},withxj=0of the solution vector x defines voter vjto be excluded from the voting process in the standard form.We have already mentioned that a solution of a control problem not necessarily has to exist and this is expressed by the fact that the modeling integer program has no feasible solution. The sufficient condition of the existence of a feasible solution for the program (RE) is the existence of at least one voter whose preference list quotes c1 as the best candidate. Otherwise, deleting any subset of voters may not lead to a feasible solution where c1 wins.As the second problem, we investigate the constructive control by deleting voters for a given Condorcet election (C, V, ( >v)v ∈ V). Doing so, we represent the preference profile ( >v)v ∈ Vby a single binary matrixA∈{0,1}(m−1)×nsuch that for alli∈{1,…,m−1}andj∈{1,…,n}it holdsAij=1⇔c1>vjci+1.To give an example, if we assume the setC={c1,c2,c3,c4}of candidates, the setV={v1,v2,v3}of voters, and the preference profilev1:c1>v1c2>v1c3>v1c4v2:c1>v2c3>v2c2>v2c4v3:c4>v3c3>v3c2>v3c1,then the binary matrix A ∈ {0, 1}3 × 3 that represents this preference profile looks as follows:A=(110110110)We establish the binary decision vector x ∈ {0, 1}nto represent the solution V* of the problem, that is, havexj=1iff voter vjis permitted to vote in(C,V*,(>v)v∈V*),for allj∈{1,…,n},and candidate c1 is the unique winner of this election. Thus, we arrive at the binary integer program (CE) of Fig. 2for Condorcet elections.Constraint (10) defines the objective function as the maximum number of voters allowed to take part in voting. Constraints (11) ensure that for alli∈{2,…,m}the number of voters who gives a vote to candidate c1 over candidate ciis strictly greater than the number of those who prefers ciover c1. Indeed, the form of (11) is equivalent to the form∑j=1nAijxj>∑j=1n(1−Aij)xj,which is based on the idea that for each voter vjeither c1 dominates ciandAij=1,or c1 is dominated by ci, and thereforeAij=0and the coefficient(1−Aij)is 1. In fact, this set of constraints makes c1 a unique winner. Finally, (12) states that variablesx1,…,xnare binary.For the program (CE) the necessary condition of the existence of a feasible solution requires that for each candidate ci,i∈{2,…,m},there exists at least one voter vj,j∈{1,…,n},who prefers c1 over ci. A feasible solution always exists when the sufficient condition holds, thus, when there exists at least one voter who gives a top preference to candidate c1 over any other candidates.As the third problem, we consider the constructive control by deleting candidates for a given plurality election (C, V, ( >v)v ∈ V). Here, we assume the election’s preference profile ( >v)v ∈ Vto be specified by a list of n binary matricesA1,…,An∈{0,1}m×msuch that for alli,k∈{1,…,m}andj∈{1,…,n}it holdsAikj=1⇔ci>vjck.Note, that each Ajis nothing else than the binary matrix representation of the linear strict order>vj. Hence, in the case of the example from Section 4.2 we get the following binary matrices A1, A2, A3 ∈ {0, 1}4 × 4:A1=(0111001100010000)A2=(0111000101010000)A3=(0000100011001110)Since we seek for a maximum subset C* of the set C of candidates such that c1 wins the plurality election(C*,V,(>v*)v∈V),where(>v*)v∈Vdenotes the restriction of the preference profile ( >v)v ∈ Vto the set C*, we represent the solution by a binary decision vector x ∈ {0, 1}msuch thatxi=1iff candidate ciis admitted to take part in the election, for alli∈{1,…,m}. Furthermore, we introduce a set of auxiliary binary variableszij,wherezij=1holds iff candidate ciis of the highest preference for voter vjamong the set of candidates chosen by the vector x, for alli∈{1,…,m}andj∈{1,…,n}. In such a way, the solution of the problem can be derived by the binary integer program (PE) of Fig. 3.Here, (13) defines the objective function as the maximum number of candidates admitted to take part in the election. Constraints (14) imply that for alli∈{1,…,m}andj∈{1,…,n}voter vjmay give the highest preference to candidate ciover all other candidates selected by the vector x only if there exists no candidate ck,k∈{1,…,m},that is preferred by vjover ci. In its turn, (15) imposes that when candidate ciis allowed to the contest, either cimust be of the highest preference for the voter vj, or a candidate ckpreferred over cimust exist. Each of constraints (16) enforces that candidate cicannot be of the highest preference for any voter if he is not permitted to participate in the election, for alli∈{2,…,m}. Thus, the constraint requires for alli∈{2,…,m}andj∈{1,…,n}thatzij=0if candidate cihas been deleted from the election. The next constraints (17) ensure that candidate c1 is the candidate with the highest number of voters having c1 as top priority, and therefore is strictly preferred over other candidates. Implicitly, this set of constraints requiresx1=1and hence candidate c1 has to be selected in any feasible solution. Finally, (18) and (19) state that variablesx1,…,xmandz11,…,zmnare binary.There always exists a feasible solution for the program (PE), which is guaranteed by possible deleting of all candidates but candidate c1 as the worst case.The fourth problem we consider is the constructive control by deleting voters in elections with the maximin voting rule. We assume that the preference profile ( >v)v ∈ Vis given by a list of n binary matricesA1,…,An∈{0,1}m×msuch thatAikj=1⇔ci>vjck,for alli,k∈{1,…,m}andj∈{1,…,n}. We use a binary decision vector x ∈ {0, 1}nto represent the solution, wherexj=1iff voter vjhas a permission to vote, for allj∈{1,…,n}. Thus, the advantage of candidate ciover candidate ckcan be computed asadvmaximin(ci,ck)=∑j=1nAikjxj,for alli,k∈{1,…,m}. Now, let candidate c1 be the winner of the maximin election and let the positive integer variable b define the minimum advantage of c1 over any other candidate. Subsequently, let for alli,k∈{1,…,m}with i ≠ 1 and i ≠ k the auxiliary binary variablezik=1denote a situation whenadvmaximin(ci,ck)<b.Then, the solution of the posed problem can be derived by the integer program (MME) of Fig. 4.Here, (20) defines the objective function as the maximum number of voters allowed to take part in voting. Next, the set of constraints (21) strictly bound the advantage values of any candidate but c1 by b. Its combination with constraints (22) forces at least the minimal advantage value of each candidate cito be bounded by b, for alli∈{2,…m}. In its turn, constraints (23) bound, and therefore define b as the minimal advantage of c1. Finally, (24) and (25) state that variablesx1,…,xnandz21,…,zmmare binary, while (26) states that b is a positive integer.There always exists a feasible solution for the program (MME) if candidate c1 is a winner concerning at least one of the voters. In fact, if there is voter vj,j∈{1,…,n},whose top preference is c1, then deleting of all other voters in the worst case makes c1 the winner of the maximin-based rule election.The last two constructive control problems address elections with the (simplified) Bucklin voting rule, which is resistant to the constructive control by deleting voters as well as by deleting candidates.We start first with the variant of the problem which stipulates deleting voters. Doing so, we assume now that the preference profile ( >v)v ∈ Vis described by a list of n binary matricesA1,…,An∈{0,1}m×msuch that for alli,k∈{1,…,m}andj∈{1,…,n}it holdsAikj=1⇔{k∈{m′,…,m}andvotervjranksthecandidateciasm′thinhispreferencelist.In other words, candidate cimay obtain at least m′ as the personal score from voter vj. In such a way, cigets 1 for each entry in the row i of binary matrix Ajwhen it is the most preferred by vjover other candidates.In case of the example from Section 4.2 we get the following binary matricesA1,…,A3∈{0,1}4×4:A1=(1111011100110001)A2=(1111001101110001)A3=(0001001101111111)Subsequently, to represent the problem’s solution we employ a binary decision vector x ∈ {0, 1}n, wherexj=1iff voter vjparticipates in voting. Therefore,∑j=1nAikjxjdetermines the number of voters ready to give the score k to candidate ci. Let, for alli,k∈{1,…,m},the auxiliary binary variablezik=1describe the situation when strictly more than a half of the voters allowed to vote agree to give the score of k, i.e., rank ciamong the top k candidates. Then, the solution of the problem can be obtained by the binary integer program (BEV) of Fig. 5.Constraint (27) defines the objective function as the maximum number of voters allowed to take part in voting. Constraints (28) imply that each candidate cimay earn the score k iff it obtains votes of strictly more than a half of the participating voters, for alli,k∈{1,…m}. Specifically, the form of (28) is the reduction of the form12+12∑j=1nxj−∑j=1nAikjxj+nzik≤n,where the first constant ensures the strictness concerning the half of the total number of votes given to ci, the second term defines the half of all the available votes, the third term calculates the number of participating voters ready to give the score k to ci, and finally the combination of the fourth term and the constant in the right hand side introduces trigger variable zikto handle the corresponding situation. Next, for alli∈{2,…,m}andk∈{1,…,m},constraints (29) force indicator variable zikbe equal to 1 every time when ciearns votes of more than a half of the participating voters. The form of (29) is in fact equivalent to the inequality12∑j=1nxj−∑j=1nAikjxj+nzik≥0.When each of the variables zikreveals that the given threshold is reached, then (30) requires the minimal score obtained by the first candidate c1 be strictly less than the scores obtained by any other candidates. Indeed, the form of constraints (30) results from the form(34)∑l=1mlz1l+1≤kzik+n(1−zik),where the left hand side defines the minimal score obtained by c1 and ensures the strictness of the inequality of the voting rule, while the right hand side defines the score obtained by ciand bounds the former. Note that constraints (29) are imposed for all the candidates but the first one. Therefore, variable z1kmay not take the value of 1 for multiple scores k,k=1…m,while variable zikfori=2…mmust do this according to (29). This makes only one of the variables z1lequal to 1 in the sum in the left hand side part of (34). It is exactly the case corresponding to one of the possible scores l (at least the smallest one), since the left hand side part is bounded by the right hand side part, while constraint (31) asks at least one variable z1krelated to c1 be set to 1. In fact, (31) guarantees that at least the indicator pointing to the least score obtained by c1 will trigger. Finally, (32) and (33) state that variablesx1,…,xnandz11,…,zmmare binary.Similarly to the program (CE), the same necessary condition on the existence of a feasible solution must hold for the program (BEV). It requires the existence of at least one voter who prefers c1 over ci, for eachi∈{2,…,m}. If this condition fails, then no subset of voters can be deleted in order to guarantee c1’s win. As the sufficient condition for the feasible solution, it is required that at least one voter exists, who gives a top preference to c1 over any other candidates.Herein, we deal with the second variant of the control problem, where a subset of candidates may be deleted from the Bucklin election. Compared with the first case we change the input. Now, we suppose that the preference profile ( >v)v ∈ Vis modeled as in the cases of plurality voting and maximin voting, that is, by a list of n binary matricesA1,…,An∈{0,1}m×msuch thatAikj=1⇔ci>vjck,for alli,k∈{1,…,m},andj∈{1,…,n}. A binary decision vector x ∈ {0, 1}mis used for the solution description, wherexi=1iff candidate ciis admitted to take part in the election, for alli∈{1,…,m}.We construct the model in such a way that for alli∈{1,…,m}andj∈{1,…,n}candidate cimay obtain at least m′ as a personal score from voter vjwhen exactlym′−1candidates have higher ranks in vj’s preference list. To reveal this fact, we use a set of auxiliary binary variablesyilj,wherej∈{1,…,n}andi,l∈{1,…,m},such thatyilj=1when candidate cican get the score of value l from voter vj, i.e., when the number of available candidates preferred by vjover ciis strictly less than l. Subsequently, we determine the number of voters ready to give the score l to candidate cias∑j=1nyilj. Let the further auxiliary binary variableszil=1for alli,l∈{1,…,m}denote the situation when strictly more than half of the voters rank candidate ciamong the top most l candidates. Then, the solution of the posed problem can be computed via the binary integer program (BEC) of Fig. 6.Here (35) defines the objective function as the maximum number of candidates admitted to take part in the election. Each of constraints (36) permits the candidate cito get a personal score of value l iff the number candidates preferred by the voter vjover ciis strictly less than l. The form of (36) is the outcome of∑k=1mAkijxk+yilj−m(1−yilj)≤l,where the first term defines for voter vjthe number of candidates which dominate ci, while the remaining part introduces the trigger variableyilj. Each of constraints (37) implies that candidate cigets the personal score l from voter vjwhen ranked among the top most l candidates and it participates in the election. Indeed, the form of (37) is equivalent to∑k=1mAkijxk+myilj+m(1−xi)≥l.Subsequently, for alli∈{2,…,m}constraints (38) restrict each candidate cito get any personal scores when it is not allowed in the election. For alli,l∈{1,…,m}the set of constraints (39) allows candidate cito earn the score l iff it obtains strictly more than a half of all votes. In fact, the form of (39) results from12+n2−∑j=1nyilj+nzil≤n,where the first constant ensures the strictness concerning the half of the total number of votes given to ci, the second term defines the half of all votes, the third term calculates the number of voters ready to give the score l to ci, and finally the combination of the fourth term and the right hand side constant introduces the trigger variable zilto handle the corresponding situation. In its turn, constraints (40) force each indicator zilto be equal to 1 every time when ciearns votes of more than a half of voters, for alli∈{2,…,m}and alll∈{1,…,m}. When zilreveals that the given threshold is reached, (41) requires the minimal score obtained by the first candidate c1 to be strictly less than the scores obtained by any other candidates. The form of (41) is equivalent to(46)∑q=1mqz1q+1≤lzil+n(1−zil),where the left hand side defines the minimal score obtained by c1 and ensures the strictness of the inequality of the voting rule, while the right hand side defines the score obtained by candidate ciand bounds the former. Note that constraints (40) are imposed for all the candidates except c1. Therefore, variable z1lmay not take the value of 1 for multiple scores l in (40),l=1…m,while variable zilfori=2…mmust do this. Along with constraint (42), this forces only one of the variables z1qbe equal to 1 in the sum in the left hand side part of (46). It is the case corresponding to one of the possible scores q for c1 (at least the smallest one) as the left hand side part is bounded by the right hand side part. Constraint (42) implies that c1 must get at least one of the scores, thus at least one variable z1qmust be set to 1. In fact, it guarantees that at least the indicator pointing to the least score obtained by c1 will trigger. Finally, the sets of constraints (43), (44) and (45) declarex1,…,xm,y111,…,ymmnandz11,…,zmmas binary.There always exists a feasible solution for the (BEC) program which is guaranteed by deleting all possible candidates but c1.At the beginning of Section 4 we have promised to sketch how our models proposed for problems of constructive control can be adopted for ones of destructive control. Here, we explain the possible transition by the example of range voting. Recall the decisive constraints (8) of the program (RE). If we combine these constraints into the single formula(47)(∑j=1nA1jxj−∑j=1nA2jxj≥1)∧…∧(∑j=1nA1jxj−∑j=1nAmjxj≥1),then the binary decision vector x ∈ {0, 1}nof the program (RE) represents a subset V* of the set of voters V such that candidate c1 wins the range election(C,V*,(sv)v∈V*)iff (47) holds. As a consequence, c1 is not the winner of(C,V*,(sv)v∈V*)iff the negation of (47) holds, or, equivalently, iff(48)(∑j=1nA1jxj−∑j=1nA2jxj≤0)∨…∨(∑j=1nA1jxj−∑j=1nAmjxj≤0)is true. Such constraints with disjunctions are frequently called k-fold alternative constraints, where k defines the least number of constraints of the set which must be satisfied. In fact, mathematical programs with alternative constraints are no longer linear. But there is a standard technique to transform alternative constraints into a set of equivalent linear constraints; for details, see Chapter 9 of Bradley, Hax, and Magnati (1977). In our case it usesk=1and replaces (48) by(49)∑j=1nA1jxj−∑j=1nAijxj≤M(1−yi)i∈{2,…,m}(50)∑i=2myi≥1(51)yi∈{0,1}i∈{2,…,m}where each of auxiliary binary variablesy2,…,ymreflects the satisfaction of the corresponding inequality of (48), and M is a large constant. In fact,yi=1when candidate c1 obtains less or equal number of scores than candidate ci. The constant M ensures that for alli∈{2,…,m}the formula∑j=1nA1jxj−∑j=1nAijxj≤M(1−yi)holds ify=1. Here M is set asM=n·maxi∈{1,…,m},j∈{1,…,n}Aij. The constraint (50) implies that at least one inequality of (48) holds, and therefore there exists at least one candidate with scores equal or greater than candidate c1’s. In such a way, to obtain the model for the destructive control problem one needs to replace constraints (8) of the (RE) model by (49) and (50), and add those of (51).To adopt other proposed models in order to tackle the destructive control problems, it is necessary to substitute constraints responsible for the winner’s determination with corresponding k-fold constraints.In this section, the performance of the integer programs proposed in Section 4 is evaluated in terms of their solution quality and the needed computation time. We have implemented the program code in the programming language JAVA using the Cplex 12.6 library with default settings such as 1e-6 for the feasibility and optimality tolerances and 1e-5 for the integrality tolerance. The experiments have been carried out on a desktop PC with an Intel Core i7 processor with 2.0 gigahertz and 8 gigabyte RAM.In the following, the efficiency of the proposed integer programming election models is evaluated via PrefLib, assembled by (Mattei & Walsh, 2013). PrefLib is a centralized repository of real world preference data. Currently this library holds over 3000 datasets in an easily available and computer readable form. The data comes from various sources and locations. They are based on real elections (e.g., from Aspern, Berkley, Dublin, Glasgow, and trade unions in the European Union), real competitions (like the women’s 1998 skating world championships and cross country skiing from the 2006–2009 world championships), comparison of websearches (across Bing, Google, Yahoo and Ask), reviews of hotels and etc. Despite the voters of each instance of the library are grouped according to the equality of their preference lists, in our experiments we treat them independently assigning each one a separate decision variable. Furthermore, we select the first candidate of the list of candidates provided by each instance as the target winner c1.To evaluate the range election model from Section 4.1, we adopt the instances of the “Tied Order - Complete List” benchmark suite of PrefLib (Mattei & Walsh, 2013). Within this suite both the relation of equivalence and the strict order relation between the candidates may exist for each of the voters. For every instance of the suite we construct the election as Borda-like election11Note, that the elections are not Borda elections since the instances allow ties., i.e., by assigning the score of valuem−1to the most preferred candidates of a voter,m−2to ones at the second place, and so on, while the least score of 0 is given to the candidate at the last place m in a linearly ordered preference list (without ties) only. The up-to-date version of the benchmark suite consists of 331 instances. The largest instance in terms of the number of voters contains 299 664 voters and 5 candidates, while the largest instance in terms of the number of candidates has 2 819 of them and 4 voters. Exactly 293 of the 331 instances have been solved either to optimality or to optimality respecting the optimality tolerance. For each of the other 38 instances the infeasibility of the solution concerning the first candidate as a winner has been detected. The specific reasons that result in infeasibility are discussed in Section 4.1. The computation time per instance is at most 3.5 seconds, while the median over all instances is 0.016 seconds only. In fact, all the range election instances from the presented benchmark suite can be easily solved. The total computation time over the whole suite is 25 seconds.To test the other proposed integer programming election models of Section 4 we employ the instances of the “Strict Orders - Complete List” benchmark suite of PrefLib (Mattei & Walsh, 2013). Within this suite only a strict order relation between each pair of candidates is given for every voter such that the candidates are linearly ordered by each single voter. The suite contains 627 instances in total. The largest instance in terms of the number of voters has 14 081 of them and 3 candidates, while the largest instance in terms of the number of candidates has 242 of them and 5 voters. Table 1contains the information concerning the computation times required by the Cplex solver to find the optimal solutions for the instances of the Condorcet, plurality, maximin and Bucklin election models. The whole set of test instances is partitioned into four classes according to the number m of candidates. Thus, the first class contains instances whose number of candidates m falls into the range from 1 to 9, while the second, third and fourth classes have the number of candidates in the ranges 10–99, 100–199, and greater than 200, respectively. The classes correspond to the last four columns of the table one-to-one. The first four rows of the table report the number of candidates m, the number of voters n, the median n′ of the number of voters, and the number of instances c in each of the classes, respectively. Therefore, most of the instances are rather small in terms of the number of candidates. Specifically, 523 of them are contained in the first class. The remaining rows are grouped and present the minimum, median, average and maximum computation time over each of the classes for every election model we have presented.For the Condorcet election model of Section 4.2, exactly 605 out of 627 instances have been solved to optimality. For the remaining 22 instances infeasibility respecting the target win of the first candidate has been shown. It takes significantly less than a second to solve any of the instances, while the whole suite has been computed in 5.5 seconds.For the plurality election model of Section 4.3, optimal solutions have been found for all instances of the suite. Here 613 instances, thus almost all of the 627 instances, require less than a second to be solved. However, one instance occurred that needs significantly more computation time comparing to the others. It has the largest mn product, i.e., the value that strongly correlates with the number of constraints used by the model. Specifically, its mn product is 50 000 and it takes 324 seconds to find the optimal solution. The whole suite can be evaluated in 407 seconds.For the maximin election model of Section 4.4, exactly 605 out of 627 instances have been solved to optimality, where 619 instances require less than a second of computation time. For the unsolved 22 instances infeasibility respecting the win of the first candidate has been proved. The maximum computation time over all instances results in 28 seconds. In fact, only the instances of the last class corresponding to the largest m incur considerable computation time. The whole suite has been evaluated in 117 seconds.For the Bucklin election model with deleting voters of Section 4.5, again for 605 out of 627 instances optimal solutions have been obtained. Exactly 593 instances are computed rather fast; each within one second. Only the last two classes of instances with a larger value of m are time-consuming. The whole suite for this model is solved in 430 sec.The Bucklin election model with deleting candidates of Section 4.5 has shown to be considerably harder to solve. Despite of the fact that 433 of the 627 instances have been solved within a second, there are hard instances with a maximum computation time of around 8.5 hours. Specifically, all the instances with a number of candidates greater than 100 are rather time-consuming. Even the instances with a small number of candidates but large number of voters require considerably more time than those of other election models. This is mainly because of the increased number of auxiliary variables and constraints used for the problem representation. For all instances the optimal solutions have been found in a total computation time of approximately 28 hours.

@&#CONCLUSIONS@&#
