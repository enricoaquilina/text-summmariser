@&#MAIN-TITLE@&#
Compression of double array structures for fixed length keywords

@&#HIGHLIGHTS@&#
A new compression method of the double array is proposed.The BASE array is removed from the double array.The retrieval and construction algorithms are proposed.The space usage of our method is more compact than that of the double array.The retrieval speed of our method is almost the same as the double array.

@&#KEYPHRASES@&#
Trie,Double array,Fixed length keyword,Compression method,

@&#ABSTRACT@&#
A trie is one of the data structures for keyword matching. It is used in natural language processing, IP address routing, and so on. It is represented by the matrix form, the link form, the double array, and LOUDS. The double array representation combines retrieval speed of the matrix form with compactness of the list form. LOUDS is a succinct data structure using bit-string. Retrieval speed of LOUDS is not faster than that of the double array, but its space usage is smaller. This paper proposes a compressed version of the double array by dividing the trie into multiple levels and removing the BASE array from the double array. Moreover, a retrieval algorithm and a construction algorithm are proposed. According to the presented experimental results for pseudo and real data sets, the retrieval speed of the presented method is almost the same as the double array, and its space usage is compressed to 66% comparing with LOUDS for a large set of keywords with fixed length.

@&#INTRODUCTION@&#
Keyword matching is very important in many applications. A trie is one of the data structures for the keyword matching, and is an ordered tree data structure merged the prefixes of keys. It can not only retrieve keywords corresponded to an input keyword exactly, but also retrieve common prefix keywords and predictive keywords. Its applications include information retrieval systems (Brain & Tharp, 1994), natural language processing (Baeza-Yates & Gonnet, 1996), IP address routing tables (Fu, Hagsand, & Karlsson, 2007), packet filtering (Srinivasan, Varghese, Suri, & Waldvogel, 2007), and so on. Moreover, as the trie is often used as an associative array (Gusfield, 1997) which is also called a map, the trie is used both for dynamic and static key sets.Traditionally, the trie was represented by a two-dimensional array called the matrix form and by a linked list called a link form. Retrieval speed of the matrix form is very fast, but it needs large spaces. The space of the link form is efficient, but its retrieval speed is relatively slow. Aoe presented an efficient data structure for the trie called the double array (Aoe, 1989; Aoe, Morimoto, & Sato, 1992; Yata, Oono, Morita, Fuketa, Aoe, 2007; Yata, Oono, Morita, Fuketa, Sumitomo, et al., 2007). This method uses two arrays called BASE and CHECK, and combines retrieval speed of the matrix form with compactness of the list form. As these schemes reduce the space usage of the double array, a method that CHECK array keeps character codes is proposed (Yata, Oono, Morita, Fuketa, Aoe, 2007; Yata, Oono, Morita, Fuketa, Sumitomo, et al., 2007). This method is useful to make the double array compact and its retrieval speed is almost as fast as the original double array. However, the space usage is still big.Level-Order Unary Degree Sequence (LOUDS) by a succinct data structure is proposed as a structure of the trie (Jacobson, 1989). The space usage of this method is much smaller than that of the double array, but its retrieval speed is not so fast.This paper proposes the compression data structure of the double array by deleting the BASE array, which is called a single array. Furthermore, the proposed method divides the trie for each depth. In this method, as BASE array is deleted and CHECK array keeps character codes, the space usage is very small. As this data structure keeps features of the double array, its retrieval speed is very fast.Section 2 describes the trie and the double array. Section 3 defines the single array data structure, and proposes retrieval and construction algorithms for this data structure. Theoretical and experimental evaluations for pseudo and real data sets are given in Section 4. Finally, Section 5 concludes the presented algorithm and describes further works.Trie is an ordered tree data structure that merges the prefixes of keys. Fig. 1shows the trie of a key set K={ab#, abc#, b#, bac#, bb#}. Special end marker # is added to the ends of all keys. The marker is used to avoid confusion between keys “ab” and “abc”. A traversal on the trie starts from a root node (state number 1), and retrieves each character in the key step by step.The trie can not only retrieve keywords corresponded to an input keyword exactly, but also retrieve the following keywords;(1)Predictive search: when an input keyword is “a”, keywords starting with “a” are retrieved.Common prefix search: when an input keyword is “abc”, “a”,”ab” and ”abc” are retrieved.The trie is generally represented by matrix and list forms. Fig. 2shows a matrix form for key set K. Retrieval speed of the matrix form is very fast, but it takes large spaces. The space of the list form is efficient, but its retrieval speed is not so fast because it requires to traverse sibling states in order to traverse child states.Fig. 3shows an example of the LOUDS data structure. When LOUDS is built, the trie is first traversed in breadth-first order. When the traversed state has k child states, k bits of 1 and one bit of 0 are stored to array B, and characters traversed from the state to the child state are stored to array C. In Fig. 3, because state 0 has 2 child states, 1,1 and 0 are stored to B[1], B[2] and B[3], respectively. The two child state numbers are determined as 1 and 2. ‘a’ and ‘b’ are stored to C[1] and C[2], respectively. For the retrieval, the following two functions are used;select0(i) returns the index of ith bit 0 in array Brank(i) returns the number of bit 1 from B[1] to B[i]where the function rank returns 1 for i=0. The first child state t of state s is computed with t=select0(rank(s))+1. The sibling state of state t is computed with t+1 until B[t]≠1. The character traversed from state s to state t is C[rank(t)]. In Fig. 3, when s is 6, rank(6) is 4 and select0(4) is 12. Therefore, the first child state of state 6 is 13(=select0(rank(6))+1). Moreover, state 6 has one child state and the character traversed to state 13 is ‘c’(=C[rank(13)]), because B[13] and B[14] are 1 and 0, respectively.The space usage of LOUDS is very small, because LOUDS is a succinct data structure using bit string. But its retrieval speed is not so fast because of computing the functions select0 and rank.A double array proposed by Aoe is one of data structures of the trie and combines retrieval speed of the matrix form with compactness of a list form. In the double array, when character c in a key traverses from parent state s to child state t, it is satisfied as follows;(1)t=BASE[s]+CODE[c]CHECK[t]=sCharacter c traverses from state s to state t by the first equation. Connection between state t and state s is checked by the second equation. CODE[c] represents a numerical code of character c. CODE[c] for all characters are unique in order not to traverse to the same child state number by a different character from the parent state number. Fig. 4shows a CODE array and a double array for key set K. The state numbers of the double array are corresponded to indexes of BASE and CHECK, and the state numbers are defined during registering keys. As all states numbers are defined to satisfy with Eq. (1), unused state numbers happen to exist in BASE and CHECK arrays. The maximum of the state number and the size of BASE, CHECK arrays become bigger with increasing the unused states. In Fig. 1, character ‘a’ traverses from state number 6 to state number 3. Child state number t is set to BASE[6]+CODE[a]=3, then it is checked that s is equal to CHECK[3]. Traversing one character takes O(1).Moreover, a compact double array is proposed by Yata. In this data structure, character c of key is stored as a value of CHECK array. That is to say, Eq. (1) is changed as follows:(2)t=BASE[s]+CODE[c]CHECK[t]=cIn the double array, when BASE[i] is equal to BASE[j](i≠j), character c from state number i and j traverses to the same child state t. Therefore, the parent state number must be stored to CHECK[t]. If BASE values are unique, character c from state number i and j always traverses to other child states. Therefore, in the compact double array, BASE values must be unique and character c can be stored to CHECK array. The double array of Fig. 4 can be changed to a compact double array because each BASE value is unique. Fig. 5shows a compact double array of key set K. CODE is the same as Fig. 4. As character ‘a’ traverses from state number 6 to state number 3, CHECK[3] is ‘a’.In an original double array proposed by Aoe (called ODA), CHECK stores the parent state number. When the large number of keys is registered to the trie, state numbers in the trie are increased. Then, CHECK arrays are represented by 2 bytes or 4 bytes with growing the number of states for a large key set. But, in the compact double array proposed by Yata (called CDA), CHECK stores a character. CHECK arrays are always represented by 1 byte. The size of BASE array is the same in both methods.We propose a new data structure that can reduce the size of the double array by removing BASE array.If BASE[s] is set to s, Eq. (1) is as follows;(3)t=s+CODE[c]CHECK[t]=sIn this method, BASE array can be removed. This method is called single array. The space usage of this method is smaller than that of the double array. When the double array is built, CODE values are fixed, and then BASE values are determined by orders of the depth. But, in case of equation 3, only CODE values must be determined, because BASE values are fixed as s (the state number). The child state number cannot be determined without determining the parent state number. For example, let us consider a key set is ‘ab’ and ‘ba’. The CODE value of character ‘a’ is not determined without determining the CODE value of character ‘b’. The CODE value of character ‘b’ is not determined without determining the CODE value of character ‘a’. Therefore, all CODE values must be determined at the same time. When the number of keys increases more, it is more difficult to build the double array satisfied with equation 3. To solve this problem, this paper proposes a method to divide the trie into each depth, and the CODE have values for each depth.First of all, the following condition is applied for all state numbers.x<y(x∈Dk,y∈Dk+1,1≦k≦n-1)where Dkis a set of state numbers of the trie for depth k, n is the maximum depth of the trie. CODE has different values in each depth by dividing the trie into each depth. Here, CODE array is changed to two-dimensional arrays (called multi CODE). When character c of key traverses from parent state x to child state y, the following equation is defined;y=x+CODE[k][c](x∈Dk,y∈Dk+1,1≦k≦n+1)When CODE values for all characters are unique in depth k, it is impossible to traverse the same child state number for depth k+1 from parent state number x for depth k by character c. When there are CODE for each depth, CODE values can be determined by orders of the depth. When all unused CODE values are set to 0, y becomes x from the above mentioned equation. Then, character c cannot be traversed because of ∉Dk+1.In case of Eq. (2), values of fast BASE[s] are unique not to traverse the same state number by more than one character for storing character c to CHECK. In case of Eq. (3), s is always unique because of s=BASE[s], and it is impossible to traverse the same child state number by t=s+CODE[k][c]. Therefore, character c can be stored to CHECK array. Finally, the following equations are determined;(4)t=s+CODE[k][c](s∈Dk,t∈Dk+1,1≦k≦n+1)CHECK[t]=cBASE array is removed from the double array and CODE array become a two-dimensional array. This structure is named SAMC (Single Array with Multi CODE). Fig. 6shows SAMC for key set K. The maximum state numbers for each depth are stored to MAX array. This array is used in the retrieval algorithm.An input of retrieval algorithm is KEY=a1, a2, …, an, an+1=’#’ (length=n). An output is true if KEY is found. An output is false if KEY is not found. The difference between the presented method and the original double array is the way to check the range of child state number t. In the double array, the retrieval algorithm checks if t is not bigger than the maximum state number. The presented method checks if t is contained in the state numbers of next depth in (R-4). Other parts of this algorithm are the same as the original double array.[Retrieval Algorithm](R-1) s=1;(R-2) for(k=1;k<=n+1;k++){(R-3)t=s+CODE[k][ak];(R-4)if(MAX[k]<t≦MAX[k+1] && CHECK[t]==ak){(R-5)if(k==n+1)return true;(R-6)s=t;(R-7)}(R-8)else{(R-9)return false;(R-10)}(R-11)}The above algorithm is explained by retrieving key ‘ab#’ with the length n=2 from the SAMC as shown in Fig. 6.First of all, s is set to 1 in step (R-1). Next, k is set to 1 in step(R-2) and t is set to s+CODE[1][‘a’]=1+1=2 in step (R-3). MAX[1](=1)<t≦MAX[2](=3) and CHECK[t]=’a’ for step(R-4) are satisfied. Therefore, child state s is set to t(=2) in step(R-6). Repeat for character ‘b’ and ‘#’ as follows;k=2,t=s+CODE[2][‘b’]=2+3=5,s=5k=3,t=s+CODE[3][‘#’]=5+5=10Finally, because k=n+1 is satisfied in step(R-5), this algorithm returns true and is finished.Construction algorithm of SAMC is presented in this section. After all keys are registered to the trie called an original trie by a linked list or a matrix representation, the state numbers and CODE values of a new trie for SAMC are determined by orders of the depth in this algorithm. Both state numbers of root node for the original trie and the new trie are 1.The following parameters and a function are introduced.height: the height of the trie (The maximum depth of the trie)Pk: a set of a pair state numbers(o, s) for depth k, where o and s are for the original trie and for the new trie, respectively.S_SET: a set of the pair of state numbers(o, s) extracted from Pk.Σ: a set of characters to traverse in the trie.Y_CHECK(k, S_SET): This function returns minimum q that is satisfied with CHECK[s+q]=unused and s+q>MAX[k] for (o, s)∈S_SET and CODE[k][c]≠q for c∈Σ.(C-1) All CODE values are set to 0.(C-2) (1, 1) is set to P1(C-3) MAX[1] is set to 1(C-4) for(k=1; k<height; k++){(C-5)Pk+1=∅;(C-6)foreach c in Σ{(C-7)S_SET=∅(C-8)foreach (o, s) in Pk{(C-9)When c can be traversed from o in the original trie, (o, s) is added to S_SET(C-10)}(C-11)if(S_SET≠∅){(C-12)CODE[k][c]=Y_CHECK(k, S_SET)(C-13)foreach (o, s) in S_SET{(C-14)The state number t traversed from s by c is set to s+CODE[k][c].(C-15)CHECK[t] is set to c(C-16)(the state number traversed from o by c in the original trie, t) is added to Pk+1.(C-17)}(C-18)}(C-19)}(C-20)MAX[k+1] is set to maximum s ((o, s)∈Pk+1)(C-21) }(C-5)–(C-20) of the above algorithm for k=3 is explained, and CHECK[1–2], CODE[1–2] and MAX[1–3] in Fig. 6 have been already determined. Because characters traversed from all states of the trie for depth 3 are ‘c’ and ‘#’, (C-12)–(C-16) in (C-6)–(C-19) are performed only for ‘c’ and ‘#’. In (C-8)–(C-10), states 4 and 5 are extracted, because ‘c’ is traversed from states 4 and 5 of the new trie. Because minimum q satisfied with CHECK[4+q]=unused and CHECK[5+q]=unused is 4, CODE[3][’c’] is set to 4 in (C-12). In (C-14)–(C-16), child state t is set to 8 for s=4 and CHECK[8] is set to ‘c’. Moreover, child state t is set to 9 for s=5 and CHECK[9] is also set to ‘c’.In the same manner of ‘c’, (C-8)–(C-10) for ‘#’ are performed as follows;states 5 and 6 are extracted.CODE[3][’#’] is set to 5, because CHECK[5+5] and CHECK[6+5] are unused.t=10for s=5,CHECK[10]=‘#’t=11for s=6,CHECK[11]=‘#’Finally, in (C-20), MAX[4] is set to 11, because the maximum for the indexes of used CHECK is 11.This algorithm determines CODE values for all characters by orders of the depth. After CODE values are determined, the values of CHECK and MAX are also determined by orders of the depth. Therefore, SAMC can be built for any key sets.In ODA, unused states are searched from BASE and CHECK arrays, and BASE values are determined. But, in this presented method, unused states are searched from CHECK array, and CODE values are determined for all characters by orders of the depth. Morita proposed a fast method that can search unused states of the double array structure (Morita, Fuketa, Yamakawa, & Aoe, 2001). Morita’s method can be used in SAMC.Table 1shows the time complexity of retrieval. Let |Σ| be the number of characters. The retrieval algorithm of the presented method (SAMC) is very similar to that of ODA. The time complexities for retrieval for both methods are the same. Let k be the length of the input key, the time complexity of retrieval for both methods is O(k). Matrix form and CDA is O(k) by the same manner of ODA. In LOUDS, the time complexity is O(k |Σ|), because all characters may be checked for each depth like list form. Therefore, LOUDS is slower than other methods.When |D| is the number of the state numbers, the space complexity for all methods is O(|D|). The coefficients of |D| is important for evaluating spaces of each method. Therefore, spaces are compared by trie sizes. Table 2shows trie sizes. Let m be the maximum length of keywords in the key set and |D| be the number of the state numbers. The size of LOUDS is calculated from the implementation of the tx library.1http://code.google.com/p/tx-trie/.1In the ODA, both the BASE value and the CHECK value are represented as 4 bytes. In the CDA, the BASE value and the CHECK value are represented as 4 bytes and 1 byte, respectively. CODE values are represented as 1 byte for ODA and CDA. In the presented method, CHECK value is represented as 1byte. CODE value is represented as 4 bytes, because CODE values are bigger than the number of states for each depth of the trie. MAX value is represented as 4 bytes. In matrix form, state numbers are represented as 4 bytes. The size of matrix form is biggest. Because 4m|Σ|+4(m+1) is very small comparing with |D| for most of key sets, the size of the presented method is the smallest, but these sizes depend on |D|. In the double array and the presented method, there are unused states in BASE and CHECK arrays, and the sizes including unused states are evaluated by the following experimental results. However, in the presented method, as child state numbers are specified by parent state numbers, the size of CHECK array for depth k+1 is mostly bigger than that for depth k. In case of key set with variable length (maximum length n) when k(<=n) is small, |Dk+1| is bigger than |Dk|. But from some points, |Dk| is bigger than |Dk+1|. Therefore, when keys are variable length, space usage of SAMC is big for increasing unused states. When keys are fixed length, |Dk+1| is always bigger than |Dk|. So experiments are done by using key sets with fixed length.Programs of ODA, CDA and the presented method were written in C language. Tx library was used as the program of LOUDS. These programs were implemented on the following PC; Intel Xeon 2.4GHz(L2 cache:256K-Byte). It compared about the space usage and retrieval speed.The experiments for pseudo data sets used 10,000 keys with fixed length from 0000 to 9999. 1000 to 10,000 keys which were selected from 10,000 keys were used as key sets.Fig. 7shows the space usages. The size of matrix form is much bigger than other methods. When the number of keys is big, the presented method is the most compact. Furthermore, the size of the presented method is mostly more compact than ODA and CDA.Fig. 8shows the retrieval time. All the registered keys are retrieved, and the average retrieval time per 1000 keys is evaluated. LOUDS is clearly slower than other methods. Because the retrieval algorithm of the presented method is as fast as that of the double array, the retrieval speed of the presented method is similar to other double array methods (ODA and CDA).Next experiments used 7 digit numbers with fixed length from 0000000 to 9999999. Figs. 9 and 10show the space usages and the retrieval time, respectively.Next experiments used 4 lower-case alphabets from “aaaa” to “zzzz”. The number of keys in this key set is 456,976(=264). Figs. 11 and 12show the space usages and the retrieval time, respectively. According to these results, even if the length of keys is bigger or kinds of characters increase, results were the same as the most cases.Experiments were conducted by using zip codes of Bulgaria and USA2http://www.zip-codes.com/zip-code-database.asp.2as real data sets. The Bulgarian zip code is constructed by 4816 four digit numbers. The U.S. zip code is constructed by 41,855 five digit numbers. Table 3shows the space usages and the retrieval time. These results for real data sets are almost the same as results for pseudo data sets.From the above observation, the presented method has the same retrieval speed as ODA and CDA and its space usage is more compact than ODA and CDA. In addition, when a large set of keywords with fixed length is used, the space usage of the presented method is more compact than that of LOUDS as succinct data structure.

@&#CONCLUSIONS@&#
