@&#MAIN-TITLE@&#
A comprehensive process of reverse engineering from 3D meshes to CAD models

@&#HIGHLIGHTS@&#
Primitive extraction: detect primitive which corresponds locally to the 3D mesh.Adjacency relation determination: define the relationship between primitives.Wire construction: based on the intersection curves between neighboring primitives.B-Rep creation: that works even in the case of an outline on a periodic surface.

@&#KEYPHRASES@&#
CAD,Reverse engineering,3D mesh,Boundary representation (B-Rep),3D curvature,Geometric primitive fitting,

@&#ABSTRACT@&#
In an industrial context, most manufactured objects are designed using CAD (Computer-Aided Design) software. For visualization, data exchange or manufacturing applications, the geometric model has to be discretized into a 3D mesh composed of a finite number of vertices and edges. However, the initial model may sometimes be lost or unavailable. In other cases, the 3D discrete representation may be modified, e.g. after numerical simulation, and no longer corresponds to the initial model. A retro-engineering method is then required to reconstruct a 3D continuous representation from the discrete one.In this paper, we present an automatic and comprehensive retro-engineering process dedicated mainly to 3D meshes obtained initially by mechanical object discretization. First, several improvements in automatic detection of geometric primitives from a 3D mesh are presented. Then a new formalism is introduced to define the topology of the object and compute the intersections between primitives. The proposed method is validated on 3D industrial meshes.

@&#INTRODUCTION@&#
Nowadays, manufactured objects are principally designed with Computer-Aided Design (CAD) software. An object is constructed by combining geometric primitives like planes, spheres, cylinders, cones or parametric patches (e.g. Bezier, B-Splines, NURBS) and their boundaries (using intersections between primitives). This continuous representation is necessary to redesign or extract the object parameters. However, many CAD design software programs do not read or write opened geometric formats like STEP or IGES, e.g. the basic version of AutoCAD can only store a model in its proprietary format (DWG). Furthermore, for visualization, exchange or manufacturing purposes, the continuous parametric CAD model must be discretized into a 3D CAD mesh composed of a finite number of vertices and triangles. The initial CAD parametric data may be unavailable, lost or no longer correspond to the original CAD model if the 3D mesh is deformed by another designer or after a numerical simulation process. For example, in Fig. 1, a B-Rep model was discretized into a 3D mesh in order to be deformed by a stamping simulation tool. But a continuous model is often required to check the shape parameters or to modify the design. Reconstruction of a B-Rep model from the modified 3D CAD mesh, which is a particular case of reverse engineering, is thus needed.In our industrial context, we work in collaboration with the C4W11www.c4w.com.company. Through the user tests of 3D Translate,22www.3dtranslate.com/.a software allowing interoperability between CAD software translating or converting many file formats (see Fig. 2), we note considerable interest in reconstructing continuous models from 3D CAD meshes. In fact, around 90% of requests concern obtaining a continuous representation (IGES, STEP, etc.) from a 3D mesh (STL, OBJ, etc.), of which 50% are CAD meshes. A specific method, focused on reconstruction from meshes created by CAD model discretization, is thus required.The reverse engineering process has to be adapted to the 3D mesh structure, which depends on the creation or discretization process. For example, for a scanned physical object, the 3D mesh is generally very dense but composed of points whose coordinates may be disturbed by acquisition noise. On the other hand, discretization of a CAD model has accurate points but the mesh can be sparse because the discretization function does not add useless points. So, between a scanned mesh which contains many noisy points and a CAD mesh with few points but with exact positions, the reconstruction process may differ. The CAD model reconstruction problem corresponds to the second case and is rarely presented in the literature. Indeed, most reverse engineering papers try to reconstruct continuous objects from a scanned mesh. These methods cannot be used on a sparse mesh and a dedicated algorithm has to be developed.We can distinguish, as in  [1], two kinds of reverse engineering results: “simple surfaces”, such as planes, and general “free-form surfaces”, like B-Splines or NURBS. For the second case, many methods to fit free-form surfaces on a 3D mesh exist, for example  [2]. Although they are efficient for obtaining a good-looking reconstruction of a 3D mesh and allow modeling of some features (see for example  [3,4]), they do not reveal the overall information on the shape that is essential for many CAD applications. In particular, the identification of the object shape (a sphere or plane?), the computation of shape parameters (e.g. a radius or an axis of revolution) or the definition of relationships between different parts (a cylinder linking two tangent planes can be considered as a blend) are not possible with these methods.Furthermore, in the CAD model, the primitives are confined by boundaries defined as parametric 3D curves. So a CAD model reconstruction process should extract primitives, like planes, spheres or cylinders, then it has to compute their boundaries and relations so as to construct a topologically-consistent continuous CAD model (see Fig. 3).We decided to use the Boundary Representation (B-Rep) to store the CAD model (more details can be found in  [5]). This representation allows us to study or modify the object after conversion using C4W software: 3D Shop,33www.c4w.com/dev/?lang=en#customcad.and it is also easy to stock it in a common format such as IGES or STEP.In a B-Rep model (Fig. 3(c)), an object is represented by a set of faces. Each face corresponds to a geometric primitive defined by its parameters (e.g. a radius and a center in the case of a sphere) and its boundaries, or so-called wires: one exterior for the outer boundary and eventually one or several interior ones for the hole boundaries. A wire is made with one or several edges which are defined by a parametric equation and two limit points. These edges correspond to parts of intersections between two faces. In particular, if two faces are neighbors, their wires will reference common edges. Then the B-Rep model construction requires not only recovery of the primitive set, but also all the adjacency relations between the faces, in order to create topologically-consistent wires.In this paper, we present a comprehensive method to reconstruct a B-Rep model composed of planes, spheres, cylinders and cones from a 3D mesh whose vertex coordinates are considered exact. After presentation of the state of the art in Section  2, our method is detailed in Section  3. The CAD object results are presented in Section  4. The method is discussed along with its perspectives in Section  5.In this section, a study of several methods is proposed. The first part is dedicated to comprehensive procedures for reconstructing continuous objects but there are few. So in the second part, papers dealing with only one part of the procedure will be studied. The method proposed in this paper has three steps, the primitives are extracted first, then the wires are computed and the B-Rep model is then constructed. So methods proposing solutions to detect and reconstruct primitives and to compute the adjacency relations and the boundaries are analyzed.Many papers deal with part of the B-Rep reconstruction process but very few describe a complete procedure. A first one was proposed by Benko et al. in  [6]. They begin the reconstruction pipeline by a segmentation step.For each sub-mesh, the authors do not extract the geometric primitive type but instead they conduct many approximation tests to fit a parameterized geometric primitive. This method can confuse the primitive type, and indeed in the example given in the paper, cylinders are not detected as cylinders but rather as parts of a revolution surface. This confusion does not block the reconstruction but it does not allow extraction of all of parameters such as the cylinder radius. Then the topology is computed using a 3D mesh: two primitives are adjacent if the corresponding sub-meshes share at least one mesh edge. The wire construction is based on these common edges and is refined by the exact geometric intersection computation. In fact, this method depends on the edge accuracy and gives interesting results only if the 3D mesh is dense and if the mesh edges correspond to the continuous boundaries of the real object. Furthermore, the vertex normals are used to segment the mesh and to compute certain primitive parameters using a Gaussian sphere, while the computation of accurate normals requires many points or points without noise. Thus the authors did not directly use the object of the Hoschek benchmark as an example but they redesigned and resampled it.Huang and Menq  [7] propose a process to reconstruct a B-Rep model from a 3D point cloud. The first step consists of triangulating the point cloud. Then the authors propose to segment the mesh by using border edge detection and compute the primitive parameters for each sub-mesh with a method based on surface normal estimation. The topology is deduced from the sub-meshes as in  [6]; the common mesh edges give the adjacency relationship and allow construction of a first approximation of wires. Huang and Menq replace all the common edges by the real intersection curves between the corresponding faces. The resulting quality of this method is also related to the 3D mesh edge accuracy. Furthermore, it is not possible to construct a wire if four or more primitives have the same intersection point that limits the reconstructed CAD model complexity.Recently, Chang and Chen  [8] proposed a review of reverse engineering methods. In particular, they analyze some commercial software, like Geomagic Studio or Rapidform XOR. They show, as in  [1], that two kinds of results can be found. In the case of free-form surfaces (generally based on NURBS), commercial software propose automatic methods that are efficient but some problems remain when dealing with objects with sharp edges. Although all of these software packages also include some methods to reconstruct a CAD model based on geometric primitives, they do not work automatically, mostly if the 3D mesh has some sparsely discretized parts. The user has to interact by clicking along the boundaries or defining the type of primitive for each mesh part; thus a complex object reconstruction can take several hours or days. These methods are thus not available for industrial applications, unlike the process presented in this paper.In recent years, many methods have been proposed to extract only geometric primitives in a reverse engineering process. They generally involve three steps  [1]: point area extraction which defines mesh areas having the same shape features; classification which associates one primitive type with each point area and the fitting to compute primitive parameters corresponding to each point area. Thus, in the method proposed by Benko et al.  [9], the shape features are based on co-planarity between neighbor triangles. They highlight the sharp edges or small blends which separate the sub-meshes. Then a plane is fitted to each sub-mesh. If the plane is close enough to the sub-mesh, it is kept. Otherwise, the sub-mesh is approximated with more complex geometric primitives such as a sphere, cylinder, etc., until it closely corresponds. Note that the authors do not formally classify the geometric primitive type but test all possibilities and, as we have already said, this method can lead to confusion between types. This fitting result may be improved by adding some constraints such as tangency between the geometric primitives. In  [10], Bénière et al. propose to use curvatures to segment the mesh, to define the primitive kind associated with each sub-mesh and to compute the primitive parameters.Many papers deal with just one step. For example, Bohm et al.  [11] and Lavva et al.  [12] describe techniques to segment and classify the sub-mesh by using curvature features. The segmentation is based on propagation from a seed triangle to triangles with the same curvature feature. In a second step, using curvature properties of the geometric primitives, a type is attributed to each sub-mesh. Sunil and Pande  [13] base the segmentation and classification steps on the CAD mesh characteristics. The dihedral angle and the size of each triangle are used for segmentation. A first classification is made with the curvature feature and then, with CAD a priori knowledge, the sub-meshes can be further classified. For example, if a cylinder is between two planes, it corresponds to a blend.Lukács et al.  [14], Shakarji  [15] and Schnabel et al.  [16] propose solutions to only fit primitives on a sub-mesh or a point cloud. Lukács and Shakarji’s methods use two kinds of approximation on all points to obtain the primitive parameters. In contrast, Schnabel et al. define one primitive for each point group (e.g. groups of three points for a plane) and keep the best one. The Chaperon and Goulette method  [17] is more specific and deals only with point cloud approximation by a cylinder. This approximation is based on features of the cylinder Gaussian image. The Gaussian image of a cylinder gives the axis and, in case of cones, this gives the angle too.Even though these methods give good results, their adaptation is not always possible in a complete process. However, some of the ideas were adopted for our method.Adjacency relations between the geometric primitives which are extracted from a mesh are important in many domains. Thus, in  [18], Li et al. use these relations to align primitives after a RANSAC extraction. The authors construct a graph to represent the relation between primitives, and to extract primitives connected by the same feature. In this article, the extracted relations are not adjacency relations but rather relations on primitive parameters, like the same axis, or the same radius. In contrast, in  [19], adjacency relation extraction allows remeshing improvement. Chappuis et al.  [19] use relations between primitives to construct correct intersections and to be sure that the edges corresponding to these intersections are not deleted by this remeshing. After computation of primitives belonging to the mesh, the adjacency relations are extracted from the sub-meshes used to compute the primitives and are stored in an adjacency graph. The intersections between primitives which guide the remeshing are computed using this graph defined by a primitive node and an edge if the primitives are neighbors. Even though this is not a B-Rep reconstruction method, its definition of the relationship between faces can be used to extract consistent intersections and reconstruct a B-Rep model.Computing intersection curves between two geometric primitives is a classical problem and efficient methods exist (see for example  [20]). The difficulty is in combining parts of these intersection curves, computed on pairs of geometric primitives, in consistent wires that are continuous and closed curves.This seems very similar to the so-called “Boundary Evaluation”  [21] problem which allows recovery of a B-Rep representation from a CSG model. For example, Miller  [22] first computes intersections between all solids. Indeed, in the case of a CSG, the primitives are solid, for example a cylinder is described by a cylindrical surface and by the two extreme circular planes. Miller then gets a set of edges which are labeled as Cross-edge for an edge resulting from an intersection or Self-edge for an edge already existing in the CSG model. The wire construction is based on the definition of a path through the edges; if several paths are possible, the path using the Cross-edge is chosen. Thus the wires are constructed for each face with intersections between the volumes. Nevertheless, the Boundary Evaluation problem is much easier because it is based on an exact set of bounded volume primitives, whereas in our case only infinite surface primitives associated with a discrete set of points are used.Our comprehensive process, presented in this section, involves three steps (see Fig. 4):•Step 1: Primitive extraction: in this step, the idea is first to detect the type of geometric primitive (i.e. a plane, sphere, cylinder or cone) that corresponds locally to the 3D mesh and to then compute the parameters which give the best fit. The method is based on differential geometry operators which characterize the local 3D shape.Step 2: Wire construction: this is a key complex problem. It defines the relationship between all the extracted geometric primitives, which is subsequently used to compute intersection curves between two geometric primitives. Then all of these curves are combined to build a continuous wire in a consistent way.Step 3: B-Rep creation: the B-Rep construction is presented. It consists of combining the information extracted or reconstructed during the two previous steps to construct a consistent model.The local shape around pointPon a surfaceSis characterized by the minimum and maximum principal curvature (kminandkmax) and by the two principal directions (dminanddmax) corresponding to the tangent vectors for which the principal curvatures are obtained. Simple geometric primitives, like planes, spheres, cones and cylinders, have specific curvature characteristics (see Table 1). Thus, in the case of a plane, the curvature value is equal to 0, which meanskmin=kmax=0. For a sphere, all the points have the same curvature whose value is equal to the inverse of the radius (kmin=kmax=1R). A cone or a cylinder point is characterized by one principal curvature equal to 0 with the corresponding principal direction following the cone or cylinder generating line. Furthermore, the other principal curvature allows us to define a point on the axis for each point on the cone or cylinder.The first step of the method (see  [10]) extracts primitives from a 3D mesh using these curvature characteristics. Therefore for the mesh in Fig. 5(a), the curvature is computed and displayed on the mesh of Fig. 5(b) with a color code: green for planar, yellow for spherical, blue for convex and red for concave points.Many methods have been proposed to compute the curvature on a discrete 3D mesh as reviewed in the surveys  [23,24]. In the following, a combination of the two methods described in  [25,26] is used. The idea proposed in these papers involves computing, for each neighbor vertex, a discrete curvature; using a regression based on the Euler formula, the principal curvatures are obtained. Then, using the curvature features, point areas are extracted with a propagation method and labeled (Fig. 5(c)) by one color per primitive type. To offset the numeric noise or irregularities in the point area extraction, epsilons, computed according to the input mesh, are used. The parameters of one primitive are approximated for each point area, with linear approximation and curvature verification; the extracted primitives are shown in Fig. 5(d).To find planes and spheres, neighbor vertices having|kmax−kmin|<ϵSPare grouped in the same point areas. A point area is initialized by a first point and propagated to the neighbor points having the same curvature characteristics. Then, for each point area, a geometric primitive is fitted. If|kmax+kmin2|<ϵPL, the point area corresponds to a plane. The implicit Eq. (1) is used to extract coefficients by linear regression.(1)ax+by+cz+d=0.If|kmax+kmin2|>ϵPL, the point area corresponds to a sphere. The implicit Eq. (2) of the sphere is not linear and not easy to fit by the least-squares method. So, the center and the radius of the sphere are approximated using Eq. (3) obtained by a variable change  [27]. A regression with a least-squares method is also carried out in this case.(2)r=(xc−x)2+(yc−y)2+(zc−z)2(3)x2+y2+z2+xA1+yA2+zA3+A0=0with:{A0=xc2+yc2+zc2−r2A1=−2xcA2=−2ycA3=−2zc.A cylinder is considered to be a particular case of a cone. These primitives are characterized by two 3D lines: the rotation axis and the generating line. The axis is defined by a vector and a point which is the cone vertex or any axis point for cylinders. The generating line can be determined by the angle to the rotation axis in the case of a cone or by the radius for a cylinder. Both geometric primitives have the same curvature behavior:kmin=0,dmincorresponds to the generating line and the pointP+n⋅1kmaxbelongs to the rotation axis, withPbeing a point on the cone andnthe normal inP.In the other methods, detection of cones or cylinders using curvature features is only based on the curvature values: one equals 0 and one differs from 0. Although the points on cones or cylinders have this property, some points on other primitives can have the same property like certain ruled surfaces. Here we define a new criterion to exclusively detect cone or cylinder points. Thus to check if two neighbor points belong to the same cone or cylinder, the following key criterion is used (see Fig. 6). LetP1′=P1+n1⋅1Cur1andP2′=P2+n2⋅1Cur2,P1′andP2′define a potential axisAand(P1,d01)and(P2,d02)define two potential generating lines.P1andP2belonging to the same cone or cylinder must satisfy: the anglesα1andα2between axisAand the generating lines are identical (and close to 0 in the case of a cylinder).This criterion is used to extract point areas corresponding to cones or cylinders. If two neighbor vertices have akmin<ϵCoandkmax>ϵCo, they belong to a cone. Then the criterion is used, to ensure that they belong to the same cone. Secondly, to propagate the point area, the curvature of the neighbors is also studied to check the criterion with these vertices.For each point area, a cone or cylinder is approximated by using the Gaussian image and not only the property of the curvature as in  [10]. In the case of cones or cylinders, the Gaussian image is a circle (see Fig. 7). The normal of the plane which fits this Gaussian image corresponds to the direction of the axis. It allows us to obtain the axis and also the angle for the cone. To determine the cylinder radius, the points of the point area are projected onto the approximated plan and form a circle which corresponds to a cylinder circle, i.e. with the same radius and the center equivalent to an axis point.Curvature computation is based on the vertex neighborhood. In the case of a sparse mesh, the vertices can correspond to several primitives because only the points on the object edges are used. For these meshes, if the edges of the object are detected and used to make a segmentation, a vertex on an edge will belong to several sub-meshes. Computation of the curvature is thus better with segmentation; with the neighborhood of each vertex not being disturbed by vertices of other primitives. In our case, the dihedral angle (angle between two triangles) is used to obtain this pre-segmentation by a propagating method. After initialization with a not yet used triangle, the neighbor triangles are added to the sub-mesh, if the dihedral angle between its and the neighbor triangle belonging to the sub-mesh is greater than a threshold angle. This segmentation improves our primitive extraction. In Fig. 8, the point areas (Fig. 5(d)) extracted from the segmented meshes (5(b)) are more extended than the point areas obtained from the original mesh. In other cases, no primitives are found without this segmentation, whereas with the segmentation all primitives are detected and reconstructed.In order to get a B-Rep representation, each geometric primitive has to be trimmed, according to its intersections with the other ones. To find out which intersection is involved to build the wires, the adjacency relations are determined. An adjacency graph containing the relationship between the primitives is used for this purpose. Each primitive corresponds to a node of the graph, and an edge is added between two nodes if the two corresponding primitives are neighbors.The extraction of point areas is based on a propagation method. A point area is initialized by a vertex with specific curvature and neighbor vertices with the same curvature characteristics (according to the primitive type) are added to the area. During this construction, vertices on the primitive limits cannot be added in the point area. Indeed, the curvature computation is based on a neighborhood study for each vertex, so the vertex curvatures on the primitive limits are disturbed by the vertices of the neighbor primitive. To obtain point areas containing all vertices corresponding to the primitive, an extension of these areas is then carried out. To extend a point area, the distance between adjacent vertices of the area and the corresponding primitive is computed. If the distance is lower than a threshold, the vertex is added to the point area and their neighbors are also studied. Thus, using the information contained in the primitives and point areas, the extended areas are obtained, see Fig. 9(a).Then, the extended areas allow us to define the common points (Fig. 9(b)). For each pair of primitives, a set of common points is defined; if a point belongs to several extended areas, it is added to the common points of the primitive pair corresponding to the extended areas. An adjacency graph is used to represent the adjacency relations. It is initialized with a node by primitive. If the set of common points corresponding to two primitives is not empty, an edge is added to the graph between the two corresponding nodes, as shown in Fig. 9(c).In the first step, no limit is defined for the geometric primitives, and they can be infinite as planes, cylinders or cones. To recover wires representing the geometric primitive boundary, the intersection curves between the geometric primitives first have to be computed.For this, the edges of the adjacency graph which define pairs of intersecting primitives are used. We decided to use the Open Cascade Library44http://www.opencascade.org.to perform this operation which gives intersection curves as parametric curves which can be closed (e.g. sphere/plane) or infinite (e.g. plane/plane). These parametric curves are defined by an equation according to the type (a B-Spline curve or a circle, for example) and two limit points.In Fig. 9(d), the set of all intersection curves between geometric primitives is presented. However, the problem is not very straightforward, some intersection curves are not really significant such as the one between the cylinder Cyl2 and the top of the sphere Sph1. Then the validity of each intersection curve has to be checked by comparing it with the common points shared by the two corresponding primitives. Then, in Fig. 9(e), the red intersection curve is rejected whereas the green ones are validated.The geometric primitives do not only intersect two by two. For instance, in Fig. 9(e), the side cylinder Cyl2 intersects, at the same location, the superior plane Pl1 and the main cylinder Cyl1. In this area, the contour of Cyl2 will then be composed of portions of the two intersection curves with Pl1 (a circle) and Cyl1 (two parallel lines). More generally, each valid intersection curve has to be decomposed into parts corresponding to the intersection restricted only to two primitives. These parts are called edges and are delimited by junction vertices which correspond to intersections between three geometric primitives.The example in Fig. 10is used to explain the edge construction. From the mesh in Fig. 10(a), fourteen planes are extracted and the adjacency graph is deduced, see Fig. 10(b). Intersection curves are computed for each primitive pair bound in the graph, Fig. 10(c).First, all potential junctions are extracted by intersecting all valid intersection curves two by two. Nevertheless, not all the potential junctions are valid: they have to correspond in the B-Rep model to a vertex, i.e. to a connection between two edges, so it binds three primitives as shown in Fig. 10(a). Furthermore, these three primitives have to be adjacent two by two because they have a common vertex. This implies that the four geometric primitives leading to the junction (two per valid intersection curve) are in fact three (one in common on the two edges) and that they are connected, forming a cycle in the adjacency graph. As the same junction can be extracted from several intersection pairs, a fusion is performed when two junctions correspond to the same vertex.After the junction extraction and fusion, the edges are created by cutting the valid intersection curves. To construct the wires, a closed path through the edges is constructed; so if an edge has an extremity which is not connected with an another edge extremity, this edge cannot belong to a closed path. All of these edges are removed. Thus a set of valid edges is obtained, as shown in Fig. 11.To build wires, one exterior and zero or several interior ones for each geometric primitive, closed paths have to be computed that assemble a subset of the valid edges. In fact, there are two cases: a wire can be created in an unique way with the valid edges or several paths are possible to create a wire.In the first example in Fig. 11, the seven valid edges are available for the frontal plane of the object. All of these edges are connected two by two, and there is only one way to make a closed path. In this case, building the wire is straightforward. In the second example in Fig. 11, several closed paths are possible: one follows the exterior boundary or a second shortcuts the corner or a third just with the corner.To choose between the different paths, a weight is attributed to each edge. This weight corresponds to the average distance between the edge and the extended areas. The minimal distance induces the most probable edge on the object. A sequential method is used to find a path closer to the optimal path. The wire construction is initialized with the edge having the lowest weight. Then the connected edges are studied and the one with the lowest weight is selected and connected to the current wire. The process terminates when the wire is closed or if there is no more edge to connect. The wire is kept in the first case but rejected in the second.In Fig. 12, all wires computed from the mesh of Fig. 10 are presented. This building process ensures that all wires have a valid topology. They are closed and cannot self-intersect (otherwise there will be a supplementary junction on the self-intersection). After the B-Rep creation, the consistency of the wire can be checked by assessing whether the B-Rep model is closed: all faces are entirely delimited by the edges.Once the wires have been constructed, they are combined with the geometric primitives and the adjacency graph to reconstruct the B-Rep model (see Fig. 9(h)).The B-Rep model is composed, for each geometric primitive, of its type of primitive, its parameters, and the corresponding wires, i.e. one outer and no or several inner ones for the hole boundaries. Each edge is stored once and the wires only reference the edges. This structure ensures that the model is watertight because the adjacent faces have edges in common, unlike a structure in which each boundary is defined without links with the others.

@&#CONCLUSIONS@&#
