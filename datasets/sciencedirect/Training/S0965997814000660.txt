@&#MAIN-TITLE@&#
An open source program to generate zero-thickness cohesive interface elements

@&#HIGHLIGHTS@&#
We present an open source program to insert cohesive interface elements to be in fintie element meshes.The algorithms are discussed in details and installation and usage are presented.The code generates one/two dimensional cohesive interface elements, both linear and quadratic.High order Bezier elements are also supported.It fills the gap in the literature that there does not exist any such open source program.

@&#KEYPHRASES@&#
Interface cohesive elements,Fracture mechanics,Cohesive zone models,Finite element method,Open source code,Intrinsic cohesive laws,

@&#ABSTRACT@&#
An open source program to generate zero-thickness cohesive interface elements in existing finite element discretizations is presented. This contribution fills the gap in the literature that, to the best of the author’s knowledge, there is no such program exists. The program is useful in numerical modeling of material/structure failure using cohesive interface elements. The program is able to generate one/two dimensional, linear/quadratic cohesive elements (i) at all inter-element boundaries, (ii) at material interfaces and (iii) at grain boundaries in polycrystalline materials. Algorithms and utilization of the program is discussed. Several two dimensional and three dimensional fracture mechanics problems are given including debonding process of material interfaces, multiple delamination of composite structures, crack propagation in polycrystalline structures.

@&#INTRODUCTION@&#
Cohesive crack models (CM) which were pioneered in [1,2] is a continuation of linear elastic fracture mechanics with which the unrealistic stress singularity ahead the crack tip is avoided. Application of CMs as fracture models used in the context of the finite element method however appeared substantially later in [3]. From a numerical point of view, CMs have been incorporated in a finite element (FE) context using zero-thickness interface elements, elements with embedded discontinuities and elements with discontinuous enrichment via the extended/generalized finite element method (XFEM/GFEM). A comparative study on the modeling of discontinuous fracture using these techniques was given in [4] and a review of computational methods for fracture in quasi-brittle solids has been recently reported in [5]. It should be emphasized that the term “cohesive elements” usually used to refer to cohesive interface elements is misleading since elements with embedded cohesive cracks or XFEM with cohesive cracks are also cohesive elements. Therefore, in this contribution, we suggest the name “cohesive interface elements” (in subsequent discussion interface elements are used for brevity) to indicate interface elements equipped with a cohesive law.Elements with embedded discontinuities are a powerful tool to model crack propagation, see e.g., [6–9], among others. Its most distinct advantage is the simplicity of implementation into existing FE codes compared to XFEM. Recently XFEM, which is a local partition of unity (PUM) [10] based finite element method, pioneered in [11] has become the dominant numerical method for both weak discontinuities (material interfaces) [12–14] and strong discontinuities (cracks), see e.g., [15–17] among others. Its popularity is arguably due to the fact that XFEM can be applied to numerous varieties of problems (fluid mechanics, biofilm growth, multiphysics, etc.). However, it comes with complications including numerical integration of elements crossed by the discontinuities, complexity concerning the implementation of the method in existing finite element packages. Furthermore, finding the enrichment functions to model intersecting discontinuities is not a feasible task, especially for three dimensions. Also, parallelizing the XFEM is not straightforward.For polycrystalline structures, a common fracture phenomenon is inter-granular cracking, i.e., cracks propagate along the grain boundaries. This fracture mechanism is naturally modeled with interface elements that are inserted, prior to computation, along the grain boundaries because the crack path is known in advance. Recently, this problem was tackled with the generalized finite element method (GFEM) [18]. The advantage of GFEM is that only a structured simple mesh is required since the grain topology is independent of the mesh and modeled with special enrichment functions. However extending these enrichment functions to three dimensions and intra-granular fracture is not easy. Moreover, imposing Dirichlet boundary conditions on enriched nodes is not a trivial task. In contrary, using interface elements, both two dimensional (2D) and three dimensional (3D) inter and intra-granular fracture can be modeled. Such a 2D application has been recently reported in [19] and 3D cases in [20].Delamination of laminated composites has been traditionally modeled using interface elements [21–23]. Recently, PUM-based finite elements has been used to model delamination with mesh independent of the delamination surface [24,25]. However, to model 3D delaminated composites, PUM-based method must employ either a layer of 3D solid elements or solid-like shell elements which increases the computational efforts significantly. Furthermore, PUM-based method is not suited for two dissimilar structures bonded together such as skin-stringer interface. Using interface elements, an effective cohesive element for shell analysis was presented in [26].In addition to the natural application of interface elements for problems in which crack paths are known a priori such as material interface debonding [27,28], delamination, inter-granular cracking, other advantages of interface elements include (i) crack initiation does not rely on some fracture criteria, (ii) straightforward implementation, and (iii) complex fracture mechanism such as crack branching, crack coalescence can be handled with ease [29,30,19,31,20]. Other applications of interface elements are mesoscopic modeling of concrete materials [32], dynamic fracture and fragmentation of solids [33,34] and shell fracture [35,36]. Other computational methods that are capable of dealing with complex fracture mechanics problems (with large deformation) include meshfree methods, e.g., [37–42], and peridynamics see [43,44] among others.There are two ways by which one can implement interface elements. In the first approach, interface elements are introduced, where necessary, before the simulation starts. The cohesive laws used in this approach is referred to as intrinsic cohesive laws. In the second approach, interface elements are inserted during the simulation and the corresponding cohesive laws are referred to as extrinsic cohesive laws. Both approaches have their own advantages and shortcomings. In the former, the shortcomings are (i) mesh sensitivity (this however does not apply for problems in which the crack path is known in advance, for example delamination analysis, inter-granular fracture of polycrystals or debonding of material interfaces) and (ii) reliance on a high dummy stiffness to model the perfect bond prior to fracture. Mesh sensitivity issue can be eliminated with sufficiently refined random meshes. For the artificial compliance introduced by the interface elements, one remedy is to initially constraint the interface elements (using the master–slave method [19] or a discontinuous Galerkin [45,20]) and only active them when necessary. Another possibility is to find the proper value for the dummy stiffness for interface elements as in [46]. In the latter, by only introducing interface elements when a fracture criterion is met all the shortcomings of intrinsic cohesive elements are removed. However, it brings complex implementation and parallelism issues.Although implementation of intrinsic cohesive elements is straightforward (and thus available in major commercial FE packages), the pre-processing stage in which one has to insert interface elements into an existing finite element mesh is quite complicated and there does not exist any open source tool to do that. The aim of this manuscript is therefore to present a simple pre-processing program which is able to insert one and two dimensional interface elements in a finite element mesh. This program is independent of mesh generation programs and freely downloadable on our website. We believe that it is helpful for researchers doing fracture analysis using interface elements, which play an important role despite of the emergence of novel methods such as XFEM, but do not have access to commercial preprocessors. It should also be useful for Discontinuous Galerkin based analyses [47]. The code also generates interface elements that are suitable for discontinuous Galerkin based methods. Moreover, through the open source code, adaptation to individual needs is much easier than using commercial preprocessors. The tool has been used in [48–50] and we hope through this manuscript it will be shared with the fracture and the discontinuous Galerkin communities. For completeness, this paper also presents implementation details of 2D interface elements in a nonlinear FE setting.The structure of the rest of the paper is as follows. In Section “Finite element formulation”, the governing equations of a cracked solid are given together with the semi-discrete equations discretized by finite elements. Section “Automatic generation of interface elements” presents the algorithms that are used to insert one and two dimensional interface elements in a finite element mesh. In the next section, the installation and usage of the presented program is discussed. Various numerical examples are given in Section “Numerical examples” including material interface debonding, two dimensional crack propagation problems in homogeneous structure and in polycrystalline structure; two and three dimensional delamination analysis. Finally some conclusions are drawn in Section “Conclusions”.The governing equations include the equilibrium equation, the natural, essential boundary conditions and the traction continuity on the crack surface(1a)∇·σ+b=0x∈Ω(1b)n·σ=t¯x∈Γt(1c)u=u¯x∈Γu(1d)nd+·σ=tc+;nd-·σ=tc-;tc+=-tc=-tc-x∈Γdwhereσis the Cauchy stress tensor,uis the displacement field andbis the body force vector. The traction applied over the boundaryΓtwith outward unit normal vectornis denoted byt,u¯is the applied displacement over the Dirichlet boundaryΓu;Γu∪Γt=Γ,Γu∩Γt=∅;tcis the cohesive traction across the crackΓdwith unit normal vectornd. For simplicity, only small strain assumption is considered where the strain is taken as the symmetric part of the displacement gradient∊s=12(∇us+∇Tus). Constitutive relations for the bulk and the cohesive crack are given later.The weak formulation reads, see [51] for details(2)δWext=δWint+δWcohwith(3a)δWint=∫Ω∇sδu:σdΩ(3b)δWext=∫Ωδu·bdΩ+∫Γtδu·t¯dΓt(3c)δWcoh=∫Γdδ〚u〛·tcdΓdwhere〚u〛denotes the displacement jump (see Fig. 1).The bulk is discretized by standard continuum elements and the discontinuity surfaces (cracks, material interfaces) are discretized by zero-thickness interface elements which are one dimensional less than the continuum elements. Fig. 2illustrates the idea for two dimensions.The displacement fields of the upper and lower faces of the interface element are given by(4)u+=Nintu+,u-=Nintu-withNintdenotes the matrix of shape functions of the interface element2For 4-node element, we haveNint=N10N200N10N2whereN1,N2are the two-node line element shape functions.2andu+andu-denote the nodal displacements of the upper face and lower face, respectively.Having defined the displacement of the upper and lower faces of the interface, it is able to compute the displacement jump as(5)〚u(x)〛=u+-u-=Nint(u+-u-)where we have used Eq. (4).For completeness, the displacement of the continuum elements and the virtual displacement are recalled here(6)u=NIuI,δu=NIδuIwhereNIis the shape functions of the continuum elements.Introducing Eqs. (6) and (5) into the weak form Eq. (2), we get the following semi-discrete equations(7)fext=fint+fcohwherefext,fintandfcohare the external force, internal force and cohesive force vectors, respectively.The external and internal force vectors are computed from contributions of continuum elements and given by(8)feint=∫ΩeBTσdΩe(9)feext=∫ΩeNTbdΩe+∫ΓteNTt¯dΓtewhere the shape function matrix and the strain–displacement matrix, of which expressions are standard and thus not given here, are denoted byNandB.The cohesive force vector is computed by assembling the contribution of all interface elements. It is given by for an interface element, i.e.(10)fie,+coh=∫Γd(Nint)TtcdΓfie,-coh=-∫Γd(Nint)TtcdΓwhere the first quantity is assembled to the total internal force vector according to the degrees of freedom (dofs) of nodes of the upper surface and the second quantity contributes to the internal force vector to locations defined by nodes of the lower surface.For the sake of simplicity, we assume that the nonlinear process is concentrated on the cohesive cracks. The bulk is thus simply a linear elastic material. The behavior of cracks is modeled with a cohesive law or a traction separation law (TSL). The constitutive equations are then given in rate form as(11)σ̇=D∊̇ṫc=T〚u̇〛whereDis the bulk tangent matrix which is simply the elasticity matrix andTis the cohesive (discrete) tangent matrix whose precise form depends on the TSL used.The linearization of the internal force vector Eq. (8) leads to the standard material tangent stiffness matrix which is given by(12)Kecon=∫ΩBeTDBedΩwhich is regiven here only for completeness. The implementation of interface elements is independent of the bulk solid element formulation.Substituting the displacement jump in Eq. (5) into Eq. (11) leads to(13)ṫc=TNint(u̇+-u̇-)This is then transformed to the global coordinate system by using the orthogonal transformation matrixQ(14)ṫc=QTQTNint(u̇+-u̇-)withQis given by(15)Q=nstwherenis the unit normal vector of the interface element ands,tare the unit tangential vectors of the interface element. Refer to [52] for the construction ofQfor 2D interface elements.The linearization of the cohesive force vector Eq. (10) requires a bit of elaboration as shown(16)∂fie,+coh∂u∂fie,-coh∂u=∂fie,+coh∂u+∂fie,+coh∂u-∂fie,-coh∂u+∂fie,-coh∂u-δu+δu-Therefore, the cohesive tangent stiffness matrix for a given interface element is given by(17)Keint=∫ΓdNTQTQTNdΓ-∫ΓdNTQTQTNdΓ-∫ΓdNTQTQTNdΓ∫ΓdNTQTQTNdΓIn fact only one term, which is a2n×2nmatrix with n being the number of nodes of one surface of the interface element, in the above needs to be computed, and it is then assembled to the appropriate locations. Also noting that in the above we have omitted the superscript int for clarity. It is interesting to note that the above equation for the interface stiffness has the same form with the one established with the phantom node method [53,54] or the method used by [55]. For completeness, the pseudo code of a general interface element program is given in Box 1 in which we have omitted the contribution of continuum elements since it is standard.Flowchart of a general interface element model.1.For a given load step and for an interface element e, doGet the connectivity inodesGet dofs of upper and lower faces,idofsA,idofsBGet nodal displacements of upper and lower faces,uA,uBCompute the global jump:〚u〛=uA-uBLoop over integration points, ip with weight wip∗Any kind of numerical integration rules can be used here. However, it has been reported that, [56] the Newton–Cotes scheme overcomes the traction oscillation issues. The integration surfaceΓis generally the midsurface of the cohesive element.∗(a)Compute displacement jump atip:〚u〛ip=N〚u〛Convert to local system:〚u〛iploc=QT〚u〛ipCompute local traction and tangenttloc,Tusing〚u〛iplocand a TSLCompute the cohesive internal force vector:fcoh=fcoh+NTQtlocwipCompute the tangent stiffness:Kcoh=Kcoh+NTQTQTNwip∗∗In literature, was made use ofKcoh=∫ΓNTQTTQNdΓ, in this case, their transformation matrix is the transpose of our.∗∗Assembling to global force and tangent∗∗∗Extension to large displacement case can be made by two additions. First the midsurfaceΓis the one in the current deformed configuration. Second, a geometry tangent stiffness is added toKcoh.∗∗∗(a)f[idofsA]=f[idofsA]+fcohf[idofsB]=f[idofsB]-fcohK[idofsA,idofsA]=K[idofsA,idofsA]+KcohK[idofsB,idofsB]=K[idofsB,idofsB]+KcohK[idofsA,idofsB]=K[idofsA,idofsB]-KcohK[idofsB,idofsA]=K[idofsB,idofsA]-KcohThe implementation of interface elements into an existing finite element code is quite straightforward provided that meshes including both continuum and interface elements is available. However, creating such meshes has not been discussed in the literature yet, at least to the authors’ knowledge. In this section, a simple pre-processing program3Freely downloadable at https://sites.google.com/site/phuvinhnguyensite/home/programs. The code consists of about 2000 lines of C++ code and uses extensively the STL and Boost libraries.3is presented that reads a FE mesh and modifies that mesh so that 1D and 2D interface elements can be inserted along either material interfaces or grain boundaries of a polycrystalline solid or along a surface where the crack is assumed to grow. Supported interface elements are given in Fig. 3. Note that high order B-spline interface elements given in [49] are also implemented. The program starts by reading a FE mesh including nodal coordinates, element connectivity arrays and element groups. It then builds the support for all nodes (support of a node is the set of elements sharing this node) and the neighbors of all elements. After that, it adapts the mesh by duplicating nodes and changing connectivities. Finally it generates a set of interface elements. In the following, algorithms used to insert interface elements along material interfaces and grain boundaries in 2D and 3D are going to be given in detail. We note that in an isogeometric analysis framework, interface elements can be created straightforwardly as presented in [57].Fig. 4illustrates the algorithm, adopted to place 1D cohesive elements along a material interface, which is given in detail in Box 2. In words, nodes on the material interface are cloned and elements containing this interface are divided into two groups. The first group contains elements below the interface: their connectivities are kept unchanged. The second group consists of elements above the interface, their connectivities are modified using the duplicated nodes.Algorithm to insert interface elements along material interfaces.1.Initialization(a)Building nodal supportDetecting interface nodes(a)For node I, loop over its supportCount the number of materials present in this support, nmatIfnmat⩾2, then I is an interface nodeDuplicating nodes(a)i=nodeCount,nodeCountis the total number of original nodesFor an interface node I, doi.Clone node I: build a new node with coordinate of I, index of iStore index of node I induplicatedNodes[I][0]Store index of this new node induplicatedNodes[I][1]i=i+1Tearing elements (modifying connectivities)(a)For node I of interface nodes, loop over support of node I, si.First element in s kept unchanged, let mat be the material of this elementFor element e in the rest of s,if material of e coincides with mat, continue with next elementchange node I in the connectivity of e by duplicatedNodes[I] [1]†In fact, we store the original connectivity of one element in an arrayinodes0and the new (modified) one in inodes.†End loop over sInserting interface elements(a)For element e, loop over edges s of e‡For quadratic elements, the edge s connects the two corner nodes I and J and the midside node of s is P. Then the interface element’s connectivity is[IPJduplicatedNodes[I][1]duplicatedNodes[P][1]duplicatedNodes[J][1]]Notingthat this is dependent on the node numbering convention of the FE code.‡i.If s is on external boundary or s already treated, continue next edgeLet the nodes of edge s be I and JIf either I or J is not an interfacial node, continue next edgeAdd one interface element with connectivity as[IJduplicatedNodes[I][1]duplicatedNodes[J][1]]End loop over edgesTo generate 2D cohesive surfaces along 2D material interfaces, the procedure in Box 2 needs only be modified in step 5 by looping over the faces rather than the edges. To this end, after reading the mesh, the program constructs the faces of all elements. For quadratic 3D solid elements, two kinds of face are created, one consists of corner nodes of that face and the other contains all nodes. The former is used to check whether a given face f is interfacial, i.e., lying on a material interface and f is treated already. The later is used to build the connectivity of the inserted interface elements.The algorithm in Box 2 has been extended with minor modifications to insert cohesive elements along grain boundaries of polycrystalline solids. To this end, elements belong to different grains are assigned to different materials (more precisely different groups) when meshing the domain as shown in Fig. 5(a). Thus, the grain boundaries can be considered as material interfaces. The procedure is given in Box 3 with the only difference from Box 2 lies in the treatment of junction nodes (e.g., those have three materials present in their supports) because for a junction node there are two duplicated nodes whereas for a normal interfacial node there is only one duplicated node. To tear elements around a junction node I, refer to Fig. 5(b), elements belonging to one grain are kept unchanged, elements in the second grain will be modified using the first duplicated node of I and finally elements in the third grain will be changed to the second duplicated node of I. This is exactly what is given in step 4 of Box 3. To insert an interface element along the edge s, connecting nodes I and J, of element, i.e. where s connects one junction node or two, we find the neighbor element je sharing the same edge s. Knowing the positions of I and J in the original connectivityjnodes0of je, it is able to find the indices of the duplicated nodes of I and J by using the new connectivity jnodes of je. See Fig. 5(c) for an illustration. It is noting that in some special cases, there are edges (kJ in Fig. 5(d)) connecting interfacial nodes but they are not on grain boundaries. Thus, no interface elements are created there. The extension to 3D polycrystals is straightforward and also implemented in the program.Algorithm to insert interface elements along grain boundaries.1.Initialization(a)Building nodal supportBuilding neighbors for all elementsDetecting interface nodes (see Box 2)Duplicating nodesTearing elements (modifying connectivities)(a)For node I of interface nodes, doIf I is not a junction node, following Box 2Get support of node I, sj=0For element, i.e. in s, doi.Let material of, i.e. be imatFor element je in s, doA.Ignore elements treated (je<ie)Let material of je be jmatIfjmat≠imatcontinue with next elementChange connectivity of je at node I byduplicatedNodes[I][j]End loop over jej=j+1End loop over, i.e.Inserting interface elements(a)For element, i.e., loop over edges of, i.e.,si.If s is on external boundary or s already treated, continue next edgeLet the nodes of edge s be I and J,If neither of I nor J is a junction node, following Box 2Loop over neighbors of, i.e., then find element je sharing the edge s with, i.e.Get original connectivity of je, sayjnodes0Get new connectivity of je, say jnodesDenote positions of I and J injnodes0asp1,p2Add a cohesive element withconnectivity[IJjnodes[p1]jnodes[p2]]End loop over sThe program is also capable of inserting cohesive elements in between every inter-element boundaries. This is useful for discontinuous Galerkin problems and for dynamic fracture and fragmentation problems. In this case, at a node I, there are (duplicity-1) duplicated nodes where duplicity is the size of the support of I, Fig. 6. To tear elements in the support s of a node I, the first element in s uses the first duplicated node of I (which is essentially node I), the second uses the second duplicated node of I and so on.Extension to the case where interface elements are not allowed at a certain domain (for example for hard inclusions in a composite material) is straightforward as demonstrated in Fig. 7. There are two differences: interfacial nodes and nodes locate in the domain where interface elements are not allowed (restricted domain). To tear elements in the support s of an interfacial node I, all the elements in s that belong to the restricted domain keep their connectivities, other elements use the duplicated nodes of node I to change their connectivities (at location of node I). Nodes within the restricted domain are skipped in the loop over all nodes of the mesh.In the formulation of the cohesive interface elements one has to compute the displacement jump which is essentially the difference between the displacement of the upper and lower faces. Therefore, evaluating the jump needs only the displacement of the element edges locating on either side of the interface. The volumetric elements are not needed for the computation of the cohesive terms. The situation, however, changes for discontinuous Galerkin (dG) methods, see e.g., [47,34]. In dG methods, the FE displacement field is discontinuous across interelement boundaries (this is achieved by inserting interface elements along every interelement boundaries) and continuity in the displacement is weakly enforced by introducing extra terms which involve, in addition to〚u〛, also the averaged stress fieldσ=0.5(σ++σ-); whereσ+/-denote the stresses at either side of an interface. It has been shown that [34] dG methods can be implemented using interface elements. However, in order to compute the averaged stresses, the two volumetric elements to which the interface element is attached, see Fig. 8, are needed. In order to support dG methods, or the hybrid dG/cohesive interface elements [45,34,20], the previously presented algorithms were updated (with a slight modification) to generate the indices of volumetric elements that attach to the interface elements. Note that this is also useful for analyses based on triaxiality cohesive elements [58] or dG based rotation-free shell elements [36].The program is entirely written in object-oriented C++ and uses the Standard Template Library (STL) and the Boost library which can be downloaded at www.boost.org. The program can be compiled using the scons program, (www.scons.org) or using Gnu Make. It has been compiled and tested on Ubuntu and Mac OS machines. By issuing the command ./interface-elem –help on a terminal, one gets the help given in List 1.Currently the code only supports Gmsh meshes [59] and the FE solver jem-jive [60]. In other words, it reads a Gmsh mesh file, generate the interface elements and write output files in jem-jive format. However extension can be made to support other formats. An Abaqus extension is about to finish. As can be seen, the program generates two output files–one stores the modified mesh of bulk elements and the second contains the mesh of interface elements. The option ”–isContinuum” is used to generate either standard cohesive interface elements or discrete spring elements [61]. The option ”–domain domNum” is used to not create interface elements in a domain numbered domNum. This is useful for instance if one does not allow hard inclusions (embedded in a soft matrix) to be cracked.In this section some numerical results will be presented to illustrate the utility of the proposed meshing program and the efficiency of the energy-based arc-length control [62–64] in modeling material failure. The quasi-static examples include debonding of a single fiber in an epoxy matrix, multiple delamination of a composite beam and inter-granular cracking of a notched polycrystalline sample. A dynamic fracture example using the hybrid discontinuous Galerkin/cohesive elements is also given. The original meshes (one without interface elements) have been generated using Gmsh [59].Considering a single fiber in an epoxy matrix as shown in Fig. 9[65]. The specimen is subjected to prescribed displacement in the x direction while the top and bottom edges are constrained in the y direction. The bulk materials are taken as linear elastic materials with parameters given in Fig. 9 whereas the interface is modeled by the Xu–Needleman’s TSL [29] withσmax=50MPa,q=1,r=0andδn=δt=10-5mm. The weighting factorβused to compute the effective displacement jump is taken as 2.3 [66]. Due to symmetry, only a quarter of the specimen is modeled and the plane strain condition is assumed.Given the displacement jump(Δn,Δt), the traction according to the Xu-Needleman’s TSL [29] is written as(18)tn=-ϕnδnexp-Δnδn-r+Δnδn1-qr-1-q+r-qr-1Δnδn-1exp-Δt2δt2tt=2ϕnδt2Δtq+r-qr-1Δnδnexp-Δnδnexp-Δt2δt2whereδnandδtare the characteristic separations in the sense thattn(δn)=σmaxandtt(δt/2)=τmaxwithσmaxbeing the maximum value of the normal traction (also called tensile strength) andτmaxdenotes the ultimate shear traction. Furthermore, the mode-mixity of the model is controlled by the parameters q and r. The first parameter denotes the ratio of the fracture energy in the normal and shear directionq=ϕt/ϕn, the second parameter controls the magnitude of the normal openingΔn∗in case of a complete pure shear separation when the normal traction is zero:r=Δn∗/δn. In Eq. (18),ϕnandϕtrepresent the amount of work needed for complete separation. Using the definitions of the characteristic separationstn(δn)=σmaxandtt(δt/2)=τmax, one can determineϕnandϕtas follows(19)ϕn=σmaxexp(1)δn,ϕt=τmaxexp(1)/2δt,An unstructured mesh consists of 3440 quadratic triangular elements and 31 six-node interface elements is adopted. Concerning the solver, the simulation starts with load control of constant load step equals 0.1N up to step 6 where the released energy G exceeded 510−8Nmm the solver is switched to the arc-length control. The load versus prescribed displacement curve is shown in Fig. 10together with the deformed configuration. It can be shown that the energy arc-length control is able to capture both the limit point and the snapback behavior in a low number of load steps. The number of iterations of all steps around this critical point is only 3 which proves the robustness of the method.This example addresses a multiple mixed-mode delamination analysis of a composite specimen. The geometry and loading is given in Fig. 11. This problem was studied several times, see e.g., [23,67]. There are two initial cracksthe first initial crack on the left-hand of the specimen is placed along the mid plane and the second initial crack is positioned 20mm on the right of and two plies below the first crack. In the numerical model, a plane strain state is assumed and material properties, which are taken from [23], is given in Table 1. The interface stiffness is k=105N/ mm3. In this example, we adopt the damage-based bilinear cohesive law developed in [68,69].Since there are two potential delamination surfaces, one is the interface between layers 12 and 13, the second one is the interface between layers 10 and 11, the mesh has been built in such a way that elements on either sides of those delamination surfaces are assigned to different groups (indicated by different colors in Fig. 12). Following the standard procedure given in Box 2 would generate interface elements along the whole delamination surfaces which is obviously not desired. So, the program has been implemented an option not to add interface elements along existing notches (however, the nodes on those notches are still duplicated). Furthermore, for nodes fall within0⩽x⩽60andy=-0.265, albeit interfacial nodes, they are not duplicated, thus no interface elements are created there. A mesh of5×360four-node quadrilateral elements and 361 four-node interface elements is adopted. Contact elements are placed along the second initial crack to avoid interpenetration there.The deformed configuration obtained is presented in Fig. 14. The response of the specimen in terms of the reaction and two times the displacement at the top left corner is plotted in Fig. 13. A good agreement with the solution reported in [70] was obtained.In this section the intergranular fracture of a specimen made of polycrystalline material is presented. The geometry of the specimen together with the FE mesh is shown in Fig. 15. The bulk material is simply an isotropic elastic one with E=72,000N/mm2 andν=0.33. The interfaces are modeled using the Xu–Needleman exponential TSL [29] with the following parametersβ=1,rand q are taken of 0 and 1 respectively,σmax=500N/mm2andδn=δt=0.001. The left edge is fixed in both directions and a horizontal force is applied on the right edge. The deformed configuration is given in Fig. 16. For a throughout study on inter-granular fracture of polycrystals, we refer to the work given in [71] which employs XFEM/GFEM.Finally we present some examples on 3D fracture problems using the 2D interface elements as shown in Fig. 17. In the top-left figure is shown the deformation of a sample made of a composite material with four long fibers. The sample is subjected to a uniaxial displacement in the horizontal direction. In the top-right figure, a thin slice of a polycrystalline solid was studied. Again the sample was under uniaxial tensile loading. The bottom figure is the familiar 3D cantilever beam with an initial notch at the middle plane of the beam starting from the left. It should be emphasized that the examples were provided to demonstrate the capability of the presented program to generate 2D cohesive elements for 3D geometries..A doubly notched specimen under an impact load is investigated. The geometry of the specimen is shown in Fig. 18, and the impact loading is applied by a projectile. In the experiment [72], two different failure modes were observed by modifying the projectile speed,v0; at high impact velocities, a shear band is observed to emanate from the notch at an angle of10°with respect to the initial notch and at lower strain rates, brittle failure with a crack propagation angle of about70°is observed. We are interested only in the velocity range that resulted in a brittle failure mode. Note that the failure model also depends on the notch tip radius, see [73] for a discussion on this. The material parameters of Maraging steel 18Ni (300), which are taken from [74], are as follows: Young’s modulus E=190GPa (×103MPa), a Poisson ratio ofν=0.3, and a density of ρ=8000kg/m3. The material properties for the interface elements (the initially rigid damage-based bilinear cohesive law [68,69] is used) areτ10=τ30=1733MPa (N/mm2) (tensile and shear strength),GIc=GIIc=22.2N/mm (fracture energies),K=106N/mm3 andμ=1.0. The wave speed isc=E/ρ=4873.4m/s. Due to symmetry only the upper half was modeled and the impact velocityv0of 16.54m/s is applied along the edge of the sample hit by the projectile. In our implementation we imposed the displacement boundary conditions rather than the velocities. Therefore, on the impact edge, a prescribed displacementux=v0×t(t denotes the time) is imposed.The FE mesh is depicted in Fig. 19with a refinement of the region where the crack is going to appear. The crack trajectory with respect to time is shown in Fig. 20. It can be seen that a good agreement of the crack path with the experiment was obtained. The propagation angle is estimated to be around 69°, which agrees well with the experimental prediction 70°. Although the overall crack path follows an inclined direction, from Fig. 20b, the initial crack propagation shows a short vertical segment. Other researchers [37,73,74] also reported similar results, although in [74] a very short vertical crack segment was present. In order to study mesh convergence of crack path, we performed another simulation with a slightly different mesh, called mesh2 in the sequel (the other is called mesh1). The crack path obtained with mesh2 is compared with the one obtained with mesh1 and the result is depicted in Fig. 21. As can be seen, the crack paths are quite similar regardless of using different meshes.

@&#CONCLUSIONS@&#
In this paper, simple algorithms to generate cohesive surfaces into a finite element mesh was presented. The resulting program, which is available for download without any cost on our website, is believed to be useful for researches on fracture modeling of structure and material. The program is able to create both one and two dimensional cohesive elements, both linear and quadratic. In the current implementation, only the mesh created by Gmsh is supported and the output format is tailored to our in-house FE code. Extension to other mesh formats, is, however, straightforward. Future work would be to incorporate this directly into a good free mesh generator like Gmsh.Also given in the paper was the flowchart of a general interface element implementation that works for any interface element type in both 2D and 3D. This flowchart is interestingly very closed to the one of the phantom node method, a simple version of XFEM, that has simplified the implementation of XFEM into existing FE codes.Concerning fracture modeling using interface elements, as mentioned in the introduction, one remedy to the reliance of the method on the use of a high dummy stiffness is to exactly constraint the interface elements and activate them when a certain failure criterion is fulfilled. This technique was adopted in [19] but without implementation details. It would be interesting to perform a comparative study between this technique and the discontinuous Galerkin based cohesive interface elements [45,20] which approximately constraint the interface elements in the pre-failure stage.