@&#MAIN-TITLE@&#
A hybrid metaheuristic algorithm for the multi-depot covering tour vehicle routing problem

@&#HIGHLIGHTS@&#
We propose a generalization of the multi-depot capacitated vehicle routing problem.The demand of customers could be satisfied by visiting them on the tour or by covering.Mixed integer formulations and a hybrid metaheuristic algorithm are proposed.Extensive computational tests indicate the effectiveness of developed solution method.

@&#KEYPHRASES@&#
Vehicle routing,Multi-depot capacitated covering tour vehicle routing problem,GRASP,Simulated annealing,Hybrid metaheuristic,

@&#ABSTRACT@&#
We propose a generalization of the multi-depot capacitated vehicle routing problem where the assumption of visiting each customer does not hold. In this problem, called the Multi-Depot Covering Tour Vehicle Routing Problem (MDCTVRP), the demand of each customer could be satisfied in two different ways: either by visiting the customer along the tour or by “covering” it. When a customer is visited, the corresponding demand is delivered at its location. A customer is instead covered when it is located within an acceptable distance from at least one visited customer from which it can receive its demand. For this problem we develop two mixed integer programming formulations and a hybrid metaheuristic combining GRASP, iterated local search and simulated annealing. Extensive computational tests on this problem and some of its variants clearly indicate the effectiveness of the developed solution methods.

@&#INTRODUCTION@&#
The vehicle routing problem (VRP) is one of the most widely studied problems in the field of combinatorial optimization. VRP literature dates back to 1959 when Dantzig and Ramser (1959) introduced it for the first time as the “truck dispatching problem”. Generally, VRP is aimed at servicing a given set of customers using a set of vehicles located at a central depot. Several objectives have been reported for the VRP among which we can mention the minimization of the routing cost (time) and the minimization of the total fixed and variable costs. For a complete review of the different VRP variations we refer the interested readers to the books Cordeau et al. (2007, chap. 6), Golden et al. (2008),Toth and Vigo (2002) and the survey papers by Eksioglu et al. (2009) and Laporte (2007); 2009). In the classical capacitated VRP (CVRP), we are given a fleet of homogenous capacitated vehicles located at a central depot. The goal of the CVRP is to construct a set of vehicle routes having the minimum total cost while satisfying the entire demand of the customers. Each vehicle starts and ends its route at the depot while the total demand carried by each vehicle cannot exceed its given capacity. Several heuristics, metaheuristics and exact methods have been proposed for the solution of the CVRP in the literature (see, e.g. Baldacci et al., 2004; Baldacci and Mingozzi, 2009; Chen et al., 2010; Cordeau et al., 2007, chap. 6; Toth and Vigo, 2002). In contrast to the classical VRP in which a single depot is available, in the multi-depot VRP (MDVRP) we are given several depots, each equipped with a given number of vehicles (see, e.g. Chao et al., 1993; Laporte et al., 1984; Liu et al., 2011; Tillman, 1969; Toth and Vigo, 2002). Several methods have been developed to solve the MDVRP including a branch and bound exact method (Laporte et al., 1988), heuristics (Chao et al., 1993; Gillett and Johnson, 1976; Raft, 1982; Sumichras and Markham, 1995) and metaheuristics (such as genetic algorithm (Ho et al., 2008; Vidal et al., 2012), adaptive large neighborhood search (Pisinger and Ropke, 2007), variable neighborhood search (Polacek et al., 2004), tabu search (Renaud et al., 1996) and ant colony optimization (Yu et al., 2010)). A recent survey on the MDVRP and its variants is performed in Tiantang et al. (2011).In many practical applications due to restrictions on time, budget, resource availability (e.g., the number or the capacity of the vehicles) or unavailability of roads reaching a specific customer, it is not possible to visit all the customers with the vehicles routes. To cope with some of these situations, the option of covering has been introduced in the literature. In this case the demand of unvisited (covered) customers could be delivered at a place located within an acceptable walking distance from that. The covering salesman problem (CSP) is one of the first routing problems in which visiting each of the customers on the tour is not necessary (see, Current and Schilling, 1989). In this problem we are given a single vehicle and a set of customers. The goal is to construct a minimum length Hamiltonian cycle over a subset of the customers in such a way that unvisited locations lay within a pre-specified covering distance from at least one visited customer. Several solution methods have been presented in the literature for the CSP and its variants (Arkin and Hassin, 1994; Golden et al., 2012; Salari and Naji-Azimi, 2012).Gendreau et al. (1997) introduced the covering tour problem (CTP) in which the set of vertices is divided into two groups (i.e. N = N1∪N2). Set N1 includes the vertices that can be visited and contains a set T of vertices that must be visited. In addition, set N2 includes the vertices that must be covered by the tour. The goal of the CTP is to construct a minimum length Hamiltonian cycle over the vertices in T and possibly a subset of vertices in N1∖T, in which all vertices in N2 are covered. Hachicha et al. (2000) developed a multi vehicle variant of the CTP with several practical applications, including the design of the routes for mobile healthcare delivery teams. In this problem the goal is to design m Hamiltonian cycles over a subset of vertices to visit the vertices in T and cover all of the vertices in N2. The authors proposed a mathematical formulation and three heuristic algorithms for the introduced problem. Moreover, Lopes et al. (2013) developed a branch-and-price algorithm for this problem. Finally, branch-and-cut and metaheuristic algorithms were proposed by Bostel et al. (Hà et al., 2013).The covering issue has a wide variety of applications in the real world. As an example, we can find the combination of routing and covering concepts in problems arising in emergency situations such as earthquake, flood and tsunami (Altay and Green, 2006; Caunhye et al., 2012; De La Torre et al., 2012). Nolz et al. (2010) defined a multi-objective covering tour problem to distribute water to people in an area affected by a disaster. The objectives considered in this problem are the minimization of the total distance travelled by the covered customers to reach their nearest visited vertex, the number of the customers unable to reach a visited customer within a pre-specified maximum distance, the tour length, and the latest arrival time at a customer. Doerner et al. (2007) described a multi-objective combinatorial optimization problem which is applicable in the healthcare management. The goal of their problem is to design a single tour through a subset of vertices by taking three objective functions into account: (1) improving the economic efficiency of the tour, (2) minimizing the average distances traveled by the unvisited people to reach their nearest tour stops and (3) minimizing the population percentage unable to reach a tour stop within a pre-specified maximum travel time. Another application of covering to healthcare is described in Hodgson et al. (1998). Finally, Naji-Azimi et al. (2012) modeled a generalization of the covering tour problem in which the customers demand is fulfilled by some satellite distribution centers located within a predefined distance from their domiciles.In this paper, we propose a generalization of the MDVRP including the covering option, called the Multi-Depot Covering Tour Vehicle Routing Problem (MDCTVRP). Here, the demand of each customer could be satisfied either directly, by being visited on the tour or indirectly, by being covered by the tour, i.e., when its location is within a given covering distance of at least one visited customer. In other words, our problem is a combination of the MDVRP and CSP problems. Among the many practical applications of MDCTVRP we mention the distribution of goods to the people in an area affected by a disaster. In such a situation, the humanitarian services could be provided by different depots and, because of the limitation in time resource we cannot visit all customers on the routes. In addition to the routing cost occurred by visiting the customers on the vehicles’ routes, we introduce a covering cost which is proportional to the distance travelled by the covered customers to reach their corresponding allocated nearest customer visited on a route. To the best of our knowledge this problem has not been previously addressed by the literature. An illustrative example of the studied problem is given in Fig. 1. This sample network contains 2 depots, 74 customers and 2 vehicles per depot. Overall, 30 customers are visited by the tours which are used to cover the demand of the unvisited customers.The paper is organized as follows. The formal description of the introduced problem is provided in Section 2 where two mixed integer linear programming models are introduced. Details of the proposed hybrid metaheuristic algorithm are presented in Section 3. In Section 4 we report the results of computational tests of the proposed algorithms on MDCTVRP and some of its variants. Finally, some conclusions are drawn in Section 5.In MDCTVRP we are given a directed graph G = (N, A) in which N = NC∪NDis the set of vertices, and A = {(i, j)|i, j ∈ N} is the set of arcs. More precisely, NC= {1, 2, …, nc} represents the set of customer vertices where each i ∈ NChas a pre-specified demand, di> 0, to be met by exactly one vehicle. Moreover, ND= {1, 2, …, nd} is the set of depots from which the vehicles start their trips. Each arc (i, j) ∈ A is associated with a non-negative routing cost cij, equal to the cost of traversing arc (i, j) by the vehicles. In MDCTVRP it is not necessary that each customer is visited by a vehicle and the unvisited customers should be within an acceptable distance from at least one visited customer. To this end we defineπ=[πij]nc·ncas the covering matrix, where ∀i, j ∈ NC, πij= 1 if and only if customer i is located within a pre-specified distance from customer j. Note that to favor feasibility we assume that for each i ∈ NCthere is at least one j ∈ NCsuch that πij= 1. For each i, j ∈ NCthe non-negative costcij′represents the allocation cost of customer i to the visited customer j. We assume that a limited set P = {1, 2, …, p} of capacitated vehicles is available, where each vehicle v ∈ P has capacity Q. The assumption is that the capacity of each depot k ∈ NDis limited and equals to H. Finally, at each depot k it is located a given set of vehicles represented by Pk= {1, 2, …, pk} where Pkconstitute a partition of P.We have developed two mathematical models, namely one flow-based and one node-based formulation for MDCTVRP that will be used in the computational evaluations. Before getting into the details of each model, we define the variables which are common to both formulations. In particular, we use two sets of binary decision variables:xijv={1ifarc(i,j)∈Aistraversedbyvehiclev∈P,0otherwise.wijv={1ifdemandofcustomeri∈NCisallocatedtothevisitedcustomerj∈NCbyvehiclev∈P,0otherwise.Note thatwiiv=1if customer i ∈ NCis visited by vehicle v ∈ P.In this section, we develop a flow-based integer programming formulation for MDCTVRP. In this model the subtour elimination constraints are adaptations of those introduced for the VRPs (Kara, 2008; Karaoglan et al., 2009; 2012). The model uses an additional set of continuous decision variables,uijv,which represent the load of vehicle v ∈ P after leaving vertex i when traversing arc (i, j).The model reads as follows:(1)Fflow:min∑i∈N∑j∈N∑v∈Pcijxijv+∑i∈NC∑j∈NC∑v∈Pcij′wijvsubject to:(2)∑j∈Nxijv=∑j∈Nxjiv∀i∈N,v∈P,(3)∑j∈NC∑v∈Pwijv=1∀i∈NC,(4)∑l∈N,l≠iπijxjlv≥wijv∀i,j∈NC,v∈P,(5)∑j∈Nxijv≤wiiv∀i∈NC,v∈P,(6)∑j∈Nxijv≤1∀i∈N,v∈P,(7)∑i∈NC∑j∈NC∑v∈Pkdiwijv≤H∀k∈ND,(8)∑i∈N∑m∈ND,m≠kximv=0∀k∈ND,v∈Pk,(9)∑j∈Nujiv−∑j∈Nuijv=∑j∈NCdjwjiv∀i∈NC,v∈P,(10)∑j∈NCukjv=∑i∈NC∑j∈NCdiwijv∀k∈ND,v∈Pk,(11)∑i∈NCuikv=0∀k∈ND,v∈Pk,(12)uijv≤(Q−di)xijv∀i,j∈N,v∈P,(13)djxijv≤uijv∀i,j∈N,v∈P,(14)xijv∈{0,1}∀i,j∈N,v∈P,(15)wijv∈{0,1}∀i,j∈NC,v∈P.The objective function (1) minimizes the total routing and allocation costs. For each i ∈ N and v ∈ P, constraint (2) imposes that the number of arcs entering i by using vehicle v has to be equal to the number of arcs leaving i associated with the same vehicle. For each customer i ∈ NC, constraint (3) indicates that the demand of i has to be satisfied by either visiting it or by allocating it to a visited customer. Constraint (4) stipulates that i ∈ NCcan be allocated to the visited customer j ∈ NC, if i is within an acceptable covering distance of j, i.e., when πij= 1. For each customer i ∈ NC, its demand can be allocated to itself (i.e.,wiiv=1) if and only if it is visited by a vehicle v ∈ P and this is imposed by using constraint (5). For each customer i ∈ NCand vehicle v ∈ P, constraint (6) shows that i can be visited at most once by a vehicle v. Constraint (7) gives the capacity restriction of each depot k ∈ NDwhich is bounded by H, followed by constraint (8) imposing that each vehicle terminates its trip at the same depot from which it was started. Flow conservation constraints are given in (9)–(11) which remove the subtours from the solution and impose the capacity restrictions. In particular, constraints (9) state that the load difference for vehicle v ∈ P before and after visiting customer i is equal to the total demand allocated to i. Furthermore, the total load of each vehicle v ∈ P is equal to the total demand allocated to v and it is imposed by applying constraints (10). Constraint (11) shows that the load of the vehicles is equal to zero when visiting the depot as the last vertex. Finally, (12) and (13) are the bounding constraints for the flow variables while (14) and (15) define the variables.An alternative model for MDCTVRP in now provided, where the subtour elimination constraints are a generalization of the well-known Miller–Tucker–Zemlin constraints developed for the TSP (Miller et al., 1960). These constraints were adapted to the VRP by Kulkarni and Bhave (1985). Finally, improvements of the original constraints for the TSP were proposed by Desrochers and Laporte (1991) and by Kara et al. (2004). This model requires additional decision variables, defined as follows.uiv: The load of the vehicle v ∈ P just before visiting customer i ∈ NC.The model, denoted as Fnode, is given in the following.Fnode:min∑i∈N∑j∈N∑v∈Pcijxijv+∑i∈NC∑j∈NC∑v∈Pcij′wijvsubject to: (2)–(8) and (14)–(15)(16)ujv−uiv+Qxijv+(Q−di−dj)xjiv≤(Q−∑s∈NCdswsiv)∀i≠j∈NC,v∈P(17)∑j∈NCdjwjiv+∑j∈NC,j≠idjxijv≤uiv∀i∈NC,v∈P(18)uiv≤Qwiiv∀i∈NC,v∈PConstraints (16) remove subtours from the solution. Finally, (17) and (18) put bounds on the values taken by uivfor each i ∈ NCand v ∈ P.As shown by the computational results presented in Section 4, the developed exact models fail to obtain optimal or even a feasible solution for the majority of the tested instances. As a result, by combining the iterated local search (ILS), greedy randomized adaptive search procedure (GRASP) and simulated annealing (SA) metaheuristics, we propose a hybrid metaheuristic algorithm for MDCTVRP that is able to obtain high quality results within acceptable CPU time.GRASP is a multi-start algorithm proposed by Feo and Resende (1995) where each iteration of it consists of two phases: construction and local search. During the construction phase an initial feasible solution is generated. Then a local search procedure tries to improve it. The ILS combines the local search and shaking procedures for solving different optimization problems. In particular, the algorithm uses the shaking procedure to escape from local optimal solutions obtained by applying the local search procedure (Lourenço et al., 2003). The SA is a probabilistic search method introduced by C̆erný (1985) and Kirkpatrick (1984). To escape from a local optimum, the SA method allows acceptance of non-improving solutions during the search process.We propose a hybrid algorithm, called GRASP × ILS, with a threshold accepting rule based on SA to accept also degraded solutions, as shown in Algorithm 1. The method consists of φ iterations of the GRASP algorithm, where, at each iteration we have: (1) the construction procedure to create an initial feasible solution (S), (2) the local search procedure to find fromSa possibly improved solutionSimpand, (3) the execution of the ILS algorithm to possibly further improveSimp. Given the current solutionScur,at each iteration of the ILS algorithm a shaking procedure is employed in order to escape from local optimum solution, followed by the local search procedure to possibly obtain an improved solutionStemp. Moreover, we have designed an integer linear programming (ILP) based improvement procedure that is executed every ξ iterations. If the solutionStempobtained by utilizing the local search procedure improves the best solution,Simp,the algorithm accepts that as the new current solution, otherwise, it will be accepted with a probability proportional to the deviation of its cost with respect to that ofSimp. A similar combination of the GRASP and ILS algorithms for vehicle routing has been introduced by Prins (2009). The same author in Prins (2012) has introduced in the hybrid algorithm a threshold accepting rule as that described above. In the following sections, we provide the details for each procedure.The algorithm we use to generate an initial feasible solution consists of two steps. First we have the clustering phase in which the customers are allocated to the depots, followed by the routing phase, where routes are generated. The detailed description of the two phases are as follows.•Clustering: To generate an initial feasible solution, first the customers are clustered into |ND| groups. To this end, each customer is allocated to the nearest depot. Following this step, if the clustering is feasible, i.e., it does not violate the depot capacity H, we proceed to the second step, otherwise the algorithm makes the clusters feasible as follows. Let k ∈ NDbe a depot for which the capacity has been violated. We represent by Bk= {1, 2, …, bk}, the set of all customers allocated to depot k. For each i ∈ Bk, the algorithm calculates a penalty proportional to the cost difference of allocating customer i to its second nearest feasible depot vertex. Upon calculating such a value, the customers are sorted in a non-decreasing order of their corresponding penalties. Starting from the customer with the smallest penalty, it will be allocated to the second nearest feasible depot. This procedure is iterated as long as the total demand of customers allocated to each depot k ∈ ND, i.e.∑i∈Bkdi,is greater than H.Routing: During the routing phase, we represent by Rkthe set of generated routes for depot k. Given a depot k ∈ NDwith the clustered customers set Bk, the routing phase starts by randomly selecting a customer from Bk. An initial route is generated by connecting the selected customer to the depot k. Then we have |Bk− 1| iterations in each of which a new customer is selected from Bkand is either visited or covered in the best feasible position in Rk, i.e. the position with the cheapest routing or covering cost. Moreover, the customers are allowed to generate new routes depending on the extra cost imposed to the solution and this could happen if the number of routes in Rkis less than |Pk|. In particular, for each customer j ∈ NCthe cost of routing or allocating j into its best feasible position is first calculated, then the customer with the cheapest insertion cost is selected and added to its corresponding position in the solution. For each depot k ∈ ND, the procedure is iterated until all the customers are visited or covered into feasible positions.Local search has been applied to a wide variety of combinatorial optimization problems (see Aarts and Lenstra, 1997 for an overview). In this section, we introduce seven local improvement procedures, called LS1, …, LS7 that we use to possibly improve the feasible solutions. The first six local search procedures are used within the local search phase, while LS7 is only executed every ξ iterations of the SA algorithm (see Algorithm 1). The six locals search procedures are executed in a random order every time the local search phase is performed. The procedures are described in the following:•Removal-reinsertion of a visited customer (LS1): Given an initial feasible solutionSfor MDCTVRP, the algorithm selects a visited customeri∈Sand builds a restricted solutionS′by removing i from its original position inS. Then i is reinserted in the best feasible position inS′to possibly improve the visiting cost. When using this procedure the removed customer could also have some customers allocated to it. In such a situation, both i and all of its allocated customers, will be reinserted intoS′from the original place they have been disconnected. Moreover, if the extracted component consists of a single customer, the algorithm checks both possibility of revisiting it as visited or as covered. The procedure is repeated by considering all the visited customers inSin ascending index order and stops when there is no improvement in the tour length by repositioning any such customers. The framework of LS1 is given in Algorithm 2, while an illustrative example is shown in Fig. 2. In this example, the visited customer A together with the covered customers B and C are removed from the jth route and inserted into a new position in route i.Removal-reinsertion of a covered customer (LS2): This procedure attempts to improve the solution cost by reallocating the covered customers. More precisely, a covered customer i ∈ NCis removed from the initial solutionSand reinserted into the through the best feasible position, i.e. the location with the cheapest reinsertion cost. The removed customer could be reinserted in a route as visited or covered by another visited customer. The procedure is applied to all covered customers inS(in an ascending order of their index) and it stops when there is no improvement by repositioning all of the covered customers.Swap of the visited customers within the same route (LS3): LetSkdenote the set of customers visited by vehicle k ∈ P. This procedure possibly improve the route cost by swapping the positions of vertices visited in route k, see Flood (1956). In case one or both of the swapped customers have some customers allocated to them, such allocation will be kept. The pseudo code of LS3 is given in Algorithm 3, and an example is depicted in Fig. 3in which the customers A and B are swapped together with the allocated customers.Swap of the customers visited in different routes (LS4): This procedure follows the same idea of LS3 by considering customers belonging to different routes. An example is given in Fig. 4where the visited customers A and B are swapped. The moves may be infeasible with respect to the capacity constraints.Two-arc exchange (LS5): Two distinct routes belonging to the same depot are selected and two partial routes will be obtained by extracting one arc from each of the routes. Following this step, the algorithm attempts to make two feasible routes by inserting to the partial solutions all feasible choices of the two arcs and selecting the best substitution, i.e. the one with the minimum total exchange cost. The move will be accepted if it improves the initial cost of the solution, see Potvin and Rousseau (1995). For each pair of routes, all the possible ways of extracting the arcs will be considered. The framework of this procedure is shown in Algorithm 4. An illustrative example is given in Fig. 5, where arcs (A, C) and (B, D) are removed from the initial solutionSand two new solutions are generated by substituting arc sets {(A, B), (C, D)} and {(A, D), (B, C)}.Cross string (LS6): Given two distinct routes i and j, two sequences of consecutively visited customers are removed from i and j, respectively. Then, all the possible ways of reconnecting the generated partial routes are considered and the best one is selected (see Taillard et al., 1997 for more details). We consider, for all pairs of routes, all the possible sequences with at most three consecutive customers or less. The algorithm stops when there is no improvement in the objective function by using this type of exchanges. In case the selected customers have some covered customers, they remain allocated to their original customer after the substitution. An example is given in Fig. 6in which the sequence {A, B, C} is removed from the first route and the sequence {D, E} from the second route. As the figure shows, in total four different ways to reconnect the resulting partial routes exist.ILP-based procedure (LS7): The goal of this procedure is to obtain a new rearrangement of the allocated customers in order to reduce the total allocation cost. Suppose we are given an initial feasible solutionSin whichN⊆NCrepresents the set of covered customers ofS. A restricted solutionS′is constructed by extracting fromSall the customers inN. After this step, the extracted customers are reallocated to the visited locations ofS′through solving an ILP-based model to optimality. Before introducing the proposed ILP model we define VCvas the residual capacity of route v ∈ P in the restricted solutionS′,and DCkas the residual capacity of depot k ∈ NDin the restricted solutionS′. Let alsoSv′denote the set of customers visited by route v in the restricted solutionS′,v=1,…,|P|.The model, called the reallocation model (RM) defines the allocation decisions for the covered customers as follows:(19)RM:min∑i∈N∑v∈P∑j∈Svcij′wijvsubject to:(20)∑v∈P∑j∈Sv′wijv=1∀i∈N,(21)∑i∈N∑j∈Sv′diwijv≤VCv∀v∈P,(22)∑i∈N∑v∈Pk∑j∈Sv′diwijv≤DCk∀k∈ND,(23)wijv∈{0,1}∀i∈N,v∈P,j∈Sv′.The objective function (19) minimizes the total reallocation cost. Constraint (20) imposes that eachi∈Nis allocated to exactly one visited customer. Capacity limitations of each vehicle v ∈ P and each depot k ∈ NDare imposed by applying constrains (21) and (22), respectively. Finally, decision variables are defined in (23).To try to escape from the local optimum solutions we have designed a shaking procedure. In this procedure, a restricted solutionS′is obtained from the initial solutionSby removing from it a given percentage (say h) of customers randomly generated in the interval [δ1, δ2]. If the selected customer has some covered customers, all of them are also removed from the solution provided that the total number of customers are not greater than the given percentage h. LetL′represent the set of removed customers. The second phase starts by selecting the first customer ofL′and assigning it to the best feasible position inS′,either as visited or covered. We iterate this process until all the extracted customers inL′are visited or allocated.We performed extensive computational tests to evaluate the performance of the proposed hybrid algorithm. Section 4.1 provides the characteristics of the generated data, followed by the discussion about the parameters tuning. In Section 4.2, we compare the performance of the hybrid metaheuristic, described in Section 3, with two models. Finally, Section 4.3 provides extensive tests on classes of capacitated VRP which are special cases of our problem. The code has been implemented in C + + and tested on a PC running at 2.93 gigahertz with 3.21 gigabytes of RAM. We use ILOG Cplex 12.3 to solve the exact models based on formulations Fflowand Fnode, and the ILP-based procedure presented in Sections 2 and 3.2, respectively.We have designed several randomly generated instances which are divided into small-size and large-size classes. The small-size class involves instances with 20, 25 and 30 vertices (in total three classes) which are considered to run the proposed exact formulations to optimality. Moreover, large-size instances contain between 50 and 90 vertices (in total four classes). Each instance is characterized by seven elements: the number of depots (|ND|), the number of customers (|NC|), the routing cost matrix (cij), the allocation cost matrix (cij′), the vehicles capacity (Q), the depots capacity (H) and the maximum number of vehicles assigned to each depot k ∈ ND(|Pk|). For each instance, the coordinates of the involved vertices are generated as integer values uniformly distributed in [0, 100]. Moreover, the demand of each customer is an integer value randomly generated in the interval [12, 20]. For each i, j ∈ N, the distance cijis obtained as the Euclidean distance between i and j while the allocation costcij′is calculated by using the following formula (24) in which parameter τ is either 2 or 4.(24)cij′={0cij≤α,(cij−α)·τα<cij≤β,∞cij>β.In particular, if the distance cijbetween vertices i and j is less than a given value α, it will be covered at no cost, if cijbelongs to (α, β], the customer will be covered by paying a cost proportional to the distance exceeding α. Finally, if cijis greater than β, the customer cannot be covered.In our instances all the depots have the same capacity (H) calculated as follows:(25)H=∑i∈NCdi|ND|·ν.where ν is a random parameter generated from a uniform distribution in [1, 1.2].Moreover, we assume a fleet of homogenous vehicles to be available where the capacity of each vehicle is represented by Q. Finally, for each depot k ∈ NDthe total number of assigned vehicles is obtained using the following relation.(26)|Pk|=⌈HQ⌉∀k∈ND.According to the total number of vertices, the instances are divided into seven categories. Each category contains eight different groups of instances by considering two scenarios for the number of depots, the capacity of the vehicles and the coverage coefficient, resulting in 56 groups of instances. Moreover, for each such group of data, five random instances are generated which differ in customers coordinates and demands. The characteristics of the generated instances and the range of the involved parameters are summarized in Table 1. According to this table, for each of the parameters ND, Q and τ, two scenarios have been considered which are indicated by 0 and 1 in the appropriate columns.In the following tables, each group of instances have names of the form InputXYZT, where “X” represents the category of the problem, and “Y”, “Z” and “T” represent the scenarios corresponding to the number of depots, capacity of the vehicles and the coverage coefficient (τ), respectively. For example, Input7101 is a group of data with |N| = 90, |ND| = 4, Q = 180, τ = 4, α = 2 and β = 5.To set the value of algorithm parameters, we assign a value to each of them in turn and keep all the other parameters fixed. For each combination of parameters we ran the program five times on a set of benchmark instances and the combination with the best overall gap is selected as the best setting. Table 2gives the assigned values for the involved parameters.In this section we compare the performance of the proposed exact formulations and the hybrid metaheuristic algorithm. First, we focus on the small-size instances for which we run the exact formulations. For each such instance, CPLEX is run with a time limit of 7200 seconds using both Fflowand Fnodemodels. Moreover, we use the results obtained by the exact formulations to evaluate the performance of the hybrid GRASP × ILS algorithm. In Table 3the columns corresponding to Fflowand Fnodegive the results obtained by the flow-based and node-based formulations, respectively. As stated in Section 4.1, each group of data contains five instances where each of which has been processed by CPLEX within the given time limit. The columns “Avg. gap” and “Avg. time” give the average optimality gap and the average running time over the five instances in each group of data, respectively. Moreover, for each group of data, column “#Opt” gives the total number of instances (out of 5) solved to optimality within the given time limit. The last eight columns of Table 3 give the results obtained by the hybrid metaheuristic algorithm. For each instance, we executed our hybrid metaheuristic five times. In the table, the columns labeled by “Best” and “Avg.” give, respectively, the best and average solutions’ cost obtained by the metaheuristic over the five runs. Similarly columns “Best gap” and “Avg. gap” report the best and the average gap of the solutions with respect to the best solution found by the exact algorithm. Moreover, column “#Best” gives the number of times that the best solution is obtained by the hybrid algorithm out of five different executions. We also compare the two exact models by reporting their corresponding lower bounds (LB) obtained from the linear programming (LP) relaxation of the models. For each group of data, the corresponding average gap between LB and the best feasible solution (UB) obtained by our developed hybrid algorithm (i.e. Gap = 100 × (UB − LB)/UB) are reported in the “LP gap (Fflow)” and “LP gap (Fnode)” columns, for the flow-based and node-based formulations, respectively.Based on the results reported in Table 3, the overall gap to the optimality, over 120 instances of the small-size data is 8.99 percent and 30.28 percent for the flow-based and node-based formulations, respectively. When considering the number of instances solved to optimality, the flow-based model is able to prove optimality for only 10 instances, while this is as small as four for the node-based formulation. As to the LP relaxation gap of the exact models with respect to the best feasible solutions obtained from the hybrid metaheuristic algorithm, it is clear that the flow-based model performs much better than the node-based formulation. Particularly, the overall gap over 120 instances is 24.45 percent and 89.16 percent for the flow-based and node-based formulations, respectively. Comparing the best feasible solutions obtained from the GRASP × ILS algorithm with the best upper bounds reached by different formulations, shows the superiority of the hybrid metaheuristic algorithm for which the overall gap is − 0.38 percent. By considering the values reported in column “#Best”, we observe that in almost all of the executions of the hybrid algorithm, it has been able to reach the same solution.Table 4gives the results obtained from the hybrid metaheuristic algorithm over the 160 large-size instances. For these classes, the metaheuristic algorithm is compared against the LBs obtained from the LP relaxation of the flow-based model. The algorithm has been executed with three different values of parameter φ (see Algorithm 1) where for each value taken by φ. In this table the “Avg. gap” column gives the corresponding gap of the “Avg.” column with respect to the results obtained by the LP relaxation of the flow-based model. The results indicate that the algorithm is not so sensitive to the global number of the GRASP iterations and also to the different executions of the algorithm over the same instance. Taking into account the best performance of the hybrid metaheuristic algorithm, by increasing the value of φ from 5 to 10 it leads to 0.06 percent improvement in the overall gap while this is just 0.03 percent when increasing φ from 10 to 15. Considering the small-size instances, the overall LP relaxation gap of the flow-based model with respect to the hybrid method is 24.45 percent while this is around 21 percent for the large-size data. Therefore, it is likely that the actual quality of the heuristic solutions is very good being close to optimal solution as happened for the small-size instances.The proposed hybrid metaheuristic algorithm could be easily adapted to be applicable to some of the VRP variants. Essentially, MDVRP, CVRP and OVRP are three special cases of MDCTVRP and their relations with it are shown in Fig. 7. More precisely, by removing the covering assumption from the problem (i.e., by setting πij= 0, ∀i ≠ j ∈ NC) transforms MDCTVRP into MDVRP. Moreover, by assuming |ND| = 1 and πij= 0, ∀i ≠ j ∈ NC, the problem will be converted into CVRP. Finally, by setting to zero, the cost corresponding to each arc i ∈ NCand j ∈ ND, |ND| = 1 and πij= 0, ∀i ≠ j ∈ NC, we will obtain the OVRP.To evaluate the performance of the GRASP × ILS algorithm, we compare it with the state-of-the-art solution techniques available in the literature for MDVRP, CVRP and OVRP. To perform a fair comparison of the running times of the different methods available for VRP variants, we scaled the running times for the different computers as indicated in Dongarra (2013). The computer scaling is shown in Table 5, where for each reference the second column represents the computer used, followed by its Mflops from Dongarra (2013) and the scaling factor (r) given in the next two columns, respectively. Running times in different papers are appropriately multiplied by the scaling factor r. All reported CPU times in this section are expressed in seconds and scaled according to the values of r given in Table 5. We use almost the same set of parameters as those already developed for the introduced problem except [δ1, δ2] that is [7, 37] and [6, 40] for CVRP and OVRP, respectively. In the following, the obtained results are described in details.We have selected a set of 11 instances of MDVRP that are utilized by many researchers to assess the performance of their developed solution methods. The comparison between GRASP × ILS and the best available results on 11 test problems are reported in Table 6. In this table, the column labeled by “Best” gives the best available results introduced in the literature for different available instances. Columns 6–11 show the results obtained by Pisinger and Ropke (2007),Vidal et al. (2012) and Subramanian et al. (2013), respectively. More precisely, these methods are of the best heuristics proposed for MDVRP. For each such method, “Cost” and “Time” represent, respectively, the best solutions obtained over the 10 different executions of the algorithm and the total running time. For each instance we run the GRASP × ILS five times for which the best and average results are reported in columns “Cost” and “Avg.”, respectively. Column “#Best” gives the number of times that the best solution is obtained by the hybrid algorithm out of five different executions. Finally, the running time corresponding to a single algorithm’s execution is reported in the last column. In this table, the best solution in each row is written in bold. Computational results indicate that almost all of the best-known results are achieved by GRASP × ILS. There is only one instance that our method is not able to achieve the best available result for which the gap is only 0.05 percent.To test the performance of our method, we have selected seven instances proposed by Christofides et al. for the CVRP (Christofides et al., 1979). In particular, the method is compared with four of the best methods available in the literature. The detailed results are provided in Table 7for which the columns’ labels have the same meaning as those proposed for Table 6. The results clearly show the effectiveness of the method with the average gap 0.09 percent from the best-known results. Out of seven different instances in all but one of them the best-known results are achieved for which the gap is 0.62 percent. Taking into account the average performance of the hybrid metaheuristic algorithm, we can observe that in five instances the best known solutions are obtained by all of the five independent executions of the algorithm.Table 8shows the results obtained by our algorithm over nine different OVRP instances taken from Christofides et al. (1979) (instances C1–C15, C11 and C12) and from Fisher (1994) (instances F11 and F12). We compare our method with five state-of-the-art heuristics available in the literature. The results illustrate the efficiency of the GRASP × ILS algorithm. Moreover, the best cost available in the literature for C5 is that obtained by Salari et al. (2010) with 17 vehicles, while our algorithm is able to improve the best-known result. The best solutions obtained by the rest of the methods for C5, contain solutions with 16 vehicles (the number of vehicles is reported in parentheses).

@&#CONCLUSIONS@&#
