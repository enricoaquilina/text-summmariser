@&#MAIN-TITLE@&#
Facets and valid inequalities for the time-dependent travelling salesman problem

@&#HIGHLIGHTS@&#
We study theoretical properties of two formulations for the Time-Dependent TSP.We derive five families of facets and five other families of valid inequalities.The theoretical framework presented can be used to derive more families of facets.The polyhedral study significantly reduced the computing times of a B&C algorithm.The TDTSP stands as a very challenging problem to be solved by exact algorithms.

@&#KEYPHRASES@&#
Combinatorial optimization,Integer programming,Time-Dependent TSP,Branch and Cut,

@&#ABSTRACT@&#
The Time-Dependent Travelling Salesman Problem (TDTSP) is a generalization of the traditional TSP where the travel cost between two cities depends on the moment of the day the arc is travelled. In this paper, we focus on the case where the travel time between two cities depends not only on the distance between them, but also on the position of the arc in the tour. We consider two formulations proposed in the literature, we analyze the relationship between them and derive several families of valid inequalities and facets. In addition to their theoretical properties, they prove to be very effective in the context of a Branch and Cut algorithm.The Time-Dependent Travelling Salesman Problem (TDTSP) is a generalization of the classical Travelling Salesman Problem (TSP) in which the cost of the travel between two cities depends not only on the distance between them, but also on the time of the day the arc is travelled.This problem can be stated as follows: Consider a complete digraph D=(V,A), with V={0,1,…,n} the set of vertices and A the set of directed arcs. Assume that there exists a discrete time horizon 0, 1, …, T and an (n+1)×(n+1) time-dependent cost matrix C(t)=[cij(t)], 0⩽t⩽T, that associates a cost cij(t) to each arc (i,j) in A, where cij(t) is a time-dependent cost function for the arc (i,j) if departing from i at instant t. Vertex 0 is a special vertex representing the depot. The TDTSP involves finding a minimum cost tour that visits each vertex exactly once, starting at and returning to vertex 0.The TDTSP can handle many interesting practical applications. One of the main advantages is that it allows us to model some real world situations that the classical TSP cannot deal with. For example, the travel time between any two cities may be different if the arc is taken early in the morning or at noon, or if it is known that traffic jams may occur during rush hours, etc. The TDTSP can model this kind of scenarios by using an appropriate cost function for each arc.In its simplest version, TDTSP assumes that the travel time between any two cities is one time period, meaning that the travel time function depends on the distance between the cities and on the position of the arc in the tour. The time-dependent cost function for arc (i,j), cij(t), can be expressed as a step function with one constant value for each time period k=1, …, n, named cijk. In addition to the advantages mentioned above, this version of TDTSP can be used to model different scheduling and assignment problems.Fox (1973) proposes TDTSP formulations to solve the problem of scheduling production with time-dependent staff requirements. Picard and Queyranne (1978) give three integer programming formulations-two of them are linear-for TDTSP to model a scheduling problem with time-dependent transition costs. They use these formulations to minimize the tardiness costs in one machine scheduling and they report instances with up to 20 vertices solved to optimality. Fox et al. (1980) give a new formulation with O(n3) variables and only n constraints, but no computational results are reported. Gouveia and Voss (1995) present two new formulations for the TDTSP derived from a Quadratic Assignment Problem (QAP), and establish a relation among the previously mentioned formulations and the new ones in terms of the tightness of the linear relaxations.Almost at the same time, Vander Wiel and Sahinidis (1995) present a new formulation for the TDTSP which results to be the same as the one proposed by Gouveia and Voss (1995). The only difference between them is that Vander Wiel and Sahinidis (1995) prove that the integrality condition of some variables can be relaxed. As a result, their formulation has O(n3) variables, but only O(n2) are required to be binaries. The main idea of the model is to reformulate the TDTSP as the problem of finding the shortest constrained path in a directed multi-partite graph. They use a Benders-based heuristic to compute upper and lower bounds for their formulation of TDTSP. Computational experience shows that this procedure achieves very good bounds with minimal computational effort. In a follow up paper, Vander Wiel and Sahinidis (1996) develop an exact algorithm for the TDTSP. Preliminary computational results show instances with at most 20 cities solved to optimality.A very interesting approach is proposed by Bigras et al. (2008). The authors study the path formulation proposed in Picard and Queyranne (1978) and evaluate the improvements in the LP relaxations of pricing path without four cycles. Cutting planes are applied at the root node, considering different families of valid inequalities of TSP as well as clique inequalities obtained by constructing the conflict graph using incompatibilities specially inferred for the TDTSP. They evaluate a Branch-Cut and Price (B&C&P) algorithm on different instances and are able to solve randomly generated instances having up to 50 vertices as well as some instances from the TSPLIB. In two very recent papers, Abeledo et al. (2010) provide good computational results using a B&C&P based on the approach of Bigras et al. (2008) and Godinho et al. [Godinho et al., 2011] present an extended formulation based on Picard and Queyranne’s model for which the lower bound given by the linear programming relaxation has gap close to zero on the instances tested.This simplified version of TDTSP also generalizes the well-known Travelling Deliveryman Problem (TDP). Given a vehicle depot and a number of customers with known travel times between each pair of them, the TDP involves finding a path starting at the depot and visiting every customer exactly once that minimizes the sum of the times required to reach every customer. In particular, this objective function can be captured defining cijk=(n−k+1)cij, where cijdenotes the travel time from vertex i to vertex j. Exact solution algorithms for the TDP are available in Lucena (1990); Fischetti et al. (1993); van Eijl (1995); and Méndez-Díaz et al. (2008).In Picard and Queyranne (1978), one of the models is a three-index integer linear programming formulation. Méndez-Díaz et al. (2008) tested it for TDP instances and the results obtained for instances having up to 30 vertices show a reasonable tradeoff between the quality of the bound provided by the LP relaxation and the computational effort required. In addition, Gouveia and Voss (1995) prove that this formulation is equivalent to the one presented in Vander Wiel and Sahinidis (1995) in terms of the linear relaxation, and that this value is an upper bound for the rest of the formulations considered.These results suggest that both models look promising to be used in a Branch and Cut (B&C) algorithm. Picard and Queyranne (1978) use a Branch and Bound (B&B) algorithm. Vander Wiel and Sahinidis (1996) developed a B&C algorithm to solve the master problem of the Benders decomposition, but they only use general purpose cuts for a restricted set of inequalities. They suggest that, as future research, it would be interesting to study the polyhedron of the TDTSP. The aim of this paper goes in that direction. We consider the models presented in Picard and Queyranne (1978) and Vander Wiel and Sahinidis (1995). Since both models are a linearization of QAP, it results that their polytopes are strongly related. We derive several families of valid inequalities and facets for both polytopes. In particular, we provide a theoretical framework that allows to derive further families of facets by means of applying a maximum sequential lifting procedure over some specific set of variables. Finally, in order to analyze their computational behavior, we incorporate them in a B&C algorithm which is tested over instances from the related literature, obtaining very good computational results.The paper is organized as follows. In Section 2 we introduce the models from Picard and Queyranne (1978) and Vander Wiel and Sahinidis (1995) and establish a strong relation between them. In Section 3 we introduce a new family of valid inequalities based on the well known cycle inequalities for the ATSP. We also analyze some polyhedral properties for this family, which is used to derive five families of facets, and present another four families of valid inequalities. In Section 4 we give the outline of the B&C algorithm, which is tested and compared with other exact algorithms in Section 5. Finally, in Section 6, we present some conclusions and future research.This model is proposed in Picard and Queyranne (1978). It uses a set of binary decision variables yijk, where yijk=1 if city j is visited in time period k+1 after city i was visited in time period k. By forcing vertex 0 to be the depot, we can remove from the formulation the variables yij0∀i⩾1, yijn∀j⩾1, yi0k∀k⩽n−1, y0jk∀k⩾1, given that they always take value zero. The formulation is shown below(1)(PQ)min∑j=1nc0j0y0j0+∑i=1n∑j=1,j≠in∑k=1n-1cijkyijk+∑j=1ncj0nyj0n(2)s.t.∑j=1ny0j0=1(3)∑i=1,i≠jnyji1=y0j0j=1,…,n(4)∑i=1,i≠jnyijk=∑i=1,i≠jnyjik+1j=1,…,n;k=1,…,n-2(5)∑i=1,i≠jnyijn-1=yj0nj=1,…,n(6)y0j0+∑i=1,i≠jn∑k=1n-1yijk=1j=1,…,nyijk∈{0,1}i=1,…,n;j=1,…,nk=1,…,n-1;i≠jyj0n,y0j0∈{0,1}j=1,…,n,The objective function minimizes the total travel cost of the tour. Eq. (2) forces the vehicle to depart from the depot in time period 0. Eqs. (3)–(5) ensure that the selected transitions are travelled in consecutive time periods. Constraints (6) establish that the vehicle must arrive to each vertex j∈V⧹{0} in exactly one time period. Finally, integrality conditions on variables are imposed.Feasible solutions satisfying constraints (2)–(6) correspond to tours with transitions travelled in consecutive time periods, starting from the depot in time period 0. It is important to remark that this formulation does not allow subtours.We also consider the TDTSP formulation of Vander Wiel and Sahinidis (1995) (VW). The model is a linearization of the QAP presented in Picard and Queyranne (1978), and it can be seen as the problem of finding the shortest constrained path in a directed multi-partite graph. We show this formulation in a slightly different way than the one in Vander Wiel and Sahinidis (1995) because we force the vertex 0 to be the depot.The QAP formulation uses a set of binary decision variables xik, where xik=1 if city i is assigned to time period k, and xik=0 otherwise. This model is quadratic because of the presence of the product between xi k−1 and xi kin the objective function for each possible combination of (i,j) and k.In Vander Wiel and Sahinidis (1995), variables xikare referred as the assignment variables. To linearize the objective function of the QAP, they define the transition variables, yijk, which have the same meaning as the ones defined in the previous section. Moreover, they prove (see Proposition 1 of Vander Wiel and Sahinidis (1995) for a detailed proof) that yijk=1 if and only if xik−1xjk=1, when variables yijkare considered as positive continuous variables. The advantage of this linearization is that it only introduces continuous variables to the original formulation of the QAP. See Vander Wiel and Sahinidis (1995, Section 1) for a detailed explanation and examples.(7)(VW)min∑j=1nc0j0y0j0+∑i=1n∑j=1,j≠in∑k=1n-1cijkyijk+∑j=1ncj0nyj0n(8)s.t.∑k=1nxik=1i=1,…,n(9)∑i=1nxik=1k=1,…,n(10)y0j0=xj1j=1,…,n(11)∑i=1,i≠jnyijk=xjk+1j=1,…,n;k=1,…,n-1(12)yi0n=xini=1,…,n(13)∑j=1,j≠inyijk=xiki=1,…,n;k=1,…,n-1(14)∑j=1ny0j0=1(15)∑j=1nyj0n=1(16)yijk⩾0,xik∈{0,1}Similarly to model (PQ), the objective function minimizes the total travel cost of the tour. Eqs. (8) and (9) establish that each vertex must be assigned to exactly one time period and that each time period can be assigned to exactly one vertex, respectively. Eqs. (10) and (11) ensure that the arrival to a vertex is done according to the time period in which it is assigned. An analogous relation is established in Eqs. (12) and (13) for the departure of each vertex. Eqs. (14) and (15) establish that the vehicle must depart from the depot in time period 0 and arrive in time period n, respectively. Finally, integrality conditions on variables are imposed.As in the previous formulation, by forcing vertex 0 to be the depot, we can remove from the formulation the variables xi0∀i⩾1, x0k∀k⩾1, yij0∀i⩾1, yijn∀j⩾1, yi0k∀k⩽n−1, y0jk∀k⩾1, given that they always take value zero.As we mentioned in the introduction, (PQ) and (VW) are strongly related. It is easy to see that (PQ) is the projection of (VW) onto variables yijk, and Gouveia and Voss (1995) prove that these formulations are equivalent in terms of the linear relaxation. Formulation (VW) expresses each assignment variable, xik, in terms of the transition variables yijk. Considering the results shown in Balas and Oosten (1998), we deduce that there is a 1–1 correspondence between the faces of (PQ) and the faces of (VW). Moreover, ifPPQnandPVWnare the polytopes associated with models PQ and VW, respectively, we can also state thatdimPPQn=dimPVWn. From Müller (1996) we also know the dimension ofPPQn.Theorem 1Müller (1996)The dimension ofPPQnis n(n−1)(n−2) for n⩾5.Then, if an inequality is valid forPPQn, it is also valid forPVWnsince variables yijkare considered in formulation (VW). Conversely, if an inequality is valid forPVWn, the projected version of the inequality is valid forPVWnsince variables xikcan be replaced by their expression in terms of variables yijk.In this section we focus on deriving families of valid inequalities and facets. Based on the results presented in Section 2.3, these inequalities are valid for bothPPQnandPVWn, although most of the inequalities consider variables xik.In Section 3.1 we propose a new family of valid inequalities exploiting the idea of time dependent cycles. For this family, we prove that they are facet defining on a polytope obtained by restrictingPPQnandPVWnand, from this characterization, we provide in Section 3.2 a procedure to obtain facets ofPPQnandPVWnby means of maximum sequential lifting. Finally, in Section 3.3 we derive further valid inequalities that express certain properties regarding time periods.In this section we introduce a new family of valid inequalities based on the idea of the well known cycle inequalities for the asymmetric TSP. The main characteristic is that they include the time dependency of the transitions between vertices. Time dependent cycles are not allowed by the formulations considered in this paper. However, this family can be used to cut fractional solutions which can be useful in practice. Indeed, in the next section we will strengthen these inequalities by applying a lifting procedure.Fig. 1illustrates the idea behind time dependent cycles. The value associated with each arc stands for the time period in which it is travelled. Let C=〈v1,v2,v3,v4,v1〉 be a simple cycle with transitions between consecutive vertices travelled in time periods k, k+1, k+2, k+3. If we consider n⩾4, then this time dependent cycle cannot be part of a feasible solution.To forbid this situation, we can consider the following inequalityyv1v2k+yv2v3k+1+yv3v4k+2+yv4v1k+3⩽3.However, as we show next in Proposition 1, we can replace the right hand side by some of the vertex variables xikfrom formulation (VW) involved in the cycle, as shown below. This new expression dominates the previous one, since by definition variables xikare upper bounded by 1.yv1v2k+yv2v3k+1+yv3v4k+2+yv4v1k+3⩽xv2k+1+xv3k+2+xv4k+3We will refer to this family of inequalities as the Time-Dependent Cycle Inequalities (TDCIs). For the sake of notation, we express them in terms of both variables xikand yijk.Proposition 1TDCILet C=〈v1,v2,…,vl,vl+1=v1〉, l<n, be a simple cycle with transitions between consecutive vertices travelled in time intervals k, k+1, …, k+l−1, k+l⩽n. Then, inequality(17)∑i=1lyvivi+1k+i-1⩽∑i=1l-1xvi+1k+iis valid forPPQnandPVWn.From Eq. (11) we know thatyvivi+1k+i-1⩽xvi+1k+ifor i=1, …, l−1 are valid. Adding these inequalities we get that(18)∑i=1l-1yvivi+1k+i-1⩽∑i=1l-1xvi+1k+iis a valid inequality. Using a similar argument, but now considering Eq. (13), inequalitiesyvivi+1k+i-1⩽xvik+i-1for i=2, …, l are valid. Adding them and rewriting the right hand side we get that(19)∑i=2lyvivi+1k+i-1⩽∑i=1l-1xvi+1k+iis also a valid inequality.Considering inequalities (18) and (19), we can rewrite them asyv1v2k+∑i=2l-1yvivi+1k+i-1⩽∑i=1l-1xvi+1k+i∑i=2l-1yvivi+1k+i-1+yvlv1k+l-1⩽∑i=1l-1xvi+1k+iGiven thatyv1v2kandyvlv1k+l-1cannot both take value one in a feasible solution, the inequality∑i=1lyvivi+1k+i-1⩽∑i=1l-1xvi+1k+iis valid forPPQnandPVWn.□The TDCI do not define facets forPPQnandPVWn. However, similarly to the cycle inequalities for the ATSP, TDCI define facets of a projection ofPPQnandPVWnover some specific variables. Let C=〈v1,v2,…,vl,vl+1=v1〉, l<n and k as defined in Proposition 1. For notational convenience, we restrict our analysis toPVWn, although it is also valid forPPQn. We define the following sets of variables.•F1={yvlvjk+j-2=0:j=2,…,l-1}F2={yvlvjk+l-1=0:j=2,…,l-1}F3={yvivjk+j-2=0:i=3,…,l-1,j=2,…,i-1}F4={yvivjk+i-1=0:i=2,…,l-1,j=1,…,i-1}F5={yv1vjk+j-2=0:j=3,…,l},andPVWn(C,k)=PVWn∩⋂i=15Fi.Variables characterizing subspaces F1, …, F5 represent chords (vi,vj) of C, vi,vj∈C, travelled in valid time periods of departure from vior of arrival at vjwith respect to their corresponding positions in the cycle.We begin characterizing the dimension of the restricted polytopePVWn(C,k)in Theorem 2. Then, based on this result, we prove in Theorem 3 that the TDCI (17) are indeed facet defining ofPVWn(C,k). The importance of this result is twofold. First, it implies that the TDCI cannot be strengthened when consideringPVWn(C,k). Secondly, based on the definition of F1, …, F5 we can devise which variables may be considered to obtain strengthened versions of the TDCI for the general polytopePVWn. This topic is addressed in detail in Section 3.2.We now establish the following results. Due to space limitations, the complete proof of Theorem 2 is shown in Appendix A.Theorem 2Let C=〈v1,v2,…,vl,vl+1=v1〉, 4⩽l<n and k the set of vertices and the starting time period associated with a TDCI as defined inProposition 1. The dimension ofPVWn(C,k)is n(n−1)(n−2)−(l+1)(l−2) for n⩾5.Based on this theorem, we now state the following result. Similarly to Theorem 2, the detailed proof is shown in the appendix.Theorem 3Let C=〈v1,v2,…,vl,vl+1=v1〉, 4⩽l<n and k as defined inProposition 1. The TDCI(17)are facet-defining forPVWn(C,k)for n⩾5.In this section we study the complexity of the separation problem associated with TDCI inequalities. We consider the reformulation of the TDTSP as the problem of finding the shortest constrained path in a directed multi-partite graph, as suggested by Picard and Queyranne (1978) and Vander Wiel and Sahinidis (1995). Let DM=(VM,AM) be this graph. A vertex u∈VMis a combination between a vertex i∈V and a time period k, where 0⩽k⩽n. We will denote this vertex as u=ik. In addition, we will refer to arcs e∈AMas e=(ik,jk+1), with ik, jk+1∈VM.The separation problem for this family of inequalities can be formulated as follows:Time-Dependent Cycle Inequalities SeparationInstance:A pointz̃=(ỹ,x̃)∈PVWnQuestion:Doesz̃violate some Time-Dependent Cycle Inequality?.We begin showing that this family can be separated considering the support graph,DM(z̃), instead of the complete graph. The following proposition proves this result.Proposition 2Letz̃=(ỹ,x̃)be a solution of the relaxation that satisfies(8)–(15)andz̃⩾0,C={v1,…,vl}⊂Vand k the set of nodes and the starting time period associated with a TDCI, and i0∈{1,…,l}. Ifỹvi0vi0+1k+i0-1=0, then the TDCI induced by C and k is trivially satisfied.From Proposition 1, the TDCI associated with C and k, can be rewritten consideringvi0as∑i=1i0-1ỹvivi+1k+i-1-∑i=1i0-1x̃vi+1k+i︸A+ỹvi0vi0+1k+i0-1+∑i=i0+1lỹvivi+1k+i-1-∑i=i0l-1x̃vi+1k+i︸B⩽0.It is easy to see that A⩽0 and B⩽0, since solutionz̃satisfies Eqs. (11) and (13), respectively. Then, knowing thatỹvi0vi0+1k+i0-1=0, the inequality is satisfied byz̃.□Based on this result, we first identify some necessary conditions for the existence of a violated TDCI. As we have seen before, the main idea behind TDCI is the presence of a time-dependent cycle, starting and ending in the same node but with different time-periods. Then, there must exist vertices v k, v k′∈VM, with k′=k+l, for some l>1, k+l⩽n. In addition, even when this condition holds, it is also necessary the existence of a simple path-in terms of vertices vi∈V-going from vk to vk′, which is not always the case. Let v1k, v1k′∈VMbe those vertices as defined before. We want to determine if there exists or not a set of vertices C={v2,…,vl}⊂V such that(20)∑i=1lỹvivi+1k+i-1-∑i=1l-1x̃vi+1k+i>0,where vl+1=v1. We now restrict our search to the subgraph defined by those vertices in the support graph with time periods between k and k′, i.e., u=vt such that v∈V and k<t<k′. For this subgraph, we also define the arc weight functionw:AM→Rasw(it,jt+1)=ỹvivjtifi=1,t=kỹvivjt-x̃vitotherwise.Considering these two definitions, we seek for a maximum-weight path connecting v1k and v1k′. This can be done in polynomial time with a straightforward application of dynamic programming.However, the optimal solution returned by the maximum-weight path algorithm may not be simple in terms of vertices v from the original graph (i.e., it is possible that the path contains vertices vit, vit′∈VM, with t≠t′, visiting more than one time the row corresponding to vertex viin different time periods). Let P be this optimal solution, and w∗ the weight of P. Clearly, if w∗⩽0, thenz̃does not violate any TDCI starting and ending in v1k and v1k′, respectively, since w∗ is an upper bound for the value of any simple path connecting these two vertices. On the contrary, if w∗>0, there might exist a TDCI that is violated byz̃. The following proposition proves that if this condition on w∗ holds, then we can separatez̃.Proposition 3Letz̃=(ỹ,x̃)be a solution of the relaxation that satisfies(8)–(15)andz̃⩾0, and P=〈v1,…,vl〉, vl+1=v1, the sequence of nodes returned by the maximum path algorithm with optimum value w∗>0. Then, there exists a subsequence P0⊆P and a time period k0such that the TDCI defined byP0′and k0is violated byz̃.We start by pointing out that if sequence P has no repetitions, then clearly P and k define a violated TDCI, since w∗>0.Otherwise, P has at least one repeated vertex and each vertex may appear even more than two times. We also know that these repetitions cannot be in consecutive time periods, since this situation is not allowed even in graph DM. However, it is not difficult to see that there exists a repeated vertexvi0=vi1∈P, i0<i1, appearing in time periods k0=k+i0−1 andk0′=k+i1-1, respectively, such that the vertices of P between two of its repetitions defines a subsequence of P which is a simple path connectingvi0k0andvi0k0′. LetP0={vi0,…,vi1-1}⊂Pbe this sequence, where ∣P0∣⩾3. We now analyze the TDCI defined by P and k in terms of subsequence P0 and k0. Expression (20) can be rewritten as(21)∑i=1i0-1ỹvivi+1k+i-1-∑i=1i0-1x̃vi+1k+i+(22)∑i=i0i1-1ỹvivi+1k+i-1-∑i=i0i1-2x̃vi+1k+i+(23)∑i=i1lỹvivi+1k+i-1-∑i=i1-1l-1x̃vi+1k+i>0,where (22) is the expression related to P0. We consider each part separately:1.The value of expression (21) is at most zero, since solutionz̃satisfies Eq. (11).Analogously, expression (23) is also upper bounded by zero, given thatz̃satisfies (13).From the previous two items, it follows that (22) is strictly greater than zero. In addition to this fact, by construction, P0 has no repeated vertices. Moreover, if we consider k0=k+i0−1, expression (22) defines a TDCI for P0 and k0. Then, we have found a sequence of vertices P0 and time period k0 that represent a TDCI violated byz̃.To sum up, given the sequence of nodes P for whose optimal value w∗ is strictly greater than zero, we are able to find a TDCI that is violated byz̃.□Finally, considering all we have seen so far, we can state that the separation problem for the TDCI can be solved in polynomial time. A pseudocode for the separation procedure summarizing all steps from this section is shown in Algorithm 1. The complexity in the worst case is O(n5), although in practice it requires little effort since the support graphDM(z̃)tends to be sparse and many cases can be avoided.Algorithm 1TDCI Separation AlgorithmInput:z̃=(ỹ,x̃)∈PVWn.1. forik,ik′∈DM(z̃),k′>k+1, do:2.Calculate the maximum path onDM(z̃)consideringw:AM→Ras the arc weight function. Let P be the optimal solution and w∗ its cost.3.Ifw∗>0 then4.If P is simple, then answer yes and return the TDCI induced by P.5.else6.Determine the simple subpath P0⊆P as shown in Proposition 3 answer yes and return the TDCI induced by P0.7.end if8. end forBased on the ideas from Balas and Fischetti (1999) and Gutin and Punnen (2002), from Proposition 3 we can derive facets ofPPQnandPVWnapplying a maximum sequential lifting over the variables present in F1, …, F5. It is well known that the order in which variables are lifted may generate different inequalities. Indeed, we lifted these variables in five different ways to obtain five families of facets. The support graph for some of these inequalities with l=4 is shown in Fig. 2. In all cases, a solid arc corresponds to a variable in the original TDCI, and a dashed arc represents a variable obtained by the lifting process.The following proposition shows the five different families of facets. The proof is provided in Appendix.Proposition 4Let C=〈v1,v2,…,vl,v̇l+1=v1〉, l<n, be a simple cycle with transitions between consecutive vertices taken in time intervals k, k+1, …, k+l−1, k+l⩽n. Then, inequalities(24)∑i=1lyvivi+1k+i-1+∑i=2l-1∑j=1i-1yvivjk+i-1+∑j=2l-1yvlvjk+l-1⩽∑i=1l-1xvi+1k+i(25)∑i=1lyvivi+1k+i-1+∑j=3lyv1vjk+j-2+∑j=2l-1yvjv1k+j-1⩽∑i=1l-1xvi+1k+i(26)∑i=1lyvivi+1k+i-1+∑i=3l-1∑j=2i-1yvivjk+j-2+∑j=2l-1yvlvjk+l-1+∑j=2l-1yvlvjk+j-2⩽∑i=1l-1xvi+1k+i(27)∑i=1lyvivi+1k+i-1+∑i=3l-1∑j=2i-1yvivjk+j-2+∑j=3lyv1vjk+j-2+∑j=2l-1yvlvjk+j-2⩽∑i=1l-1xvi+1k+i(28)∑i=1lyvivi+1k+i-1+∑i=3l-1∑j=2i-1yvivjk+j-2+∑j=3lyv1vjk+j-2+yvl-1v1k+l-2⩽∑i=1l-1xvi+1k+idefine facets ofPPQnandPVWn.This proposition proves that constraints (24)–(28) are facet defining. We next remark that these five lifting of a TDCI indeed define different facets ofPPQnandPVWn. For this purpose, we use feasible solutions satisfying them by equality. Let C=〈v1,v2,v3,v4〉 be a time dependent cycle. We consider feasible solutions with the following permutations of the vertices.•v4v1v3v2 satisfies by equality (24), (25), (27) and (28), and strictly (26). Then, constraint (26) is different from the other Lifted TDCIs.v4v2v1v3 satisfies by equality (24)–(27), and strictly (28). Then, constraint (28) is different from (24), (25) and (27).v3v2v4v1 satisfies by equality (26)–(28), and strictly (24) and (25). Then, constraint (27) is different from (24) and (25).v3v1v5v4v2 satisfies by equality (24) and (26), and strictly (25), (27) and (28). Then, constraint (24) is different from (25).These five inequalities can be written as the Admissible Flow Constraints (AFC) proposed in Abeledo et al. (2010). In this paper, the authors conjecture that some of the AFC are facet defining, but that it is difficult to characterize which ones have this property. In Proposition 4 we characterize a subset of the AFC that are facet defining.1The results in Abeledo et al. (2010) have been obtained independently and simultaneously from ours.1In order to incorporate these inequalities to the B&C algorithm, we use a heuristic separation routine based on the separation algorithm for the TDCI. For every two vertices of the form ik and ik′ that are present in the support graph, we execute the maximum path algorithm. If the returned path is simple (in terms of vertices in V of the original graph D), then we add the value of the lifted variables involved in the inequality to the cost of this path.Although this approach is heuristic, in practice it is quite effective for all families, finding a considerable number of violated cuts.In this section we present four families of valid inequalities forPPQnandPVWn. The following proposition introduces the first of them. The idea behind this family is to bound a particular variable,yi0j0k0based on the values of the variables representing arcs leaving a particular vertex, l0, with l0≠i0,j0. The remaining constraints follow a similar idea.Proposition 5Family 1For i0, j0, l0=1, …, n: i0≠j0≠l0, inequalities(29)yi0j0k0+yj0l0n-1+yi0l0n-1⩽yl0i0k0-1+∑t=1t≠k0-1,k0,k0+1n-1∑w=1w≠i0,j0,l0nyl0wt+yl00nfor k0=2, …, n−3, and(30)yi0j0n-2+∑w=1w≠j0,l0nywl0n-1⩽yl0i0n-3+∑t=1n-4∑w=1w≠i0,j0,l0nyl0wt+yl00n(31)yi0j0n-1⩽yl0i0n-2+∑t=1n-3∑w=1w≠i0,j0,l0nyl0wtare valid forPPQnandPVWn.We start by noting an identity that will be used several times within the proof. If we focus in the case, whereyi0j0k0=1, and considering Eqs. (3)–(6), it is quite easy to see that for 1⩽k⩽n−1(32)yl0i0k-1+∑w=1w≠i0,j0,l0n∑t=1t≠k-1,k,k+1n-1yl0wt+yl00n=y0l00+∑w=1w≠l0n∑t=1n-1ywl0t=1.Now we prove the validity of each inequality separately.1.For inequality (29), we consider three different cases:•Ifyi0j0k0=yj0l0n-1=yi0l0n-1=0, the inequality is trivially satisfied since all variables are non-negative.Ifyi0j0k0=1, it follows thatyj0l0n-1andyi0l0n-1have value zero since k0⩽n−3. Then, by (32) the inequality is satisfied.If eitheryj0l0n-1=1oryi0l0n-1=1, variableyi0j0k0=0and the inequality is satisfied since by Eq. (5)yl00n=1.These three cases cover all possible situations, and therefore inequality (29) is valid forPPQnandPVWn.For inequality (30), we separate again the proof in three cases:•Ifyi0j0n-2andywl0n-1are zero, for w=1, …, n, w≠l0, j0, then the inequality is trivially satisfied.Ifyi0j0n-2=1,ywl0n-1=0for w=1, …, n, w≠l0, j0. Using Eq. (32) for k=n−2, we get the expression in the right hand side of the inequality, and therefore it is satisfied.If for some w=1, …, n, w≠l0, j0,ywl0n-1=1, it follows thatyi0j0n-2=0and from Eq. (5),yl00n=1and the inequality is satisfied too.Therefore, the inequality is valid fromPPQnandPVWn.Finally, we consider inequality (31). Ifyi0j0n-1=0, the inequality is satisfied. Otherwise, considering Eq. (32) and the factyi0j0n-1=1implies thatyl00n=0, the inequality is also valid forPPQnandPVWn.The next family uses mainly the same idea as in the previous proposition, with the only difference that instead of looking at the arcs leaving l0, we consider the entering ones. Regarding the proof for this family, since it is analogous to the one in Proposition 5, we omit the details.Proposition 6Family 2For i0, j0, l0=1, …, n: i0≠j0≠l0, inequalitiesyi0j0k0+yl0i01+yl0j01⩽yj0l0k0+1+∑t=1t≠k0-1,k0,k0+1n-1∑w=1w≠i0,j0,l0nywl0t+y0l00for k0=3, …, n−2, andyi0j02+∑w=1w≠i0,l0nyl0w1⩽yj0l03+∑t=4n-1∑w=1w≠i0,j0,l0nywl0t+y0l00yi0j01⩽yj0l02+∑t=3n-1∑w=1w≠i0,j0,l0nywl0tare valid forPPQnandPVWn.By combining inequalities from Propositions 5 and 6 in a particular way, we derive the two other families. Next we introduce the inequalities resulting of the combination of inequalities from Proposition 6.Proposition 7Family 3For i0, j0, l0=1, …, n: i0≠j0≠l0, inequalities(33)yi0j0k0+yj0i0k0+yl0i01+yl0j01⩽yi0l0k0+1+yj0l0k0+1+∑t=1t≠k0-1,k0,k0+1n-1∑w=1w≠i0,j0,l0nywl0t+y0l00for k0=3, …, n−2, and(34)yi0j02+yj0i02+∑w=1w≠i0,j0,l0nyl0w1⩽yi0l03+yj0l03+∑t=4n-1∑w=1w≠i0,j0,l0nywl0t+y0l00(35)yi0j01+yj0i01⩽yi0l02+yj0l02+∑t=3n-1∑w=1w≠i0,j0,l0nywl0tare valid forPPQnandPVWn.We prove first the validity of inequality (33). From the previous proposition, we know thatyi0j0k0+yl0i01+yl0j01⩽yj0l0k0+1+∑t=1t≠k0-1,k0,k0+1n-1∑w=1w≠i0,j0,l0nywl0t+y0l00yj0i0k0+yl0i01+yl0j01⩽yi0l0k0+1+∑t=1t≠k0-1,k0,k0+1n-1∑w=1w≠i0,j0,l0nywl0t+y0l00are valid inequalities. Given thatyi0j0k0andyj0i0k0are mutually exclusive, the proposed inequality is valid forPPQnandPVWn. The same argument can be used for inequalities (34) and (35). However, the former is slightly modified by excluding bothyl0i01andyl0j01from the sum on the left side of the expression.□Finally, the remaining family exploits the same idea as Proposition 7 but for inequalities present in Proposition 5. Again, due to the similarity with the previous result, the details of the proof are not provided.Proposition 8Family 4For i0, j0, l0=1, …, n: i0≠j0≠l0, inequalitiesyi0j0k0+yj0i0k0+yi0l0n-1+yj0l0n-1⩽yl0i0k0-1+yl0j0k0-1+∑t=1t≠k0-1,k0,k0+1n-1∑w=1w≠i0,j0,l0nyl0wt+yl00nfor k0=2, …, n−3, andyi0j0n-2+yj0i0n-2+∑w=1w≠i0,j0,l0nywl0n-1⩽yl0i0n-3+yl0j0n-3+∑t=1n-4∑w=1w≠i0,j0,l0nyl0wt+yl00nyi0j0n-1+yj0i0n-1⩽yl0i0n-2+yl0j0n-2+∑t=1n-3∑w=1w≠i0,j0,l0nyl0wtare valid forPPQnandPVWn.Regarding the separation problems for these families, since each of them is composed by a polynomial number of members, we explicitly enumerate them in order to find a violated cut.In order to evaluate the strength of the inequalities introduced in Section 3, we develop a B&C algorithm considering the model (PQ). We focus mainly on the cutting planes and a primal heuristic leaving, among other parameters, the branching and the node selection strategies as CPLEX’s defaults. For notational convenience, sometimes we refer to variables xikfrom (VW) formulation, the value of which can be calculated in terms of variables yijk.We observed that in some instances applying a simple preprocessing improved drastically the overall computing times. This preprocessing phase aims to eliminate feasible solutions for which we can assure that either they are not optimal or there exists an alternative optimal solution.The main idea is quite simple and looks for identifying time dependent arcs which cannot be present in an optimal solution. Given i, j∈V⧹{0}, i<j, 1⩽k⩽n−2, if for all v, w∈V, v, w≠i, j, if(36)cvik-1+cijk+cjwk+1⩽cvjk-1+cjik+ciwk+1,then we can fix variable yjik=0. Otherwise, we check whether swapping i and j the condition is satisfied to fix yijk=0. It is important to remark the second test is applied only when the first one fails, since otherwise the optimal solution may be cut off.For some particular cases of the TDTSP, such as the TSP and the TDP, this test can be executed without considering the particular position of the arc in the tour and, therefore, the implication is valid for all possible time periods k.The use of heuristic procedures to obtain feasible integer solutions based on the information provided by the solution of the LP relaxation have been proven to be very effective to obtain good quality upper bounds. The main purpose is to reduce the number of nodes explored in the B&C tree, aiming to reduce the overall running time of the algorithm. However, it is important to find a reasonable tradeoff between the effectiveness of the algorithm and the computational effort.In our algorithm we consider a primal heuristic consisting of two phases. The first one is a construction phase, which generates different feasible solutions based on a heuristic. The second phase consists on applying for each solution an improvement procedure. We give further details about each phase in the following sections.The greedy heuristic considered in this phase iteratively adds vertices to positions 0, 1, …, n−1 using the information of the fractional solution of the current node. In particular, in iteration k selects as the next vertex v to be added to the partial tour the one having the greatest value its corresponding assignment variableyvlastvk, where vlast is the last vertex added to the current partial path. In case of tie, we select the vertex with minimum cost for the corresponding arc.In order to generate several possibilities, we execute this procedure considering each vertex w∈V as the first one in the tour.The aim of this phase is, given a feasible solution for the problem, to find a new one with a better total cost by applying a local search procedure. We consider two different improvement operators, which are executed sequentially. It is important to remark that this improvement phase is applied to all solutions generated in the construction phase.First we consider a vertex interchange heuristic. Given C=〈 0,v1,…,vn,0〉 a feasible tour, we define the neighborhood of C, N(C), as all the possible tours obtained by interchanging the positions of any two different vertices of C. From all of the tours in N(C) that improve the cost of C, in case there is any, we choose as our new solution the one with the smallest cost. We apply this procedure iteratively until no improvement is achieved or a maximum of fifteen iterations is reached. Secondly, when this procedure is finished, we execute a 3-opt procedure (Lin, 1965).In this section we specify the cutting plane algorithm considered. Based on restricted preliminary computational results, considering together inequalities (24)–(28) slows the resolution of the LP relaxations. This is due to their similarity, given that some of them share many of the variables involved in the inequality. As a consequence, more inequalities are added to the formulation but obtaining similar results in terms of improvements of the lower bound. We observed that the best results are produced considering together constraints (24) and (26).In addition to the inequalities presented in Section 3 we included also the Subtour Elimination Constraints (SEC). In order to include these constraints, variables zijcan be defined aszij=∑k=1nyijk,indicating if vertex j is visited immediately after vertex i in the tour.2To avoid confusions with variables xikfrom model (VW), we rename variables xijfrom the classical formulation for the TSP as zij. It is important to remark that variables zijare not included explicitly in the formulation (PQ).2We consider adding more than one of these constraints instead of only the most violated one by means of the separation routine proposed by Letchford et al. (2002) and Lysgaard et al. (2004). At the root node we perform a maximum of fifteen rounds of the cutting plane algorithm and only one round in the internal nodes.On preliminary computational results, we observed that the best improvements at the root node is produced by a combination of the SEC, the TDCI with l=2 and the Lifted TDCI (24) and (26). For example, in some instances considering only SEC or TDCI with l=2, constraints (24) and (26) the gap at the root node is reduced to nearly an 8% in both cases. However, when considered together, this value drops below 2%. For this reason, we include the three sets of constraints in the cutting plane algorithm. As regards inequalities presented in Section 3.3, although they do not produce big improvements in the objective function, they are useful to find violated Lifted TDCI in successive rounds.The constraints considered in the cutting plane algorithm are enumerated below.•SEC. At most 30 per round.TDCI with l=2.Lifted TDCI (24) and (26). At most 100 per round.Families from Section 3.3. At most 100 for each of them per round.The experiments were conducted on a workstation with Intel Core i7-2600 with 16gigabytes of RAM running a Fedora Linux distribution. The algorithms are coded in C++and combined with Ilog CPLEX 12.2 callable library for the optimization routines.We use benchmark instances that are divided into three groups. The first group includes instances from TSPLIB. These instances are considered both as TSP instances (i.e., cijk=cij) and as TDP instances (i.e., cijk= (n−k+1)cij). A second group regards randomly generated instances for TDP from Méndez-Díaz et al. (2008). Finally, the third group considers the instances proposed in Rubin and Ragatz (1995) and considered also in Bigras et al. (2008). We slightly modify the original instances of the third group by discarding the corresponding due dates, which results in1|sij|∑Cjscheduling instances (equivalent to TDP).As regards the methods evaluated, we consider the following ones:•B&C: the B&C algorithm described in Section 4 considering the PQ model. All CPLEX cuts and heuristics are disabled.B&C-R: the B&C algorithm for the TDP proposed in Méndez-Díaz et al. (2008). This algorithm is based on a special formulation for the TDP, whose variables capture the cumulative nature of costs. It includes several facet defining inequalities as well as a primal heuristic, producing good and competitive computational results. Taking to account the benchmark instances tested, the results produced by this algorithm represents a good baseline for the evaluation of B&C. Since we have access to the code, the computational experiments for this algorithm are carried out in the same environment described before.CPLEX-PQ: CPLEX’s default algorithm considering the PQ model. It also includes the variable fixing phase explained in Section 4 and all CPLEX’s general features. The comparison with this algorithm will show the benefits obtained by including special purpose features in B&C.For each algorithm we report the computational time (in seconds) and the number of tree nodes explored in the B&C algorithm. A cell filled with (∗∗∗) means that the instance was not solved within 2hours by that algorithm. We also show the gaps at the root node (%rG) and at the end of the execution (%fG). The %rG is calculated as 100∗(BESTUB−LB)/BESTUB, where BESTUB is the objective value of the best solution obtained considering all algorithms tested. For %fG we adopted a different criterion, and is computed as 100∗(UB−LB)/UB, where UB stands for the objective value of the best solution found by the algorithm under consideration. In this way, %fG gives us a measure of the progress made by the algorithm when the time limit is reached. For the B&C-R algorithm we do not report results of TSP instances, since B&C-R is specifically developed for the TDP.In Tables 1 and 2we show the computational times for the TSPLIB instances considered as TSP and TDP instances, respectively. One of the messages of this table is that our B&C algorithm outperforms CPLEX-PQ in all the instances considered, producing much better results and solving almost all instances considered. This lies on the fact that the inequalities incorporated to the cutting phase are quite effective, specially the combination of the TDCI of size 2, the Lifted TDCI and SECs. The best gains are obtained at the root node, where the gap with respect to the optimal solution is considerably reduced. The average of %rG over all TSP instances considered is 0.36% for B&C while for CPLEX-PQ is 13.84%. For TDP instances, these values are 1.82% for B&C and 15.85% for CPLEX-PQ. It is important to note that in both cases the %rG for TDP instances tend to be larger than for TSP ones. Furthermore, the number of instances solved at the root node by B&C is smaller when considered as TDP.The most interesting results are the ones regarding instances with 40 vertices or more. CPLEX-PQ algorithm is able to solve to optimality only 2 of the 26 instances (ftv44 TSP; ftv47 TDP) within 2hours, while our B&C solves 23 of them. This is also expressed in the number of nodes explored in the B&C tree, where CPLEX-PQ requires to visit an extremely higher number of them compared to B&C.Considering B&C-R algorithm, it is able to solve 4 of the 13 TDP instances with more than 40 vertices, The computational times are considerable higher compared to the ones produced by B&C. This can be explained by the fact that B&C-R LP relaxations are difficult to solve and, even when they produce good lower bounds, the procedure of B&C is more effective.We now turn our attention to two specific instances for which computational times are affected by the preprocessing explained in Section 4. Instance br17, when considered as a TDP instance, without this variable fixing requires 209.24 s and 1549 nodes in the B&C tree to be solved. In Table 2 we can appreciate that it is solved in less than a second at the root node. A similar observation can be done for p43, which cannot be solved within the time limit imposed without the preprocessing, neither in its TSP version nor in its TDP one. Although it is a quite restrictive condition, it shows to be very effective and produces significant changes in the overall computational times.Regarding the %fG, we can observe that B&C produces the best results in the instances that cannot be solved within the time limit imposed. For TSP instances, B&C is not able to solve only one instance and %fG is 0.33 %, while for CPLEX-PQ the average %fG over the unsolved instances is 28.15%. For TDP ones, the average %fG over the unsolved instances is 1.99% for B&C, 14.61% for B&C-R and 17.64% for CPLEX-PQ. Based on this values and the number of instances solved we can deduce that B&C represents a more robust approach than B&C-R and CPLEX-PQ. This is due to the combination between the improvements obtained by means of the cutting planes and the effectiveness of the primal heuristic in finding good feasible solutions early in the B&C tree.The results for the instances from Méndez-Díaz et al. (2008) are presented in Table 3. Each row shows the average value for the computational time, number of nodes explored and gaps over five instances. If present, a number between parenthesis indicates how many of the five instances are actually solved to optimality within 2hours and the value in the cell represents the average considered only these instances.In general, results are similar to the ones for the TSPLIB instances. The B&C algorithm produces considerable reductions in the computational times, and these differences become larger as the number of vertices of the instances increase. Both B&C and B&C-R are capable of solving all instances, in general enumerating a small number of nodes in the B&C tree. CPLEX-PQ begins to fail in symmetric and euclidean instances with 35 and 40 vertices. The gaps at the root node for B&C-R are very good in general, but the algorithm is more time consuming than B&C because of the time required to solve each LP relaxation. As expected, CPLEX-PQ enumerates a great number of nodes in the B&C tree, showing the benefit of the cutting plane algorithm of B&C.An interesting observation from the results observed in this table regards the difficulty of the instances depending on its type. Both B&C and B&C-R are able to solve asymmetric and symmetric instances within a reasonable time, and for each algorithm the times are comparable. However, we can observe an increment on the times as well as in the number of nodes explored for euclidean instances, which seem to be harder to solve than the ones mentioned previously.In Table 4we show the average computational times for the scheduling instances from Rubin and Ragatz (1995). The average value is calculated over eight instances for each n=15, 25, 35, 45. These results are aligned with the ones from the previous tables. Our B&C performs better than CPLEX-PQ, both in the computational times and the number of nodes explored. It is important to note that this difference is significantly higher when n=45, since the other instances are easily solved by both methods. Again, this behavior is due to the strengthening of the bounds produced by the cutting phase and the primal heuristic.Finally, we compare our results with the ones reported in Bigras et al. (2008) in Table 5. As mentioned in the introduction, the authors study the path formulation proposed in Picard and Queyranne (1978). The formulation has an exponential number of variables and therefore they consider a B&C&P algorithm. For the pricing phase, they consider adding paths (columns) without four cycles. They also include several families of valid inequalities of the TSP and clique inequalities obtained by constructing the conflict graph using incompatibilities inferred for the TDTSP.The authors report computational times in all cases, exceeding our time limit of 2hours in four instances. It is important to remark that the computer used by Bigras et al. (2008) dates from 2008. Based on standard CPU comparisons3Obtained from www.cpubenchmark.net. Bigras et al. CPU obtains a rating of 744, and ours 1922.3and considering that our code runs in single thread, our computer has a speed-up of nearly three compared to theirs. Thus, we report (∗∗∗) for their computing times whenever they exceed 3*7200=21,600seconds. Besides this, we can observe some interesting results in the comparison.First we note that B&C solves more instances than all the other methods. In some cases, computational times obtained by Bigras et al. are reduced by B&C to a 10% of the time. Furthermore, computational times reported by the authors for instances dTSP50.1, dTSP50.3 and dTSP50.4 are 56,240, 47,771 and 109,586seconds, respectively. Regarding B&C, it can solve dTSP50.1 in less than an hour. It is also interesting the reduction obtained for instance rbg050b, where B&C requires approximately 10minutes to solve it. Despite the difference on the computers, the reductions on the computational times are also due to the inclusion of specific purpose cuts and the primal heuristic. On the other hand, for the instance dTSP40.3 their algorithm performs much better than B&C, which is able to find the optimal solution but the initial gap is large and encounters difficulties to close it. This is related to the nature of their approach, which can also be observed in the fact that their B&C&P algorithm tends to enumerate less nodes than B&C. As regards B&C-R and CPLEX-PQ, the behavior is similar to the previous experiments.

@&#INTRODUCTION@&#


@&#CONCLUSIONS@&#
In this paper we consider the TDTSP formulations of Picard and Queyranne (1978) and Vander Wiel and Sahinidis (1996). We analyze both polytopes and derive several families of valid inequalities for both models. We generalize the idea of the well-known cycle inequalities for the ATSP, and derive five families of facets by applying a lifting procedure. We develop a B&C algorithm in order to evaluate these inequalities which, together with a primal heuristic, prove to be very effective. The overall approach produces good computational results over different benchmark instances compared to a general purpose B&C algorithm for the model proposed in Picard and Queyranne (1978), that inclues also a particular preprocessing for the problem and is solved with CPLEX default algorithm, and the B&C algorithm from Méndez-Díaz et al. (2008). The proposed algorithm is capable of solving instances with up to 58 vertices within 2hours of computing time.As future research, it would be interesting to analyze the complexity of the separation problems for the lifted TDCI in order to improve the separation routines implemented so far. Regarding the polyhedral study performed in this paper, although we do not have a proof, we conjecture that valid inequalities proposed in Section 3.3 are facet defining. More work could be done in this direction.Investigating how to improve the computational times required to solve the LP relaxations of B&C, by means of studying particular characteristics of the formulation (PQ), could lead to significant reductions in the overall computational times, specially for instances with large values of n. In addition, as mentioned in the computational experiments, the preprocessing proposed showed to be very effective on instances satisfying condition (36). It is worth to investigate further this aspect of the problem to derive new rules to fix variables in the model.