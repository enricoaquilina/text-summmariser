@&#MAIN-TITLE@&#
Automatic validation for binary translation

@&#HIGHLIGHTS@&#
An automatic validator supports static, dynamic, and hybrid binary translator.Instruction-level validation by comparing the architecture states and stored values.We propose two mechanisms to make the comparisons into simple equality checks.Two acceleration method provided to make the validation process faster.

@&#KEYPHRASES@&#
Binary translation,Validation,ARM,QEMU,Architecture state,

@&#ABSTRACT@&#
Binary translation is an important technique for porting programs as it allows binary code for one platform to execute on another. It is widely used in virtual machines and emulators. However, implementing a correct (and efficient) binary translator is still very challenging because many delicate details must be handled smartly. Manually identifying mistranslated instructions in an application program is difficult, especially when the application is large. Therefore, automatic validation tools are needed urgently to uncover hidden problems in a binary translator. We developed a new validation tool for binary translators. In our validation tool, the original binary code and the translated binary code run simultaneously. Both versions of the binary code continuously send their architecture states and the stored values, which are the values stored into memory cells, to a third process, the validator. Since most mistranslated instructions will result in wrong architecture states during execution, our validator can catch most mistranslated instructions emitted by a binary translator by comparing the corresponding architecture states. Corresponding architecture states may differ due to (1) translation errors, (2) different (but correct) memory layouts, and (3) return values of certain system calls. The need to differentiate the three sources of differences makes comparing architecture states very difficult, if not impossible. In our validator, we take special care to make memory layouts exactly the same and make the corresponding system calls always return exactly the same values in the original and in the translated binaries. Therefore, any differences in the corresponding architecture states indicate mistranslated instructions emitted by the binary translator. Besides solving the architecture-state-comparison problems, we also propose several methods to speed up the automatic validation. The first is the validation-block method, which reduces the number of validations while keeping the accuracy of instruction-level validation. The second is quick validation, which provides extremely fast validation at the expense of less accurate error information. Our validator can be applied to different binary translators. In our experiment, the validator has successfully validated programs translated by static, dynamic, and hybrid binary translators.

@&#INTRODUCTION@&#
Binary translation [1, p. 49–52] is an important technique for migrating application binaries from one platform to another. It is widely used in virtual machines and emulators. There are three categories of binary translators: static binary translators (SBT), which translate code offline, dynamic binary translators (DBT), which translate code at run time, and hybrid binary translators (HBT), which translate code both offline and at run time. UQBT [2], FX!32 [3], and LLBT [4] are considered as static binary translators while Aries [5] and QEMU [6] are dynamic. Shen et al. [7] also implement a hybrid binary translator, which runs statically translated code and invokes the dynamic binary translator whenever the code-location problem [1] is encountered.Developing quality binary translators is challenging because many issues must be handled carefully, such as code translation (including the code-discovery and code-location problems [1]), speculative execution and system calls. Lots of details must be handled correctly in order to produce a correct translation.An intuitive way to validate the translated program is manually checking machine states after each instruction is executed. However, this approach is both slow and error-prone. An efficient and automatic validation tool is eagerly called for.Traditional validation methods fall into two categories. The first approach compares the outputs of the original program and the translated program. This is similar to black-box testing in software engineering. Though simple, this approach is unsuitable for validating binary translators since a correct translated program may not always produce exactly the same output as the original program due to different run-time environments. Moreover, this approach would yield little information to assist debugging.The second approach performs validation based on the basic blocks of the programs. This approach is widely applied in the validation of optimizing compilers [8,9]. However, the basic-block validation is not suitable for validating static binary translators because the target addresses of indirect branches may not be resolved completely at static time, which implies that it may not be possible to build an accurate control flow graph from binary code. In contrast, we choose to perform validation based on individual instructions since per-instruction validation can help to detect the mistranslated instructions more accurately.Our validator attempts to validate binary translators that translates ARM code into x86 code. In our experiments, we validate all three kinds of binary translators. The validator is composed of three processes: two processes run the original code and the translated code, respectively, and the third process compares the corresponding architecture states generated from the first two processes. The first two processes respectively send the architecture state immediately after each ARM instruction is executed to the third process. Instrumentation code is inserted in both the ARM program and the translated x86 program at the corresponding places, which serve as checkpoints. The original ARM program and the translated program run side by side. The instrumentation code collects data in both the ARM and the translated binaries, including the emulated architecture states and stored values, and then sends the data to the validation process for comparison.We try to keep our validation strategy as simple and intuitive as possible. However, there are still many challenging delicate issues to overcome. For example, the registers may hold addresses of variables. The same variable may be allocated at different addresses in the original ARM program and the translated program, respectively, due to different memory layouts or different dynamic memory allocations. Therefore, the same register in the original ARM program and in the translated program may hold different values even if the translated x86 program is considered correct. In order to simplify the comparison of architecture states, we need to make the addresses of the global variables, the run-time stack, and the allocated memory blocks exactly the same in the original ARM version and the translated version.System calls also bring about challenges. For example, the system call sbrk returns the address of the allocated memory block. The complex allocation mechanisms make the same sbrk system call return different values when the underlying system-call handlers are different. Because the ARM version and the translated version use different system-call handlers, the system call sbrk may return different values. We need both the ARM version and the translated version allocate memory at exactly the same addresses in order to facilitate the comparison of architecture states.Another challenge is that system calls, such as getpid, that may return system-dependent values must also be forced to return identical values in both the ARM binary and the translated binary.Performance is also an important issue. Instruction-level validation brings about a large number of messages between the emulation processes and the validator. The tremendous number of messages take a lot of execution time and make the validation a time-consuming and impractical task. We propose two improvements in an attempt to reduce the number of messages. The first is the validation blocks, the purpose of which is to reduce the number of validations while maintaining the accuracy of the validation. Several consecutive instructions are grouped into a single validation block, which is similar to a basic block. In a validation block, a register or variable is defined no more than once. The avoidance of redefinition helps to identify the mistranslated instructions once any register or variable is found to hold a wrong value. On the other hand, architecture-state comparison is performed once per validation block, rather than once per instruction.The second improvement is quick validation, which adopts a code-coverage based validation. It only validates an instruction when that instruction is executed for the first time. Although it sacrifices some degree of correctness, quick validation can be used as an immediate validation for minor modifications to the translator. The rigorous validation is left to specific milestones.In this paper, we propose a methodology to validate binary translators. Our methodology is implemented in a real tool that works by comparing the execution states of the original ARM program and the translated x86 program. We run the ARM program with an emulator, QEMU, on an x86 platform instead of running the ARM program on a real ARM board. The translated x86 program also runs on the same x86 platform concurrently. QEMU can be run as a process-level virtual machine, which means it does not need to emulate a whole operating system. This makes QEMU efficient and, sometimes, even faster than a real ARM device, especially when there are a large amount of messages between QEMU and the validator. The popularity of multi-core microprocessors also makes the parallel validation model on a single machine feasible. Another reason is that the process-level virtual machine is much easier to be adapted for validation. In summary, we make the following contributions:•We develop an automatic validation tool that can validate all three kinds of binary translators: static, dynamic, and hybrid.We propose two mechanisms that reduce the comparison of architecture states to a simple equality check.We also come up with two improvements that significantly speed up the validation process.The remainder of this paper is structured as follows. Section 2 sketches the binary translators to be validated and the emulator QEMU, which is used to validate the translators. Section 3 describes the challenges of automatic validation. Section 4 illustrates the implementation details and shows how to overcome the challenges described in Section 3. Section 5 mentions some tips to notice when modifying the validator to support other frontend ISAs. Section 6 discusses the experimental results. Section 7 suggests some testsuite to help the validator provide a sound solution. Section 8 lists related works on debugging, testing, and validation. Section 9 summaries and concludes this paper.

@&#CONCLUSIONS@&#
We developed an automatic validator to validate binary translators. The validator works on the instruction level and can support different binary translators. In our experiments, we validate the static, dynamic, and hybrid binary translators from different code bases. The validator takes care of memory layouts and system calls of the emulated programs so that architecture states obtained from two emulation processes (one for QEMU and the other running the translated code) can be directly compared. Besides the architecture states, the stored values of each store instruction are also validated. The validator is carefully designed to make as few modifications to the binary translators as possible. In average, the execution time ratio of the validator versus directly emulating ARM programs on QEMU is 29.7 for the static binary translator LLBT. For the dynamic and hybrid binary translator, the execution time ratios are 61.5 and 54.3, respectively.Furthermore, in order to speed up the validation process, we propose the validation-blocks, which could significantly reduce the communications between the validation process and the emulation processes without sacrificing the accuracy of instruction-level validation. The average execution time ratio is reduced to 13.8 for LLBT. For the dynamic and hybrid binary translator, the execution time ratios are reduced to 23 and 26.1, respectively. The validation-block approach speeds up about 2.1x to 2.4x compared with the per-instruction validation.Finally, the quick validation based on the code-coverage techniques offers a very fast validation to uncover translation errors. For LLBT, the execution time ratio is reduced to 2.8 times of direct emulation on QEMU so that it may be applied to cover more applications with many different input data sets. For dynamic and hybrid binary translators, the execution time is also reduced to 3.7 times and 2.5 times of direct emulation on QEMU.