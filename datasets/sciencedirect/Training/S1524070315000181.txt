@&#MAIN-TITLE@&#
Isthmus based parallel and symmetric 3D thinning algorithms

@&#HIGHLIGHTS@&#
We propose a 3D paralel and symmetri homotopi thinning method.The frame work of critical kernels ensures the topological soundnes of our method.Salient geometri features of the objects are deteted by “isthmuses”.Either curvilinear or surface skeletons may be produced.“Isthmus persistence” alows us to cope with the robustness to noise issue.

@&#KEYPHRASES@&#
Topology preservation,3D thinning algorithm,Symmetric thinning,Curvilinear and surface skeleton,Critical kernel,

@&#ABSTRACT@&#
We propose a 3D symmetric homotopic thinning method based on the critical kernels framework. It may produce either curvilinear or surface skeletons, depending on the criterion that is used to prevent salient features of the object from deletion. In our new method, rather than detecting curve or surface extremities, we detect isthmuses, that is, parts of an object that are “locally like a curve or a surface”. This allows us to propose a natural extension of our new method that copes with the robustness to noise issue, this extension is based on a notion of “isthmus persistence”. As far as we know, this is the first method that permits to obtain 3D symmetric and robust curvilinear/surface skeletons of objects made of voxels.

@&#INTRODUCTION@&#
Skeletons play an important role in many applications of image processing, pattern recognition and geometric modeling. Originally introduced by Blum [1] in the continuous plane, the skeleton (or medial axis) may be defined as the set of centers of maximal included balls in a shape. This definition is also valid for objects in spaces of higher dimension, e.g. in 3D.The following properties were established in the continuous framework, under some smoothness conditions on the object X:•homotopy: the object X and its skeleton S(X) are homotopy-equivalent [2],thinness: S(X) is thin (more precisely, its interior is empty),invariance:S(Ψ(X))=Ψ(S(X)),where Ψ is any affine transformation (rotation, symmetry, homothety…).In addition, if one associates to each point of the medial axis, the radius of the corresponding maximal ball, it is possible to reconstruct the original object exactly from the medial axis by performing the union of all these balls.Besides, it is known that the transformation S is not continuous: a small perturbation of the contour of X may result in a big change of the skeleton. This is a key issue in most applications of the skeleton, often referred to as stability or robustness to noise issue [50].Other issues are due to the discrete nature of the data from which skeletons are usually computed. Acquisition devices such as MRI scanners, X-ray tomographs or positron emission tomographs produce 3D images in the form of a grid of voxels labelled with values, and are commonly used in various fields, mainly medical imaging and materials science. In this paper, we are interested in skeletons of 3D objects that are represented by sets of voxels, i.e., unitary cubic elements.In the 2D square gridZ2,or in the 3D cubic gridZ3,the definition of the medial axis as the set of centers of maximal included balls still makes sense, but the properties of the continuous skeleton (homotopy, thinness, invariance) are lost. Hence, considerable effort has been devoted to design discrete skeletonization methods that aim at retrieving these properties, at least partially.These methods find their roots in different frameworks: discrete geometry [3–7], digital topology [17–19,52], mathematical morphology [8,9], computational geometry [10,55,59], partial differential equations [11], and level-sets [12]. Recent surveys of the state of the art in skeletonization may be found in [13–16].The most common process to obtain skeletons from voxel objects with the assurance of topology preservation, is homotopic thinning. Thinning (as an iterative object reduction) may be seen as a digital simulation of a fire front propagation. It consists of sequentially removing a voxel or a set of voxels from the objet, in such a way that each removal does not change the topological characteristics. A voxel that may be removed from the object while preserving its topological characteristics is called a simple voxel [20,21]. A sequential homotopic thinning procedure consists of iteratively choosing one simple voxel and removing it.Homotopic thinning is often used in complement of a geometry-based method that aims at identifying the center lines or surfaces of the object. A popular method consists of computing a distance map of the object, then extracting the centers of maximal balls from this map, and finally performing homotopic thinning of the object with the constraint of preserving the detected centers [17,19,52].Besides the computational cost of these successive steps, one can notice that the resulting skeletons are made of two classes of voxels, heterogenous in nature: the ones that are kept for geometrical reasons, and the ones that are kept for topological reasons. This may lead to artifacts, as shown in [52], even when the thinning step is guided by the same distance map that was used for detecting ball centers.In our approach, we take advantage of the thinning process itself to gather information such as the distance from a voxel to the object border. This is made possible because we use a parallel thinning scheme (see next sections). During this process, we are able to detect “on the fly” voxels that correspond to centers of maximal balls, and we may decide to preserve them or not, depending on the desired type of skeleton.Parallel homotopic thinning procedures are generally preferred to sequential ones, as they produce results that are more robust to noise.Among the parallel homotopic thinning procedures, one must distinguish between the ones that are symmetric and the ones that are asymmetric. For example, the seminal directional method of Rosenfeld [25] is an asymmetric algorithm. This method, which works only in 2D, consists of the iteration of four substeps. Each substep identifies and removes only the simple pixels that have no neighbor of the object in one of the four main directions (North, South, East, West), and that have at least two 8-neighbors belonging to the object (thus, extremities of curves are kept). Several authors proposed directional thinning algorithms for the 3D case [26–32].The asymmetric algorithms, on the positive side, produce skeletons that are thinner, in general, than the ones produced by symmetric algorithms, see examples Fig. 1 and Fig. 4. On the negative side, their result depends —sometimes heavily— on some arbitrary choices. In the case of directional algorithms like the one of Rosenfeld, the order in which the directions are considered may dramatically influence the result, see Fig. 2.We refer the reader to Fig. 3, to better understand what happens in the example of Fig. 2 when different orders of directions are used. Notice that, a similar behavior would result if we use a same order of directions, but with this object before and after a rotation of 90°.Symmetric parallel algorithms produce a result that is invariant under 90° rotations and under arbitrary reflections and translations. In such an algorithm, a thinning step consists of 1. the identification of a set D of deletable voxels, independently of any privileged direction or subgrid, and 2. the deletion of the set D from the current object.Thus, with a symmetric parallel thinning algorithm, the result is uniquely defined, independently of any arbitrary choice. Furthermore, a symmetric parallel thinning algorithm makes it possible to evaluate, with no added cost, the distance between a voxel of the object and its nearest background voxel. When a voxel is considered as a candidate for deletion for the first time during the thinning, the step number corresponds to this distance, which corresponds to the L1 norm (4-distance or city-block distance in 2D, 6-distance in 3D).Existing symmetric parallel homotopic 3D thinning algorithms are very few: [33–35] (to our knowledge, these are the only ones). Among them, [33,35] are based on a set of masks designed to ensure the preservation of both topological characteristics and main surfaces of the object, and [34] is based on the notion of P-simple point, introduced by one of the authors in [49]. Particularly, designing a symmetric parallel homotopic thinning algorithm that produces 3D curvilinear skeletons is very difficult: to our knowledge, the only such algorithm proposed in the literature is in [34].Proving that the removal in parallel of a set of voxels does not alter the topological characteristics of an object, is a difficult task. The critical kernels framework, introduced by one of the authors in [22], allows one to design various homotopic thinning procedures in which this guarantee of topology preservation is “built in” [23,24].Furthermore, with this framework it is possible to impose the preservation of various sets of voxels. For example, to obtain a curvilinear skeleton (resp. surface skeleton), it is usual to preserve “curve extremities” (resp. surface edges). However, in the framework of symmetric thinning, it is difficult to define and use such notions. The reason is that curves or surfaces obtained by a symmetric thinning method may have a certain “thickness”. For example, a two voxels wide ribbon could be the result of a symmetric thinning (see Fig. 4).In our new method, rather than detecting curve or surface extremities, we detect isthmuses, that is, parts of an object that are “locally like a curve or a surface”. For this purpose, instead of considering voxels and their neighborhoods, we consider cliques and their neighborhoods, a clique being a set composed of mutually adjacent voxels. The notion of a clique permits to handle thick curvilinear or surface structures. Intuitively, a 1D-isthmus (resp. 2D-isthmus) is a clique whose neighborhood corresponds - up to an homotopic thinning - to the one of a curve (resp. a surface), see examples Figs. 5and 6. This allows us to produce both curvilinear and surface skeletons, that are invariant under 90° rotations.In this paper, we propose a symmetric homotopic thinning method based on the critical kernels framework. It may produce either curvilinear skeletons or surface skeletons, depending of the kind of isthmuses that are detected in order to prevent salient features of the object from deletion.Then, we propose a natural extension of our new method that copes with the robustness to noise issue. This extension is based on a notion of “isthmus persistence” [36], which has been originally introduced in the framework of arbitrary 3D complexes (objects that are not necessarily made of voxels). Isthmus persistence is natural in our framework, and could not be adapted to other approaches based, e.g., on curve extremity detection.We also propose a way to efficiently compute a hierarchy of nested filtered skeletons, corresponding to the different values of isthmus persistence.As far as we know, the method presented in this paper is the first method that permits to obtain 3D symmetric and robust curvilinear/surface skeletons of objects made of voxels.In this section, we give some basic definitions for voxel complexes, see also [20,37].LetZbe the set of integers. We consider the families of setsF01,F11,such thatF01={{a}|a∈Z},F11={{a,a+1}|a∈Z}. A subset f ofZn,n ≥ 2, which is the Cartesian product of exactly d elements ofF11and(n−d)elements ofF01,withd=0,1,…,n,is called a face or a d-face ofZn,d is the dimension of f.A 3-face ofZ3is also called a voxel. A finite set which is composed solely of voxels is called a (voxel) complex. We denote byV3the collection of all voxel complexes.We say that two voxels x, y are adjacent ifx∩y≠∅. We writeN(x)for the set of all voxels that are adjacent to a voxel x,N(x)is the neighborhood of x. Note that, for each voxel x, we havex∈N(x). We setN*(x)=N(x)∖{x}.Let d ∈ {0, 1, 2}. We say that two voxels x, y are d-neighbors if x ∩ y is a d-face. Thus, two distinct voxels x and y are adjacent if and only if they are d-neighbors for some d ∈ {0, 1, 2}, see Fig. 7for an illustration.LetX∈V3. We say that X is connected if, for any x, y ∈ X, there exists a sequence〈x0,…,xk〉of voxels in X such thatx0=x,xk=y,and xiis adjacent toxi−1,i=1,…,k.Intuitively a voxel x of a complex X is simple if its removal from X “does not change the topology of X”. This notion may be formalized with the help of the following recursive definition introduced in [24], see also [38,39] for other recursive approaches for simplicity.Definition 1LetX∈V3. We say that X is reducible if either:(i)X is composed of a single voxel; orthere exists x ∈ X such thatN*(x)∩Xis reducible and X∖{x} is reducible.LetX∈V3. A voxel x ∈ X is simple for X ifN*(x)∩Xis reducible. If x ∈ X is simple for X, we say that X∖{x} is an elementary thinning of X.Thus, a complexX∈V3is reducible if and only if it is possible to reduce X to a single voxel by iteratively removing simple voxels. Observe that a reducible complex is necessarily non-empty and connected.In Fig. 8(a), the voxel x is simple for X (N*(x)∩Xis made of a single voxel), the voxel y is not simple for X (N*(x)∩Xis not connected), the voxel z is simple for X (the complexN*(x)∩Xis made of two voxels which are 1-neighbors, and is reducible).In [24], it was shown that the above definition of a simple voxel is equivalent to classical characterizations based on connectivity properties of the voxel neighborhood [21,40–43]. An equivalence was also established with a definition based on the operation of collapse [44,45], this operation is a discrete analogue of a continuous deformation (a homotopy), see also [21,22,38].The notion of a simple voxel allows one to define thinnings of a complex, see an illustration Fig. 8.LetX,Y∈V3. We say that Y is a thinning of X or that X is reducible to Y, if there exists a sequence〈X0,…,Xk〉such thatX0=X,Xk=Y,and Xiis an elementary thinning ofXi−1,i=1,…,k.Thus, a complex X is reducible if and only if it is reducible to a single voxel.Let X be a complex inV3. It is well known that, if we remove simultaneously (in parallel) simple voxels from X, we may “change the topology” of the original object X. For example, the two voxels e and g are simple for the object X depicted Fig. 9(a). Nevertheless X∖{e, g} has two connected components whereas X is connected. Thus, if we use only the notion of a simple voxel, an arbitrary choice has to be made between e and g. In this case, the result would not be invariant under 90° rotations. In other words, such a thinning would not be symmetrical.In this section, we recall a framework for thinning in parallel discrete objects with the warranty that we do not alter the topology of these objects [22–24]. This method may be extended for complexes of arbitrary dimension. As far as we know, this is the first method which permits to thin arbitrary complexes in a symmetric way.Let d ∈ {0, 1, 2, 3} and letC∈V3. We say that C is a d-clique or a clique if ∩{x ∈ C} is a d-face.In Fig. 9 (a), {b, c} is a 0-clique, {e, d, g} is a 1-clique, {f, h} is a 2-clique.If C is made of solely two distinct voxels x and y, we note that C is a d-clique if and only if x and y are d-neighbors, with d ∈ {0, 1, 2}.LetX∈V3and let C ⊆ X be a clique. We say that C is essential for X if, for all cliques D such that C ⊆ D ⊆ X and∩{x∈C}=∩{x∈D},we haveC=D.Observe that any complex C made of a single voxel is a clique (a 3-clique). Furthermore any voxel of a complex X constitutes a clique which is essential for X.In Fig. 9(a) , {b, c} is a 0-clique which is essential for X, {e, d} is a 1-clique which is not essential for X, {e, d, g} is a 1-clique essential for X, {f, h} is a 2-clique essential for X.Definition 3LetS∈V3. TheK-neighborhood of S, writtenK(S),is the set made of all voxels that are adjacent to every voxel in S. We setK*(S)=K(S)∖S.We note that we haveK(S)=N(x)whenever S is made of a single voxel x. We also observe that we haveS⊆K(S)whenever S is a clique.Definition 4LetX∈V3and let C be a clique that is essential for X. We say that the clique C is regular for X ifK*(C)∩Xis reducible. We say that C is critical for X if C is not regular for X.Thus, if C is a clique made of a single voxel x, then C is regular for X if and only if x is simple for X. Therefore, if X∖C is not a thinning of X, then C is critical for X whenever C is made of a single voxel. More generally, let C be an arbitrary essential clique for X such that X∖C is not a thinning of X (X∖C and X have not “the same topology”). Then, as a direct consequence of the forthcoming Th. 5, either C is critical for X, or C contains a clique that is critical for X.We illustrate this fact with Fig. 9(a) . Let us consider the cliquesC1={b,c}andC2={e,g},which are essential for X. We observe that both X∖C1 and X∖C2 are not thinnings of X. We haveK*(C1)∩X=∅,K*(C2)∩X={c,d,f,h}. Thus, C1 and C2 are both critical for X. Now, let C3 be the essential clique {d, e, g}. Again, X∖C3 is not a thinning of X. The clique C3 is regular for X (we haveK*(C3)∩X={c}) but C3 contains C2, which is critical for X.The following result is a straightforward consequence of a general theorem which holds for complexes of arbitrary dimensions (Th. 4.3 in [22], see also [24]).Theorem 5LetX∈V3and let Y ⊆ X. The complex Y is a thinning of X if any clique that is critical for X contains at least one voxel of Y.See Fig. 9 which provides an example of two complexes X and Y that satisfy the above property. For example the clique {e, g}, which is critical for X, contains the voxel g, which belongs to Y. See also Fig. 10 for other examples.Our goal is to define a subset of a voxel complex X that is guaranteed to include at least one voxel of each clique that is critical for X. By Th. 5, this subset will be a thinning of X.We want this subset to be as small as possible in order to obtain an efficient thinning procedure. We also want our method to be independent of arbitrary choices, in particular of a choice of specific voxels in a given critical clique. For that purpose, the following notion of a “crucial kernel” was introduced11The crucial kernel as presented in this paper is referred to in [24] as the “D-crucial kernel”.in [24], see also [23,46].Definition 6LetX∈V3and C be a d-clique that is critical for X. We say that C is crucial for X if:(i)d=3; ord ∈ {2, 1, 0} and C does not contain any voxel belonging to a d′-clique that is crucial for X and such that d′ > d.We say that a voxel x ∈ X is crucial for X if x belongs to a clique that is crucial for X. We denote byD(X)the set composed of all voxels that are crucial for X,D(X)is the crucial kernel of X.Note that a 3-clique is crucial for X if and only if it is made of a single voxel that is not simple for X.By the very definition of a crucial voxel,D(X)is guaranteed to include at least one voxel of each clique that is critical for X. Thus, by Th. 5,D(X)is a thinning of X.Let us consider the complex X of Fig. 11(a) . The 3-cliques that are crucial for X consist of voxels that are not simple for X, these voxels are highlighted in (b). The cliquesC1={a,b}andC2={e,g}are the only 2-cliques that are critical for X. The clique C1 contains a voxel that is not simple for X. Thus, only C2 is crucial for X. The cliqueC3={e,f,g,h}is the only 1-clique that is critical for X. Since C3 contains a voxel that is in C2, this clique is not crucial for X. The same is true for the two 0-cliquesC4={b,c}andC5={c,d,e,g},which are critical for X. It follows that the crucial kernel of X is precisely the complex depicted in (d).In order to thin a complex X, we may iteratively compute crucial kernels starting from X. If we repeat this procedure until idempotence, we obtain the minimal crucial skeleton of X, see [24].In Fig. 12(b) , the complexY=D(X)is highlighted, the complex X being the one of Fig. 10(a) . The complexZ=D(Y)is given in (c) and (d). We haveZ=D(Z),thus Z is the minimal crucial skeleton of X. As far as we know, no other method permits to obtain such minimal symmetric skeletons. In fact, the methods based on crucial kernels remove more voxels, in one iteration, than any other symmetric parallel thinning scheme.In order to compute curvilinear or surface skeletons, we have to keep other voxels than the ones that are crucial. In the following notion of a crucial kernel constrained to preserve a given set K, the set K corresponds to a set of features that we want to be preserved by a thinning algorithm. For example, K could correspond to pieces of curves if we want to obtain a curvilinear skeleton. Observe that this notion generalizes the definition of a crucial kernel, which corresponds to the case whereK=∅.Definition 7LetX∈V3and let K ⊆ X.Let C be a d-clique that is critical for X and such that C ⊆ X∖K. We say that C is crucial for ⟨X, K⟩ if(i)d=3; ord ∈ {2, 1, 0} and C does not contain any voxel belonging to a d′-clique that is crucial for ⟨X, K⟩ and such that d′ > d.We say that a voxel x ∈ X is crucial for ⟨X, K⟩ if x is in K or if x belongs to a clique that is crucial for ⟨X, K⟩.We denote byD(X,K)the set composed of all voxels that are crucial for ⟨X, K⟩,D(X,K)is the crucial kernel of X constrained by K.Again,D(X,K)is guaranteed to include at least one voxel of each clique that is critical for X. Thus,D(X,K)is a thinning of X (Th. 5). In other words, any constrained crucial kernel of an object preserves the topology of this object. Furthermore we haveK⊆D(X,K).Remark 8It should be noted that, in some cases, the constrained crucial kernel can be smaller than the (unconstrained) crucial kernel. For example, in Fig. 11(a) , if K is the set {e}, then the crucial kernel of X constrained by K is the complex {b, c, e}, i.e., the voxel g has been removed. Note that, in this example, K is a proper subset of a clique. We will see in the next section that, since our goal is to compute symmetric skeletons, the set K that is considered in our method is a union of cliques.In this section, we propose a symmetric 3D thinning algorithm which computes either curvilinear or surface skeletons. This thinning procedure preserves a constraint set K which is made of ”isthmuses”.When considering thin 3D objects made of voxels, isthmuses may be detected by considering the connected components of both the object and the background in the neighborhood of a voxel, see [47].In order to handle thick structures, we replace the notion of a voxel by the one of a clique. Also, we no longer consider connected components. Intuitively, a crucial clique C of an object X is said to be a 1-isthmus (resp. a 2-isthmus) if the neighborhood of C corresponds - up to a thinning - to the one of a point belonging to a curve (resp. a surface). See also [48] for a general definition of a discrete k-surface.We say thatX∈V3is a 0-surface if X is precisely made of two voxels x and y such thatx∩y=∅.We say thatX∈V3is a 1-surface (or a simple closed curve) if:(i)X is connected; andFor each x ∈ X,N*(x)∩Xis a 0-surface.LetX∈V3and let C be a clique that is essential for X.We say that C is 1-critical for X ifK*(C)∩Xis reducible to a 0-surface.We say that C is 2-critical for X ifK*(C)∩Xis reducible to a 1-surface.We say that C is2+-critical for Xif C is either 1-critical or 2-critical for X.We say that a clique C is a 1-isthmus (resp. 2-isthmus,2+-isthmus) for Xif C is crucial for X and if C is 1-critical (resp. 2-critical,2+-critical) for X.Recall that a clique C is critical for X if C is essential for X and ifK*(C)∩Xis not reducible to a single voxel (Def. 4). Thus, a k-critical clique,k∈{1,2,2+},is necessarily critical. See Figs. 13and 14where several examples of 1- and 2-critical cliques are given. See also Figs. 5 and 6 which provide examples of 1- and 2-isthmuses.Definition 10LetX∈V3,K ⊆ X, and letk∈{1,2,2+}.We say that a voxel x ∈ X is a k-isthmus for ⟨X, K⟩ if x belongs to a clique that is crucial for ⟨X, K⟩ and that is a k-isthmus for X.We denote byI(X,K,k)the set composed of all voxels that are k-isthmuses for ⟨X, K⟩.Note that, for anyk∈{1,2,2+},we haveI(X,K,k)⊆D(X,K).The following algorithm CrucialIsthmus computes both the crucial kernel of an object X constrained by K (the setD(X,K)) and the setI(X,K,k). It corresponds to a direct implementation of previous definitions. Observe that, in this procedure, each step except step 3 may be done in parallel. We will see in Section 10 how to implement efficiently the detection of critical and k-critical cliques.Our thinning algorithm IsthmusSymThinning is given below. We compute iteratively, until stability, crucial kernels constrained by K. The set K is the set of all voxels that have been detected as k-isthmuses so far during the process. The computation ofD(X,K)andI(X,K,k)(lines 3 and 4) is done using the algorithm CrucialIsthmus. Note that K ⊆ Y and Z ⊆ Y (lines 3 and 4), thus K ⊆ X (lines 5 and 6).We obtain curvilinear skeletons withk=1,and surface skeletons withk=2+. These two cases, where skeletons are made of pieces of curves (k=1), and skeletons may contain both curve and surface parts (k=2+), correspond to the two main classes of skeletons studied in the literature. The 2-skeletons, obtained withk=2,may also be useful when some a priori knowledge about the original object indicates that the skeleton must be surface-like. For example, one may think of a thick hollow sphere or a thick membrane.Observe there is the possibility that a voxel belongs to a k-isthmus at a given step of the algorithm, but not at further steps. This is why previously detected isthmuses are stored (line 6).In Figs. 15and 16, we illustrate the above algorithm for computing curvilinear and surface skeletons respectively.To our knowledge, the only other parallel and symmetric method for obtaining both types of skeletons was proposed in [34]. It is based on P-simple points, introduced by one of the authors [49]. In [34], the preservation of salient object features is achieved through the detection of end voxels. Using such strategy, it is not possible to define a notion of persistence (see Section 7) that allows one to filter skeletons. Filtering is mandatory in almost all applications dealing with skeletons, as noise is usually affecting real data and skeletons are notoriously sensitive to noise (see Fig. 17). This problem will be studied and a solution will be proposed in the following section (see Fig. 18).Even in the continuous framework, the skeleton suffers from its sensitivity to small contour perturbations, in other words, it lacks stability. A survey [50] summarizes selected relevant studies dealing with this topic. This difficulty can be expressed mathematically: the transformation which associates a shape to its skeleton is only semi-continuous. This fact, among others, explains why it is usually necessary to add a filtering step (or pruning step) to any method that aims at computing the skeleton. Hence, there is a rich literature devoted to skeleton pruning, in which different criteria were proposed in order to discard “spurious” skeleton points or branches.An easy approach to obtain filtered skeletons consists of using a method of contour or shape smoothing prior to the thinning. This approach has the drawback of altering the shape on which the skeleton is computed, in particular its topological characteristics may be changed.Most skeleton pruning methods rely on a criterion to decide whether a skeleton element (a branch or a point) is significant or not. The simplest example of such a criterion is the branch length: once the skeleton is computed, detect all peripheral branches whose length is below a given threshold, and suppress them (see e.g. [51]). With this criterion, it is very difficult, and sometimes impossible, to find a threshold value that indeed separates spurious branches from significant ones, see Fig. 19.Many other measures of significance have been proposed in the literature. One may cite, at the level of a skeleton point:•the bisector angle [52,53], which also corresponds to a notion of “velocity of meeting fronts”, used in the pioneering works on skeletonization and pruning (see [54] for a review);the radius of the corresponding maximal ball, possibly in combination with the previous criterion [55];the radius of the smallest ball including the set of contour points at smallest distance from the considered point [7,56–58];the so-called “collapsing” volume or surface [59–62];the proportion of points in the corresponding maximal ball, which are not covered by other maximal balls [63];a scale-based criterion [64,65].And, at the level of a skeleton branch:•the reconstruction error [54,66–68], which corresponds either to a volume, a surface area, or a thickness;criteria based on a simplification of the contour, obtained for example by discrete curve evolution [69,70] or empirical mode decomposition [71];some ad-hoc measures, for example [72] builds a measure based on the study of the intensity profile of the branch, and [73,74] counts the proportion of “significant voxels” in the branch.A particularly appealing approach to prevent the appearance of spurious skeleton branches (or surfaces) is based on the notion of isthmus persistence. Its advantages are the following:- it applies both in 2D and 3D cases, and to curvilinear as well as surface skeletons,- it is governed by a single parameter,- it is effective (although measuring this criterion is difficult, because the quality of a skeleton is always a tradeoff between fidelity and low complexity, see [54], and therefore its assessment depends very much on the application),- it is quite simple to compute in the framework of a thinning procedure.This notion first appeared, to our knowledge, in the context of cubical complexes, in the work of L. Liu et al. [36].The idea is the following. When an element x of a voxel complex is detected as an isthmus for the first time during the thinning process, the index of the current thinning step is recorded and called the birth date of this element, written b(x). Intuitively, b(x) gives an information about the local thickness of the object around this element (see Fig. 20for an illustration in 2D). Then, later on during the thinning process, the same element may become a candidate for deletion, that is, it is no longer an isthmus. At this time, we consider the index of the current thinning step, and we call this number the death date of the element, written d(x). The differenced(x)−b(x)is called the persistence of the element (see also [75]). An element that has a short persistence is very likely to be part of a spurious skeleton branch, whereas elements with long persistences indicate the presence of robust skeleton parts (Fig. 20). In this approach, only isthmuses having a persistence greater than a given threshold will be kept.The works [36] and [75] present some asymmetric thinning procedures which take place in the framework of general cubical complexes, i.e., complexes that are not necessarily made of voxels. With our definitions of 1D and 2D isthmuses, either single-voxel or multiple-voxels cliques, it becomes easy to implement this strategy to detect robust skeleton elements in the context of symmetric parallel thinning of objects made of voxels.In the following algorithm PersistenceSymThinning, k stands for the dimension of the considered isthmuses (k=1,2, or2+), and p is a parameter that sets the persistence threshold. The function b associates to certain voxels their birth date, and K is a constraint set that is dynamically updated by adding those isthmus voxels whose persistence is greater than the threshold p (lines 7–9).Notice that the two instructions in lines 4–5, which compute the set Y that is the crucial kernel for ⟨X, K⟩, and the set Z of all k-isthmuses for ⟨X, K⟩, can be computed by a single call to Algorithm 1 (CrucialIsthmus). In line 6, the birth date b(x) of each new isthmus voxel x is recorded. In line 7, the test b(x) > 0 means that the considered voxel x has been recorded as an isthmus voxel. Furthermore, since this voxel x belongs to Y, it is not deletable, thus its death date d(x) is strictly greater than i. The conditioni+1−b(x)⩾pthus impliesd(x)−b(x)⩾p,meaning that the voxel x must be added to the constraint set K (see line 9) because its persistence is greater than p.Extreme cases for the values of the parameter p arep=1andp=+∞. Notice that, by the very definitions of isthmus and persistence, the persistence of any isthmus is at least one. Ifp=1,then all detected isthmuses are added to the constraint set. In this case, we retrieve the behavior of algorithm IsthmusSymThinnning. Ifp=+∞,then no voxel is added to the constraint set. In this case, the result is a minimal crucial skeleton of X.In Figs. 21 and 22we show outcomes of algorithm PersistenceSymThinning, withk=1andk=2,respectively, for different values of parameter p.The followingexamples, in Figs. 23, 24, 25, 26, illustrate our algorithms on various 3D shapes. They also illustrate the fact that filtering is an essential step for practical uses of skeletons. The notion of persistence introduced in Section 7 allows us to directly produce filtered skeletons, without post-processing, based on a single parameter. In all these examples, our method achieves visually satisfactory results.An important question is the following: can the notion of persistence be adapted to other parallel thinning algorithms, e.g. to those based on the detection of curve extremities?The intuition behind the definition of the persistence, is to put in relation two different sources of geometrical information about the original object. The first one is a notion of “local thickness” and is given by the birth date. The second one is a notion of “global centeredness” and is given by the death date. We saw how to collect these two measures dynamically and quite easily in the context of our thinning methods.With the other thinning methods, either based on extremity detection or on centers of medial balls, only one source of information is easily available to measure the local thickness: the radius of medial balls, or almost equivalently, the distance to the object border. This information could indeed be used instead of our birth date, but only for curvilinear skeletons in 2D or for surface skeletons in 3D. Consider the case of a “flat” 3D object, for example, a subset of a discrete sphere (see Fig. 27). In this case, the distance to the border is null everywhere. Thus, this information does not permit to make any difference between the different voxels. The same remark can be made if we replace this flat object by a “nearly flat” object that has a non-null, but small or moderate thickness.On the contrary, our definition of birth date effectively captures the notion of local thickness, even for this kind of ribbon-like object, see the curve skeletons of Fig. 27.From this discussion, we conclude that the notion of isthmus is indeed essential to define, in the framework of discrete thinning methods, a notion of persistence.With the preceding examples, we saw that —intuitively— the greater the persistence, the smaller the filtered skeleton. By varying the value of the persistence parameter, we may try to compute a whole family of nested homotopic skeletons, to the cost of applying the previous algorithm once for each parameter value. Once computed, such a family can be stored as a function (i.e., a grayscale image) obtained by stacking all the filtered skeletons. Thresholding this function (named symmetric skeleton stack function, or SSSF in the sequel) at a given value would give back the filtered skeleton corresponding to this value of the parameter.It may be interesting to compute a SSSF instead of a single filtered skeleton in cases, which are frequent, where there is no trivial way to fix a priori a single parameter value for a set of images. In such cases, the precomputed SSSF may allow a user to interactively visualize the effect of each parameter value on the filtering. Alternatively, a post-processing algorithm may be applied, in certain applications, to automatically choose a threshold of the SSSF that satisfies a given criterion (for example, a chosen number of skeleton branches).Now, we are facing the problem of efficiently computing an SSSF. We show in the rest of this section that the cost of this computation can be dramatically reduced with respect to the one of the naive method evoked above.A first idea consists of storing, during the thinning process, the function Π that associates its persistence to each voxel that is detected as an isthmus at any step. The following algorithm Persistence, derived from algorithm PersistenceSymThinning, computes this function. Notice that it corresponds to the case where the parameter p is set to infinity in algorithm PersistenceSymThinning. This is necessary in order to compute the death dates of all non-permanent isthmus voxels.What happens if we threshold the map Π at a given level π? We could expect to get a filtered skeleton as computed by algorithm PersistenceSymThinning with parameterp=π,but this is not always the case: see Fig. 28for a counter-example. We also see with this example that the topological characteristics are not always preserved by this procedure.In order to compute a skeleton stack based on the persistence map, we propose the following strategy. Informally, this strategy consists of performing a symmetric parallel thinning of X guided by Π (that is, voxels are considered in increasing order of the value Π(x)), and storing for each voxel x the value of a function Ψ. The values Ψ(x) increase monotonically during the thinning, but as slowly as possible, and by construction the function Ψ is the lowest SSSF of X that is above Π.This strategy is implemented by algorithm Persistence SSSF. We illustrate this algorithm in 2D, as it is much easier to visualize a 2D map than a 3D one. Fig. 29 displays an object X, its SSSF computed by the above algorithm, and two thresholds of this map. The first threshold, at the value 1, is indeed identical to the result of algorithm IsthmusSymmetricThinning withk=1(curvilinear skeleton). The second threshold, at the value 3, provides a filtered skeleton that captures the main structure of the object.A key point, in the implementation of the algorithms proposed in this paper, is the detection of cliques that are critical or k-critical. The detection of such cliques is mandatory for extracting constrained crucial kernels of an object and for extracting the set made of all isthmuses of an object (procedure CrucialIsthmus).In this section, we will see that it is possible to detect these cliques with efficient algorithms operating on four different kinds of neighborhoods. See also [24] where a set of masks is proposed for critical cliques.First of all, recall that a clique that is either critical or k-critical for a complex X inV3,is necessarily essential for X.Up to π/2 rotations, the three configurationsC2,C1,andC0given in Fig. 30 may be used for the detection of a clique that is essential for a complexX∈V3(in this figure a voxel is represented by a point). Let C ⊆ X. It may be seen that, up to π/2 rotations:- C is a 2-clique that is essential for X if and only ifC=C2.- C is a 1-clique that is essential for X if and only ifC=C1∩Xand there exist two voxels of C that are 1-neighbors.- C is a 0-clique that is essential for X if and only ifC=C0∩Xand there exist two voxels of C that are 0-neighbors or three voxels of C that are mutually 1-neighbors.TheK-neighborhoods of the configurationsC2,C1,andC0are shown in Fig. 31.Observe that we haveK0=C0.Recall that a single voxel x of an object X constitutes a clique (a 3-clique) that is essential for X. Therefore, there are precisely four different kinds of neighborhoods for an essential clique (K0,K1,K2,andN(x)).Thus, the neighborhoods involved in the very definitions of critical and k-critical cliques (Def. 4 and Def. 9) are fully specified.Nevertheless, we observe that, in these two definitions, we have to check if a given complex S is reducible to a certain complex T determined by specific properties.For example, for checking if an essential clique C is 1-critical for X, we have to verify whetherS=K*(C)∩Xis reducible to a complex T composed of two non-adjacent voxels.LetS∈V3be an arbitrary complex that is reducible to a complex T. In fact, there is the possibility that S is reducible to a complex R, with T ⊆ R, but that R is not reducible to T.For example, such a situation occurs when S is a cuboid, T is made of a single voxel, and R is an object such as the so-called dunce hat[76], or the house with two rooms[77]. In [21], this kind of object is referred to as a lump.As a consequence of this fact, for testing if an arbitrary complex S is reducible to T, it is a priori necessary to compute all the complexes R such that S is reducible to R, and T ⊆ R. In other words, the “reducibility problem” is, in general, a complex problem from the point of view of algorithmics. See for example [78] for this issue.In [21], it was shown that it is possible to find lumps in the neighborhood of a cubical element (a face) ofZ5. The following result shows that, inV3,there is not enough space for such objects to be in theK-neighborhood of a clique. Note that point 1) of Th. 11 corresponds to Th. 17 of [24].Theorem 11LetC∈V3be a clique, letS⊆K*(C),and let x be a voxel that is simple for S.(1)If S is reducible, then S∖{x} is reducible.If S is reducible to a 0-surface, then S∖{x} is reducible to a 0-surface.If S is reducible to a 1-surface, then S∖{x} is reducible to a 1-surface.We proved this property using a computer program, that generates all possible configurations of theK-neighborhood of a clique by increasing order of cardinality. The program builds a table of all configurations that are reducible to a singleton (resp. 0-surface, 1-surface). To achieve this, for any given configuration of n voxels, the program checks whether it contains a simple voxel such that removing this voxel leads to a configuration that is reducible to a singleton (resp. 0-surface, 1-surface): this may be done by simply looking up the table. If such a voxel exists, then the configuration is added to the table. The total number of configurations (regardless of their reducibility) is equal to 226 (resp. 216, 28) for the case of a 3-clique (resp. 2-clique, 1-clique). Finally, the whole table is scanned in order to check the property: for each configuration that is reducible to a singleton (resp. 0-surface, 1-surface), we check that removing any simple voxel leads to a configuration that is reducible to a singleton (resp. 0-surface, 1-surface).□As a consequence of Th. 11, we can use a greedy algorihm for testing if an essential clique C is critical, 1-critical, 2-critical or not critical for X. We can arbitrarily select and remove a voxel that is simple for the setS=K*(C)∩X. After repeating this operation until stability, we check if C is critical (the resulting set is not made of a single voxel), if C is 1-critical (we obtain a set made of two voxels), or if C is 2-critical (we obtain a simple closed curve).Testing whether a voxel x is simple or not for an object S can be done in constant time, if we consider the size of the neighborhood of x as a constant (this size equals 26 in 3D space). This may be done by using previously proposed characterizations [21], or by using a pre-computed look-up table. Hence, from Th. 11, testing the status of a clique may be performed in linear time with respect to the size of its neighborhood. Again, to speed up the test, the results can be pre-computed and stored in look-up tables (as done in the proof of Th. 11). Each test (simple, critical, 1-critical, 2-critical) can thus be performed in constant time.In this section, we discuss the time complexity of the five algorithms presented in the paper.Algo. 1 (CrucialIsthmus): With a straightforward implementation, this algorithm may be computed in O(n) time on a sequential computer, where n is the number of voxels, and in O(1) on an ideal parallel computer.Algo. 2 (IsthmusSymThinning): This algorithm may be computed in O(t.n) time on a sequential computer, where t is the number of steps to thin the object (which corresponds, intuitively, to its thickness), and in O(t) on an ideal parallel computer.Alternatively, a breadth-first strategy may be employed in order to achieve a linear (O(n)) processing time for algorithm 2 with a sequential computer. It consists of maintaining a list of the voxels whose status changes during an iteration, and to use it to restrict the work to be done, in the next iteration, to their neighborhoods.Algo. 3 (PersistenceSymThinning): On an ideal parallel computer, the instructions in lines 4–7 may be executed in constant time. Thus, the overall complexity of the algorithm is in O(t), where t represents the number of steps of the repeat loop needed to reach stability (intuitively, this corresponds to the thickness of the object X). On a sequential computer, a direct implementation leads to an algorithm in O(t.n), where n is the number of voxels in the boolean array representation of X. However, the use of a breadth-first strategy leads to a linear-time (O(n)) algorithm.Algo. 4 (Persistence): The complexity analysis is the same as for Algo. 3 (PersistenceSymThinning).Algo. 5 (PersistenceSSSF): To obtain the best complexity for this algorithm, a breadth-first strategy must be employed to compute the sets Y, as in Algo. 3 (Persistence SymThinning). Also, an adapted priority queue data structure must be used to represent the set Q. As the priorities are small integers (step indices), which may be sorted in linear time by counting sort, Q can be managed to perform insertion and min extraction operations in constant time (see [79]). Furthermore, observe that the sets V (lines 11–12) at different iterations of the repeat loop are disjoint, and that for each voxel x there are at most 32 neighboring voxels y (line 14). Overall, the algorithm may be implemented on a sequential computer to run in O(n) complexity.

@&#CONCLUSIONS@&#
