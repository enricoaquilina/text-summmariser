@&#MAIN-TITLE@&#
ESFM: An Essential Software Framework for Meshfree Methods

@&#HIGHLIGHTS@&#
ESFM, an object-oriented software framework for meshfree methods, is described.Using few ESFM components can yield 48 variations of meshfree methods.ESFM enables exploring meshfree method implementations such as data structures and algorithms.Using ESFM, researchers can develop new meshfree methods with much less effort.ESFM is an ideal platform for future research on meshfree methods.

@&#KEYPHRASES@&#
Meshfree methods,Meshless methods,Software framework,Object-oriented design,Design pattern,Weak-form,

@&#ABSTRACT@&#
This paper describes an Essential Software Framework for Meshfree Methods (ESFM). Through thorough analyses of many existing meshfree methods, their common elements and procedures are identified, and a general procedure is formulated into ESFM that can facilitate their implementations and accelerate new developments in meshfree methods. ESFM also modulates performance-critical components such as neighbor-point searching, sparse-matrix storage, and sparse-matrix solver enabling developed meshfree analysis programs to achieve high-performance. ESFM currently consists of 21 groups of classes and 94 subclasses, and more algorithms can be easily incorporated into ESFM. Finally, ESFM provides a common ground to compare various meshfree methods, enabling detailed analyses of performance characteristics.

@&#INTRODUCTION@&#
Over the past two decades, the meshfree method is an active and popular research topic in many fields. Due to their meshless nature, meshfree methods can yield more accurate solutions than FEM (finite element methods), and they have other advantages [1–3] over FEM such as: (1) avoiding the manual effort in designing appropriate FE (finite element) meshes, (2) evading element distortion issues seen in large deformation problems [4–9], and (3) simulating crack propagations with ease [9–14]. Many literatures on meshfree methods have been published, and some important overview or comparison papers have been organized and discussed [15–19]. In contrast, very few studies have discussed implementations of meshfree methods. Most open literatures associated with implementation issues of meshfree methods focus on the construction of shape functions [20,21], and some discusses one particular flavor of meshfree methods [17,22,23]. Some open source or public domain codes for meshfree or related methods [24–31] were developed to demonstrate new procedures or new methods such as IGA (isogeometric analysis) using Matlab or Octave. Using these software packages for developing meshfree methods is convenient and keeps researchers focus on developing the meshfree method from mathematical perspectives. However, it becomes impossible to explore how data structures (such as sparse-matrix storage) can affect performance of developed meshfree analyses. Furthermore, most current implementations of meshfree methods do not necessarily consider best practices in software engineering, such as design patterns [32] and code reuse. No publication to date, to author’s knowledge, discusses software framework for meshfree methods developed in C++. There are several advantages using C++ for development. First, programs developed in native languages such as C++ typically perform much faster than those developed in interpreted languages do. Furthermore, many parallel computing toolkits or technologies such as OpenMP [33], CUDA [34], Intel Thread Building Blocks [35], and Thrust [36], are only available to C and C++. Therefore, using C++ for development enables the use of these parallel computing toolkits or libraries.This paper presents an Essential Software Framework for Meshfree Methods (ESFM), which supports implementing many basic meshfree methods and their associated numerical algorithms. It is intended for ESFM to solve partial differential equations raised from various physical problems, such as solid mechanics, and heat conduction, using different flavors of meshfree methods. As a result, many meshfree methods, numerical methods, and formulation methods need to be considered into ESFM. We believe ESFM provides a logical and well-organized framework to fulfill the aforementioned goals, and it is the first of its kind in the context of meshfree methods, while many other software frameworks were developed for finite element method [37–57] or for discrete element method [58,59].It is believed the ESFM cannot only facilitate the development of programs using meshfree methods, but also stimulate new research and development efforts in this field. During the development of ESFM, extensive use of (1) object-oriented analysis and design (OOAD) and (2) well-known design patterns [32] allows ESFM inherit benefits of being extensible and maintainable from object oriented programming (OOP). Furthermore, with carefully structured class hierarchy, new development can be achieved with less coding effort by reusing most of the developed classes. Furthermore, the framework is validated by implementing a program for solving plane-stress beam problem well documented in most literatures using three different meshfree methods.The rest of this paper is organized as the following: Section 2 analyzes the requirements for ESFM and identifies its basic components. Section 3 presents the design of ESFM. Section 4 describes three major procedures and operations in most meshfree methods and their implementations in the current ESFM. Section 5 demonstrates sample calculations on two-dimensional and three-dimensional problems with different shape functions, sparse matrix storage schemes, and parallelization. Conclusive summary are given in Section 6.ESFM was designed and developed based on the following three general requirements. (1) It should be able to implement most existing meshfree methods. (2) It should provide adequate modulization and abstraction to allow independent developments of algorithms in various parts of meshfree methods with minimal efforts. For example, implementations of search algorithms should not affect implementations in shape functions of meshfree methods. (3) Performance should also be considered in order to develop high-performing meshfree analysis programs. Furthermore, we only focus on the most fundamental aspects of meshfree methods that are common to all surveyed methods. Therefore, several features in surveyed literatures such as adaptivity, crack growth, and multi-physics are excluded.Based on these requirements, it is necessary to review existing meshfree methods to: (1) identify common procedures amongst various meshfree methods for unifying implementation efforts; (2) discover fundamental components in meshfree methods; and (3) isolate performance-critical numerical method components.By analyzing calculation procedures in some major meshfree methods [60–63] and finite element methods, it is not difficult to identify a unified calculation procedure for these methods. Fig. 1shows the flowchart for the identified calculation procedure for general meshfree analyses in the context of linear and static solid mechanics, but this can be easily extended to solving problems formulated from other fields as well. These general steps are:1.Setting up model: the model for meshfree analyses mainly consists of field nodes, boundary nodes, integration meshes needed by weak formulation, and material constitutive models. Field nodes are used by shape functions (or approximation functions) for generating approximations to the problem being solved, and often evaluations of derivatives are required. Boundary nodes are used to impose boundary conditions. Integration meshes can be manually assigned or automated generated by Delaunay or Voronoi diagram [64] in 2D, but robust-generation of 3D integration meshes remains difficult. Material constitutive models are mainly used to consider material behaviors during evaluation of global stiffness matrices in later steps.Assembling global stiffness matrix: the governing equation is first approximated using a chosen meshfree approximation method, and then integrated over the entire problem domain using numerical integration methods such as Gauss integration [65] on integration points (which are different from field nodes), or nodal integration [66] using field nodes.Imposing natural boundary conditions: imposing natural boundary conditions such as external loadings and body forces is similar to the procedures in finite element methods. Natural boundary conditions often contribute to the load vector, and the global stiffness matrix is usually untouched.Imposing essential boundary conditions: the imposition of essential boundary conditions can be difficult in meshfree methods. There are two types of shape-functions, one with Kronecker delta property and one without. Those without the Kronecker delta property require special treatments on imposing essential boundary conditions. Often imposing essential boundary conditions leads to modifications on both global stiffness matrices and load vectors.Solving discretized system equation: once the previous steps are completed, a discretized system of linear equations Ku=F is formed, and the system of equations can be then solved using various methods.Computing the final solution: for meshfree methods using shape functions without the Kronecker delta property, the computed u from the previous step needs to be substitute into the shape function in order to recover the true solution. This step is unnecessary for shape functions that possess the Kronecker delta property.Computing stresses and strains: after the final solution is obtained, strains and stresses in each gauss point can then be calculated by using shape functions and supplied constitutive laws.The above steps do not consider nonlinearity solution procedures such as Newton–Raphson iterations and use linear-static solid mechanics notations (K, u, and F). We focus mainly on linear-static solid mechanics procedure in this study.To ease the implementations of meshfree analysis programs by code re-using and to encourage new developments in meshfree methods, it is necessary to categorize and modulize major components in meshfree analyses, so that various algorithms in meshfree analyses can be independently developed without being affected or affecting other already developed modules. Therefore, not only the general procedure needs to be identified as in Section 2.1, but also important algorithms in meshfree analyses need to be identified.In the above general steps, often step 2 holds the most notable differences amongst different meshfree methods. In this step, different approximate functions [67–69], support-domain definitions [70], and domain integration schemes [66,70–73] have been discussed or proposed in the past for this particular step. Different selections on the approximation function in step 2 also affect the method that can be used for imposing essential boundary conditions in step 4. Direct imposition can only be used for shape functions with the Kronecker delta property, and many techniques such as penalty method [74] and Lagrange multiplier method [60] have been adopted to impose essential boundary conditions for shape functions without the Kronecker delta property. Fig. 2shows fundamental components for weak-form meshfree methods. These algorithms are further discussed:1.Approximation function: approximation functions, often called shape functions, are one of the main components in meshfree analyses to discretized continuum problems into discrete system. Many meshfree methods are only distinguishable by their shape functions, and many meshfree approximate functions [60,62,63,75–78] have been incorporated into meshfree analyses. Approximation functions are often composed of two parts: basis functions and weighting functions. Basis functions determine the fundamental form of approximations, and weighting functions often localize the evaluation of basis functions to form compact support. Table 1enumerates some popular choices of basis and weighting functions.Support domain: support domain essentially replaces the role of finite elements in finite element procedures for field approximation, and determines field nodes that have influence on an evaluation point. Support domain is formed dynamically through neighbor-search, and this is one of the reasons that meshfree methods are slower than the finite element method. Support domains can be defined in many ways. They are often circular/spherical or rectangular/hexahedral in 2D and 3D analyses, and their sizes are often determined empirically using various methods [79–83]. It should be noted the size of support domain has detrimental effects on solution accuracy [84].Essential boundary condition: many algorithms were proposed to impose essential boundary conditions for meshfree methods using shape functions that lack Kronecker delta property [74,85].Domain integration: weak-formulations integrate governing equations to form system of linear equations. The Gauss integration method is a popular choice for such task. High-order Gauss quadrature rules are believed necessary because of the high-smoothness in shape functions [70], but they incur significant number of shape-function evaluations. Therefore, many researchers are now interested in nodal integration methods, and problems such as instability associated with nodal integrations are being resolved [71,86–89].Through steps listed in Section 2.1, there are many numerical methods or components involved. Some of the performance-critical components, as shown in Fig. 3, are identified and discussed.1.Search algorithm: the search algorithm concerns about spatial search, which is used to find field points in the support domain to construct the field approximation. Finding support domain is done at each integration point, and can therefore consume significant amount of computation time, especially when there are many points to be sought. Therefore, it is necessary to use highly-efficient algorithms for spatial search such as using KD-Tree [90], DESS [91], and many others.Sparse matrix storage: it is well known the resultant global stiffness matrix assembled by meshfree methods is sparse. In order to solve the resultant system of linear equations, it is necessary to use sparse storage schemes such as banded [92], skyline [93], compress row [94], and many others to avoid operations on zero elements. Different storage schemes may use different amount of memory, and can consume different computation time in order to store one matrix element into the global stiffness matrix. In other words, their assemblage costs are different.Ordering: it is a common practice to re-order resultant system of linear equations in order to (1) reduce the memory consumption and (2) to reduce fill-ins during LU factorization of the system equations. The ordering here concerns only on reducing the memory consumption. When banded or skyline storage schemes are used for storing the global stiffness matrix, the memory consumption is determined by the bandwidth of the matrix, and algorithms such as reverse Cuthill–McKee [95] and Sloan algorithm [96] can be used to reduce the bandwidth.Equation solver: the resultant system of linear equations (i.e. Ku=F) can be solved by either direct methods such as LU factorization and Gauss elimination or non-stationary iterative methods such PCG, GMRES, and BICGSTAB, [97]. Many of these methods are available as public domain or open-source software and can be readily integrated or linked into the software to be developed.In summary, a common procedure is formulated based on many surveyed meshfree methods and review papers, and different meshfree methods can be formulated by changing shape functions, support domain definitions, domain integration methods, and boundary condition imposition methods. Furthermore, some performance-critical numerical methods are also identified in order to help develop high-performing meshfree programs. It should be emphasized these numerical method components have great effect on the performance of meshfree analyses, and they cannot be easily explored using software packages such as Matlab or Octave since their internal data structures may not be changed easily.ESFM is developed based on the requirements gathered through the survey of existing meshfree methods in the last section. The central design concept of ESFM is that each of the conceptual components (e.g. support domain, shape function, etc.) in meshfree methods or numerical methods (e.g. sparse matrix, solver, etc.) is encapsulated using an abstract class to formalize its interface. The actual algorithms for these conceptual components are implemented in subclasses, which encapsulates its private data. This design concept is a well-known design pattern known as Strategy pattern, which lets the algorithms vary independently from clients that use them[32]. By following this design concept, each conceptual component can have multiple implementations in subclasses that can be easily switched between one another without affecting any other part of the developed program through polymorphism mechanism in object-oriented programming. Other design patterns are used, and will be mentioned when the design of the framework is described. ESFM has been iteratively refined and validated through implementations in C++ to reach the current design.ESFM consists of 21 main groups of classes that are summarized in Table 2. Class diagrams in UML (Unified Modeling Language) [98,99], documenting relationships between classes, are shown in Figs. 4–6. Major operational behaviors are documented using sequence diagrams and are discussed in Section 4. Fig. 4 documents core classes and their associated classes in ESFM, and three classes in Fig. 4 play central roles: the Model class, the Domain class and the Formulation class. Responsibilities of these three classes and their associated classes are described in Sections 3.1–3.3. Finally, a SystemInterface class is developed to ease the use of the framework, and is describe in Section 3.4.The Model class is an abstract class defining interfaces used by other classes in ESFM. Instances of the Model subclasses carry information required to solve a given physical problem, as well as data required by the numerical method used, which is the meshfree method in this work. Information related to the physical problem such as material properties, boundary conditions are contained in the instances of this class, as well as the data needed by the meshfree method such as field nodes and integration meshes. Furthermore, once the solution is obtained, solution variables such as displacements, strains, and stresses are also stored in this class instance. It should be noted concrete Model subclasses are used to define models of different physical problems (e.g. solid mechanics, fluid mechanics, etc.) or to implement different model definition methods, such as using programs to generate nodes and meshes, while defining them by parsing input files.The Model class is primarily used to store data used by other classes. However, it has one major operational responsibility to define support domains for points of interest. This is achieved by using two classes: the InfluenceDomain class and the InfluenceDomainSize class. They correspond to the shape and size of support domains and implement various support domain definitions. In the surveyed literatures, support domains are either circular/spherical or rectangular/hexahedral, and the size is often determined by some distance measure (e.g. average nodal spacing, distance to n-th nearest node) scaled by empirical factors. Therefore, ESFM separates shape and size definitions into the InfluenceDomain class and the InfluenceDomainSize class. All different shape and size definitions can be implemented as subclasses of these two classes, and different pairs of these two classes result in different support domain definitions. It should be noted the InfluenceDomain class, determining shape of support domains, uses subclasses of the SearchAlgorithm class to perform spatial search of nodes. Such design enables different support-domain definition methods share implemented search algorithms.The Domain class concerns about the final mathematical system representing the physical problem to be solved in the problem domain, such as Ku=F in static solid mechanics, and is responsible for using numerical methods to solve this mathematical system. Deriving the mathematical abstractions, however, is left to the Formulation class to be introduced in the next section.The Domain class operates on the mathematical system leading to the solution of the problem being solved, and the system is expressed as matrices and vectors. These matrices and vectors are managed by an instance of the Assemblage class, or simply an Assemblage object. Once the Formulation object has developed the mathematical system and stored in an Assemblage object, the Assemblage object will then be passed into a Solver object to solve. The obtained solution may be a partial solution. The Domain class will then pass the partial solution into the Formulation object in order to finish solving for the whole solutions.As above-mentioned, the Assemblage class helps the Domain class to manage matrices and vectors, and therefore hides details of these matrices and vectors from the Domain class. The main purpose of the Assemblage class is to apply different ordering strategies on degrees of freedom (DOF) to be solved. It is well known that different ordering of DOF results in different memory usage, as previously discussed in Section 2.3. Introducing this class also increases coherence of the Domain class, which do not need to know about the ordering of matrices and vectors.The Solver abstract class is responsible for solving the resultant system of linear equations, e.g. Ku=F in static solid mechanics. Many freely available software packages can be applied to solve the resultant system of equations, such as PARDISO [100], SuperLU [101], and UMFPACK [102]. Each solver package uses different techniques and strategies to solve the system efficiently, and different problems may require different packages to achieve optimal solution efficiency. These packages may use different formats of matrices and vectors, and they often have different application programming interfaces. These differences in different packages are handled by different subclasses of the Solver class. Each Solver subclass encapsulates details of different solver packages, allowing each subclass independently evolve with upgrades of its own targeting solver package.Both Assemblage and Solver classes and their respective subclasses follow the Strategy design pattern.The Formulation class is responsible for developing the mathematical system for a given physical problem described by the Model class. This class is an abstract class defining interfaces used by the Domain class, and its subclasses define the actual implementations, which may use different governing equations (e.g. force equilibrium condition), formulation methods (e.g. weak form or strong form), and different PDE solution methods (e.g. meshfree or finite element methods) to derive the mathematical system required by the Domain class. The design of the Formulation class not only uses the Strategy pattern, but also uses the Mediator pattern [32] to loosen the coupling between its associated classes, enabling each associated class independently evolved or developed, as most interactions between these related classes are enclosed in the Formulation class.The Formulation class seen in Fig. 4 is developed specifically for meshfree methods formulated using global weak form. In ESFM, field variables are approximated using shape functions evaluated by the ShapeFunction class with support domains stored in the SupportDomain class. The governing equation is integrated using the Integration class and yields equations or conditions for solving unknown field variables. Furthermore, different algorithms provided by the EssentialBoundaryCondition class may be used to impose essential boundary conditions. Once the governing equation is evaluated and boundary conditions are applied, the mathematical system leading to the solution of the problem is developed. The associated classes: ShapeFunction, SupportDomain, and EssentialBoundaryCondition classes will be introduced in Sections 3.3.1–3.3.3.The GlobalSolidMechanics class in Fig. 4 inherits from the Formulation class and implements a general procedure to use meshfree methods with global weak form to solve linear-elastic solid mechanics problems. The implemented general meshfree weak-form procedure and interactions between associated classes will be discussed in Section 4. It should be noted different physical problems may need additional classes seemingly unrelated to meshfree methods. For example, the implemented GlobalSolidMechanics class contains a Material class and a StrainDisplacement class. The Material class evaluates constitutive models of materials, and the StrainDisplacement class converts displacements into strains. Therefore, these classes are specific for solid mechanics. However, depends on implemented meshfree methods, these seemingly unrelated classes may provide new opportunities in meshfree methods. For example, the Stabilized Conforming Nodal Integration method (SCNI) method [71] uses alternative formulation in Strain–Displacement conversion in conjunction with an innovative integration scheme and yields a new efficient meshfree method with stable numerical properties.Shape functions are the main component in meshfree methods, and some meshfree methods are only differentiable by distinct shape functions. The main responsibility of the ShapeFunction class is to evaluate shape functions based on the associated support domain. Fig. 5 shows the design the ShapeFunction class and its descendants in ESFM. Two major kinds of shape functions are considered in this framework: mesh-based and mesh-less shape functions.The mesh-based Isoparametric shape functions are widely used in FEM. These shape functions are implemented in ESFM to perform domain integration for weak formulations. These shape functions are implemented as subclasses of the Isoparametric class. It is possible in the future to use these shape functions to implement FEM in ESFM, but is beyond the scope of this paper.The mesh-less shape functions usually have three main ingredients: basis functions, weighting functions, and associated support domains. The shape function value is usually the product of its weight and the basis function values. Therefore, as seen in Fig. 5, the MeshlessShape class has a BasisFunction and a Weight class, and uses a SupportDomain class. The MeshlessShape class provides a generic shape function implementation that contains both basis and weighting functions, and one can easily change both the form of basis and weighting functions to derive a new shape function. It should be noted this class provides interfaces to other parts of the framework to evaluate shape functions, their first derivatives, and sometimes their second derivatives. These values are derived from its associated weighting and basis functions. For shape functions that do not have weighting or basis functions may use the Unity class as its weight or basis. Alternatively, one may directly subclass the MeshlessShape class and implement all its interfaces, ignoring the basis and the weight altogether.Many fundamental basis functions have been used in meshfree methods, and they can all be implemented as concrete subclasses of the BasisFunction class. In our survey, some shape functions are “enriched” or “augmented.” For example, radial basis functions can be augmented by polynomial basis in order to reproduce polynomials up to a given order n, also known as consistency condition [1,2]. Decorator pattern [32] is adopted in the design of the BasisEnrichment class to facilitate augmentation of basis functions. As seen in Fig. 5, the BasisEnrichment class inherits from the BasisFunction class, and it aggregates two basis functions to enrich one basis function with the other. The augmentation algorithm [1,2] is implemented the BasisEnrichment class. Therefore, arbitrary combinations of implemented basis functions can be easily achieved without changing existing basis functions. This design allows each basis function being augmented without knowing such augmentation.The Weight class provides various weighting functions to the shape function. It is interesting to note that weight used in meshfree methods in 2D or 3D often generalizes from 1D weights such as cubic spline, quartic spline, and exponential by either rectangular or circular shapes. Therefore, 1D weight functions are implemented as subclasses of the WeightSeed class, while generalization into 2D or 3D weights are done through WeightCircular or WeightRectangular classes.Support domain is the other central component in meshfree methods, and various definitions methods are introduced in Section 3.1.1. In the design of ESFM, the SupportDomain class is a concrete class for storing information of neighbor field nodes that are found by the InfluenceDomain object, invoked through the Model object. It should be emphasized the stored neighbor field nodes can be defined by arbitrary InfluenceDomain definition methods.Imposing essential boundary conditions in meshfree methods can be done in many ways. Direct method, penalty method, and Lagrange multiplier approaches have all been used successfully to impose essential boundary conditions in meshfree methods. These methods are usually applied after global stiffness matrices and load vectors have been assembled, and different methods modify the stiffness matrix and the load vector differently.In the design of ESFM, as seen in Fig. 4, the EssentialBoundaryCondition class uses the Assemblage class to impose boundary conditions. Selection of different imposition methods is usually based on the existence of the Kronecker delta property of shape functions. Similarly, Strategy pattern is applied to allow easy switching between different methods for imposing essential boundary conditions.The Integration class is designed to help implement different numerical integration methods in domain integration, natural boundary conditions, body forces, etc. Methods such as Gauss integration, nodal integration with stabilization, and cubature rules can be implemented as subclasses of the Integration class. However, Gauss integration need to use the Isoparametric shape function previously discussed to compute locations of integration points and their associated Jacobians and determinants.As seen in Figs. 4 and 5, the entire framework is large, contains many classes, and requires many objects to be created before a meshfree analysis can be conducted. In order to simplify the use of ESFM, the SystemInterface class is designed. The SystemInterface class uses Façade pattern to provide a simplified interface to a larger body of code[32].As shown in Fig. 6, developers first prepare a model object, which describes the problem being solved with information such as nodes, integration meshes, and material models. The model object will then be fed into an instance of the SystemInterface class to setup required objects and to establish relationships between these objects. Interfaces are provided to developers for operations that cannot be automated. When new classes or processes are added to ESFM, the SystemInterface class needs to be updated accordingly to maintain the ease-of-use of ESFM.Three major operations ESFM are described in this section: (1) the main procedure, concerning interactions between Domain, Formulation, and Model classes; (2) the initiation procedure before the formulation procedure; and (3) the formulation procedure. These procedures are described in subsequent sections.The main procedure, depicted in Fig. 7using the sequence diagram in UML, controls the collaborations between the Model object, the Domain object, the Formulation object, the EssentialBoundaryCondition object, the Assemblage object, and the Solver object to obtain solution to the interested problem. These objects are the instances of their respective classes shown in Fig. 4. The GlobalSolidMechanics formulation is used to depict this sequence. This main procedure is executed by calling the analyze method of the SystemInteface object. Using static solid mechanics with global weak form as an example, the main procedure executes the followings steps:1.Evaluate the global stiffness matrix and the load vector: the Domain object invokes the calc() method in the GlobalSolidMechanics object, with a Model object containing a model definition and an Assemblage object for holding results. The steps for forming the global stiffness matrix and the load vector are triggered by the calc() method, which is itself a template function, allowing subclasses to rewrite details of each step it invokes to assemble the global stiffness matrix and the load vector. This design uses the well-known Template pattern [32].Solve the resultant system of linear equations: the resultant global stiffness matrix and the load vector are stored in an Assemblage object. This object is then given to a Solver object to solve for the solution to the mathematical system obtained from the previous step.Obtain complete solution: the solution obtained in the previous step is sometimes partial solutions to the system, and the partial solution is then fed back to the Formulation object to solve for the complete solution.Fig. 8shows the initiation procedure of the Formulation class using global weak formulation as an example. The initiation procedure is invoked by the iniParameter() function call as the first step in the calc() function shown in Fig. 7. This procedure has five parts, as shown in Fig. 8:1.Obtain necessary data such as field node coordinates, integration mesh definitions, and integration points from the Model object.For each integration point, find field nodes in its support domain by calling a method in the Model object. Also, nodal connectivity information is set into the Assemblage object if it needs such information for re-ordering degrees of freedom.For each of the field nodes, find its support domain by calling a method in the Model object.Set field information into the shape function and the maximum number of support nodes into the ShapeFunction object. This information will later be used during the formulation procedure and for memory allocations.When the used approximation function lacks Kronecker delta property, nodal shape functions are needed for enforcing essential boundary conditions. Thus, related data (SupportDomain object) from part 3 above will also be passed into the ShapeFunction object, and the calculated data (shape function values) are stored into the Model object.Overall, the initiation procedure prepares necessary calculation data for the next core procedure: the Formulation procedure.The Formulation procedure in this work concerns about solid mechanics using global weak formulation, and is illustrated in Fig. 9. Domain integration is performed using Gauss integration. The procedure has three steps:1.Obtain necessary information, such as nodes, integration meshes, and integration points from the Model object.At each integration point, compute its local stiffness matrix and contribute it to the global stiffness matrix. The formulation of this step can be found in several Refs. [15,17–19]. This is achieved by first using the ShapeFunction object to evaluate the first derivative of the shape function, which is then used to compute strain–displacement matrix, B. Later, the Material object is used to compute the material stiffness matrix, D. Local or nodal stiffness matrix (BTDB) is then calculated by using the GuassIntegration object. Finally, the integrated local stiffness matrix is given to the Assemblage object to assemble the global stiffness matrix.This step is only engaged when body force calculation is involved, and it computes the integrals of the body force element-by-element. The resultant elemental loads are added to the system load vector.In subsequent sections, ESFM is firstly validated on two classical problems, one in 2D and one in 3D. These validations show that the developed program with ESFM can produce accurate solutions. Then, three potential uses of ESFM are demonstrated. First, ESFM provides a common ground to compare different meshfree methods fairly. Second, ESFM can explore the effect of sparse matrix storage or data structures on the performance of meshfree methods. Such capability encourages further development of data structures suitable for meshfree analyses. Finally, parallelization can be introduced into implementations with ESFM to enhance performance of meshfree analyses significantly.A 2D plane-stress cantilever beam shown in Fig. 10is analyzed with the following settings: a concentrated load at the free-end with P=1000N; Young’s modulus of the material E=3×107N/m2; Poisson’s ratio v=0.3; depth of the beam D=12m; length of the beam L=48m.ESFM is used to construct three different analyses with different shape functions: RPIM, RPIM augmented with 1st order polynomial basis, and MLS. Table 3shows selected ESFM components in constructed programs. Furthermore, field nodes are uniformly distributed within the problem domain.Fig. 11shows the Mises stress obtained with different numbers of DOF from several meshfree analyses of three different shape functions. It also shows the analytical solution. In these analyses, as expected, RPIM cannot obtain good approximate solution until very high number of DOF is used. This is due to the lack of polynomial-reproducing capability of radial basis functions. RPIM augmented with 1st order polynomial basis remediates such situation. At the end, all three methods converge to the analytical solution.The same three methods as in Section 5.1 were used to analyze a 3D point-load in elastic half-space problem, as shown in Fig. 12. By using the symmetry condition, only one quarter of the elastic domain is modeled. Roller boundary conditions are applied on all sides except the top surface to restrain out-of-surface displacements. The analyses have the following settings: point load with P=1N; Young’s modulus E=3×107N/m2; Poisson’s ratio v=0.3. Vertical stress increments, at various depth, z, of the three methods, together with analytical solution offered by the classical Boussinesq solution [103] in Eq. (1), are compared in Fig. 13.(1)Δσz=3P2π1z2It should be noted the logarithm scale is used in the figure. It can be seen in Fig. 13 that all three methods agree with the analytical solution, except at points close to the bottom. This is because the Boussinesq solution is a half space solution, while limited boundary is used for the meshfree analyses. Therefore, we are seeing boundary effects in Fig. 13 that causes the meshfree solutions to deviate from the analytical solution.ESFM enables exploring how shape functions can affect solution time. Without using frameworks like ESFM, it is often difficult to compare different methods proposed by different researches because they may use (1) different support domain definitions, (2) different shape functions, (3) different programming languages, (4) different nodal search algorithms, etc. Combinations of all possible differences make it impossible to compare different methods, especially when the solution performance is of concern. Using ESFM enables fair comparisons between different methods because we can well control the selected components used in the developed meshfree programs to allow only intentionally introduced differences, e.g. the shape function, while keeping all other parts identical.Table 4shows the observed solution time for each of the above examples using selected components listed in Table 3. In terms of solution time, these three methods do not differ much, and the differences between these analyses are entirely due to different shape functions used. Such conclusion can only be drawn from using programs developed using ESFM or using similar practices to avoid differences in other parts, such as sparse matrix storage schemes or equation solvers.Further performance explorations through ESFM are possible. Section 2.3 discusses some of performance-critical components, and researchers may try out new spatial search algorithms or sparse matrix storage schemes by subclassing corresponding classes and study how performance of meshfree analyses changes accordingly.One of such exploration is done on sparse matrix storage schemes [104] by authors. Programs were developed using ESFM, and computing time that spent on global stiffness matrix related operations were isolated and collected into Table 5. It can be seen that different storage schemes alter calculation time significantly. This is one area rarely addressed in meshfree methods. There were many such studies for FEM, and several such sparse matrix storage schemes were developed. However, the global stiffness matrices assembled by FEM and meshfree methods have different characteristics. New storage schemes may thus be necessary for efficient meshfree methods.Parallelism can be incorporated into ESFM by using OpenMP [33] on multicore machine, using CUDA [34] on GPU device, or through hybrid computing (CPU+GPU). Hybrid computing technique was successfully incorporated into ESFM by authors [105] with encouraging results.Table 6compares total solution time obtained by six different cases. Each case was computed twice, one calculated using CPU, and one calculated using CPU+GPU. It is seen for 2D cases, the speed up is not significant. However, for 3D cases, the speed up can reach 11.5 times. In other words, significant performance boost is reached using hybrid computing technique. It may seem strange that 3D cases have fewer DOF than 2D ones, but the solution time is much longer. This is because the resultant global stiffness matrices of 3D cases are much denser than one ones obtained from 2D cases.A general software framework for weak-form meshfree methods known as ESFM is developed in this work. ESFM logically divides developments of meshfree methods into three separate concerns: the Model that describes the physical problem, the Formulation that turns the physical problem into a system of linear equations, and the Domain that deals with the resultant mathematical system. Key components in these three concerns were discussed. Components associated with the Formulation class present research and development opportunities in meshfree methods, while components associated with Domain and Model classes mostly present opportunities to improve the solution efficiency in meshfree methods.It is intended for ESFM to provide common components to implement most existing meshfree methods and to be flexible to mix-and-match components from different researches to create new methods and techniques with minimal coding effort. For example, the current ESFM can generate 48 variants of shape functions using 4 different weights, 3 basis functions (including augmentation of various basis functions), and 4 support-domain definitions. However, some of these 48 variants may be numerically identical, and some of them should never be used due to undesirable properties. It is researchers’ responsibility to choose the “right” combination. Furthermore, ESFM enables combining different shape functions, search algorithms, sparse matrix storage schemes, and sparse matrix solution packages into many meshfree method implementations with different solution accuracies and performance characteristics.Furthermore, ESFM encourages explorations on data structures and numerical methods associated meshfree methods. For example, the global stiffness matrix assembled from meshfree methods has quite different properties from the one assembled from FEM. In other words, new data structures may be necessary to construct more efficient meshfree methods.ESFM is a software framework still in active development. Interested researchers are encourage to contact authors via email to gain access to our code.

@&#CONCLUSIONS@&#
