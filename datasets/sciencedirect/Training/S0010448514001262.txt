@&#MAIN-TITLE@&#
An algebraic taxonomy for locus computation in dynamic geometry

@&#HIGHLIGHTS@&#
A taxonomy for locus computation in dynamic geometry is proposed.An algorithm for automatic locus computation using the Gröbner Cover is described.A prototype of web application implementing the main algorithm is provided.

@&#KEYPHRASES@&#
Dynamic geometry,Locus computation,Parametric polynomial systems,GröbnerCover algorithm,

@&#ABSTRACT@&#
The automatic determination of geometric loci is an important issue in Dynamic Geometry. In Dynamic Geometry systems, it is often the case that locus determination is purely graphical, producing an output that is not robust enough and not reusable by the given software. Parts of the true locus may be missing, and extraneous objects can be appended to it as side products of the locus determination process. In this paper, we propose a new method for the computation, in dynamic geometry, of a locus defined by algebraic conditions. It provides an analytic, exact description of the sought locus, making possible a subsequent precise manipulation of this object by the system. Moreover, a complete taxonomy, cataloging the potentially different kinds of geometric objects arising from the locus computation procedure, is introduced, allowing to easily discriminate these objects as either extraneous or as pertaining to the sought locus. Our technique takes profit of the recently developed GröbnerCover algorithm. The taxonomy introduced can be generalized to higher dimensions, but we focus on 2-dimensional loci for classical reasons. The proposed method is illustrated through a web-based application prototype, showing that it has reached enough maturity as to be considered a practical option to be included in the next generation of dynamic geometry environments.

@&#INTRODUCTION@&#
In general, a geometric locus is a set of points satisfying some condition. For instance, the set of pointsAat a given distancedto a specific pointCis the circle centered atCof radiusd. For another simple example of a different kind, letcbe a given circle with centerC, letQbe an arbitrary point on the circle and consider the locus of midpointsPof the segmentsCQ, asQglides along the circlec.In Dynamic Geometry (DG), the term locus generally refers to loci of this second kind: i.e. to the trajectory determined by the different positions of a point (the tracer, as pointPabove), corresponding to the different instances of the construction determined by the different positions of a second point (the mover, such as pointQabove) along the path where it is constrained. This is the case for the first standard DG systems developed in the late 1980s (such as Cabri  [1] and The Geometer’s Sketchpad  [2]), but it is also true for the more recent ones, such as GeoGebra  [3] or Java Geometry Expert  [4].Note that even simple DG constructions can involve two-dimensional loci. Consider, for instance, two circles, each one with a point moving on it. While the locus of their midpoint is a circular region, no current DG environment would return such set, since the corresponding locus command cannot manage two independent mover points. Thus, our discussion is restricted to loci in constructions with exactly one degree of freedom. This approach includes standard DG loci, and also constructions currently not covered by the locus function in interactive environments, such as a circle computed through its standard definition as the locus set of points at a given distance to a given point.There is a wide consensus among DG developers to consider locus computation as one of the five basic properties in the DG paradigm (together with dynamic transformation, measurement, free dragging and animation; see, for instance  [5]).In Section  2 we review the different approaches followed by DG environments to address the computation of loci. We discuss the traditional numeric method, as well as some improvements aimed at providing a more detailed knowledge of loci, including those coming from the field of symbolic computation. Limitations and failures of these methods are emphasized, with a view towards providing a benchmark to test the performance of our method, which is illustrated by the examples in Section  5.Our approach considers a given locus as a certain subset of the projection set of an associated algebraic variety (see Section  3). Many methods have been developed to obtain the Zariski closure of such projections (Gröbner bases, characteristic sets, discriminant varieties, border polynomials, …). Our proposal takes advantage of the specific features found in the recently developed GröbnerCover algorithm (see Section  4) to•compute the projection set, yielding a constructible set (and not just the algebraic set given by the Zariski closure), andautomatically discriminate the relevant components, within the constructible set, containing the given locus.Following this taxonomy, we establish a protocol that yields a faithful symbolic description of a given locus in terms of constructible sets, collecting pieces of the projection set featuring ‘good’ labels. In Section  4, a software tool implementing our proposal is described. Finally, several examples illustrating the method are discussed in detail in Section  5.The provided examples show that our method overcomes limitations found in previous proposals, and also that it allows the computation of generalized loci in the sense of  [6], see Section  5.4.Sutherland’s Sketchpad  [7], one of the first graphic interfaces, developed half a century ago, already included some key concepts in the paradigm of dynamic geometry. Most remarkably, it introduced the use of a light pen to select and dynamically interact with geometric objects displayed on a screen, in a way almost identical to mouse dragging (or finger dragging on touchscreens).In particular, for locus computation, the approach followed by Sketchpad is basically the same as the one present in current standard DG systems, namely, it consists of building a set of sample locus points (a time exposure in Sutherland’s words). Below, we briefly describe this ‘traditional’ method, as well as some attempts towards its improvement.The standard approach followed by DG systems to obtain loci is based on sampling the path of the mover. Each sample point determines a position for the tracer, and hence a point in the locus. This set of locus points can then be shown as a collection of pixels on the screen, suggesting the sought locus.On this list of locus points, most DG systems apply some simple heuristics to join contiguous points, in order to return the locus as a continuous, (usually) one-dimensional object, on the screen. A first difficulty arises here, because the applied heuristics can return aberrant loci, since small modifications in a construction can sometimes produce significant changes of position in dependent objects (see  [8] for details).A second problem, regardless of whether the locus is returned as a sequence of points or as a continuous curve, is the fact that the locus is simply a graphical representation, preventing the system from working any further with such output. For instance, since the equation of a curve (as a locus) is not available if this locus is obtained by the traditional method, computing its tangent at a point becomes many times very imprecise, if not impossible altogether.11See comment by the creator of The Geometer’s Sketchpad about the construction of tangents to a locus set as the limit of secants in http://mathforum.org/kb/message.jspa?messageID=1095049.Another difficulty emerging from this numerical method is found when trying to obtain the intersection of a locus with another element in the construction. Although various solutions have been introduced in different systems, these are essentially approximate, and they often add serious inaccuracies to the construction.The search for more sophisticated ways to automatically obtain loci has led different DG systems to consider different approaches. We summarize here the most relevant.The first DG system to include a command to provide algebraic information for a locus was Cabri. Since its release in 2003, Cabri Geometry II plus, the current version of Cabri, incorporates a tool for computing approximate algebraic equations for loci.Although proper documentation of this feature is not provided by Cabrilog, the company behind Cabri, a schematic description of the algorithm used in the back-end can be found in  [9]. It is based on the random selection of one hundred locus points and the computation of the best approaching polynomial curve (up to degree six) to this collection of points. Let us point out that the limiting factors of this approach come from sampling and fitting points to sufficiently high accuracy. Moreover, the number of monomials whose coefficients must be found grows as the square of the degree.This numerical procedure does not result, in our opinion, in a satisfactory solution. In fact, simple locus constructions can easily give rise to algebraic curves of degree higher than 6 (see, for instance,  [10]), that would go undetected for Cabri. Moreover, no comment is attached to the locus output concerning the (in)exactness of the algebraic information provided, hence inducing a non expert user to take it as an accurate one (cf.  [11], where Cabri is shown to return a cubic as equation for the curve of Watt).Likewise, in  [12,13], the authors consider also the rendering of some (many) sample points of a locus set constructed by ruler and compass as the initial data of an algorithm to determine the degree and parameters of an algebraic curve ‘resembling’ the locus. In a second step, a collection of such curves, obtained varying the position of basic construction points, is analyzed in order to get more general knowledge about the involved locus.Although impressively precise in certain situations, the algorithm is prone to inaccuracies for curves of high degrees  [12, p. 63]. Besides these problems, the authors report other drawbacks in the method, that make it unsuited for efficient implementation. In summary, we consider this a promising, but still an open approach to automated locus determination.In  [14,15], the authors (and developers of Cinderella  [16]) review how their software uses automatic theorem proving to add extra information to certain elements in a geometric construction. In particular, Cinderella uses automated deduction techniques based on randomized methods to improve the knowledge about some loci.Roughly speaking, randomized theorem proving consists on checking a property for a sufficient number of examples. Moreover, randomized theorem proving could provide a valid certificate answer if tested on a sufficient number of examples related to the degrees of the involved polynomials. For instance, given a construction including three pointsA,BandC, the system will take as a fact that the points are aligned if the lineABcontains the pointCfor a large set of instances obtained by randomly modifying the position of pointsAandB. From then on, the system will take the elementsline(A,B)andline(B,C)to be identical.In particular, for any locus in a diagram (i.e. a finite set of sample locus points), the line defined by the first two sample points, is constructed. The system then checks whether the rest of the sample points belong to this line, not only for that particular instance of the diagram, but also for any instance in a large set of random modifications of the diagram. In that case, the locus element is replaced by that line (together with its equation). If the locus is not identified as a line, a similar process is followed using the circle defined by the first three locus points. If not identified as circle either, the conic defined by the first five interpolation points is taken as candidate.This replacement, when successful, not only facilitates the rendering process of the locus, but also allows the system to use it for further constructions, such as intersections with other objects.Although approximate in nature, the method provides an effective way to improve locus generation for many constructions. However, the current Cinderella implementation can deal only with lines and conics, since there are no other locus objects defined by equations in this system. This makes this approach a limited answer to the general question of locus implementation in DG.Related to randomized theorem proving, but more sophisticated, is numerical algebraic geometry, which also exploits the idea of drawing conclusions about algebraic sets by numerically testing whether sample points satisfy algebraic conditions. Moreover, it uses sampling over the complex numbers, not just real numbers, to strengthen its performance (see  [17]). Although no DGS has yet incorporated numerical algebraic geometry, it should provide a strong numerical alternative for locus computation to the approaches mentioned in this note.In many instances, a dynamic geometry construction concerning a locus computation can be viewed as a set of polynomial equations, corresponding to the analytic expression of the geometric objects involved in the description of the mover and tracer points. Then, roughly speaking, computing a locus can be understood as obtaining an equivalent set of polynomials, but only in the variables corresponding to the tracer, i.e. as eliminating the remaining variables.For this task, constructive elimination tools, such as Gröbner bases  [18,19] and Wu’s method  [20,21], are crucial. Although some authors have used Wu’s method for algebraic loci computation (e.g.  [22–24], albeit with no GUI, and  [25]) the use of Wu’s method for a true automatic generation of loci within a DG system remains unexplored. On the other hand, Gröbner bases have been widely used for automatic theorem proving  [26–28]. In particular, in  [29], a method based on Gröbner bases for automatic discovery is described. Moreover, linking Cabri, the most popular DG system at the time, and the Gröbner basis method for automatic discovery, in an intelligent program for learning Euclidean geometry, is explicitly proposed. Specializing this approach, an algorithm for automatic discovery of loci based on Gröbner bases was introduced in  [30].The elimination (using Gröbner bases) of some variables in the polynomial ideal obtained as translation of the construction, leaves us with a set of polynomials in the tracer-point coordinates only. The zero set of these polynomials is, in general, a superset of the sought locus set.A problem with this algebraic approach is that the obtained algebraic set may contain extra components, sometimes due to the fact that the method returns only Zariski closed sets,22That is, the complete solution set of a system of polynomial equations. No missing points are allowed (see Section  5.1).some other times due to degenerate instances of the construction.For instance, let us consider the limaçon of Pascal, a conchoid that can be constructed as a DG locus as follows. LetObe a fixed point on a circlec, letlbe a line passing throughOandP(a general point onc). LetQbe a point onlsuch thatdistance(P,Q)=k, wherekis a constant. The limaçon of Pascal is the locus set traced byQasPmoves alongc, as shown on Fig. 1(left).We make the following assignment of coordinates:P(x1,x2),Q(x,y). For example, if we consider thatOis the point(0,2),k=1and(0,0)the center ofcwe get the idealI=(x12+x22−4,(x1−x)2+(x2−y)2−1,x(x2−2)−x1(y−2))whose polynomials correspond, respectively, to the following geometric constraints:Pis in the circle of center(0,0)and radius 2,distance(P,Q)=1andQ∈Line(P,O). Eliminating variablesx1andx2, we obtain the following product of two polynomials(x4+2x2y2+y4−9x2−9y2+4y+12)(x2+y2−4y+3). While the first factor provides the implicit equation for the actual limaçon, the second factor corresponds to a spurious circle associated to the degenerate case for whichP=O, when the linelceases to exist (see Fig. 1, right).Example 1 in Section  5 provides an example of locus for which this procedure would return an algebraic set with extra points, due to the Zariski closedness of the result.Despite its limitations, this algebraic approach was a significant improvement, not only over the traditional method, but also over all other approaches mentioned above. The provided analytical knowledge about general algebraic loci, albeit sometimes incorrect, is a prerequisite for integrating loci as standard objects in DG environments. Thus, the approach attracted the attention of developers, being this approach behind the LocusEquation command in the current version of GeoGebra.33See http://wiki.geogebra.org/en/LocusEquation_Command.Furthermore, it has also been implemented by the DG system JSXGraph using remote computations on a server  [31], an idea previously developed in  [32].As described in Section  2, many dynamic geometry constructions in the plane can be viewed as polynomial systems on the variables corresponding to the symbolic coordinates of the objects in the construction. While in standard dynamic geometry loci always involve a mover point, our approach subsumes these loci into a more general setting. In this way, simple loci as the circle defined through a point and a radius, or loci where there is not a mover bound to a linear object (see Section  5.4), can be efficiently found.We start by distinguishing the variables corresponding to the coordinates of the tracerT(x,y)from the rest of variables, sayx1,…,xn, corresponding to the remaining points and objects in the construction; in particular the coordinates of the mover if they are explicitly specified. Note that the consideration of a mover point comes from the constructive strategy followed in most DG environments when considering loci. However, in a constraint-based geometric system, no mover point is involved when searching for a locus, since more than one point can be generally used to drag the construction. Thus, although for the sake of clarity we talk about mover points when describing the examples, the reader should be aware that no algebraic preeminence is given to any point other than the locus point.The translation of the geometrical constraints defining the construction results in a systemFof polynomial equations in the variablesx1,…,xnwith coefficients given by polynomials in the parametersx,y.Our approach consist of detecting for which values of the parameters(x,y)(tracer) there exist solutions of the systemF. The set of equations is defined over a computable fieldK, that we always take to beQ, whereas the values of the variables (and parameters) must be considered over an algebraically closed extensionK¯ofK, that we take to beC. Our approach involves the comparison of dimensions of different algebraic varieties. Since the dimensions of complex and real varieties are in general different, we have opted to work in the complex framework, as customary in the field (see, for instance,  [15,21]).Let us point out that the algebraic study of loci that we are developing in dimension 2 for classical reasons, can be generalized in theory to higher dimensions. In fact Gröbner covers are not constrained to work only in the 2D case. Here, we focus on 2-dimensional loci since 3D DG environments are not yet quite developed. Furthermore, there are specific issues concerning the application of the theory of parametric polynomial systems to 3D DG. Thus, we delay such a study to a future communication.Before giving our definition of locus, let us state some basic concepts about locally closed sets and constructible sets.A locally closed setLis a difference of algebraic varietiesL=V(E)∖V(N). As explained in  [33], for a locally closed set, a canonicalP-representation expressed in terms of prime ideals can be obtained:Prep(L)={{pi,pij:1≤j≤ri,r}:1≤i≤r}so thatL=⋃i=1r(V(pi)∖(⋃j=1riV(pij))).As illustrative examples one can consider the following simple locally closed sets:S1=V(x)∖V(y(y−1))Prep(S1)=V(x)∖(V(x,y)∪V(x,y−1))p1=〈x〉,p11=〈x,y〉,p12=〈x,y−1〉S2=V(xy)V(x+y−1)Prep(S2)=(V(x)V(x,y−1))∪(V(y)∖V(x−1,y))p1=〈x〉,p11=〈x,y−1〉,p2=〈y〉,p21=〈x−1,y〉.Each elementV(pi)∖(⋃j=1riV(pij))is called a component ofLand is represented by{pi,{pij:1≤j≤ri}}, that, by abuse of terminology, is also denoted component whenever there is no ambiguity. In the canonical representation, the irreducible varieties are expressed in terms of prime ideals on account of the well known one-to-one correspondence between irreducible varieties and prime ideals. Given a component as above, the varietyV(pi)(or its representativepi) is called the top of the component. Similarly, the varietiesV(pij)(or their representativespij) are called the holes. In particular, the dimension of each hole variety is smaller than the dimension of its corresponding top variety.A constructible set is a union of locally closed sets. In general, a union of locally closed sets is not locally closed, but we can also give a canonical description in terms of disjoint embedded locally closed subsets and represent them canonically inP-representations. Furthermore, we consider another representation for constructible sets, theC-representation, defined as follows.Proposition 3.1C-Representation of Constructible SetsLetS⊂K¯mbe a constructible set. There exist uniquely determined radical ideals((a(ℓ),b(ℓ)):1≤ℓ≤s), such that•a(1)⊂b(1)⊂a(2)⊂b(2)⊂⋯⊂a(s)⊂b(s)S(ℓ)=V(a(ℓ))∖V(b(ℓ)),S(ℓ)¯=V(a(ℓ))whereS(ℓ)¯is the Zariski closure ofS(ℓ)S(ℓ)¯∖S(ℓ)=V(b(ℓ))S=⋃ℓS(ℓ)is a disjoint union of embedded locally closed sets,dim(a(1))>dim(b(1))>⋯>dim(a(s))>dim(b(s)).The canonicalC-representation of a constructible set expresses the set as a hierarchical and disjoint union of locally closed subsets given inC-representation.ProofLetS¯be the closure ofS.a(1)can be described canonically byS¯=V(a(1)). IfSis locally closed, then the complement ofSw.r.t.S¯will be closed, and in that casebcan be canonically defined byV(b)=S¯∖S⊂S¯and soS=V(a(1))∖V(b). IfS¯∖Sis not closed, thenb(1)can be defined by the closureV(b1)=S¯∖S¯so thatV(b(1))⊂S¯=V(a(1)), and denoteS(1)=V(a(1))∖V(b(1)). We haveS(1)=V(a(1))∖V(b(1))=S¯∖(S¯∖S)¯⊆S¯∖(S¯∖S)=SandS∖S(1)=S∖(S¯∖V(b(1)))⊆S∖(S∖V(b(1)))=V(b(1)).ThusS(1)⊆Sand its complementS∖S1w.r.t.Sis again constructible and included inV(b(1)). ParticularlyV(a(2))=S∖S1¯andV(a(2))⊆V(b(1)). The process can be continued untilS(s+1)becomes empty.To prove the strict inclusionsa(1)⊂b(1)⊂a(2)⊂b(2)⊂⋯⊂a(s)⊂b(s),we have to consider the prime decomposition of the radical idealsa(1),b(1),a(2),b(2),…,a(s),b(s),and observe that, by construction, no prime ideal in the decomposition of one of those ideals can be equal to a prime ideal in the decomposition of the next radical ideal in the chain, as we have always consider closures and complements. From this result, as the dimension of an irreducible variety containing another irreducible variety is strictly higher than the latter, the result of the descending dimensions of the chain follows.□Note 3.2Because of the strict decreasing dimension of the hierarchical description, a constructible set of dimension 1 is not only constructible, but is also locally closed.We can proceed now with the definition of a locus. As stated above, a locus in DG is translated into a set of parametric polynomial equationsF⊆Q[u,x]whereu=(x,y)are the parameters (representing the tracer) andx=(x1,…,xn)the variables. Consider its solutions:V(F)={(u,x)∈C2+n:∀f∈F,f(u,x)=0}.Denote byπ1andπ2the projections onto the parameter and variable space, respectively:π1:C2+n⟶C2XXXXπ2:C2+n⟶Cn(u,x)↦u(u,x)↦x.We can now introduce a generic formal definition of a locus in algebraic terms.Definition 3.3The generic locusLassociated to the parametric polynomial systemF(u,x), is the setL=π1(V(F))⊂C2.Roughly speaking, the locus is the set of points(x,y)satisfying the polynomials inF. Looking atFas a parametric polynomial system, we will discuss this system attending to the number, finite or infinite, of solutions ofx1,…,xnin terms of parametersx,y. As a first step in the classification process at the base of our taxonomy, we split the complex locusL=π1(V(F))into two disjoint subsets, regarding the dimension of the solution set for the variables corresponding to a specific value of the parameters: the normal locus and the non-normal locus. This distinction comes from the fact that a point in a DG locus is usually produced by a finite set of values of the variables.Definition 3.4Normal and Non-Normal LocusNormal points are those pointsu∈C2of the locus for whichdim(π2(V(F)∩π1−1(u)))=0. The pointsuof the locus for whichdim(π2(V(F)∩π1−1(u)))>0are called non-normal. The set of all normal points is called the normal locus and the set of all non-normal points is called the non-normal locus.Proposition 3.5The normal and non-normal loci are constructible sets.ProofBy Chevalley’s theorem  [34, IV.13.1.3 and IV.13.1.5], we know that the set{u∈C2:dim(V(F)∩π1−1(u))<d}is open (in the Zariski topology) for anyd∈N. In particular, ford=1, we obtain that the normal locus is constructible.For an arbitrary dimensiondwe have that{u∈C2:dim(V(F)∩π1−1(u))=d}is equal to{u∈C2:dim(V(F)∩π1−1(u))<d+1}minus{u∈C2:dim(V(F)∩π1−1(u))<d},which is the difference of two open sets, and hence constructible. This implies that the non-normal locus is a union of constructible sets and hence constructible.□Proposition 3.5 allows us to further subdivide the locus set by considering the components associated to the canonical representations of the normal and non-normal locus as constructible sets. Informally speaking, a part of the locus is distinguished if it violates the one-to-one correspondence between the locus points and the corresponding set of variable values.Definition 3.6Normal and Special ComponentsA componentCsof the normal locus is special ifdim(Cs)>0anddim(π2(V(F)∩π1−1(Cs)))=0. The remaining components of the normal locus are normal.Definition 3.7Degenerate and Accumulation ComponentsThe componentsCdof the non-normal locus of dimension greater than 0 are considered degenerate components, whereas the zero-dimensional components are accumulation points of the locus.The geometric relevance of this algebraic classification of the different parts of a locus is open to interpretation by the user. Dynamic Geometry systems could present the collection of different parts (with the corresponding typology) of the computed locus, so the user would decide which pieces to discard or to keep as pertinent in a particular context.Based on our experience (see Section  5), we will discard the degenerate components as geometrically irrelevant, as they usually correspond to degenerate instances of a construction, such as two coincident vertices in a triangle. However, we consider the accumulation points as forming part of the (geometric) locus, since they represent special points that are determined by infinitely many values of the variables. Examples of both phenomena can be found in the battery of examples included in the web prototype described in Section  4.2 ([35], Locus 7 and Locus 12 respectively).Finally, let us point out that the relevance of our proposal for a taxonomy is that, in the many instances we have worked with so far, we have never had to split one component (in the sense of Definitions 3.6 or 3.7) in order to keep a part of that component as relevant and to throw away the other part as inadequate for the locus computation.In this section we address the following problem: how to effectively and efficiently compute the different components of a locus, according to Definitions 3.6 and 3.7 above. Here we propose the use of the recently developed GröbnerCover algorithm to automatically detect the different components of a locus in a DG system. This algorithm, inscribed in the theory of parametric polynomial systems solving, has as input a finite set of parametric polynomials, and outputs a finite partition of the parameter space into locally closed subsets together with polynomial data, from which the reduced Gröbner basis for a given parameter point can be directly determined.What follows is a summary of the main properties of this algorithm, whose details can be found in  [33].LetI⊂Q[u][x]be a polynomial ideal for the parametersu=u1,…,umand the variablesx=x1,…,xnand considerV(I), the solution set of the system given byI:V(I)={(u,x)∈Cm+n:∀f∈I,f(u,x)=0}.Given the idealI⊂Q[u][x](and a monomial order in the variables), its Gröbner cover (GC) is a set of pairs{(Si,Bi):1≤i≤s}of (segment, basis), that classifies the parameter spaceCmby the kind of solutions in the variables:1.The segmentsSi⊂Cmare disjoint.The segmentsSiare locally closed subsets of the parameter spaceCm, expressed in the canonicalP-representation, namelySi=⋃j(V(pij)∖(⋃kV(pijk))),and(pij,(pijk:1≤k≤sij))is called thejth component of theith GC-segment.Associated to each segmentSithere is a basisBi⊂Q[u][x]that specializes to the reduced Gröbner basis ofIfor every pointu∈Siof the segment.The kind of solution in the variables is given by the set of leading power products (lpp’s) of the basesBi, that are fixed for each GC segmentSi(and is also explicitly given by the algorithm). Thus, for all points in the segment, the idealIhas the same number of solutions.Moreover, if the idealIis homogeneous, then thelpp’s sets are different on each segment. (Thelpp’s of the homogenized ideal are also explicitly given by the algorithm for each segmentSias they characterize the segments.)Based on the output of the GröbnerCover algorithm applied to the systemFassociated to a DG locus, the Locus algorithm in Table 1computes and classifies the locus components.Definitions 3.4, 3.6 and 3.7 allow us to assign to each segment of the Gröbner cover a first locus taxonomy, regarding simply the set of leading power products of the bases (lpp). We obtain segments of three types:Type 1Segments with basis{1}do not belong to the locus. In particular, the generic segment, which is the unique open segment inC2(having thus dimension 2) is expected to have basis{1}, so the locus components are expected to have dimension less or equal to 1.Segments with a finite number of solutions correspond to the normal locus.Segments with an infinite number of solutions correspond to the non-normal locus.Inside the normal locus segments of type 2, specializing the basis over each component allows us to refine the locus taxonomy. If the specialized basis does not depend on the parametersu, then the component is labeled ‘Special’. Otherwise it is labeled ‘Normal’.The non-normal locus segments of type 3 need not be previously classified.To obtain the components of the constructible locus sets, the Locus algorithm has to collect now separately the components of both kinds of locus: the components of the normal segments of type 2 and of the non-normal segments of type 3. For this purpose, it uses the LCUnion algorithm (see  [33]) which is designed to compute the canonicalP-representation of the addition of locally closed components given inP-representation. LCUnion takes the components to be added and outputs the canonicalP-representation of the first level of the resulting constructible set, and it also returns the components that have not been used because they belong to higher levels of the constructible set. To build the whole constructible set one has to iterate LCUnion with the remaining components. In fact, by Note 3.2, the additions to be done are locally closed, and so it suffices to use LCUnion only once.For the normal locus, since the top varieties of the union are also tops of some component of the components of type 2 that are added, the label ‘Normal’ or ‘Special’ is inherited from the tops in LCUnion.For the non-normal locus, it suffices to add the components of type 3 using LCUnion, and then label the resulting components as ‘Accumulation’ if the resulting component of the constructible set has a finite number of points, and ‘Degenerate’ if it contains infinitely many points.The normal and the non-normal loci are disjoint, since a point in the parameter space cannot be normal and non-normal, and the GröbnerCover algorithm forms these subsets by adding segments that are disjoint. But the components inside the normal locus can have non-empty intersection and in that case the intersection points will belong to both components.However, ‘Accumulation’ and ‘Degenerate’ components of the non-normal locus are disjoint, since ‘Accumulation’ points must be isolated points not adherent to any higher dimensional component, for in that case it would be incorporated to the higher dimensional component when considering the union.The Locus algorithm detailed in the previous section provides four different kinds of components for a locus set, namely, normal, special, degenerate and accumulation components. Although all of them are algebraically meaningful, only the normal and accumulation components of a locus have been considered true geometric parts of a dynamic geometry locus.Following this criterion, a prototype web application that provides the accurate algebraic and graphic description of a geometric locus in a DG system has been developed. This prototype, freely accessible in  [35] (where the code is moreover available), includes a battery of 12 representative examples.The system consists of a drawing canvas, where the computed locus is displayed together with the initial elements. It is based on the free DG system GeoGebra44http://www.geogebra.org.and the open source CAS Sage.55http://www.sagemath.org.More concretely, to obtain the algebraic description of a given locus, the algebraic knowledge obtained from a construction introduced through a GeoGebra applet is automatically encoded and sent to a Sage server, where it is remotely processed by Singular  [36], a system bundled inside the Sage distribution.Despite the technicalities of the remote interconnection of GeoGebra and Sage, the web application is presented as a simple web page with a GeoGebra applet, where to construct/upload a locus. Given a locus construction (specified using a predetermined set of GeoGebra commands), the prototype provides the algebraic description of the locus set by just pressing one button. The process goes roughly as follows.Despite the technicalities of the remote interconnection of GeoGebra and Sage, the web application is presented as a simple web page with a GeoGebra applet, where to construct/upload a locus. Currently, there is a reduced list of admissible GeoGebra commands involving points (Point, Midpoint), lines (Line, PerpendicularLine) and circles (Circle), together with intersecting objects (Intersect) and the standard Locus command (see the prototype web page, where links to the exact meaning of used commands are given). For a locus construction, the prototype provides the algebraic description of the locus set by just pressing one button. The process goes roughly as follows.First, the XML description of the GeoGebra construction is sent to a Sage cell server  [37]. On the server, the construction follows an algebraization process as specified by a special library  [38]. The obtained parametric polynomial system is then fed into an implementation in Singular of the GröbnerCover algorithm. The results are finally returned to the user in text form as well as graphically in the applet.A screen capture of the web page with an accurate description of the limaçon of Pascal discussed in Section  2.2 is shown in Fig. 2. It provides its graph (thick dotted) together with its description as an algebraic set. Note that no extra special component is included in the description, unlike the description provided by standard algebraic methods, as discussed in Section  2.2.Although only the normal and accumulation components of a locus, as provided by the algorithm, are used by the system when describing the locus, all four sets of components are provided when pressing the Show components (from GC algorithm) button. The following is the textual information provided by the prototype, showing the different components for the limaçon of Pascal, where the extra circle mentioned in Section  2.2 is identified as special.Note that the goal is not to provide a system for a complete general use, but to show a proof of concept of the feasibility of using sophisticated algorithms like the GröbnerCover to supplement the symbolic capabilities of existing dynamic geometry systems, as well as to show the advantage of connecting different systems by using web services.We consider the original locus example by Sutherland in   [7, p. 102]66Available at http://www.cl.cam.ac.uk/techreports/.that can be described as follows:LetA(xa,ya),B(xb,yb)andC(xc,yc)be three fixed points, andaandbtwo lines passing respectively throughAandB. Letcbe the circle with centerCand radiusr. Consider a pointGon the circlecas the mover point. The lineCGintersectsain a pointIandbin a pointH. We take as tracer the intersection pointJof linesAHandBI(see Fig. 3).We revisit this example through a simple Gröbner based elimination approach, as well as through our proposed method.Assigning symbolic coordinates toH(x1,y1),I(x2,y2),G(x3,y3),J(x,y), and considering that the equations of linesaandbcan be written asm(X−xa)−(Y−ya)=0andn(X−xb)−(Y−yb)=0respectively, it is easy to establish the polynomials for the construction:(1)F=(x3−xc)2+(y3−yc)2−r2,m(x2−xa)−(y2−ya),n(x1−xb)−(y1−yb),|x1y11x3y31xcyc1|,|x2y21x3y31xcyc1|,|xy1xaya1x1y11|,|xy1xbyb1x2y21|.In order to minimize the number of parameters, we fix pointsA(0,0),B(3,0), and the radiusr=5.To determine the locus, we use basic elimination first. Computing the Gröbner basis of the idealF(xa=0,ya=0,xb=3,yb=0,r=5)of formula (1) to eliminate the variablesx1,y1,x2,y2,x3,y3(with the graded reverse lexicographical ordergrevlex(x1,y1,x2,y2,x3,y3),grevlex(xc,yc,n,m,x,y)) we obtain(2)mnycx2+((m+n)xc−yc−3n)y2+(mn(3−2xc))xy−3mnycx+3mnxcythat gives a parametric locus depending on the parameters(xc,yc,m,n).Let us now compute the locus using our algorithm. We must manually fix pointCand the parametersm,nto have a concrete locus problem, as the algorithm does not efficiently deals with free parameters in its current version. We chooseC(1,3),m=1andn=−1/2.The specialized system is now:(3)F0=(x3−1)2+(y3−3)2−25,x2−y2,x1−3+2y1,x1y3−3x1+3x3−x3y1+y1−y3,x2y3−3x2+3x3−x3y2+y2−y3,−xy1+x1y,−xy2+3y2−3y+x2y.In Singular we call:>LIB "grobcov.lib"77Library available at http://www-ma2.upc.edu/montes/.;ring R=(0,x,y),(x1,y1,x2,y2,x3,y3),dp;ideal F0= ---;locusdg(grobcov(F0));Once the locus equation is known, it is trivial to check that the conic is tangent to linesACandBC, a statement mentioned by Sutherland in  [7].This locus is Example 10 in our prototype  [35]. By clicking the Find locus button, we obtain the picture of Fig. 3, where the description of the locus as a conic with two missing (real) points is provided.It is instructive to analyze where the missing points come from. Dragging the mover pointGto make lineCGparallel to linea, makes lineBIchange, approaching a limit position parallel toCGanda. ThusBIandado not intersect,Igoes to infinity, and the system has no solution. This happens for the missing point(1/2,−5/2). Things are analogous for the missing point(7/2,−7/4).Although in this paper we focus on locus computation, our approach can be efficiently used for computing other derived elements in a geometric construction, as it will be reported in a future note. Consider, for instance, the 1-offset of a circlegcentered at the origin with radius 1. The offset is described by the system consisting of the equations of the base circle, the familyfof circles enveloping the offset, and the expression∂f∂a∂g∂b−∂f∂b∂g∂a:(4)F=a2+b2−1,(x−a)2+(y−b)2−1,4(y−b)a−4(x−a)b.Applying the GröbnerCover algorithm to the idealJ=〈a2+b2−1,(x−a)2+(y−b)2−1,4(y−b)a−4(x−a)b〉,we obtain the following three segments:Nr.SegmentBasislpp1C2∖(V(x2+y2−4)∪V(y,x)){1}{1}2V(x2+y2−4){2b−y,2a−x}{b,a}3V(y,x){a2+b2−1}{a2}The Locus algorithm produces two disjoint components with different character:V(x2+y2−4)NormalV(y,x)∖V(1)Accumulation .The normal component is the circle of radius 2, as expected. For the accumulation point(0,0)we haveπ2(π1−1(0,0))=V(a2+b2−1)and the whole basic circle is part of the solution (a 1-dimensional set of points).When illustrating the prototype (Fig. 2) we considered the limaçon of Pascal, showing that the extra circlex2+y2−6x−8y+24=0comes from a degeneration due to the coincidence of pointsMandB. It can happen that a degeneracy of the construction forces the GröbnerCover algorithm to consider the whole space of parameters as solution. More concretely, the first segment of the GröbnerCover algorithm is called the generic segment. It is the unique open segment in the whole parameter space, i.e. it consists of the whole parameter space except a variety (of dimension less than the one of the parameter space itself).We assumed in the definition of the locus, that the generic segment has basis{1}, i.e. there is no solution of the system on it, as the locus is expected to be of dimension less than the parameter space. Nevertheless, as mentioned above, it could happen that a construction collapses for some values of the variables. For these values, the number of constraints decreases and almost all points are valid parameter values for the system having a solution.As an example, consider the following locus construction (see Fig. 4). The pointM(y1,y2)runs over the circle with center atO(3,1)and radiusOA, whereA=(3,4). We construct the line parallel to the lineAMpassing throughOand the line perpendicular to it passing through the pointB=(3,−2). Both lines intersect at pointP(x1,x2). Construct the lineAPand the circle with centerMand radiusMP. We define this intersection as the tracer point(s):T(x,y).The polynomial system describing the problem is the idealFgiven by(5)F=〈(y1−3)2+(y2−1)2−9,(4−y2)(x1−3)+(y1−3)(x2−1),(y1−3)(x1−3)−(4−y2)(x2+2),(4−x2)x+(x1−3)y+3x2−4x1,(x−y1)2+(y−y2)2−(y1−x1)2−(y2−x2)2〉.WhenMcoincides withA(i.e.y1=3,y2=4), the above system reduces to(6)F=〈(3−3)2+(4−1)2−9,(4−4)(x1−3)+(3−3)(x2−1),(3−3)(x1−3)−(4−4)(x2+2),(4−x2)x+(x1−3)y+3x2−4x1,(x−3)2+(y−4)2−(3−x1)2−(4−x2)2〉.Thus, every point in the plane satisfies it. Note that since the lineAMis undefined, there are no constraints onT, which can be then placed anywhere in the plane. Since we are computing loci at most linear, the generic segment can be discarded without losing solutions. This is the approach currently used in the prototype.Finally, the result consists of two irreducible normal componentsV(x2−6x+y2+y+7)V(x4−12x3+2x2y2−13x2y+236x2−12xy2+78xy−1200x+y4−13y3+60y2−85y+1495).This locus is Example 9 in our prototype  [35]. By clicking the Find locus button, we obtain the locus description shown on Fig. 5.In the previous locus examples, the mover point is constrained to a one dimensional object, so to sample its path, the user/system has to perform a bound dragging, as defined in  [6]. There, Arzarello et al. introduce other types of dragging in order to analyze different kinds of student interactions with dynamic constructions. The process of searching for plausible geometric conjectures is often closely related to dragging manipulations. One of these dragging modalities, the dummy locus dragging, is defined as…moving a basic point so that the drawing keeps a discovered property; the point which is moved follows a path, even if the users do not realize this: the locus is not visible and does not ‘speak’ to the students, who do not always realize that they are dragging along a locus.We show a non trivial illustration of this kind of locus: we use our locus algorithm to prove the classic Steiner–Lehmus theorem that establishes necessary and sufficient conditions for a triangle to have two equal-length bisectors (we refer the reader to  [39] for details, where a detailed study of the theorem in relation to the GröbnerCover algorithm is discussed).More concretely, let us consider the locus set of pointsCfor which the theorem is true; that is, given a triangleABC, we search for the pointsCfor which one bisector at angleAis equal to one bisector at angleB(internal or external bisectors, see Fig. 6).Setting pointsAandBas origin and unit respectively, and assigning coordinatesC(x,y),M(x1,y1),T(x2,y2),P(p,0),R(r,0), the construction leads to the following polynomial system:{x2+y2−p2,yx1−(x+p)y1,y(1−x1)+(x−1)y1,(x−1)2+y2−(r−1)2,y(1−x2)+(x+r−2)y2,xy2−yx2,x12+y12=(x2−1)2+y22.The GröbnerCover algorithm applied to this system provides 9 segments, each of them having specific properties concerning the number of solutions, and the Locus algorithm group them into components. From the locus perspective we are only interested in the normal and accumulation solutions. Applying the Locus algorithm to the grobcov output, we obtain two normal components and a degenerate one. In the description, the following curve appears:C1=V(8x10−40x9+41x8y2+76x8−164x7y2−64x7+84x6y4+246x6y2+16x6−252x5y4−164x5y2+8x5+86x4y6+278x4y4+31x4y2−4x4−172x3y6−136x3y4+20x3y2+44x2y8+122x2y6+14x2y4−10x2y2−44xy8−36xy6+12xy4+9y10+14y8−y6−6y4+y2).The components, with their character, are:C1∖(V(y,x)∪V(y,x−1)∪V(y,2x2−2x−1))NormalV(2x−1)∖V(y,2x−1)NormalV(y)Degenerate .In  [39], the whole GröbnerCover algorithm output is analyzed, using the sign of the variablespandqon the solutions, and a detailed study of which parts of the curves and special points correspond to which equalities between bisectors ofAandB. In particular, the second component corresponds to the classical Steiner–Lehmus theorem, well known since the XIX century, where the inner bisector ofAis equal to the inner bisector ofB. The fact that the outer bisectors are also equal over this component is a new result obtained as a side product.It is worth remarking that the first component has only been known since the development of computer algebra methods. The third component, as well as the holes of the two normal components, correspond to degenerate triangles. Fig. 7shows all three locus components.Using our approach, this kind of “dummy” locus computation in DG systems could be easily automated, thereby allowing students to tackle general what if questions.

@&#CONCLUSIONS@&#
