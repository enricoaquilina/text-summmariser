@&#MAIN-TITLE@&#
Ann: A domain-specific language for the effective design and validation of Java annotations

@&#HIGHLIGHTS@&#
Ann is a domain-specific language for the design of dependent Java annotation types.It allows to design explicitly the constraints in the conceptual model behind them.The consistency validation of the constraints is performed using model finding.Automatic code generation enables validation of the annotations at compile time.Ann was tested in a real use-case of JPA annotations, obtaining successful results.

@&#KEYPHRASES@&#
Model driven engineering,Domain-specific languages,Code generation,Java annotations,Model finders,

@&#ABSTRACT@&#
This paper describes a new modelling language for the effective design and validation of Java annotations. Since their inclusion in the 5th edition of Java, annotations have grown from a useful tool for the addition of meta-data to play a central role in many popular software projects. Usually they are not conceived in isolation, but in groups, with dependency and integrity constraints between them. However, the native support provided by Java for expressing this design is very limited.To overcome its deficiencies and make explicit the rich conceptual model which lies behind a set of annotations, we propose a domain-specific modelling language. The proposal has been implemented as an Eclipse plug-in, including an editor and an integrated code generator that synthesises annotation processors. The environment also integrates a model finder, able to detect unsatisfiable constraints between different annotations, and to provide examples of correct annotation usages for validation. The language has been tested using a real set of annotations from the Java Persistence API (JPA). Within this subset we have found enough rich semantics expressible with Ann and omitted nowadays by the Java language, which shows the benefits of Ann in a relevant field of application.

@&#INTRODUCTION@&#
In 2004 the possibility of adding custom meta-data to programs was added to the Java language in the form of annotations.11http://docs.oracle.com/javase/1.5.0/docs/guide/language/annotations.htmlPredefined annotations were available previously for very specific tasks, however, the huge amount of boilerplate code that many Application Programming Interfaces (APIs) required motivated their establishment as another general tool in the language. Schildt [33] suggests other reasons as motivation to the appearance of annotations in Java: the increasingly growing tendency of including the meta-data associated with a program within the program itself instead of keeping it in separate files; and the pressure from other programming languages which already included similar features, like C#.Since their introduction in the language, annotations have become a success and are widely used in many important projects within the software development scene. We find them in frameworks like Seam22http://docs.jboss.org/seam/latest/reference/html/annotations.htmland Spring,33http://spring.io/in the Object Relation Mapping of Hibernate,44http://hibernate.org/orm/and also in proper Sun Java standards such as the Java Persistence API (JPA).55http://www.oracle.com/technetwork/java/javaee/tech/persistence-jsp-140049.htmlHowever, despite this success, the native support that Java provides for their construction is very poor. This is so as Java annotations are not defined using a specialised syntax, but reusing the syntax to create interfaces. This lack of specialised syntax greatly limits the ability to specify the elements where an annotation can be placed and further correctness conditions. Moreover, annotations are rarely conceived in an isolated way; instead they are usually part of a set with dependencies and integrity constraints. Currently there is no effective way in Java for making explicit the constraints underlying a set of annotations at design time, and validate that they are not conflicting. Instead, the usual path taken to overcome these deficiencies is to develop an extension to the Java compiler (called annotation processor) to ensure that such constraints are complied with, and rely on extensive manual testing of such processor.As a first step towards the alleviation of this situation, we propose Ann, a textual Domain-Specific Language (DSL) [36] aiming to provide a more expressive and suitable syntactic support for the design of sets of annotations and their associated integrity constraints. We have developed an Integrated Development Environment (IDE) as an Eclipse plug-in, which integrates seamlessly with the Java IDE. The environment includes a code generator to translate the design and constraints expressed using Ann into Java code, which can be fully integrated into projects in such language. Moreover, Ann makes use of a constraint solver over models (a model finder [25]), which is able to detect whether the constraints posed by a set of annotations are unsatisfiable, and provide examples (annotated class mock-ups) of usages of the annotations. These examples could be used by designers to validate whether the encoded integrity constraints defined with Ann are according to their intentions. Ann has been tested using a real set of annotations from JPA, demonstrating that it can capture a wide set of the constraints in its specification, and showing advantages with respect to other approaches with similar goals in the state of the art. More information and the source code of the project can be found at http://irenecordoba.github.io/Ann.This paper is an extended version of [6,7], where we have added validation mechanisms based on constraint solving, and integrated such mechanisms with the environment. Additionally, all sections have been enlarged with additional explanations and more details.The rest of the paper is organised as follows. Section 2 analyses related work. Section 3 gives a more detailed overview on the current limitations of Java annotations. Section 4 introduces the main concepts of Model-Driven Engineering (MDE) and the different choices when building a DSL. Section 5 provides an overview of our approach. Section 6 describes the proposed DSL, Ann. Section 7 explains our approach to validate annotations. Section 8 contains the evaluation of Ann, including a detailed real case study and an evaluation of the efficiency of the model finder for annotation validation. Finally, Section 9 summarises the conclusions and future development. Two appendices detail the description of the textual concrete syntax of Ann, and the generated OCL invariants for the JPA case study.Some research has been made in order to improve and expand the functionality of Java annotations. For example, Phillips in [28] aims at conciliating object oriented principles with the design of annotations by the introduction of a new one: composite. With it, he manages to support composition, allowing encapsulation and polymorphism of annotations.A Java extension, @Java, is proposed by Cazzola and Vacchi [4] in order to expand the range of application of an annotation to code blocks and expressions, although some improvement in this respect has also been made natively in the latest version of Java.66Java 8 at the time of writing.The expressiveness limitations of Java annotations are recognised in [5], where a proposal is made to embed DSLs into Java, with a more natural and flexible syntax. JUMP [1] is a tool to reverse engineer Java programs (with annotations) into profiled UML class diagrams.Although the aforementioned approaches expand the features of Java annotations, they do not facilitate their design, nor address the limitations with respect to expressing integrity constraints within an annotation or between the annotations in an annotation set, which is the main goal of our work.Just a few works are aimed at improving the design of annotations. Darwin [11] suggests a DSL, called AnnaBot, based on claims about a set of existing annotations, with a concrete syntax very similar to Java. With these claims, interdependency constraints can be expressed within a set of annotations. However, there is no possibility of characterising the valid targets of an annotation type (i.e., the valid elements in a program where the annotation can be placed). Moreover, no improvement is made with respect to the syntax for defining annotations in Java, given its heavy focus on existing sets of annotations and constraints between them, and not on isolated ones. Finally, the approach uses reflection to check the statements of its claims, which could and should be avoided.Another approach is AVal [27], a set of meta-annotations (annotations which are placed at other annotations) to add integrity constraints at the definition of the annotation type. The drawback of this approach is that its expressiveness is rather restricted, given the limited flexibility which the structural characteristics of meta-annotations provide.Pluggable type systems [2] provide a way to support improved analysis of programs by ensuring stronger type checking. Implementation of these systems exist for Java, like the JavaCOP framework [26]. Java 8 improves the support for such systems via type annotations. Pluggable type systems provide a customised semantics to sets of programming elements via the use of annotation sets. However, they normally do not provide a unified way to describe and validate the syntax and integrity constraints of a set of annotations.Regarding constraint validation, constraint solving strategies are extensively used in connection with program testing [13]. Many times, constraint solving is used as a means to generate interesting test data for programs, perhaps derived from specifications [19], or making the program execute a certain path [8]. In [21] constraint solving is used to generate both test cases and mock-up classes, considering advanced features like reflection and annotations. Hence, while they can generate mock-up programs with annotations, they need to derive the needed constraints from the analysis of reflective Java code (i.e., at runtime), with the consequent loss of precision and drawbacks of runtime checking. Instead, for our purposes, it would be more desirable to have a language making explicit the annotation constraints at design time, which then can be analysed before such annotations are used.Hence, as we have observed, there is currently a need for: (i) better syntactical support for the specification of Java annotations; (ii) explicit, high-level means to describe constraints for an annotation (e.g., regarding its valid targets), and between a set of annotations (e.g., expressing their dependencies); and (iii) ways to analyse such constraints to find inconsistencies, at design time. For this purpose, in the rest of the paper, we describe Ann, a DSL directed to describe both the syntax and well-formedness constraints of annotation families, to validate the correctness of the annotation constraints and to make explicit the design of such annotation set, allowing their immediate use on Java projects thanks to the code generation facility.To help understanding the current limitations of Java annotations, in this section we describe how they are defined in Java (Section 3.1), their usage and limitations (Section 3.2) and how their correct use is checked (Section 3.3).Java annotations do not constitute a type of their own. Instead, they are defined as special interfaces. There are many differences between annotations and interfaces, however we will only review those necessary to understand the design of Ann.Listing 1 shows an example of the definition and usage of a simple annotation called Person. Such annotation definition is called an annotation type. As it can be noticed, the special nature of annotations is indicated by the @ character before the interface keyword (line 7). The zero-argument methods inside the container (lines 7–9) are the fields (the parameters) of the annotation. To assign a default value to those fields, the keyword default must be used. An annotation can have an arbitrary number of fields, which can be of primitive type, Class, String, an annotation type, or an array of the previous types.Listing 1Annotation Person defined in Java.Since the goal of annotations is to add meta-data to Java programs by being placed at certain elements, it is important to know which elements are eligible as their targets. Annotations can be employed in the declaration of many constructions in Java; however with Ann we have focused on the most usual ones, namely types (classes, interfaces, enumerates, annotations), constructors, methods and fields.77Ann was started before the official release of Java 8, and hence some of its feature regarding annotations, like the possibility of defining type uses as targets is not currently supported, but left for future work.Another important characteristic of annotations is that they can have three different levels of retention, which depends on the phase where they will be used: in the source code (they are discarded by the compiler); compiled but ignored by the Java Virtual Machine (JVM); and compiled and read by the JVM when the type that contains them is loaded. The last ones are accessible by the Java Reflection API at runtime, which can check the values in their fields.Both the targets allowed for an annotation and its desired level of retention can be specified at design time by using the standard Java meta-annotations Target and Retention, respectively. As we will see in the next subsection, the former is very poor regarding its expressive power with respect to real and common use cases where annotations are used.Listing 2 shows the use of the defined Person annotation. Annotations are considered as modifiers when using them on a target in Java. This is why, although in Listing 2, line 3, annotation Person appears above the class, it could perfectly be merged with the rest of the modifiers, but the former is the usual syntax.Listing 2Usage of the annotation Person.Pairs key=value are used in order to specify the values of the fields of the annotation. It is mandatory to set a value for all the fields that do not have a default value predefined on the annotation type, and the order of the fields does not matter.Traditionally only one instance of a particular annotation type could annotate a target; however with Java 8 it is possible to use several such instances if the corresponding annotation type is properly marked on its definition.Line 5 of Listing 1 shows another example of an annotation being used: Target. In this case, the value is directly specified because the annotation has only one field and it is named value. By using the value TYPE of the enumeration ElementType, Person is restricted to be applied to classes, interfaces (including annotation types) and enumerations. However, there is no way to e.g., restrict its applicability to classes only.We have presented a very simple example of an annotation type, but if we take a look at the JPA documentation, particularly the extensively used Entity annotation, we find that it can only be applied to classes meeting the following more elaborated requirements88http://docs.oracle.com/javaee/7/api/:•They must have a public or protected constructor.They must not be final.They must not have any final method.Their persistent fields must be declared private, protected or package-private.None of these constraints can be expressed nowadays with the syntax available for the definition of annotation types.What is more, when designing annotation sets, it is common to have constraints involving several annotations, because the annotations are usually inter-related. For example, the JPA annotation Id is only allowed in attributes within classes annotated with Entity. We call such constraints the static semantics or integrity constraints of an annotation, or an annotation set. Given a large and complex set of requirements for an annotation set, it is easy to make mistakes, by requiring conflicting features from the different annotations, specially at design time. Just for the sake of illustration, if we require Id to be applicable on a public attribute, then it would make the Id annotation to be in conflict with Entity (as the latter requires non-public attributes), and hence inapplicable.Therefore, what can be done to ensure the compliance of such outlined constraints and ensure their validity? The only remaining choices are to write a guiding comment for its use and signal an error at runtime. In addition, it is possible to develop extensions to the Java compiler, known as annotation processors, and rely on their extensive manual testing to validate that the annotation requirements are met by their implementation in the processor. In the next subsection we review these annotation processors, since they are one of the key components of Ann.The Java package javax.annotation.processing provides a set of elements for processing annotations at compile time. An annotation processor is invoked by the compiler, and it can check the annotations attached to any program element, performing an arbitrary task. Typically, the processor will check the correctness of the annotation placement (i.e., its static semantics), and may perform further actions (e.g., generating code). Annotation processing works in rounds. In each round a processor may be required to process a subset of the annotations found in the source code and the binary files produced in the prior round. If a processor was executed in a given round, it will be called again in the next rounds.Listing 3 shows the structure of a typical annotation processor. Line 1 specifies the annotation to be checked, Person in this case. The key method of the processor is process (lines 5–23), where the elements annotated with the particular annotation are looked up and checked. If any of them does not satisfy the checks, then an error is raised using the functionality provided by the processing package (lines 15–20).Listing 3Structure of an annotation processor.It is important not to confuse annotation processing with reflection. While the former takes place at compile time, the latter is at execution time. The values of an annotation at a given program element can be checked at execution time via the Java Reflection API (if the annotation type is properly marked, as explained in Section 3.1), but it has several disadvantages, like an overhead in performance, the requirement of runtime permission (which may not be granted), and the possibility of breaking object-oriented abstractions.In the context of checking the correctness of annotations, it is more appropriate to do it via annotation processors, because they can find and signal the errors without the need to execute the program. However, coding and testing such processors is tedious, cumbersome and error prone. It requires long cycles for coding, installing the processor, and testing. Moreover, we believe it would be advantageous to make explicit the underlying annotation constraints at a higher level, together with the annotation structure. In addition, this would facilitate the analysis of annotation conflicts at design time, with no need to install the processor to make those tests. For this purpose, we have created Ann, a DSL to define the structure and integrity constraints of Java annotations, and validate their correctness.For the development of Ann we have followed what is called Model-Driven Engineering (MDE) [3,10], which is characterised by the use of models as the main component of the development process. A model is a simplified or partial representation of reality, defined in order to carry out a specific task or reach an agreement on some matter. A great advantage of MDE is that it fills the communication gap between the requirements and analysis phase and the implementation phase in a software project.Modelling languages are extensively used in MDE, and are conceptual tools to describe reality in an explicit way, at some level of abstraction and from a certain point of view. They are composed and defined by three key elements:•Abstract syntax: It describes the structure of the language and the way in which the different elements can be combined.Concrete syntax: It describes the particular representation of the modelling language, covering features such as the codification or visual appearance, and hence it determines how users visualise or create models. It can be graphical [24,29,32] or textual [36,14].Semantics: It describes the meaning of the language elements and also the meaning of the different ways of combining them.Modelling languages can be classified depending on their domain of application. A Domain-Specific Modelling Language (DSML) is a modelling language designed for a specific domain or context, with the purpose of easing the task of describing the elements in such domain. In contrast, General-Purpose Modelling Language (GPML) can be applied to a much broader context. This distinction is not always easy to draw as it depends on what we consider as a domain (e.g., we could consider the general problem of modelling as a specific domain).Given that models play a key role in MDE, and they constitute an abstraction of the real world, a natural step is to represent them as instances of higher levels of abstraction, i.e., higher levels of models or meta-models. Consequently, using this definition, meta-models describe the set of models considered valid. They define the abstract syntax of a modelling language, since they are a way of describing all the types of models that can be represented with such language. We could iterate this abstraction levels and obtain meta–meta-models and so on. However, in practice, it has been shown that meta–meta-models are enough to describe themselves (see Fig. 1) [3].The two main alternatives for defining the semantics of modelling languages are code generation and model interpretation [20]. They can be thought of as the analogous for compilers and interpreters in the case of programming languages, respectively. A code generator can be thought of as a model compiler that generates executable code from a high level model in order to create a functional application. This generation of code is usually done by using template languages like Acceleo99http://www.eclipse.org/acceleo/or the Epsilon Generation Language [31]. On the other hand, model interpretation is based on implementing a general tool that translates and executes the model on the fly.Fig. 2shows a feature model [23] summarising the possible choices when designing a modelling language. The diagram is not meant to be exhaustive, but to gather the most common and typical choices. In the first place, a language can be designed taking as a basis a GPML, or a general purpose programming language. Using a GPML like the UML, one can design a profile [15], with stereotypes annotating the different UML elements and providing domain-specific concepts. This is the approach taken by JUMP [1]. A DSML can also be embedded in a general purpose programming language (the so-called internal languages). The flexible syntax and dynamic features of languages like Ruby make them especially amenable for this task [9]. Alternatively, one can use a GPML “as is”, but then domain-specific concepts have to be expressed as conventions (e.g., naming conventions), programming idioms, or remain at the level of APIs in the case of general purpose programming languages.The alternative is the definition of a DSML independent of a base GPML. These are called external DSMLs. To define the abstract syntax, a meta-model can be used, as previously explained. While this is the standard choice when using MDE, it is not the only alternative. For example, it is possible to define a (Chomsky) grammar instead (especially if the language has a textual concrete syntax) [36], or a graph-grammar that defines the set of admissible models [16]. Deciding between graphical and textual concrete syntax is not exclusive, and there are languages featuring both [18]. Finally, interpretation and code generation are normally alternative choices. The figure shows in colour the choices made for Ann, whose rationale will be explained in Section 6.Since the goal of Ann is to make explicit the conceptual model behind a set of annotations, using a modelling language is a robust choice, because that is what they are precisely designed for. We have decided to restrict the domain to Java annotations, and that is why we have developed a Domain-Specific Language (DSL).Fig. 3shows the working scheme of our approach to solve the problems outlined in Section 3 by using the DSL. The main idea is to describe the syntax and static semantics of the family of annotations to be built in a declarative way (label 1 in the scheme). The Ann DSL provides appropriate primitives for this task, beyond those natively offered by Java.We have incorporated a model finder in our approach, in order to check conflicts between the integrity constraints of the different annotations. A model finder is a constraint solver over models [25]. This way, its goal is trying to find a model satisfying a number of constraints. In our implementation, we use the USE validator [25] (label 2), a model finder that takes as input a meta-model and a set of invariants expressed in the Object Constraint Language (OCL).1010http://www.omg.org/spec/OCL/As output, it produces a model, a valid instance of the meta-model that satisfies all OCL constraints. In our case, the sought model is a Java program that contains annotations satisfying all the designed integrity constraints. If a model does not exist, then there is some conflict in the annotation set. As the sought models are fragments of Java programs (in the form of models) containing the designed annotations (label 3), we can render them as textual Java programs. These could serve designers as a means for validation, as they can check whether the produced example fulfils their requirements and expectations about the designed constraints. Actually, this approach is very natural to be used in an iterative process, where the model finder is used to check conflicts and generate examples, and the results of the validation are used to re-design the annotation set, if needed.Once the annotation design is satisfactory, the designer can make use of a code generator (label 4) that produces plain Java files with the annotation type definition and the annotation processors for the defined annotation (label 5). Then, the annotations can be safely used (label 6), because their definition does not contain conflicts, and their correct use in Java programs is checked by the generated annotation processors.Altogether, using Ann has several advantages, including: (i) it allows to make explicit the structure and integrity constraints of a set of annotations in a high-level, declarative way; (ii) it provides automatic check of conflicts between constraints at design-time, as well as a generator of annotated example Java programs; and (iii) it automatically produces the annotation processors to check the correct use of annotations.The next section explains the Ann DSL, including its supporting environment, while the details on how to express Ann constraints in OCL and the interaction with the model finder are left to Section 7.Fig. 2 showed the different options when designing a DSML, showing in colour the design choices for Ann.First, Ann has been designed as an external language. We could have opted for a UML profile, which could be a sensible choice, but we preferred a tighter integration with Java programming environment. An internal language within Java was also discarded, as the Java syntax currently does not offer great flexibility for language embedding.Given that one of the goals of Ann is to give a more user-friendly syntax for Java developers defining annotations, mitigating the incoherences that can be found nowadays in the Java language, a textual concrete syntax has been chosen for it. An alternative graphical concrete syntax to facilitate expressing and visualising the integrity constraints within an annotation set could be interesting, but is left for future work. The abstract syntax was designed using a meta-model, which is the standard choice when using MDE.For the semantics of Ann, code generation has been the adopted solution. While an interpreter was also possible, we opted for code generation in order to be able to use the generated annotation processors independently of Ann and its tooling. Moreover, the generated processors would normally be more efficient than processors based on interpretation of Ann models.The next three subsections describe the abstract, concrete syntax and semantics of the Ann DSL.The simplified meta-model that describes the abstract syntax of Ann can be found in Fig. 4.The Annotation meta-class contains both the attributes of an annotation and its associated constraints. Note that an annotation with no constraints is allowed, as in the Java language.Details concerning attributes are shown in Fig. 5. Meta-class ExternalAttr represents attributes declared externally to Ann, including enumerated types and other annotations. We also consider all possible primitive types for attributes, the possibility of default values and arrays.Constraints are split into two types: requirements (class Require in Fig. 4) and prohibitions (class Forbid in Fig. 4). Multiple constraints over the same annotation type have AND semantics. In Fig. 6we can see an expanded section of the meta-model of Fig. 4, in particular the one concerning the constraints.Each statement represents a description of a Java element (like class, interface or field) over which the annotation is (dis-)allowed. Ann supports the characterisation of elements regarding their visibility, and whether they should be final, static or abstract. In order to enhance the expressive power of Ann, several statements are possible within the same constraint (e.g., if the same annotation can be applied to several targets). This is why in the case of requirements multiple statements have OR semantics; whereas AND semantics are applied in the case of prohibitions. Note that AND semantics for requirements would not add any additional expressive power since this is already granted by the multiplicity of Require objects. In the case of prohibitions, the expressive power is enhanced by allowing to forbid simultaneous characteristics in a Java target element: this kind of constraints is only violated if all the statements are satisfied by such element.There is also the possibility of expressing constraints for specific target types (e.g., a field), which indicates that the given constraint only applies when the annotation is attached to that target type (e.g., a field).This corresponds to the attribute t_type of Constraint. An annotation isthus correctly placed at a target type if it satisfies some of the statements of the requirements whose t_type coincides with the given target, and none of the respective prohibition statements.For these restricted types of constraints, there is a conceptual distinction depending on whether t_type is a Java container or inner type, since the statements will refer to characteristics of its inner or containing elements, respectively. For example, if the target type is field, then the statements will constrain the classes, interfaces or annotations that contain it; that is, the attribute t_type of an Statement inside such Constraint can only be one of class, interface or annotation.1111This conceptual remark is also checked when validating the constraints.These two types of constraints, and their combinations, provide enough expressive power to cover a large scope of the conceptual model behind a set of dependent annotations; as it will be shown in Section 8, in a real use case.Fig. 7shows an example annotation in abstract syntax. The annotation has Person as name and declares three attributes: name, age and weight. It declares two constraints: one requiring a public class and another one forbidding the class to have final fields. This is an example of an annotation placed at a container Java type (class) with statements that constrain its inner components (fields are forbidden to be final).We have designed a textual concrete syntax for Ann. An excerpt of the concrete syntax definition for the constraints within an annotation can be found in Listing 4, represented in Extended Backus-Naur Form (EBNF). Appendix A includes the full definition.Listing 4Concrete syntax excerpt for constraints in Ann.Listing 5 shows how the Java annotation type Person previously shown in Listing 1, and in Fig. 7, is described using the concrete syntax of Ann. A new keyword (annotation) is used on its declaration (line 3). Instead of using methods to define the annotation parameters (cf. Listing 1), we use the regular Java syntax for defining class attributes (lines 4–6 of Listing 5).Listing 5Annotation Person defined in Ann.Regarding the restriction of the allowed targets, we can now express some more elaborated constraints, in this case that Person can only annotate public classes (line 8) with no final fields (line 10). We recall that with Java the closest we can get to this statement is that the annotation could have as targets classes, interfaces and enumerations, which is less specific than what we obtain with this annotation type definition.In the concrete syntax for requirements, we also note the special keyword all. This would apply if, for instance, we would want that all the methods of the classes annotated with Person were also public. Then we would add the clause at class: require all public method.In order to fully specify the semantics of Ann it is necessary to generate on the one hand the Java code associated with the definition of the annotations; and on the other hand the code of the processors. The latter will ensure that the constraints specified for each of the defined annotations are fulfilled.For each of the annotations defined at most two processors will be generated, one for checking the requirements and the other for checking the prohibitions. The structure of the annotation processors generated complies with the one presented in Section 3: each of the relevant elements of the Java program is looked up to check whether its properties satisfy the specified requirements or prohibitions.The different components of the Ann DSL have been developed using the Eclipse Modelling Framework (EMF) [34].The meta-model has been described with the meta-modelling language Ecore,1212http://www.eclipse.org/ecoretools/which is based on a subset of UML class diagrams for the description of structural aspects. The Xtext1313http://www.eclipse.org/Xtext/framework, integrated with EMF and able to generate a fully customisable and complete editor for the defined language, has been used to define the textual concrete syntax. Finally, the code generator has been developed using Xtend,1414https://eclipse.org/xtend/a dialect of the Java language included in Xtext. Xtend is more expressive and flexible than Java and has facilities for model navigation. It also allows creating generation templates, what makes it specially useful for code generation. The tool also integrates the USE validator, in order to check constraint conflicts. The use of such model finder will be explained in Section 7.The result is an Eclipse plug-in, which is seamlessly integrated within the Eclipse Java Development Tools (JDT).1515http://www.eclipse.org/jdt/A screenshot of the IDE is shown in Fig. 8.The advantage of using a high-level language, like Ann, to make explicit the integrity constraints of a set of annotations, is that they are amenable to analysis. We use model finding techniques for this purpose [22,25]. Model finders are tools supporting a high-level notation to describe features of models, and use constraint solving to find a model exhibiting such features. Typically, model features are described using structural data models (e.g., class diagrams with OCL constraints [25], or relational logic [22]), and rely on lower-level SAT or SMT solver engines (like KodKod [35] or Z3 [12]). Solvers typically perform a bounded search, so that only models up to a given size are sought. Nonetheless, according to the “small scope” hypothesis [22], a large proportion of errors in a system can be identified by considering only instances within a small scope. We use the USE model finder, which accepts as input a meta-model plus OCL invariants.In order to perform the analysis, we have created a simplified meta-model of Java, containing only the elements that we consider in the Ann language. Then, annotation constraints are translated into OCL, and USE is employed to search for an instance of the previous Java meta-model satisfying all constraints. If no such model is found, then the annotation constraints are incompatible. Moreover, we can also search for Java models containing a combination of annotations of interest. This can be done by another OCL constraint explicitly demanding the occurrence of the desired combination of annotations.Fig. 9shows the Java meta-model we use for the validation and verification of annotations. A few OCL constraints have been added to different classes, for example restricting the visibility of Class to be default or public; demanding abstract methods to reside in abstract Classes; and forbidding cycles of class and interface inheritance.For the analysis, the main idea is to enrich such meta-model with classes and constraints generated from the annotation definitions. If the resulting meta-model is satisfiable, then there is no conflict in the annotation definition. For example, Fig. 9 shows two classes: Person and Employee generated from two annotation definitions. The first one from the definition in Listing 5, while the second one just requires classes with package visibility and with a Person annotation. In Fig. 9, these generated classes are shown encircled in a dotted region. For class Person we generate an association to Class, which is its only allowed target. If an instance of Person is created, it needs to annotate a Class and therefore the cardinality of role targetPerson is 1. Similarly, another association is created for Employee. Additionally, the OCL constraints of Listing 6 are generated for both classes.Listing 6Generated OCL constraints from the Person and Employee annotations.The two invariant named redefs in lines 2–4 and 14–16 emulate the redefinition of the target role by targetPerson and targetEmployee in classes Person and Employee respectively. This is necessary, because for both annotations, Class is their only allowed target.Note that the target role is useful for annotations that do not explicitly declare a target, so that they can be placed anywhere. For Person we require the target class to be public (invariant require_public_class in lines 5–7), and to have no final fields (invariant at_class_forbid_final_field in lines 9–11). For Employee we require the target class to have package visibility (invariant require_annPerson_package_class, line 19), and be also annotated with the Person annotation (invariant require_ annPerson_package_class, line 20).Feeding the meta-model of Fig. 9 and the generated constraints in Listing 6 to USE, it returns no model, and hence the constraints are unsatisfiable. On reflection, we realise that the designed constraints for the annotations are in conflict, because annotation Employee demands classes with package visibility, and to be annotated with the Person annotation, which requires classes with public visibility. Designers can then modify the constraints, for example requiring Employee to annotate public classes. Alternatively, they might drop the constraint on visibility, because it would be redundant with the similar constraint from Person.While this example is simple, in more complex cases, the user has the burden to find the reasons for the conflict. This is typically done by systematically trying all combinations of constraints within the considered set (by manually disabling combinations of constraints). Automated, more efficient support for this task (e.g., like the method proposed in [30]) is left for future work. Similarly, constraint redundancy can be (manually) investigated with solvers like USE [17], but automating this task is also left for future work.Once the constraint for package visibility is deleted from Employee, USE would return a model like the one in Fig. 10(a), proving that there is no conflict, and provide the designer with an example of use of the designed annotation. Fig. 10(b) shows a representation of the USE model in the textual syntax of Java, which could be useful to the designer, to see an example of use of the designed annotations.We next provide a systematic description of how the Java meta-model is to be extended and how the OCL invariants are generated given an Ann model. For each Ann annotation named〈ANN〉, we create a subclass of Annotation named〈ANN〉. Then, additional OCL code is generated for the annotation׳s require and forbid constraints.The code generation scheme for require constraints is shown in Table 1. The second column of the table shows the generated OCL, as well as the extra elements to be created in the meta-model (using the textual notation of USE for class diagrams).As explained in Section 6, requirements have an OR semantics. This means that some should be satisfied by the annotation. This way, we create an association between the generated class〈ANN〉and every distinct〈TYPEi〉. In the case of more than one requirement, we set the role cardinality in the part of the type to0‥1. If there is only one requirement, we set it to 1, as shown in Fig. 9 (and the name of the role is also simplified totarget〈TYPEi〉). Then, we conceptually redefine the generic target association end to a particular one by means of invariant redefs.In case some require clause has a modifier, we generate another invariant for the class〈ANN〉. The table shows the different possible modifiers, regarding visibility, or demanding the type to be abstract, static or final. All the stated modifiers apply to the〈TYPEi〉, and therefore we and-concatenate the sub-expressions generated by every non-empty modifier. This is done by first checking if the corresponding association role is not empty. This checking is not needed if there is only one requirement (as in line 5 of Listing 6). Note that lines 11–16 in Table 1 represent the OCL invariant that corresponds to one single statement. In the event of more than one statement in a require (as the Ann syntax allows), the generated OCL would correspond to the or-concatenation of those lines, for each statement. For future references, we will denote those lines ascondition(〈TYPEi〉,〈MODSi〉).Table 2shows the scheme of the invariants generated for requirements of co-occurrence of annotations. In the first case, annotation〈ANN〉requires the occurrence of〈ANN1〉in every place where〈ANN〉may appear. Hence, we check that every valid target of〈ANN〉is also annotated with〈ANN1〉.In the second case, annotation〈ANN1〉acts as a constraint on a type where the annotation〈ANN1〉can be placed. This case is direct as it is analogous to the ones we explained for modifiers in Table 1.The third and fourth cases deal with the situation when at a certain target, one of its contained or containing elements (see Section 6 for an explanation of this distinction) should be annotated with〈ANN1〉, respectively. Specifically, we check that whenever〈ANN〉is annotating target〈TYPE〉, there is an occurrence of target〈TYPE1〉with the specified constraints, that is, with〈MODS1〉and annotated with〈ANN1〉. The fourth case is the converse.Again, if there is only one possible target type, then there is no need to check the role that is not empty (because the role would have 1..1 cardinality). In our example in Listing 6, there is no need to test that the role targetEmployee is not empty in line 20. Finally, recall from Section 6 that in the presence of multiple statements in the same require, the semantics is to or-concatenate them within the same invariant.Table 3describes the OCL equivalent to “at” constraints (for the require case). These kinds of constraints describe structural or positional (depending on whether the target is a container or contained type, respectively) requirements or prohibitions for the targets of a given annotation (see Section 6 for more information).The scheme of translation is similar to the one of Table 2, specially the two last cases, so for simplicity we only consider the case of a container type (the case for method and constructor, because the case of field is analogous), and the use of the all modifier. We will not consider the appearance of annotations in the statements because that case has already been treated in Table 2.We have presented only the translation for require constraints, because the case for forbid is analogous, but it differs by using negation, and conjunction instead of disjunction when in the presence of several statements.

@&#CONCLUSIONS@&#
Ann makes possible the effective design of Java annotations by improving their native syntactical support and allowing the expression of integrity constraints both related to an annotation type and within a set of annotations. Thanks to the code generator, the approach can be perfectly integrated with existing Java projects. Moreover, with the use of annotation processors all the integrity constraints described with the DSL are checked at compile time, which improves both usability and efficiency. This is because it is not necessary to execute the application in order to know whether the annotations are being correctly used, hence saving much time and effort for developers. By interacting with a constraint solver, it provides feedback to the designer of the annotations while they are being constructed, in the event of inconsistencies.Concerning future work, a large range of possibilities is available given the flexibility that a DSL provides. First, improvements can be done at the tool level, for a smoother integration with the model finder. Automated support for finding the reasons for a constraint conflict, or signalling redundant constraints is an interesting line of research. We will also consider an empirical evaluation of Ann with Java programmers. As seen in Section 2, the meta-model of Java annotations can be still improved and expanded to improve its harmony with the rest of Java elements, like, for example, its conciliation with object-oriented principles such as composition, inheritance and polymorphism, which might help to make cleaner the design of a set of annotations. We also plan to provide support for the new of Java 8 concerning annotations, like new targets for annotations (any type use). Among other considerations, this may imply using a more complete Java meta-model for the analysis, like those provided by JaMoPP1616http://www.jamopp.org/index.php/JaMoPPor Modisco.1717https://eclipse.org/MoDisco/At present two basic types of constraints are considered in Ann (requirements and prohibitions), which are enough to express common integrity constraints as it has been seen in Section 8. However, further experimentation could reveal new constraint types or combinations, which could be added to the DSL in the future, given the flexibility that a meta-model provides. Another line of work is the reverse engineering of annotation constraints from the analysis of annotated Java programs.