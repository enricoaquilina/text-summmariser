@&#MAIN-TITLE@&#
Stowage planning for container ships: A heuristic algorithm to reduce the number of shifts

@&#HIGHLIGHTS@&#
We propose a heuristic algorithm for stowage planning problem of a container ship.Our algorithm is time efficient, and can generate good solutions.Our algorithm performs better than the one proposed by Avrielet al. (1998).

@&#KEYPHRASES@&#
Stowage planning,Container movement,Shifts,Heuristic algorithm,

@&#ABSTRACT@&#
We consider the stowage planning problem of a container ship, where the ship visits a series of ports sequentially and containers can only be accessed from the top of the stacks. At some ports, certain containers will be unloaded temporarily and will be loaded back later for various purposes. Such unproductive movements of containers are called shifts, which are both time and money consuming. Literature shows that binary linear programming formulation for such problems is impracticable for real life problems due to the large number of binary variables and constraints. Therefore, we develop a heuristic algorithm which can generate stowage plans with a reasonable number of shifts for such problems. The algorithm, verified by extensive computational experimentations, performs better than the Suspensory Heuristic Procedure (SH algorithm) proposed in Avriel et al. (1998), which, to the best of our knowledge, is one of the leading heuristic algorithms for such stowage planning problem.

@&#INTRODUCTION@&#
Containerization has revolutionized cargo shipping. According to World Shipping Council, around 52 percent of the value of world international seaborne trade today is being moved in containers. The world container ports’ throughput grew by 5.58 percent to reach 651 million TEUs (abbreviation for twenty-foot equivalent units) in 2013 after a 4.97 percent growth in 2012 and 8.63 percent in 2011. Together the top 20 world container ports handled 299 million TEUs in 2013, which made up 46 percent of the world total. In relation to containerized trade, the global containership fleet expanded at an average annual growth rate of 7.9 percent over the period 2006–2013 and the total fleet amounted to about 19.9 million TEUs in 2013. The average carrying capacity of container ships grew from 2259 TEUs in January 2004 to 3161 TEUs in January 2009, and to 4449 TEUs in January 2014 (all data are taken from UNCTAD, 2014). Today, the largest container ships in the world are able to carry as many as 19224 TEUs (Wikipedia, 2015).Container ship commonly calls at a series of ports according to its planned route, and at each port containers destined for that port are unloaded and containers destined for subsequent ports are loaded. Note that containers are only accessible when they are on the top of other containers. Unloading and loading movements of same containers in the same port are called shifts. Shifts arise either when we want to unload containers destined for current port which however are beneath those destined for subsequent ports, or when we want to reorder the sequence of containers to prevent more shifts in the future. Usually it is called necessary shifts in the former case and voluntary shifts in the latter.Shifts are time-consuming and money-consuming activities, hence the arrangement of containers on board is crucial to achieve operations efficiency by reducing the number of shifts. The task of determining the arrangement of containers is called stowage planning or master bay planning (Ambrosino et al., 2004; GDV, 2008). In addition to the accessibility constraints mentioned previously, many other constraints have impacts on the stowage planning, such as horizontal and cross stability constraints of the container ship, weight constraints of containers when they are stacked on each other and on the decks, mixture constraints of containers when different sizes of containers are stacked together, electricity supply constraints of temperature controlled containers, space constraints of containers for hazardous cargo, and so on.Aslidis (1989) solved one stack over-stowage problem by a dynamic programming algorithm with the kernel of a rearrangement policy which is widely adopted in later works. Avriel and Penn (1993) presented a binary linear programming formulation to find optimal solution for stowage in a single rectangular bay with only accessibility constraint. This method is limited due to the huge number of binary variables and constraints needed. Binary linear programming formulation for stowage planning problems with stability constraints, weight constraints, mixture constraints, etc., in addition to the accessibility constraints, can be found in Botter and Brinati (1992), Ambrosino et al. (2004), Ambrosino et al. (2006), Sciomachen and Tanfani (2007), Delgado et al. (2012) and Ding and Chou (2015). However, Botter and Brinati (1992) and Avriel et al. (2000) showed that the stowage planning problems are NP-complete, and currently available versions of formulations all require extensive time and resources to be solved even with the world’s leading optimization softwares.Avriel et al. (1998) proposed the Suspensory Heuristic Procedure (SH algorithm hereafter) which is a dynamic slot-assignment scheme that terminated with a stowage plan, which, to the best of our knowledge, is one of the leading heuristic algorithms for such stowage planning problem. Various optimization search algorithms such as genetic algorithm (Dubrovsky et al., 2002; Yang & Kim, 2006), branch and bound search (Sciomachen & Tanfani, 2003; Wilson & Roach, 2000), tabu search (Ambrosino et al., 2009; Wilson & Roach, 1999, 2000; Wilson et al., 2001), simulated annealing (Dubrovsky et al., 2002), greedy algorithm (Kang & Kim, 2002), tree search algorithm(Kang & Kim, 2002; Zhang et al., 2005) etc., have been applied in similar problems. However, the efficiencies and complexities of these algorithms still need to be verified. Readers are referred to Zhang et al. (2008), Sciomachen and Tanfani (2007) and Delgado et al. (2012) for extensive literature reviews.In this paper, we propose a heuristic algorithm, which is shown to be more efficient than the SH algorithm in Avriel et al. (1998) especially when the number of ports visited or the volume capacity of the ship is large. Extensive computational experimentations show that our algorithm generally performs better than the SH algorithm. Furthermore, SH algorithm is only applicable when loading and unloading information for all ports are obtained, while our algorithm only requires such information for the current port to make a stowage plan.The rest of paper is organized as follows. Section 2 provides a clear definition of the stowage planning problem of a containership. Section 3 introduces the main heuristic algorithm together with an example illustrating how the algorithm works. Section 4 analyzes the performance of algorithms based on extensive computational experimentations and Section 5 provides concluding remarks.The most frequently used addressing notation for storage locations in a container ship is the bay-row-tier system, please refer to Ambrosino et al. (2004) for an excellent detailed description. In this paper, we adopt similar notation and definitions as in Avriel et al. (1998) since we mainly compare our results with theirs and similar notation systems will make the comparison more readable. Please note that the two notation systems can be translated into each other easily.Consider a container ship consisting of a single rectangular bay with horizontal rows labeled r = 1,…, R from top to bottom and vertical columns labeled c = 1,…, C from left to right. Slot in row r and column c is labeled (r, c). Assume that all the containers are of the same size, (e.g. 20 TEUs) and each slot can be fully occupied by one container. The volume capacity of the container ship is thus P = R · C. The assumption of single rectangular bay is just for sake of simplicity. For multiple bays, we can simply label all the columns sequentially as the formulation does not take into account where the columns are located. For irregular bays, they can be transformed into rectangular ones with some additional imaginary slots, which by additional constraints are forced to be occupied by imaginary containers during the whole voyage.Assume that a container ship plans to visit N( ≥ 2) ports, 1, 2,…, N, sequentially. At port 1, containers destined for port 2,…, N are loaded. At each port i = 2,…, N − 1, all containers destined for port i are unloaded and those destined for ports i + 1,…, N are loaded. Shifts may occur in these ports, either necessary or voluntary or both. At port N, all containers destined for port N are unloaded. The containers remain unmoved when the ship voyages among the ports.A container is called a j-container if it is destined for port j. Obviously all j-containers are loaded before the ship visits port j and should be unloaded at port j. A j-container is called a i, j-container if it is originated from port i. A j-container in slot (r, c) is said to be blocked if there exists a j′-container in slot (r′, c) with j′ > j and r′ < r, and the j′-container is called a blocking container with respect to the j-container. Occurrence of container blocking at any time means that shifts are no longer avoidable.Let T = [Tij] be the N × N transportation matrix, where Tijis the number of i, j-containers to be shipped, where i, j ∈ {1,…, N}. Note that Tij≥ 0 for all i, j and Tij= 0 for all i ≥ j. A transportation matrix is called feasible if in each port the total capacity required to stow the containers destined for subsequence ports is no more than the capacity of the ship. Technically, the non-negative upper triangular T is feasible if and only if(1)∑k=1i∑j=i+1NTkj≤P,∀i∈{1,…,N−1}If T is not feasible, decisions on which containers are to be loaded on board have to be made, which is beyond the scope of our consideration. Therefore, only feasible transportation matrices are considered throughout this paper.LetK=∑i=1N−1∑j=i+1NTijbe the total number of containers to be shipped, and L and U be the total number of loading and unloading movements during the whole voyage, respectively. Note that L = U if there is no containers loaded on board before visiting the first port. Since each container requires at least one loading and one unloading movement, the total number of shifts Z = L + U − 2K ≥ 0. Moreover, define Z/(2K) as the shifting ratio, which is a relative performance measure for stowage plans.RemarkWe have(1)If N ≤ 3, for any given T, R and C, there always exist stowage plans that lead to no shifts;If R = 1, for any given T, N and C, all stowage plans lead to no shifts;If N ≥ 4 and R ≥ 2, for any given C, there always exists T such that shifts are inevitable.Please refer to the online supplement (Ding & Chou, 2015) for proof.This remark indicates that we only need to focus on stowage planning problems with N ≥ 4 and R ≥ 2. Also, we will emphasize cases with C ≫ 1 for real life problems, noticing that C = 1 has been well studied by Aslidis (1989).A column is called eligible if it is neither empty nor full. In a non-empty column, adjacent j-containers are said to form a j-layer. The topmost layer in a column is called the 1st layer, and the adjacent layer beneath the kth layer is called the (k + 1)th layer. If the kth layer is at the bottom of the column, we regard that the (k + 1)th layer is a N-layer and there will be no (k + 2)th layer. A non-empty column is called l-top if the 1st layer is a l-layer, and it is called l-min if the container with the nearest destination in this column is a l-container.A column or a stack of containers is said to be in order if there is no blocked container in it, otherwise it is said to be out of order. The blocking number of a column is the number of necessary shifts that must be carried out at future ports assuming that no containers will ever be loaded into this column. A column is said (re)ordered up to m if there is no blocked l-container with l ≤ m in it. For a column being ordered up to m, all l-containers with l > m (if exist) are stowed under those with l ≤ m (if exist), and the latter itself is in order. Avriel et al. (1998) has similar definition of “reordered up to” which is also called “rearranged up to” in Aslidis (1989).An intuitive conclusion, which has also been proven in Aslidis (1989), is that when several containers are to be loaded into one column, it is always better to load them in order, which means containers with further destinations should be loaded before those with closer destinations. Sometimes, we may want to unload a certain number of disordered containers before the loading movements on the purpose of reducing the number of shifts in the future. In our algorithm, such voluntary unloading movements are determined by the following Myopic Voluntary Shifting Determination (MVSD) procedure.Consider the situation that we are trying to load a set of containers, called the trying set, into an eligible column c at port i. Assume that i-containers and those blocking them have already been unloaded. Note here the number of containers in trying set can exceed the number of empty slots in column c as we are just trying. Assume that the nearest destination for the containers in the trying set is port k, and the furthest destination for the containers in trying set and in column c is port u.Before any containers in trying set is loaded into column c, we may first unload some from column c to reorder the column up to m in order to reduce the number of shifts in the future. After that the unloaded containers destined for port j ≥ k form a new set, called the unloaded set, while those unloaded containers destined for port j < k are ignored (as our main algorithm deals with containers in a decreasing order of their destinations, they will be handled later). Finally, the containers in the trying set and the unloaded set will be loaded together into the column c in order and as many as possible, for containers with the same destinations, those in the unloaded set will be loaded before those in the trying set.When m ≤ k − 1 we indeed unload nothing, since a column containing only l-containers with l ≥ k > m is already ordered up to m. On the other hand, the process will be same for all m ≥ u. Hence we only need to consider the reordering level m ∈ {k − 1,…, u}. For each reordering level m, the minimum number of unloading movements required to achieve that level is assumed to be G(m), obviously G(m + 1) ≥ G(m). Moreover, define H(m) as the maximum number of containers in the trying set that can be loaded into column c after the unloading movement. Let B(0) be the blocking number of column c before any movement, and B(m) be the blocking number of column c after all these movements. Therefore, we can settle down H(m) containers in the trying set at myopic cost of B(m) + G(m) − B(0). The MVSD procedure selects the reordering level m with the largest H(m) among all considered m, or the m with the smallest B(m) + G(m) among those m with the same largest H(m), or the smallest m with the smallest B(m) among those m with the same largest H(m) and the same smallest B(m) + G(m). Please refer to the online supplement (Ding & Chou, 2015) for an example of the MVSD procedure.Given N, R, C and a feasible T, our main algorithm generates a series of matrices, {Si}, i ∈ {1,…, N − 1}, where Siis a R × C matrix corresponding to the stowage plan, that is, the status of the bay, upon leaving port i. Let S0 be the initial stowage plan before the voyage which will be a R × C matrix of 0 for an empty bay, and let the loading vector for port i bewi= [wij], i ∈ {1,…, N − 1}, j ∈ {i + 1,…, N}, wherewijis the number of j-containers to be loaded on board at port i. At each port i the initial values ofwiarewij= Tijbefore any container movement starts. Note thatwijwill be increased or decreased by 1 for each unloading or loading movement for j-container respectively, and it should always be ended up with 0 upon leaving port i. Our algorithm generates Sibased on Si − 1 andwifrom i = 1 to N − 1 sequentially. Note that Si,wiand the status of the columns are updated live after each container movement, and hence will not be mentioned repeatedly in the algorithm.During the execution of the algorithm, we sometimes have several qualified columns that can be used to stow the containers that we are dealing with and we have to specify in which order these columns are filled. When we say “the columns are filled based on the priority sequence, p1, p2,…, pk”, we mean that: (1) among all the qualified columns, the column that satisfies p1 will be filled first; (2) among all the columns satisfying p1,…, pi − 1, the column that satisfies piwill be filled first; and (3) among all the columns satisfying p1,…, pk, any column can be filled first.Please note that in the main algorithm a tagged container is a container with a tag (or a mark) reminding us that it requires further consideration. A container may be tagged (marked) in Rule 9 and a tagged container may be untagged in Rules 8 and 9.Here are some remarks on the rules in the core of the main algorithm. Rule 1 states that if there is no j-container to be loaded at all then the algorithm will in turn deal with (j − 1)-containers. Rule 2 and Rule 3 are speed-up rules for the cases in which all unassigned containers are to be loaded into the only remaining non-full column. Rule 4 assigns N-containers into empty columns and the columns that contain only N-containers as much as possible (N-containers at the bottom of columns will never be unloaded before port N, thus it will be more efficient to do so). j-containers with j < N will be loaded first into j-top in order columns based on Rule 5, then into empty columns based on Rule 6, then into l-top in order columns with l > j based on Rule 7, and then into l-min out of order columns with l ≥ j based on Rule 8. All these loading movements do not generate additional blockings. However if there are still j-containers with j ≤ N to be loaded, they have to be loaded into columns containing l-containers with l < j, hence more blockings or shifts will occur and the MVSD procedure will be applied in Rule 9 to determine which columns to be filled and how they are filled. As ij-containers have no impact on the performance when j = i + 1, Rule 10 indicates that they can be loaded on board by any feasible way.The main algorithm is directly applicable for stowage planning problems with non-rectangular bay, multiple bays, and initial containers (that is, containers loaded on board before visiting the first port).ExampleAssume N = 6, R = 5, C = 4, andT=[04104110011110000560000500000012000000]The algorithm-generated stowage plans upon leaving each port are shown in Fig. 1. For this algorithm generated stowage plan, the number of shifts is 4 and the shifting ratio is 3.85 percent. Please refer to the online supplement (Ding & Chou, 2015) for more details.We analyze and compare the performance of our main algorithm and HS algorithm with large scale computational experimentations. Both algorithms are implemented with C++ and compiled with Microsoft Visual Studio 2010. The computational experimentations are carried out on PCs with Intel Core 2 Duo CPU and 4GB memories.In order to evaluate both algorithms, we have to generate transportation matrices automatically. Obviously, the generation method of the matrices has great impact on the performance of the algorithms.A stowage planning problem with parameters N, R, C and T is called a full loading problem if the bay is fully occupied upon leaving each port, or technically,∑k=1i∑j=i+1NTkj=P,∀i∈{1,…,N−1}recalling that P is the volume capacity of the container ship. Correspondingly, T is called a full loading transportation matrix for capacity P. Notice that the numbers of i(i + 1)-containers, i ∈ {1,…, N − 1}, have no impact on the performance of rational stowage plans as i(i + 1)-containers should never be stowed beneath those containers that have further destinations. We can always transform a non-full loading T for capacity P into a full-loading T′ for the same capacity without changing the performance of rational stowage plans whereTij′={Tij,ifj≠i+1Tij+P−∑k=1i∑j=i+1NTkj,ifj=i+1We say that T has rank n if the containers to be shipped at most visit n ports (including their destined ports but excluding their original ports), that is,n=maxi,j{j−i|Tij>0}≤N−1.We say that T has norm n if the containers from same original ports have at most n different destinations, orn=maxi{∑j=i+1Nsgn(Tij)}≤N−1wheresgn(x)={1,ifx>00,ifx=0−1,ifx<0is the sign function. Obviously, for any T, the rank is no less than the norm.As a preparation, we consider a random integer partition problem in which a non-negative integer v is randomly partitioned into b non-negative integers x1,…, xb. This problem can be done efficiently by the following Random Integer Partition (RIP) algorithm, which derived from the famous Fisher–Yates shuffle algorithms (see Fisher & Yates 1948, Durstenfeld 1964; Knuth 1998). And please refer to the online supplement (Ding & Chou, 2015) for a demonstration for the RIP algorithm.We generate the authentic matrices randomly for full loading stowage planning problems with parameters N (the number of ports) and P (the volume capacity) by the following Authentic Matrices Generation (AMG) Algorithm. Please refer to the online supplement (Ding & Chou, 2015) for demonstration.Avriel et al. (1998) considered three types of auto-generated matrices: mixed matrices, long distance matrices and short distance matrices. Unlike the authentic matrices, stowage planning problems with these three types of matrices generally are not full loading problems. Besides the feasible constraints (1), mixed matrices and long distance matrices are generated by assigning random integers to unassigned elements in random sequence with the constraints Tij≤ 0.2RC and Tij≤ ((j − i)/(N − 1))2RC respectively, while short distance matrices are generated by assigning random integers to the unassigned elements in lexicographic sequence.Fig. 2compares the average ranks and norms of these four types of matrices of 10, 000 auto-generated samples, each with X = 5000. Authentic matrices have the largest average numbers of ranks and norms, which are both close to the upper bounds. Hence, most elements in the upper triangular of the matrices are non-zeros. As the elements of the same rows are generated at the same time, they have equal possibilities to be large or to be small. Problems with authentic matrices generally lead to the most number of shifts among the four types of matrices which will be shown later.The respective average ranks of mixed matrices and long distance matrices are close to each other while the latter has relatively large norms due to its smaller upper bound constraints. As the elements in the matrices are generated sequentially, there are high possibilities for those generated first to be large and for those generated later to be zero. As a result, problems with long distance matrices lead to relatively more shifts than those with mixed matrices.Short distance matrices have smaller ranks and larger norms than the mixed and long distance matrices. Also short distance matrices have large diagonal elements because the elements close to diagonal are generated before the others in each row. As mentioned previously, Ti(i + 1) have no impacts on the performance of common stowage plans, hence large Ti(i + 1) would make the problems with short distance matrices much easier than those with the other three types of matrices.Performance of our algorithm and HS algorithm are compared based on large scale computational experimentations, in which R (the number of rows) varies from 6 to 10 and C (the number of columns) varies from 50 to 1000, therefore, P = R · C (the volume capacity of the container ship) varies from 300 to 10, 000 TEUs. Moreover, N (the number of ports visited) varies from 4 to 20 and all the four types of matrices are tested. For each setting, 10, 000 times of experimentations are carried out, the average number of shifts, the average shifting ratios as well as the computation times are recorded.Fig. 3shows the average and the worst case computation time for both algorithms when dealing with authentic matrices. Note that the time axes are shown in logarithmic scales. Apparently, our algorithm is quite time-efficient, which can generate stowage plans for container ships within a minute. The worst case computation times for our algorithm are shorter than SH algorithm in general, while the average computation times for our algorithm are shorter than SH algorithm when dealing with large size problems. We have very similar results for other three types of matrices and therefore are omitted here.Fig. 4shows the average and worst case shifting ratios for stowage plans generated by both algorithms. Note that the shifting ratio axes are shown in logarithmic scales. Obviously, our algorithm outperforms the SH algorithm in general as we have smaller average and worst case shifting ratios in most cases. Indeed, our algorithm generates better, equal and worse solutions than the SH algorithm in 52.59 percent, 41.12 percent and 6.29 percent of all our computational experimentations, respectively. With such facts, we can strategically apply the two algorithms together for same problems to obtain better solutions, see Fig. 5. The probability of achieving a better stowage plan by implementing both algorithms rather than only ours is around 6.29 percent.Our algorithm generates stowage plans for each port based only on transportation information of that port, while SH algorithm generates stowage plans also based on additional transportation information of further ports. In practice, it is often impossible to obtain the whole transportation matrix at the beginning of the voyage. Our algorithm has no difficulty in dealing with such situations at all. Moreover, our algorithm can be easily applied to the cases of round trips, while the SH algorithm seems not.In this paper, we consider the stowage planning problem of a container ship. We develop a heuristic algorithm which can generate stowage plans with a reasonable number of shifts for such problems. The algorithm, verified by extensive computational experimentations, performs better than the SH algorithm in Avriel et al. (1998).Our algorithm can make a stowage plan based on the loading information of current port only, while the SH algorithm requires loading information of all ports, which prevent it from working with partial information. A future work direction is to develop a smart algorithm with certain “look ahead” mechanism, which can make use of all loading information available. For example, if a containership obtains loading information of next three ports when it arrives at some port, it will take all these loading information into account when making the stowage plan for this port, rather than only consider the loading information of this port as in our algorithm. Theoretically it can generate better stowage plans than our algorithm.Our procedures may be extended to deal with more complex stowage planning problems, such as those with additional weight constraints (e.g. a heavier container cannot be stacked on a lighter one), mixture constraints (e.g. different sizes of containers are stacked together), balance constraints and so on. Indeed, we have extended our main algorithm to deal with stowage planning problems with two additional balance constraints: the cross balance, which requires the absolute difference between the weight on the right side of the ship and the weight on the left side of the ship to be less than a given tolerance, and the horizontal balance, which requires the absolute difference between the weight on the stern and the weight on the bow to be less than a given tolerance. In particular, we have developed procedures that can generate stowage plans which have a high possibility to satisfy the balance conditions and requires reasonable number of shifts. Due to page limit, we omit the details here. Interested readers are welcome to contact the authors for details.

@&#CONCLUSIONS@&#
