@&#MAIN-TITLE@&#
Branch-and-bound with decomposition-based lower bounds for the Traveling Umpire Problem

@&#HIGHLIGHTS@&#
An exact algorithm based on a decomposition scheme is presented for the problem.Optimal solutions for all 14-team and several 16-team TUP instances were found.Most optimal solutions were obtained in very short runtime.Experiments on the influence of the components of the algorithm are reported.

@&#KEYPHRASES@&#
Traveling Umpire Problem,Decomposition strategies,Branch-and-bound,

@&#ABSTRACT@&#
The Traveling Umpire Problem (TUP) is an optimization problem in which umpires have to be assigned to games in a double round robin tournament. The objective is to obtain a solution with minimum total travel distance over all umpires, while respecting hard constraints on assignments and sequences. Up till now, no general nor dedicated algorithm was able to solve all instances with 12 and 14 teams. We present a novel branch-and-bound approach to the TUP, in which a decomposition scheme coupled with an efficient propagation technique produces the lower bounds. The algorithm is able to generate optimal solutions for all the 12- and 14-team instances as well as for 11 of the 16-team instances. In addition to the new optimal solutions, some new best solutions are presented and other instances have been proven infeasible.

@&#INTRODUCTION@&#
The Traveling Umpire Problem (TUP) is a sports timetabling problem giving attention to the schedule of the umpires (referees). The goal is to assign the umpires to the matches of a tournament, whose schedule is given beforehand.A double round robin tournament is considered, with 2n teams playing twice against each other – once in their home venue and once away. This results in a competition with4n−2rounds, each consisting of n matches. Such tournament requires assigning n umpires to the games, with the objective to minimize their total travel distance. In order to obtain a fair schedule, hard constraints (a)–(e) are imposed:(a)every match in the tournament is officiated by exactly one umpire;every umpire must work in every round;every umpire must visit the home venue of every team at least once;no umpire is in the same venue more than once in any q1 consecutive rounds;no umpire officiates games of the same team more than once in any q2 consecutive rounds. This constraint is similar to the previous one, but also takes the ‘away team’ into consideration.The values q1 and q2 range respectively from 1 to n and 1 to⌊n2⌋.11Trick and Yildiz (2007) originally presented the parameters d1 and d2 such thatq1=n−d1andq2=⌊n2⌋−d2,with 0 ≤ d1 < n and0≤d2<⌊n2⌋.Since the introduction of the TUP by Trick and Yildiz (2007), considering the Major League Baseball tournament, many exact and heuristic approaches have been developed. The initial work was extended (Trick & Yildiz, 2011) by a Benders cuts guided large neighborhood search. These papers also provided both Integer Programming (IP) and Constraint Programming (CP) formulations for the problem. A greedy matching heuristic and a simulated annealing approach using a two-exchange neighborhood were described by Trick, Yildiz, and Yunes (2012). Trick and Yildiz (2012) presented a Genetic Algorithm (GA) with a locally optimized crossover procedure. A stronger IP formulation and a relax-and-fix heuristic were proposed by de Oliveira, de Souza, and Yunes (2014), who improved both lower and upper bounds. Wauters, Van Malderen, and Vanden Berghe (2014) improved solutions and lower bounds by an enhanced iterative deepening search with leaf node improvements (IDLIs), an iterated local search (ILS) and a new decomposition based lower bound methodology. Further improvements for some instances were found by Toffolo, Van Malderen, Wauters, and Vanden Berghe (2014), who proposed a branch-and-price algorithm with a fast branch-and-bound for solving the pricing problems. Two branching strategies were investigated and many bounds were improved. Xue, Luo, and Lim (2015) presented two exact approaches to the TUP: a branch-and-bound algorithm relying on a Lagrangian relaxation for obtaining lower bounds and a branch-and-price-and-cut algorithm. The latter approach enabled solving two 14-team instances within the runtime limit of 48 hours. Several lower bounds were also improved.In this work, we present a new branch-and-bound approach to the TUP. We introduce a simple decomposition scheme that, coupled with a propagation technique, results in very strong lower bounds. This enables increasing the size of all instances solved to optimality from 12 to 14 teams. In addition, many 16-team instances are solved.The following section presents a formulation for the TUP based on the formulations introduced by Trick and Yildiz (2007) and de Oliveira et al. (2014). Section 3 details the proposed branch-and-bound technique while Section 4 discusses the lower bound strategies considered in the algorithm. Section 5 presents computational experiments considering both lower and upper bounds and, finally, Section 6 summarizes the conclusions.We present a flow formulation for the TUP based on the formulations presented by Trick and Yildiz (2007) and de Oliveira et al. (2014). A graphG=(V,E)is given, in which each node represents a game and directed edges connect the nodes (games) of round r to the nodes of roundr+1. This graph G also contains:•a source node, f, and directed edges connecting f to the nodes representing games of the first round;a sink node, l, and directed edges connecting the nodes representing games of the last round to l.Fig. 1presents an example of this graph for an 8-team instance. The formulation considers the following input data:de: distance of directed edge e;I : set of teams{1,…,2n};Hi: set of nodes where team i plays at home;R : set of rounds{1,…,4n−2};Qir′: set of nodes (games) of team i playing at home in roundsR∩{r,…,r+q1−1};Qir′′: set of nodes (games) of team i (home or away) in roundsR∩{r,…,r+q2−1};U: set of umpires{1,…,n}.And the following variables:xeu={1ifedgeeisselectedforumpireu0otherwiseFinally, let δ(I) and ω(I) denote the set of edges that respectively enter and exit the nodes in I. The formulation of the problem is given by Eqs. (1)–(7).(1)minimize∑e∈E∑u∈Udexeu(2)subjectto∑e∈δ(j)∑u∈Uxeu=1∀j∈V∖{source,sink}(3)∑e∈δ(j)xeu−∑e∈ω(j)xeu={−1ifjisthesource+1ifjisthesink0∀j∈V∖{source,sink},∀u∈U(4)∑e∈δ(Hi)xeu≥1∀i∈I;∀u∈U(5)∑e∈δ(Qir′)xeu≤1∀i∈I;∀r∈R;∀u∈U(6)∑e∈δ(Qir′′)xeu≤1∀i∈I;∀r∈R;∀u∈U(7)xeu∈{0,1}∀e∈E;∀u∈UThe objective, given by Eq. (1), is to minimize the total distance traveled by the umpires. Constraints (2) ascertain that each game is officiated by exactly one umpire. Constraints (3) are flow preservation constraints, and together with the graph structure ensure that every umpire officiates exactly one game per round. If an umpire is at the location of a team in round r, the umpire must leave from the same location to go to the next location in roundr+1. This is also guaranteed by the flow preservation constraints. Constraints (4) state that every umpire must visit every location at least once during the season. Constraints (5) and (6) specify that every umpire must waitq1−1days to revisit the same home location andq2−1days to revisit the same team, respectively. Finally, constraints (7) specify that the variables considered are binary.Building on the branch-and-bound procedure established by Land and Doig (1960), we introduce a specialized decomposition-based algorithm to the TUP. This algorithm considers the same graphG=(V,E)presented for the integer programming formulation in Section 2. Starting from the first round, the branch-and-bound algorithm assigns games to umpires, one at a time and round after round, until the sink node is reached. An assignment of a game to an umpire in a round is feasible if (i) the umpire did not visit the same location in the previousq1−1rounds and (ii) the umpire did not officiate any of the teams during the previousq2−1rounds. Whenever multiple games can be assigned to one umpire in one round, the algorithm greedily chooses the assignment incurring the smallest increase in travel distance. In case of ties, the games are sorted lexicographically.If no valid assignment can be found for an umpire in a certain round, the procedure backtracks to the previous umpire and chooses the next game in the ordered list of games in the round. If the umpire considered is the first one of the round, then the algorithm returns to the previous round. This procedure continues until the sink node is reached for all umpires. If the resulting solution does not violate constraint (c), it is feasible and its total distance serves as an upper bound. This upper bound is, together with the calculated lower bounds, used to prune the parts of the search tree where no optimal solution can reside.Whenever a new feasible solution is obtained, a local search procedure is applied in order to improve its quality. Even if the obtained solution is not feasible, i.e. if it does not satisfy constraint (c), a local search algorithm is executed trying to first restore feasibility and then to improve the quality of the resulting solution. The local search procedure is detailed in Section 3.4.Fig. 2presents an example of the branch-and-bound execution in an instance with 8 teams,q1=3andq2=2. It shows that the branch-and-bound search is currently deciding which game Umpire 1 will officiate after game B × H. The games A × D, B × G and C × H are cut from the search tree in the current stage, as they would lead to infeasible solutions. The first two games would violate constraint (d) while the second and third would violate constraint (e). Thus, the only option for Umpire 1 in the next round is to officiate game E × F.In order to speed up the branch-and-bound algorithm, we fix the games assigned to the umpires in the first round (Yildiz, 2008). This reduces symmetry in the original problem, as otherwise the umpires would be identical and introduce redundant subtrees. This preallocation can also be achieved by adding constraints (8) to formulation (1)–(7). Notation H(k) represents the edge connecting the source node to the kth game in the first round, with the games in lexicographic order.(8)xeu=1∀u∈U,e=H(u)Another way to speed up the branch-and-bound is achieved by removing edges that always violate one of the constraints (de Oliveira et al., 2014). If q1 > 1, then all edges connecting games in the same venue are removed. Likewise, if q2 > 1 then edges connecting games of the same team are also removed. For instance, the edges connecting games B × H to B × G and B × H to C × H in Fig. 2 would be removed by this preprocessing procedure.Constraint (c) – every umpire should visit the home of every team at least once – can be used as an additional pruning rule, even though it can only be evaluated on complete schedules. If the number of unvisited home locations for an umpire in a certain round exceeds the remaining number of rounds, given the assignments in the previous rounds, it is impossible to obtain a solution satisfying constraint (c). The branch-and-bound algorithm should backtrack and explore other assignments. This pruning strategy is not applied in the last round, however, because the maximum number of unvisited home locations for an umpire would be one. In this case, the local search heuristic can be used to restore feasibility, which may result in an improved upper bound.In order to quickly improve the upper bound, a local search procedure is applied to the feasible and infeasible solutions obtained by the branch-and-bound. This local search, introduced by Wauters et al. (2014), performs a steepest descent search with a matching neighborhood, i.e. moves are applied until no improvement is found.The matching neighborhood calculates the matching for each round in the solution. In order to be able to minimize infeasibility, infeasible assignments are also added to the matching problems incurring an additional cost. For every umpire u and every game g in a given round r, the matching cost Cugfor assigning game g to umpire u is a combination of two deltas presented by Eq. (9):(9)Cug=Δdug+ρΔvugwhere Δdugis the difference between the distance of the new and the current assignment, Δvugis the difference between the number of hard constraint violations in the new and the current assignment, and ρ is a high penalty value for the violations, i.e. ρ is a value sufficiently large such that any variation on Δvugis more significant than any possible value for Δdug.The pseudo-code of a recursive version of the branch-and-bound algorithm is presented in Algorithm 1. This algorithm should initially be executed as BranchBound(∅, 1, 1), i.e., receiving the parameters: (i) an empty solution, (ii) the first umpire and (iii) the first round. Initially, the umpire and round to be analyzed in the next iteration are set (lines 1 and 2) and a sorted list A of possible allocations for umpire u in round r is constructed (line 3). The algorithm then iterates through list A (line 4), pruning the allocation when possible (line 5) or adding it to the solution (line 6). If other allocations of the schedule remain unexplored, then the procedure is recursively executed for the next umpire and/or round (lines 7 and 8). Once the solution is complete (line 9), i.e. all the games have umpires assigned, the local search procedure described in Section 3.4 is executed (line 10). If the resulting solution S′ is better than the best found, then it replaces the best solution (lines 11 and 12). Finally, the current allocation is removed in line 13.A good lower bound is a basic requirement for an efficient branch-and-bound minimization procedure. The branch-and-bound procedure developed for the TUP employs a decomposition approach to quickly calculate strong lower bounds. Initially, the problem is decomposed into|R|−1subproblems. Each of them consists of exactly two consecutive rounds, which enables calculating a lower bound per set of two subsequent rounds. Next, the decomposition is changed by iteratively increasing the size of the subproblems by one round. This section details this procedure, presents a simple lower bound propagation procedure and, finally, shows how the obtained lower bounds are used to reduce the search tree of the branch-and-bound procedure.The first subproblems contain exactly two rounds and consist of finding a set of trips (edges) for the umpires to officiate the games in these rounds. The objective thus is to find a feasible edge set that connects the subproblem’s rounds. This subproblem is a simple assignment problem, and can be solved efficiently with the Hungarian Algorithm (Munkres, 1957). Constraint (c) is ignored in the subproblems.Fig. 3 shows an example of a subproblem with two rounds, r andr+1. Four games are to be officiated by four umpires in each round. The solution is a matching. Note that edges violating constraints (d) and (e) were removed from the graph. The preprocessing procedure presented in Section 3.2 avoids analyzing these infeasible connections.The sum of the distances of all|R|−1matchings is a valid lower bound for the problem. It is equal to the minimum-cost flow with node capacity (equal to 1) for the original problem. This network flow problem is a relaxation of the TUP, obtained by removing constraints (4)–(6) from formulation (1)–(7).The lower bound obtained is used by the branch-and-bound procedure for pruning. Let mrbe the value of the matching between the consecutive rounds r andr+1. The initial lower boundsLBr1,r2for the cost between rounds r1 and r2, r1 < r2, are given by Eq. (10).(10)LBr1,r2=∑r∈R,r1≤r<r2mrThe matchings provide valid, but relatively weak lower bounds. In order to improve the quality of the bounds, we proceed by incrementing the size of the subproblems to solve. The main idea is that subproblems with more rounds consider more constraints, thus, the obtained bounds tend to be stronger. However, by increasing the number of rounds, the subproblems become considerably harder. For instance, the subproblem with |R| rounds is equivalent to the original Traveling Umpire Problem with constraint (c) dropped.The subproblems with three or more rounds are solved by the very same branch-and-bound presented in Section 3, except for the evaluation of constraint (c), which is here irrelevant. Therefore, the pruning rules presented in Section 3.3 are not considered.Lower bounds computed previously are used for pruning incrementally larger subproblems. Fig. 4 shows an example of a subproblem containing four rounds of an instance with 8 teams,q1=3andq2=2. While solving this subproblem, the bounds obtained from smaller subproblems, with two and three rounds, are used to prune the search tree. Note that the algorithm ensures that smaller subproblems which can provide bounds are solved before the enclosing ‘larger’ subproblems. For instance, in the example of Fig. 4 it is guaranteed that the subproblems with rounds{r+2,r+3}and{r+1,r+2,r+3}are solved before the algorithm solves the subproblem with rounds{r,r+1,r+2,r+3}.One of the key advantages of the decomposition approach presented is that the solution of one subproblem can be used to strengthen several lower bounds. Strengthening is achieved with a simple bound propagation procedure.Consider the subproblem of Fig. 4, which includes rounds r,r+1,r+2andr+3. The total distance of the solution of this subproblem provides a new bound,Sr,r+3. This bound can be used to improve all values ofLBr1,r2with r1 ≤ r andr2≥r+3. Eq. (11) shows how these bounds can be improved. In this equation, k represents the difference between the first and the last round of the subproblem (k=3in the example of Fig. 4). Note that for any r,LBr,r=0.(11)LBr1,r2=max(LBr1,r2,LBr1,r+Sr,r+k+LBr+k,r2)Eq. (11) is applied to all pairs of rounds (r1, r2), with r1 ∈ {r, …, 1} andr2∈{r+k,…,|R|},possibly improving several bounds.Algorithm 2presents the lower bounds calculation procedure. The algorithm begins by setting all values of the matrices S and LB to zero (lines 1 and 2). The first for-loop (lines 3–6) calculates the initial lower bounds for all pairs of rounds using the values of the matchings between every two consecutive rounds. The next for-loop (line 7) is responsible for solving the subproblems with more than two rounds. The difference between the first and the last round (k) of the subproblem starts at 2 and increases till|R|−1,i.e. the subproblem size starts at 3 and increases till |R|. Line 8 specifies the first round of the current subproblem (r). The subproblems are solved in the while-loop (line 9). Some subproblems require that lower bounds are calculated beforehand. Lines 10 and 11 guarantee this requirement, by solving first subproblems starting in roundr′=r+k−2and decrementing till roundr′=r. To avoid recalculation, a subproblem with rounds{r′,...,r+k}is solved only ifSr′,r+k=0(line 10). The new bounds are then propagated to all pairs of rounds that can benefit from the improved values (lines 12 and 13). Finally, the first round r of the next subproblem is updated (line 14).Algorithm 2 is executed in parallel during the branch-and-bound procedure. Two threads are used by the final algorithm: one to calculate lower bounds (Algorithm 2) and one to compute upper bounds (Algorithm 1). Note that not all instances require solving all their subproblems. Executing both algorithms sequentially could therefore lead to a considerable waste of computation time, as it would require solving all the subproblems. Tackling both lower and upper bounds in parallel avoids this situation, since the algorithm stops whenever optimality is proven, which can be achieved before all subproblems are solved. A possible disadvantage is that the algorithm’s execution is not deterministic, since information is exchanged between the threads.The branch-and-bound procedure prunes away nodes and reduces the search tree based on the calculated lower bounds. Assume that a feasible solution with cost UB is given, and that the branch-and-bound is analyzing the node corresponding to the allocation of a specific game to an umpire in round r. Let LBr, |R| be the lower bound for all allocations after round r and let C be the sum of the distances of all the allocations in the current solution plus the distance of the allocation being analyzed. The search tree derived from the current allocation can be pruned ifC+LBr,|R|≥UB.This strategy, however, has one drawback. If remaining umpires are to be assigned in round r, the number of pruning opportunities may be limited because the bound LBr, |R| only considers allocations of rounds after r, while allocations are pending for round r. To deal with this drawback and further improve the pruning strategy, the following procedure is applied:1.A subgraph is derived containing:•the set of games of roundr−1of umpires not yet allocated in round r,the set of games of round r with allocations pending,the edges connecting games of these two sets.A matching problem on the derived subgraph is solved.This “partial” matching provides a value m that can be used to improve the lower bound, allowing to prune away a branch wheneverC+LBr,|R|+m≥UB.Fig. 5explains this procedure. The allocation of game C × H to Umpire 2 is being considered for round 3. Note that the game E × F of round 3 was already assigned to Umpire 1. In this case, the “partial” matching problem consists of games A × F, E × C, A × D and B × G and the edges connecting these games. Let m be the cost of the solution of this matching problem. The allocation of C × H to Umpire 2 in the current solution is ignored ifC+LB3,|R|+m≥UB,where C is the sum of the distances of all the allocations in the current solution plus the cost of allocating game C × H to Umpire 2 after game D × G.It is important to note that the “partial” matching procedure adds considerable overhead to the branch-and-bound algorithm. In order to reduce this overhead to an acceptable level, we employ a memoization scheme (Michie, 1968) that avoids recalculation of previously solved matching problems.The branch-and-bound algorithm was coded in Java 8 and the experiments were executed on an Intel(R) Core(TM) i7-2600 CPU @ 3.40 gigahertz computer with 16 gigabyte of RAM memory running Ubuntu Linux 12.04 LTS. In the spirit of reproducible science, the source code and all the solution files are publicly available at http://gent.cs.kuleuven.be/tup.This section is organized as follows. First the results obtained by the presented approach are compared with the best known results from the literature (de Oliveira et al., 2014; Toffolo et al., 2014; Trick & Yildiz, 2007, 2011, 2012, 2013; Trick et al., 2012; Wauters et al., 2014; Xue et al., 2015), as well as with the results obtained using formulation (1)–(8). Finally, the impact of the components of the presented branch-and-bound is discussed in Section 5.2.Table 1 shows the results obtained for the benchmark instances provided by Trick and Yildiz (2007) with 12 and 14 teams. The names of the instances are abbreviated, such that ‘12-7,2’ represents instance umps12 withq1=7andq2=2. The table presents, for each instance:•the results obtained by CPLEX using formulation (1)–(8) on the preprocessed graph (Section 3.2): the lower (LB) and upper bounds (UB) obtained in up to 3 hours;the best known results: the runtime (in minutes), when available, for obtaining the best known lower bound and the best solution, as well as the values of the best lower (LB) and upper bounds (UB), collected from different papers;the results obtained by the presented branch-and-bound: the runtime (in minutes), number of explored nodes and maximum size of subproblems solved by Algorithm 2 (|S|), as well as the lower (LB) and upper bounds (UB).The best bounds are highlighted in the table, and ⊛ indicates that the solution was proven to be either optimal or infeasible.Note that we also report results for non-standard instances in Table 1, with q1 > n andq2=2. We conclude from Table 1 that the branch-and-bound results clearly outperform the best known results from the literature for the 14-team instances. Before this work, only three 14-team instances had their optimal proven. Xue et al. (2015) required around 46 hours to prove optimality for two of these instances (the runtime to obtain the optimal solution for instance 14B-5,3, collected from Trick and Yildiz website,22http://mat.gsia.cmu.edu/TUP/ .is unknown). The proposed branch-and-bound with decomposition-based lower bounds is able to find (and prove) these optimal solutions in around 4 minutes, in total. Optimality was also proven in a very small amount of time for all the other 14-team instances. The procedure required, on average, around 5 minutes to solve each instance. It is noticeable, however, that instances with higher values for q1 and q2 demand more computational effort from the branch-and-bound.Table 2 shows the results for the instances with 16 and more teams. Again, ⊛ indicates that the solution was proven to be optimal or infeasible. The best bounds are highlighted. The time limit for these hard instances was set to 48 hours, in order to enable comparison with the approaches proposed by Xue et al. (2015). In this table, we omit the results obtained with the mathematical formulation as they were not competitive.We can see in Table 2 that the branch-and-bound found 11 optimal solutions for the 16-team instances, improving 8 upper bound values reported in the literature. Nevertheless, some of the results obtained are poor when compared to the best results from the literature. For example, no solution was obtained for instance ‘16A-8,2’. This shows that obtaining feasible solutions for highly constrained instances can take a considerable amount of time. Without an upper bound, the proposed algorithm behaves as a naive enumeration procedure. For the more constrained instances, even solving the subproblems is hard. This can be noticed by the smaller size |S| of the largest subproblem solved for these instances. Therefore, despite the impressive results for the 14-team instances, the algorithm’s exponential time complexity is noticed when solving instances with more than 14 teams. This behavior is evident in the results for the 18-team instances, where the average gap is around 21%.We present experiments to analyze the impact of some of the main components of the presented branch-and-bound algorithm. Four versions of the algorithm have been prepared:•the complete algorithm, with all the described components;the algorithm without the local search procedure presented in Section 3.4;the algorithm without the partial matching presented in Section 4.5;and the algorithm without the bound propagation presented in Section 4.3;The four different versions of the algorithm were executed for the standard 14-team instances. The total runtime and the total number of nodes generated before finding (and proving) an optimal solution were analyzed. Fig. 6presents a graph showing the results of these executions. Since the total number of nodes is proportional to the total runtime, only the runtime is shown in the figure. Therefore, the vertical axis presents the percentage of processing time to solve the instance and the horizontal axis lists the different instances considered. This figure shows that removing any of the components negatively impacts the total runtime. Between the considered components, the partial matching had the highest overall impact, followed by the local search procedure. The bound propagation had the smallest impact because the subproblems could be solved very quickly.We also ran experiments disabling other features of the algorithm, such as the lower bound strengthening by decomposition. However, the total runtime exceeded the imposed limit of 24 hours.

@&#CONCLUSIONS@&#
This work introduced a branch-and-bound approach with decomposition-based lower bounds to the Traveling Umpire Problem, devoting attention to both computation of strong lower bounds and production of good feasible solutions.The algorithm enabled improving a large number of lower and upper bounds. Among these improving results, optimality was proven for all the 14-team instances and for 11 of the 16-team instances. It was also proven that no feasible solutions exist for instances ‘16-8,4’. The branch-and-bound was able to generate competitive feasible solutions for some of the other instances, improving the best known result in one case.Future research can be conducted to improve the branch-and-bound in order to address larger instances. For instance, the algorithm can be parallelized and other branching rules can be investigated. The results obtained with the 18-team instances encourage this direction. It is also desirable to investigate the characteristics of the TUP that favor the performance of the presented algorithm, aiming at a generalized version of the procedure that can be applied to a wide range of combinatorial optimization problems.