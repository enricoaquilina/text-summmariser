@&#MAIN-TITLE@&#
The parallel stack loading problem to minimize blockages

@&#HIGHLIGHTS@&#
We formalize the parallel stack loading problem to intermediately store items without blocking.Basic complexity proofs are provided.Efficient exact and heuristic solution procedures are presented.Our computational results reveal that the positive impact of additional stacks quickly diminishes.

@&#KEYPHRASES@&#
Container storage,Stacking yard,Stack loading,Dynamic programming,

@&#ABSTRACT@&#
This paper treats an elementary optimization problem, which arises whenever an inbound stream of items is to be intermediately stored in a given number of parallel stacks, so that blockages during their later retrieval are avoided. A blockage occurs whenever an item to be retrieved earlier is blocked by another item with lower priority stored on top of it in the same stack. Our stack loading problem arises, for instance, if containers arriving by vessel are intermediately stored in a container yard of a port or if, during nighttime, successively arriving wagons are to be parked in multiple parallel dead-end rail tracks of a tram depot. We formalize the resulting basic stack loading problem, investigate its computational complexity, and present suited exact and heuristic solution procedures.

@&#INTRODUCTION@&#
The decision of how to intermediately store an incoming stream of items in a storage area consisting of parallel stacks so that they can, later on, be retrieved without excessive effort for relocating items is a widespread decision problem with quite a few real-world applications. This paper formulates a very basic core problem, denoted as the parallel stack loading problem (PSLP), which can be characterized as follows:Consider a given inbound stream of items that successively arrive at some storage yard. The incoming items, e.g., containers, boxes, or pallets, are to be intermediately stored in multiple parallel stacks. In each stack items can be stockpiled up to a given maximum height. Sometime after their intermediate storage, these items are to be retrieved again, so that each item j is assigned a weight pjthat indicates its priority of retrieval. For instance, if items i and j are assigned priority valuespi=3andpj=1,respectively, then item j is to be retrieved before i. Thus, storing i on top of j in the same stack would lead to a blockage (also denoted as mis-overlay or overstowage, see (Lehnfeld & Knust, 2014)), i.e., item i would have to be removed first in order to access item j. The PSLP aims to store the inbound stream of items in a given number of parallel stacks, such that the maximum stacking height is not violated and the number of blockages is minimized.Consider the example depicted in Fig. 1, where five items are to be successively stored in a storage area consisting of two stacks each stackable up to three tiers high. If these five items, whose priority values are indicated by the numbers within the blocks, are stored as is depicted in the middle of the figure this solution to the PSLP results in two blockages. The item with priority value 5 blocks that with value 4 which in turn blocks the lowermost item of the stack. If we take a look at the later retrieval process of the items, which is, however, not explicitly modeled as a part of our PSLP, and presuppose that the items are to be retrieved in increasing sequence of their priority weights, then the items with weights 5 and 4 need to be relocated first in order to access the lowermost item with weight 3. Thus, by reducing the number of blockages during the loading problem we actually aim to minimize the effort for relocations during the retrieval process. Note that in our example the number of blockages equals the number of relocations, but this does not have to be the case. Minimizing the number of relocations during the retrieval process is known as the blocks relocation problem, which was shown to be NP-hard (Caserta, Schwarze, & Voss, 2012). To avoid the simultaneous solution of the complex retrieval problem already during the loading phase, it is a widely applied approach to utilize a surrogate objective for the true number of relocations (see Lehnfeld & Knust, 2014). We discuss this matter in more detail in Section 5.Our PSLP occurs as a core problem in quite a few logistics applications. Three of them are depicted in Fig. 2and briefly summarized in the following:•A natural form of stack-based storage is ground storage, where items are stockpiled on top of each other. These items can be containers in stacking yards of ports (e.g., Caserta, Schwarze, & Voss, 2011a; Lehnfeld & Knust, 2014), steel slabs intermediately stored in the iron and steel industry (e.g., Zäpfel & Wasner, 2006; Tang, Zhao, & Liu, 2012), and pallets stockpiled in a warehouse (e.g., Nishi & Konishi, 2010). A large body of literature has accumulated over the past years in this field, which is reviewed in detail by the recent survey papers of Caserta et al. (2011a) and Lehnfeld and Knust (2014). However, most of the work summarized there addresses the premarshalling problem (e.g., Bortfeldt & Forster, 2012), where idle time of cranes is utilized to reshuffle existing storage compositions, or the unloading problem (also denoted as the block relocation problem (Caserta, Voss, & Sniedovich, 2011b; Kim & Hong, 2006)), where a sequence of items is to be retrieved from the stacks, such that the number of relocation moves for removing blocking boxes is minimized. The loading of items into stacks has mainly been treated in the container yard context, where the problem faces a lot of uncertainty. Typically, both the arrival sequence of containers and the retrieval sequence (from which we derive weights pj) are susceptible to forecast errors. Thus, existing research either focuses on simple online stacking rules evaluated by simulation (see Dekker, Voogd, & Asperen, 2006; Borgman, van Asperen, & Dekker, 2010) or minimizes the expected number of reshuffles, e.g., by considering probability distributions of different weight classes, which mainly influence the retrieval time (see Kim, Park, & Ryu, 2000; Kang, Ryu, & Kim, 2006b; Zhang, Chen, Shi, & Zheng, 2010; Gharehgozli, Yu, de Koster, & Udding, 2014). In this paper, we consider deterministic information on both the arrival sequence and the priority weights, which at least “can be very useful as a benchmark” (Borgman et al., 2010). However, we postpone a deeper debate on the applicability of our PSLP to Section 5. A deterministic loading problem, which comes pretty close to ours and is inspired by the successive storage of steel plates, has been introduced by Kim, Koo, and Sambhajirao (2011). Their parallel stacks, however, have no capacity limits, which may be a pardonable relaxation in the steel industry where only thin plates are stacked, but limits the transferability to other applications such as container yards. Moreover, they consider an alternative objective function. They assume that blocking items are restacked into their origin stack once a blocked item is removed, so that they minimize the total number of boxes with lower priority stacked on top of each box. They also treat an alternative objective where blocking items are removed to some alternative stack (not being part of the problem) and not reinserted at all. For both objectives they provide mixed-integer programs and present straightforward heuristics, i.e., a rule-based start heuristic and an improvement heuristic based on two-opt.Tram wagons: If we think of our items as railcars or buses that successively arrive at a depot consisting of dead-end tracks (stacks) to be parked overnight, the relation to our PSLP is readily available. The sequence of departure at the next morning is decoded by our priority values pjand it seems a valid objective for the parking process to store the wagons on the tracks, such that the effort for maneuvering them into the right departure sequence in the morning is minimized. However, existing research focuses on the release problem from the stacks and considers interchangeable wagons of the same type (Blasum, Bussieck, Hochstättler, Moll, Scheel, & Winter, 1999), treats real-time dispatching Winter and Zimmermann (2000), or integrates further real-world aspects (e.g., Freling, Lentink, Kroon, & Huisman, 2005; Jacobsen & Pisinger, 2011) such as differently sized wagons and tracks, complex time timetable constraints, and tracks accessible from both directions. A more detailed review on the literature on sorting processes in shunting yards is provided by the recent survey paper of Boysen, Fliedner, Jaehn, and Pesch (2012a).Another application of our stacking problem is the resequencing of assembly lines in the automotive industry (see the survey paper of Boysen, Scholl, & Wopperer (2012b)). Initially, the production sequence of cars is planned about three to four days before production starts and communicated to the part suppliers. Suppliers deliver the parts just-in-time to the respective assembly stations where parts remain in storage sorted right in the sequence of their later assembly. Unfortunately, the production sequence often gets stirred during the assembly process. Especially the paint-shop frequently causes rework, so that cars are delayed and the initial sequence is inadvertently altered. Consequently, car manufacturers often apply mix-banks (also denoted as lane buffers or selectivity banks) after the paint-shop to regain the initially planned production sequence (see Boysen & Zenker, 2013). Otherwise, the parts stored in the stations have to be resorted according to the altered production sequence. A mix-bank consists of multiple parallel lines. Initially, a switch distributes the successively arriving cars among the lanes where they move onwards until, at the end of the mix-bank, another switch chooses among the cars being first in lane to feed one of them into the successive line segment in each production cycle. The main difference to our PSLP is that the lanes are queues (first-in-first-out) and not stacks (last-in-first-out). However, this difference requires only a reverted numbering of our storage tiers and the PSLP can directly be applied to load the lanes at the start of a mix-bank. The weights pjrefer to the originally planned sequence position and blockages hinder the recovery of the original sequence, so that their minimization supports a reduction of the logistics effort for resorting the parts in the stations.A fourth field of application where closely related stacking problems occur is presented by Demange, Ekim, and de Werra (2009). They investigate an industrial robot that passes along a rack of stored items to be retrieved. The mobile robot has a storage platform, on which only smaller items can be stacked on larger items (which corresponds to our priority values pj). However, they rather aim to minimize the number of times the robot has to pass for retrieving all items (i.e., the number of passings corresponds to our stacks) and allow no blockages.Sorting integer values with the help of stacks is of particular importance in informatics and also closely related to very generic mathematical problems that extract subsequences from an integer sequence, so that it is not astounding that research in this field dates back to famous researchers such as Donald Knuth (Knuth, 1997) and Paul Erdös (Erdös & Szekeres, 1935; Steele & Steele, 1995). Instead of trying to summarize the vast body of literature on this topic we merely refer to the survey paper of Bona (2003). As a representative of this stream of literature, we only refer to the paper of Di Stefano, Krause, Lübbecke, and Zimmermann (2008) that comes quite close to our problem setting. Here, a permutation of integers (corresponding to our item weights pj) is to be partitioned into a minimum number of subsequences (stacks), such that each subsequence is a so-called k-modal sequence, i.e., at most k internal extrema occur (similar to our blockages). This exemplifies the reverted view on the problem of this stream of research: They rather aim to minimize the number of stacks required to reach subsequences with certain properties, while we take the economic perspective and make the best possible use of our given resources, i.e., stacks.Finally, the previously mentioned survey paper of Lehnfeld and Knust (2014) not only thoroughly summarizes all the relevant literature that treats the loading, premarshalling, and/or retrieval of items from stacks, but also provides a classification scheme for concisely defining different problem settings. According to this scheme, our PSLP is specified by the shortcut[L|πin|#USadj]and their lists of all investigated problem versions confirm our own finding, after a thorough literature search, that the PSLP has not been explored yet.This paper investigates a very basic stack loading problem that may serve as a core problem within multiple fields of application. A given stream of items is to be stored in parallel stacks with limited capacity, such that the total number of blockages (where an item to be retrieved later is stacked on top of another more urgent item) is minimized. We formally define the resulting PSLP, prove its computational complexity (Section 2), and derive suited exact and heuristic solution procedures (Section 3). Specifically, we present two alternative mixed-integer programs, an exact dynamic programming procedure, two heuristics, and an efficient lower bound procedure by relaxing the capacity constraints of the stacks. In a comprehensive computational study (Section 4), we test the solution performance of all these procedures and investigate the impact of different storage layouts. Section 5 discusses the applicability of our basic model and introduces straightforward extensions. Finally, Section 6 concludes the paper.Our basic parallel stack loading problem (PSLP) can be formally defined as follows. We have a sequence of n items (boxes) to be stored in a given number of stacks. The sequence is defined by a permutation of box set J. Without loss of generality we assume that boxes are numbered according to their succession in the sequence. Thus, boxj=1is the first to be stored,j=2the second, and so on until final boxj=n. The storage bay consists of Sstacks and in each stack we have T tiers (numbered according to increasing heightt=1,…,T) where the containers are to be stockpiled. Clearly, S· T ≥ n must hold and for a matter of convenience we assume that, initially, all stacks are empty. Each box j ∈ J is assigned a deterministic priority value pjdefining its position in the retrieval sequence; a lower pj-value indicates an earlier retrieval. Except for this priority value the boxes are assumed to be identical, so that no storage or weight restrictions are to be considered. Note that different boxes may share the same priority value. In the real-world this may occur if, for instance, two containers are collected by the same freight train and the loading sequence of these two boxes is insignificant.A storage plan Ω for PSLP consists of tuples (j, t, s) with j ∈ J,t∈{1,…,T},ands∈{1,…,S},which define that box j is stored in tier t of stack s. We say a storage plan Ω is feasible, if•for each j ∈ J we have exactly one (j, t, s) ∈ Ω, that is each box is assigned exactly one storage position in the bay,for each pair (j, t, s) ∈ Ω and (j′, t′, s′) ∈ Ω where j ≠ j′, we have s ≠ s′ and/or t ≠ t′, that each box receives a unique storage position, andfor each (j, t, s) ∈ Ω we have|{(j′,t′,s′)∈Ω:j>j′∧t>t′∧s=s′}|=t−1,that is, boxes cannot levitate, i.e., a box j can only be stored in tier t of stack s if lower tiers of the same stack are assigned to prior boxes of the sequence.We define a blockage to occur between any pair of boxes (j, t, s) ∈ Ω and (j′, t′, s′) ∈ Ω stored below each other, i.e.,t=t′+1,in the same stack, i.e.,s=s′,if we havepj>pj′,that is the upper item has to be retrieved later than the lower one; we say j blocks j′. Given this definition, we seek a feasible storage plan Ω that minimizes the number of blockages over all pairs of boxes.An alternative, even more abstract problem formulation of PSLP is inspired by sequence partition problems, e.g., treated by Di Stefano et al. (2008) and Demange et al. (2009). Letπ=[π1,π2,…,πn]be a sequence of integer values, i.e.,πj∈Nfor allj=1,…,n. A subsequence σof π is a sequenceσ=[πj1,πj2,…,πjm]with 1 ≤ jk< jh≤ m for all k < h. A partition of π of size λ is a collection of λ disjoint subsequences of π such that each element of π is contained in the collection exactly once. A subsequence positionjk∈{1,…,m−1}is called blocked ifπjk<πjk+1. Given this nomenclature, our PSLP aims at a partition of πintoλ=Ssubsequences each having at most T elements, such that the number of blocked positions over all subsequences is minimized. However, in the following we will return to our previous definition of PSLP and will only speak of boxes (or items) to be stored in stacks.Unfortunately, already our condensed basic stacking problem turns out as a challenging optimization task because of the following theorem.Theorem 1PSLP is strongly NP-hard.We prove this by reduction from the 3-Partition problem, which is well known to be NP-hard in the strong sense (see Garey & Johnson, 1979).The 3-Partition problem is defined as follows: Given 3q positive integers ai,i=1,…,3q,and a positive integer B with B/4 < ai< B/2 and∑i=13qai=qB,does there exist a partition of the set{a1,…,a3q}into q sets{A1,…,Aq},each having exactly three elements, such that∑i∈Akai=Bfor eachk=1,…,q?ProofFirst, we define the transformation scheme from 3-Partition to PSLP. The bay consists ofS=qstacks andT=Btiers in whichn=∑i=13qaiboxes are to be stored. Note that the latter makes our transformation depend on the integer values of 3-Partition and, thus, pseudo-polynomial. This, however, is no problem since NP-hardness in the strong sense is proven. The priority values of the jobs are derived as follows:pj=i,∀i=1,…,3q;j=∑k=1i−1ak+1,…,∑k=1iak. Thus, each integer value aiis represented by aiboxes of equal priority and these boxes queue in the inbound sequence such that they are ordered by non-decreasing priority values. We define all boxes with identical priority value that refer to the same integer value of 3-Partition as a box group. The answer to the instance of 3-Partition is yes if and only if there is a feasible storage plan having a total number of no more than 2q blockages. An example for this transformation scheme is given in Fig. 3.A feasible solution for an instance of 3-Partition can be transformed to a feasible storage plan by storing each integer subset of 3-Partition in a separate stack. The assignment of boxes to tiers directly follows from the respective job numbers corresponding to the integer values of 3-Partition. The result is a storage plan as is schematically depicted in Fig. 4. In each stack we have no blockages among the boxes of same group since they all have the same priority value. Exactly two blockages per stack occur at the two changeovers from the lower box group to the upper group, so that over all q stacks exactly 2q blockages occur.On the other hand, a feasible storage plan with no more than 2q blockages implies a yes-certificate for the instance of 3-Partition. First, each stacks=1,…,Smust be completely filled with boxes, because the total storage capacity equals the number of boxes to be stored. Second, each completely filled stacks=1,…,Smust contain exactly two blockages. It cannot be none or only one, because neither a single group nor two box groups jointly are large enough to fill a stack (due to the restriction of the integer values aito less than B/2). It follows that no stack may contain three or more blockages, because otherwise additional blockages would have to be compensated by other stacks with less than two blockages. Third, there are only two possibilities to have exactly two blockages each in any pair of completely filled stacks. One is schematically depicted in Fig. 4, that is exactly three box groups per stack completely fill all tiers, so that a stack and its box groups directly correspond to an integer subset of 3-Partition. The only other – yet infeasible – way to have just four blockages in any two stacks is to store three box groups corresponding to integer values with a sum larger than B in the first stack and let the overrun of the one box group and two other box groups fill the second stack. This, however, requires that in an additional stack (and such a stack must exist, because five box groups do not match our 3q integer values) more than three box groups are stored, which inevitably requires more than two blockages in that respective stack. A storage plan with no more than 2q blockages, thus, cannot deviate from the general structure depicted in Fig. 4. We only have to assign the respective integer values corresponding to the three box groups assigned per stack to a subset of 3-Partition. As any stack fills the B tiers the corresponding sum of integer values must, thus, equal B, which completes the proof.□First, we model PSLP by two different (mixed-)integer programs, which can be solved with an off-the-shelf solver. The first model explicitly assigns each box j to a tier t within a specific stack s. In addition to the notation introduced above, this model applies two kinds of variables:•binary variables xjtsreceive value 1, whenever box j is stored in tier t of stack s and 0 otherwise, andbinary variablesyj,j′receive value 1, whenever upper box j′ blocks lower box j and 0 otherwise.Given these variables and an additional big integer parameter M, a first integer program for PSLP (denoted as PSLP-IP1) consists of objective function (1) and constraints (2) to (7):(1)PSLP−IP1:MinimizeZ(X,Y)=∑j∈J∑j′∈J:j′>jyj,j′subject to(2)∑t=1T∑s=1Sxjts=1∀j∈J(3)∑j∈Jxjts≤1∀t=1,…,T;s=1,…,S(4)∑j′=1j−1∑t′=1t−1xj′t′s≥xjts·(t−1)∀j∈J;s=1,…,S;t=2,…,T(5)pj′−pj−M·(2−xj′ts−xjt−1s)≤yj,j′·M∀j,j′∈Jwithj<j′;t=2,…,T;s=1,…,S(6)xjts∈{0;1}∀j∈J;t=1,…,T;s=1,…,S(7)yj,j′∈{0;1}∀j,j′∈Jwithj<j′Objective function (1) iterates over all box pairs and minimizes the blockages among them. Constraints (2) and (3) ensure that the assignment of boxes to storage positions is well defined, that is, each container receives one storage position and each position at most one container. Constraints (4) avoid levitating boxes and Inequalities (5) determine blockage indicatorsyj,j′. Finally, the domain of the variables are defined by (6)and (7).A major drawback of program PSLP-IP1 is its struggle with symmetric solutions where otherwise identical solutions only deviate in the succession of stacks. Our second program, denoted as PSLP-IP2, breaks this symmetry by merely recording the successions of boxes within S stacks, but without identifying each stack by a specific number. For this purpose, we introduce virtual boxes 0 andn+1,which represent the start and the end of a stack, respectively. Model PSLP-IP2 applies the following additional notation:•parameterbj,j′indicates whether (bj,j′=1) or not (bj,j′=0) a blockage occurs if j′ is stored directly on top of j,binary variablesxj,j′receive value 1, whenever box j is stored directly under box j′ in the same stack and 0 otherwise,binary variables x0, j(xj,n+1) receive value 1, whenever box jis the bottom-(top-)most in some stack and 0 otherwise, andcontinuous variables tjdenominate the tier box j is stored in.Alternative mixed-integer program PSLP-IP2 consists of objective function (8) and constraints (9) to (15):(8)PSLP−IP2:MinimizeZ(X,t)=∑j∈J∑j′∈J:j′>jbj,j′·xj,j′subject to(9)∑j′∈{0,…,j−1}xj′,j=1∀j∈J(10)∑j∈Jx0,j≤S(11)∑j′∈{0,…,j−1}xj′,j=∑j′∈{j+1,…,n+1}xj,j′∀j∈J(12)tj+1−M·(1−xj,j′)≤tj′∀j′∈J;j∈{0,…,j′−1}(13)1≤tj≤T∀j∈J(14)t0=0(15)xj,j′∈{0,1}∀j∈{1,…,n+1};j′∈{0,…,j}Objective function (8) still minimizes the total number of blockages. Constraints (9) ensure that each box is assigned a storage space, whereas (10) enforces that the number of available stacks is observed. Constraints (11) and (12) ensure that the stacks of boxes are well-defined, that is each box has a successor and predecessor in its stack and successive boxes within the same stack receive adjacent tiers. Further restrictions on a valid tier assignment per box are set by (13) and (14). Finally, variable domains are set by (15).In this section, we show how to solve a relaxed version of PSLP to optimality in polynomial time, so that a lower bound solution for PSLP can quickly be found. Specifically, we relax the capacity constraints of the stacks and assume that in each stack an infinite number of items can be stored. This problem, denoted as PSLP-∞, can be solved by the simple linear assignment problem in a bipartite graph. The solution approach described in the following resembles that of a loading problem of parallel assembly lines each servicing a paint-shop in automobile production (see (Boysen et al., 2012b; Han & Zhou, 2010)).Each container and each stack is represented by a node in both node sets of the graph to be assigned to each other. Thus, each set hasn+Snodes, which we denote as box nodes and stack nodes. Arcs represent the stacking of boxes among each other and arc weights the resulting blockages. Three cases are differentiated:•An arc from a stack node to a box node means that the respective container is the lowermost in the respective stack. Since each container can be assigned to any stack and, being the lowermost, cannot block any other item, all stack nodes have to be connected with all box nodes by an arc having arc weight zero.An arc connecting the nodes of two boxes j and j′ means that the j′ is stockpiled directly on top of j in the same stack. Because of their successive arrival according to the given inbound sequence arcs are only inserted whenever j < j′ holds. The arc weight is either set to zero (pj′≤pj) or one (pj′>pj) depending on whether or not a blockage results.Finally, an arc from a box node to a stack node means that the container is the topmost in the respective stack. Each box can be the hilltop of a stack, so that each box node is connected to each stack node with arc weight zero.Given this bipartite graph solving PSLP-∞ to optimality reduces to finding a complete matching with minimum cost. The configuration of each stack corresponds to a chain of selected arcs, i.e., from a stack node to some box j (bottommost container), from j to j′, from j′ to j′′ and so on up to the topmost box, whose arc points to a stack node. By deriving a cost matrix from our arcs by assigning each box pair not connected by an arc infinite value, our matching problem corresponds to the minimum cost linear assignment problem.Example (cont.): An optimal assignment and the corresponding solution with two blockages for our example of Fig. 1 is depicted in Fig. 5.As the linear assignment problem is well-known to be solvable in polynomial time, e.g., by the Hungarian method (Kuhn, 1955), the result of this section can be summarized by the following theorem:Theorem 2PSLP-∞ is solvable inO(n3).Heuristic solutions can quickly be gained by considering boxes according to their arrival sequence and assigning them to stacks with still remaining storage space according to some priority rule, the use of which is widespread in practice. We propose five such rules, namely the fewest blockages, most similar, least-filled stack, first fit, and best fit rules, for PSLP in the following. Note that we call a stack available, if it has remaining storage space and refer to the priority value of a stack’s topmost box as the stack’s priority. Empty stacks are considered to have a stack priority ofmaxj∈J{pj}+1.Fewest blockages For each box from the input sequence, evaluate the following rules successively.1.If available stacks with higher or equal priority exist, choose the one with the lowest priority value.Among the available stacks with lower priority, choose the one with the lowest priority value.Least-filled stack For each box from the input sequence, evaluate the following rules successively.1.If available stacks with higher or equal priority exist, choose the one with the fewest boxes already stacked, where the tie breaker is the stack index.Among the available stacks with lower priority, choose the one with the fewest items already stacked (tie breaker: stack index).Most similar For each box from the input sequence, evaluate the following rule.1.Choose the available stack whose priority (either higher or lower) least differs from the priority of the current item (tie breaker: stack index).First fit For each box from the input sequence, evaluate the following rules successively.1.If available stacks with higher or equal priority exist, choose the first one (i.e., the one with the lowest index).Among the available stacks with lower priority, choose the first one (i.e., the one with the lowest index).Best fit For each box from the input sequence, evaluate the following rules successively.1.For all available stacks s with higher or equal priority, leta¯sbe the number of yet unprocessed items in the sequence that have a lower priority than that of stack s. Choose the stack s wherea¯sis lowest (tie breaker: least-filled stack, then index).Among the available stacks s with lower priority, choose the one wherea¯sis lowest, wherea¯sis determined as above (tie breaker: least-filled stack, then index).Example (cont.): For our example of Fig. 1 all five rules unanimously lead to two blockages. The varying solutions are depicted in Fig. 6.Additionally, we introduce an exact DP procedure, which is, subsequently, extended to a beam search heuristic. Our DP scheme is subdivided into n stages, where each stagej=1,…,nrepresents the decision of where to store the jth box. Each stage contains states(t¯1,…,t¯S;p¯1,…,p¯S),wheret¯sandp¯sdenote the tier and the priority value of the topmost box stored in stacks=1,…,S,respectively. Note that this information is sufficient for the decision where to locate a current box: the former information tells us whether a specific stack still has storage capacity left and by comparing the topmost priority value of a stack with that of the current item we can judge whether or not a blockage occurs. For a feasible state(t¯1,…,t¯S;p¯1,…,p¯S)of stage j,∑s=1St¯s=jandt¯s≤Tfor alls=1,…,Smust hold.As was already elaborated earlier, the problem contains some symmetry, since there are plenty solutions which only deviate in the succession of stacks but not in the assignment of boxes that share a stack. To break this symmetry, we always reorder the stacks of each state according to their non-increasing numbers of already assigned items. This way, the first stacks=1of a state does not represent the first stack of the real-world storage yard, but the stack having the most boxes assigned.A state(t¯1,…,t¯S;p¯1,…,p¯S)of stagej−1and another state(t¯1′,…,t¯S′;p¯1′,…,p¯S′)of successor stage j are connected by a transition, whenever•|{t¯1,…,t¯S}∩{t¯1′,…,t¯S′}|=S−1,that is all stacks have the same number of assigned boxes except for one,|{p¯1,…,p¯S}∩{p¯1′,…,p¯S′}|=S−1,that is the priority value of only one topmost item has changed, andfor the one deviating stack referred to as stacks s and s′ in the predecessor and successor state, respectively, we havet¯s+1=t¯s′′andp¯s′′=pj. The stack with deviating values is the one stack current box jis assigned to, so that this stack has one additional item and an updated topmost priority value. Recall that in our DP scheme s and s′ need not be identical (although they refer to the same physical stack), because of the reordering of the stacks in order to break the symmetry.If Γ(γ) is the set of states from which a transition to state γ of stage j exists, then the (partial) objective value B(γ) (minimum number of blockages) to this state can be calculated by the basic Bellman recursion as follows:(16)B(γ)=min(t¯1,…,t¯S;p¯1,…,p¯S)∈Γ(γ)×{B((t¯1,…,t¯S;p¯1,…,p¯S))+{1,ifpj>p¯s0,else},where index s denotes the one stack current box j is assigned to (according to the numbering of the predecessor state). By comparing the priority value pjof the current box with that of the stack’s previous topmost box, the latter term decides whether or not a blockage is to be added to the partial objective value of the predecessor state. By setting the number of blockagesB(1,0,…,0;pj,∞,…,∞)of the initial state to zero, solving PSLP reduces to finding a state of final stage n with minimal number of blockages. Finally, an optimal storage plan can be determined by a simple backward recursion along an optimal path.Example (cont.): The resulting DP graph for our example is depicted in Fig. 7. The nodes represent states, arcs stand for transitions, and the arc weights indicate whether or not additional blockings occur. The bold-faced path corresponds to an optimal solution with two blockages. The resulting storage plan of this solution is the one depicted in Fig. 1.We have at most TS· nSstates and each state has at most S transitions. Thus, the runtime complexity of DP is in S · TS· nS. Since T is bounded by the number of containers n, this term reduces toO(S·n2·S). Thus, it can be concluded that PSLP is solvable in polynomial time, if the number of stacks is bounded by a given constant.To reduce the computational effort our DP scheme can be extended to a bounded DP by integrating upper and lower bound solutions. An upper bound can initially be calculated either by using the best solution found by the priority rule-based heuristics or the beam search approach described hereafter. We can, also, calculate an upper bound solution in each state of DP by completing each partial storage plan by one of our rule-based heuristics; specifically, we use rule fewest blockages for this purpose because it is very quick to evaluate and typically delivers tight results. Furthermore, we calculate lower bounds in each state by applying the linear assignment based lower bound procedure described in Section 3.2. The lower bound amounts to the blockages of the already fixed storage plan plus the linear assignment for all remaining containers. The only adaptation required is that not any arc from a stack node to a box node has node weight zero, since a stack need not be empty. Whenever the priority value of a stack’s current topmost item (stored with each state) is smaller than that of the respective item not yet stored, the respective arc weight receives value one.If, nonetheless, larger instances turn out to be intractable in reasonable time, we can apply our DP scheme as the basis for a beam search heuristic (Lowerre, 1976). Instead of exploring all states per stage beam search only branches the BW (beam width) most promising states per stage in the DP graph. For a sufficiently small BW, both the space as well as the runtime needed for solving PSLP are polynomially bounded. However, there is no guarantee that the optimal solution is among those considered. To apply the beam search heuristic, the BW best states per stage are selected by their lower bound value.In this section, in order to assess the efficacy of the proposed algorithms, we will benchmark them by having them solve a set of test instances. Apart from these performance tests, we will also derive some practical guidelines as to what constitutes an efficient stacking yard layout from a PSLP perspective. All algorithms were implemented in C# 5.0 and run on an x64-PC equipped with an Intel Core i7-3770 3.4 Gigahertz CPU and 8,192  Megabyte of RAM.Since there is no established test data for the PSLP, we will first describe how we generated the instances.An instance of PSLP consists of a sequence of n jobs, where we set n to either 30, 120, or 500. Each job j ∈ J is assigned a random priority value pjfrom the interval [1; n] such that each pjis unique, i.e.,pj≠pj′,∀j, j′ ∈ J; j ≠ j′. The number of stacks S is set to either 5, 10, or 20, and the number of tiers T is correspondingly ⌈n/S⌉. Note that these parameter ranges are representative of several practical applications of PSLP. For instance, in a typical tram or bus depot there will rarely be significantly more than 30 vehicles (jobs) to park on 5 dead end tracks (stacks), whereas a stacking bay in a port can easily be about 20 stacks deep and process dozens if not hundreds of containers (jobs) in a row.For each job count n we generated 20 instances as described above, leading to a total of3·20=60instances.Table 1 shows the results of the exact solution methods for the small (30 jobs) and medium-size (120 jobs) instances. Columns n and S denote the job number and stack count, respectively. Gap opt.-LB denotes the average absolute gap between lower bound (as described in Section 3.2) and optimal objective value for those instances that could actually be solved to optimality by any of the exact methods within the time limit of 30 minutes, the number of which (out of 20) can be found in the columns labeled # opt. Finally, CPU sec. lists the CPU time in seconds for all tested exact solution methods. These methods are: dynamic programming (DP) as presented in Section 3.4, as well as a default solver, namely CPLEX 12.6.1, solving either integer program PSLP-IP1 (IP1) or PSLP-IP2 (IP2) from Section 3.1.The results clearly indicate two things: First, our bounding procedure produces lower bounds that are very tight, equaling the optimal objective value in almost all cases. We can hence, at the very least, consider it a powerful tool to benchmark heuristics, even for instances that are out of reach of exact procedures. Second, out of the three tested exact approaches, a default solver solving PSLP-IP2 is clearly both the fastest as well as the most reliable, finding the most optimal solutions within the time limit. Moreover, only IP2 manages to solve any of the medium-size instances (n=120) at all. However, even IP2 cannot solve all of these instances in time, and it completely fails when tackling the large instances wheren=500(not in the table). For these large instances, IP2 usually does not even output a feasible, let alone optimal, solution, even after running for two hours.For some applications of PSLP (e.g., bus depots), exact approaches like IP2 may be sufficient but for larger problems faster algorithms are necessary. Given that the lower bound is very tight, we can use it to estimate with great accuracy the performance of our heuristics even for the largest instances. Table 2 lists the absolute average value of the lower bound in column LB and the average absolute gap between LB and the objective value returned by either the priority rules (fewest blockages (FB), most similar (MS), least-filled stack (LFS), first fit (FF), best fit (BF); see Section 3.3) or the beam search heuristic (BS, Section 3.4) with a beam width ofBW=5,000in the columns labeled gap. Finally, the right-most column lists the CPU time taken by BS, in seconds. The CPU times for the priority rules are not explicitly shown because they are entirely negligible, that is, barely measurable, even for the very largest instances. Note that we use absolute gaps to measure heuristic performance because they appear more meaningful than relative gaps in the case of the PSLP: many solutions actually entail no or very few blockages (i.e.,Z≥LB=0), hence even a single additional blockage may cause huge (or, depending on how they are calculated, infinite) relative gaps, distorting the results.The most striking outcome here is the surprising efficacy of some of the priority rules. In particular, despite being extremely quick, the fewest blockages as well as best fit rules produce solutions with only a handful of blockages above the theoretical limit (LB). On top of that, these rules also scale very well, solving even the largest instances almost instantly, still causing only about half a dozen additional blockages over LB. The other tested priority rules (MS, LFS, and FF), however, perform significantly worse. Concerning the comparison between FB and BF, FB has the advantage of being an on-line rule, meaning that knowledge of the entire sequence is not necessary as items are assigned to stacks one-by-one. BF, on the other hand, delivers somewhat better results, but requires foreknowledge of the priorities of the incoming items (albeit not their exact order). BS often manages to further improve on these solutions, sometimes quite substantially by 4 blockages in specific instances; however, BS can only be used if the exact sequence of incoming items is already known. Given the significantly longer runtimes of BS, sometimes exceeding 2 minutes, FB and/or BF may well be the more attractive approaches from a practical point of view, at least for time-critical, large problems.In order to get a more complete picture of the proposed heuristics’ performance, we also test them on instances that are not purely random. Specifically, we investigate the solution quality if the inbound sequence contains subsequences where the priority values are strictly rising or falling. In the most extreme case, all priority values could be sorted in ascending order, e.g.,pi=i,∀i=1,…,n. In this scenario, the stack assignment would be immaterial – each item (excepting the bottom-most one) would always be stacked upon a lower-priority item. Obviously, the PSLP is also trivial to solve in the opposite case of strictly descending priorities, e.g.,pi=n−i. However, more interesting settings may occur if some short subsequences of the overall sequence are sorted according to their priorities. We thus generate a set of new instances forn=500items where we assign the priority values in one of three manners:Purely random As originally described:pj=rnd(1;n),∀j=1,…,n,where rnd denotes a uniformly distributed random integer from the interval in the argument, so long as each pjis still unique.Ascending subsequences Priority values pjare essentially random as in the purely random case, but three subsequences (l=1,2,3) containing n/6 elements each (i.e., elements〈pjl,pjl+1,…,pjl+n/6−1]) are sorted in ascending order. The start jlof each of the three subsequences is drawn randomly from the intervaljl=rnd((l−1)·n/3+1;l·n/3−n/6+1).Descending subsequences Essentially the same as in the ascending subsequences case except the elements in the subsequences are sorted in descending order.Fig. 8depicts the performance of all presented heuristics for the large instances, depending on the instances type (purely random, ascending subsequences, descending subsequences). The graphs suggest that the relative performance of the algorithms stays basically the same, regardless of how the instances are generated: BS, BF, and FB all produce very good results close to the lower bound. The three remaining priority rules fare considerably worse, the only somewhat surprising result being that the first fit (FF) rule does poorly in case of ascending priorities but comes a lot closer to LB in case of descending priorities. All things considered, however, by far the best heuristics are still BS, BF, and then FB, in that order.In the second part of our computational study, we investigate the effect of the yard layout on the number of blockages. Specifically, we ask: what is the ideal number of tiers per stack? Obviously, the less high each stack, the more stacks are necessary to store the same number of items. Planners may therefore be tempted to design their yard such that it contains only a few very deep stacks, since setting up additional stacks can be very expensive in terms of space and equipment while adding additional tiers may be far less troublesome. In container yards at a port, for example, space if often scarce, making it difficult (i.e., expensive) to have very long stacking modules (Steenken, Voss, & Stahlbock, 2004). Moreover, huge modules also increase the horizontal driving time of the cranes from one end to the other, decreasing throughput. On the other hand, from an operational perspective, having few but many-tiered stacks increases the risk of blockages, and hence time-consuming reshuffles, making it more attractive to have a spread-out design with many shallow stacks.In order to investigate this tradeoff, Fig. 9plots the number of stacks against the minimum number of blockages attainable (LB) for a given sequence (i.e., only the yard layout is varied, not the job sequence). Keeping in mind that our instances are generated such that the product of stacks and tiers always (roughly) equals the total number of jobs (i.e., T · S ≈ n), a low number of stacks automatically implies a high number of tiers and vice versa, meaning that the total number of available slots remains (just about) the same, no matter the stack count.The graphs reveal that, independent of job count, doubling the number of stacks (and thus halving the number of tiers) about cuts the incidents of blockage in half. Indeed, the number of potential blockages seems to be about linearly related to the number of tiers for any given job count. In absolute numbers, this means that increasing the number of stacks is most effective if the current number is very low (e.g.,S=5). This makes intuitive sense in that it is obviously a lot easier to spread out 30 containers over 10 stacks rather than 5. However, if there are already 20 stacks in the yard then most of the 30 containers will not have to share their stack to begin with. Further increasing S(and hence reducing T) would have almost no appreciable effect, except in those very rare cases where the input sequence is extremely (read: unrealistically) unfavorable. Our tests suggest that a stack depth of about 5 tiers still makes it possible to achieve solutions with a very low number of blockages close to 0, regardless of the other instance parameters. From that point on, doubling the number of tiers per stack also just about doubles the number of potential blockages.Our PSLP is a very basic stack loading problem, that reduces the problem to its very core. This comes at the price of quite a few limiting assumptions that restrict its (direct) applicability in some domains. In the following, we elaborate on the most important problem extensions and discuss how to integrate them into our solution concepts (if possible):Differently sized items: PSLP assumes that all items are identical except for their varying priority weights. However, especially tram wagons and buses may considerably vary in length. This requires that our stacking capacity per stack (dead-end track) is not measured in number of items T but in distances. Integrating this aspect into our DP procedure is straightforward, we only have to reinterpret the meaning of the states(t¯1,…,t¯S;p¯1,…,p¯S). Whilep¯1still represents the priority weight of the topmost item of stack s,t¯snow represents the total space utilization of all items in s. These values can be compared with the stacks’ capacity to find out whether a current item still has sufficient space. The runtime complexity of DP is not altered by this adaptation.Items may also vary in their weight, so that no heavier items may be stacked on lighter ones. Furthermore, reefer containers, for instance, require a plug, which may only provided in a subset of stacks. Such stacking restrictions can easily be integrated into DP. The former requires that the states are altered to(t¯1,…,t¯S;j¯1,…,j¯S),so that we can identify the topmost item and its priority weight. Varying properties of stacks give them an identity, so that we have no longer interchangeable stacks, which can facultatively be matched with actual stacks. Thus, we have to give up our symmetry breaking approach, which, however, does not alter the runtime complexity of DP.An identity of stacks may also originate from varying capacities, e.g., rail tracks of different length, or leftover items still blocking part of the capacity. Again, we only have to give up our symmetry breaking approach, so that stacks can be identified and checked for their leftover capacity.Whereas in some applications an intermediate stacking occurs between two well-planned and stable production steps, e.g., in the automotive and steel industry, others may be seriously affected by uncertainties. In the stacking yards of ports, for instance, the arrival sequence of automated guided vehicles and trucks delivering containers heavily depends on the current traffic situation and is, thus, hardly predictable with certainty. However, our deterministic approach might still be applicable on a rolling horizon for stacking only those (few) boxes that have already arrived. If time is even more pressing and stacking is to be decided in a real-time environment, i.e., only the stack for the current box is chosen, then our PSLP can still be an integral part when making the decision with the help of a Monte-Carlo experiment. If probabilities are available for calculating the chances of items reaching specific positions in the arrival sequence, e.g., with the help of their current GPS signals, then deterministic arrival sequences can randomly be drawn according to these probabilities and evaluated with our PSLP. This way, the (average) success of assigning the current item to one of the available stacks can be evaluated. However, as gantry cranes in stacking yards require about 2.5 minutes per container move (e.g., see Boysen, Fliedner, Jaehn, and Pesch, 2013), there exists a challenging time frame for such a Monte-Carlo experiment. Another source of uncertainty are the priority weights of the items. Again, PSLP can repeatedly be solved in a Monte-Carlo experiment, so that stochastic information on priorities can be considered. In container ports, for instance, often the weight of an arriving box is uncertain and merely estimated from past data. Since often heavier containers have to be retrieved earlier (e.g. due to stability aspects when storing them on a ship), they should not be stacked below lighter boxes (e.g., Lehnfeld & Knust, 2014).Finally, our objective function requires debate. PSLP minimizes the number of blockages, which is only a surrogate objective for the actual effort for relocating blocking items during the retrieval process. Directly quantifying the impact of the items’ storage positions may be reasonable when solving the loading and unloading problems jointly in a holistic approach (see Lehnfeld and Knust (2014) and the literature surveyed there). However, such a holistic approach will most probably turn out quite unhandy since two complex optimization tasks are combined. Nonetheless, PSLP might still be applicable as a subproblem in a decomposition step of a larger algorithmic framework for the holistic setting. On the other hand, a holistic approach may suffer from an enlarged time lag between loading and unloading problem, so that varying items and changing information may considerably alter the planning situation between both events. The dwell time of a container in a stacking yard, for instance, ranges between three and five days (see Steenken et al., 2004), so that a surrogate objective seems sufficient to roughly estimate the relocation effort in such a setting. However, there remains the question of what constitutes the best surrogate objective. In addition to the blockages minimized in this paper alternative objectives have been suggested in Kim et al. (2011); Lee and Chao (2009). The right objective is certainly heavily influenced by the specific organization of the retrieval process. Blocking items might be moved to another stack where they may block other items (Caserta et al., 2011b; Kim & Hong, 2006), they may be identically reinserted into their original stack after an intermediate movement to an empty stack (Kim et al., 2011), or relocation moves may completely be ruled out, because, e.g., in each production cycle one car has to be released into the successive assembly line segment (see Section 1.1). Identifying which surrogate objective for the stack loading problem is best suited for what organization of the retrieval process seems, thus, a valuable task for future research.

@&#CONCLUSIONS@&#
