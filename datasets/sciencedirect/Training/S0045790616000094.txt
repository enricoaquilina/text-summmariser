@&#MAIN-TITLE@&#
Inter-flow fairness support and enhanced video quality delivery over multi-hop wireless networks

@&#HIGHLIGHTS@&#
Packets that traverse more hops to the destination will get lower throughput and result in the inter-flow fairness issue.We propose a virtual queue management scheme that does not require the modification of any communication protocol.According to the number of flows, our scheme adjusts the parameters to achieve each flow's fair sharing of channel resource.Our proposed scheme can mitigate the inter-flow fairness problem and effectively improves the quality of video transmission.

@&#KEYPHRASES@&#
Multi-hop wireless network,Inter-flow,Queue,Throughput,Video,

@&#ABSTRACT@&#
Graphical abstractImage, graphical abstract

@&#INTRODUCTION@&#
In recent times, the rapid development and deployment of the IEEE 802.11 Medium Access Control (MAC) wireless local area network protocol in conjunction with the increasing number of handheld consumer electronic devices that offer wireless network functions, such as smartphones, tablets, and digital cameras, are driving the popularization and growth of wireless networks. Various devices in a wireless network environment can extend the range of the network by relaying information to one another. However, this requires network architecture that allows nodes to act as relays between the transmitting and receiving ends. Wireless networks with this type of architecture are called Multi-hop Wireless Networks (Fig. 1). In the last few years, with the evolution of wireless networks and greater bandwidth, the applications of multi-hop wireless networks have become quite diverse. Instances include vehicular ad hoc networks (VANET) [1], [2], wireless mesh networks (WMN) [3, 4], and wireless sensor networks (WSN) [5–8]. Wireless nodes compete with one another for routes. The transmission throughput at each node is limited by the bandwidth of the original channel as well as nodes neighboring the site of the transmission.When packets are from the same flow and compete for channel access with neighboring nodes, this is known as intra-flow contention. On the contrary, if packets are from different flows, the phenomenon is called inter-flow contention.Intra-flow contention refers to competition among nodes for channel access rights to transmit packets of a particular data flow. The physical position of each node affects its opportunity for obtaining channel access rights and causes unfairness of access among nodes. Inter-flow contention refers to competition among nodes for channel access rights to transmit packets belonging to different data flows. Due to competition, throughput as measured at the receiving end varies according to data flow and, hence, leads to the inter-flow fairness problem.The aim of this paper is to examine the fair sharing of network resources and the quality of video transmission in multi-hop wireless networks. There are two cases when data packets are transmitted in multi-hop wireless networks: data packets need to traverse a large or a small number of hops to reach the destination. The transmission throughput in case the packets need to traverse more hops is worse. This is because the packets that need to traverse more hops require greater effort to compete for channel access and queue space in intermediate nodes. Furthermore, when competing for channel access and queue space, packets may be dropped due to transmission collisions or overflow of the queue space in intermediate nodes. As a result, packets that need to traverse more hops have a lower probability of successfully arriving at the destination. In other words, either throughput is lower or the quality of the delivered video is poor as a consequence.Due to these fairness problems, wireless network environments with more hops can be less effective at data transmission. Past research on fairness in multi-hop wireless networks and quality of video transmission includes work by Zhai et al. [9], who proposed a backward pressure scheduling method to solve inter-flow contention conditions. In their scheme, a backward pressure threshold is assigned to each flow. When a node transmits a request to send (RTS) packet, the receiving node replies with a negative clear-to-send (NCTS) packet if it is above the backward pressure threshold. Thus, the transmitting node knows that traffic is congested in the network, and passes this information to the source node. The source node then delays data flow transmission to help reduce the congestion. When the channel is available to transmit, the receiving end informs the transmitting end of this by sending a clear to send (CTS) packet to the transmitting end that includes the source address and the flow ID. A limitation of this scheme is that it requires that each node change its communication protocol.Cho et al. [10] proposed a Multi-interface Multi-channel (MIMC) method that uses multiple channels to avoid interference and modifies RTS packets to achieve multi-hop reservation. This reduces delay and improves transmission throughput. A limitation of the method is that it requires investment in additional hardware.Hoblos [11] proposed an Adaptive Contention Window Algorithm (ACWA) to improve transmission fairness and increase channel throughput. It is based on the negative correlation between packet transmission success and the number of intermediate nodes. A greater number of intermediate nodes correspond to a lower probability of successful transmission. The scheme assigns smaller contention window (CW) values to nodes with a greater number of intermediate nodes between them and their respective destinations as well as nodes that experience less interference from hidden nodes. The lower CW values provide more transmission opportunities to these nodes, which increases fairness and channel throughput. A limitation of the technique is that immediately following a change in network topology, the CW values need to be recalculated. This complicates calculations and imposes an additional burden. Moreover, it is difficult to detect hidden nodes in a dynamic environment.Tamang and Sanguankotchakorn [12] proposed an Adaptive Dynamic Mapping Algorithm (ADMA) to protect the transmission of video frames. In this algorithm, certain video frames are protected depending on their category and importance. Video frames are assigned increasing levels of protection as they move closer to their destinations. Video frames with high importance have a low probability of being dropped, whereas those assigned low importance have a high drop probability. This strategy is used to improve the quality and throughput of video transmission. However, it does not consider data flow other than that involved in video transmission; nor does it address the inter-flow fairness problem. For example, there is no discussion of cases where video and ordinary data flow simultaneously occur.Wan [13] proposed a Dynamic Frame Assignment Algorithm (DFAA) involving a fuzzy logic controller (FL controller) whereby video frames are protected differently based on type, priority, relative queuing delay (DR), and queue length. Different care delays are executed as well. The more important video frames and those with shorter delays are placed in an Access Category (AC) queue. The study only discusses video transmission in an environment of multi-hop wireless networks without considering interference from other data flows or fairness problems.Campista et al. [14] proposed a mechanism called route length-based fairness, where higher priority to access routes is assigned to packets passing through a greater number of nodes to improve fairness in multi-hop wireless networks. The drawback of this mechanism is that it does not take into account inter-flow fairness for video transmission.Therefore, in this paper, we propose a virtual queue management scheme. The proposed scheme adjusts the queue according to the number of data flows on a given channel without having to modify any communication protocols. It effectively manages resource allocation to achieve fair sharing of network resources among all data flows. It also mitigates the inter-flow fairness problem and improves fairness of transmission. Furthermore, this scheme takes into consideration the transmission characteristics of video data. The quality of video transmission is not guaranteed to be better when system throughput is high because different video packets may vary in importance. If a less important video packet (e.g., B-frame type) has a high successful transmission rate while a more important one (e.g., I-frame type) has a low rate, or even completely fails to transmit, the quality of video transmission degrades, or the video may even fail to play due to the drop or loss of a video packet of high importance. Therefore, we need to add a protection mechanism for important video packets in the proposed queue management scheme. Our mechanism not only improves transmission fairness but also enhances the quality of video transmission. These improvements were verified through NS2 simulations.The remainder of this paper is organized as follows: Section 2 contains a description of our proposed scheme, whereas we report experimental results in Section 3 to verify the effectiveness of our scheme. Section 4 summarizes our findings and contains our suggestion for future research in the area.A multi-hop wireless network environment involves multiple flows simultaneously transmitting data. Hence, serious contention may result in congested routes, which degrades throughput and causes delays in the system due to the competition among flows for routes. This also causes a variation in the measured throughputs at the receiving ends because different flows compete with one another at different nodes. This results in the problem of inter-flow fairness. The problem of multiple flows competing for routes has traditionally been addressed by using parallel hardware queues. Each data flow is assigned a queue. If there are n data flows at a given node, n queues are assigned, and data is to be transmitted in a round-robin fashion. This method performs quite well, and solves the problems of contention and route congestion due to competition among multiple flows for routes. It also addresses the associated throughput degradation and inter-flow fairness. However, there is no way to know the number of flows in a given network a priori. The management method involving hardware queues is usually accompanied by hardware cost and additional burdens.In this paper, we propose creating virtual queues (Note that there is only one queue in the hardware at each node). The use of virtual queues for flows was traced using a data structure to ensure fairness among flows. In short, there are as many virtual queues as flows at a given node. If a flow exceeds the threshold of its virtual queue, it is discarded. In case the flow is below the threshold, data is held in the virtual queue for transmission. This method avoids the aforementioned problems as every flow has its own virtual queue. Therefore, the data packet with a greater number of hops to the destination has a similar chance of reaching it as packets with fewer hops to their destinations, despite having to compete multiple times. This strategy circumvents the problems of variation in measured throughput at the receiving ends. The distribution of resources is effectively managed according to the number of the flows by adjusting the management of virtual queues. We aim to achieve fair sharing of network resources for each flow and solve problems associated with inter-flow fairness. The fairness of data transmission improves in our scheme while video packets are simultaneously protected according to their importance. More important video packets have a higher probability of successful transmission, hence improving the quality of video transmission.Our queue management scheme has two parts, which we describe using two flowcharts. The first flowchart describes queue management as data flow enters a node, as shown in Figs. 2and 3. Due to the dimensions of the page, the first flowchart is presented in two parts to ensure clarity of understanding. The second flowchart describes queue management as data flow leaves a node (Fig. 4). The parameters for these flowcharts are listed in Table 1.In the flowchart in Figs. 2 and 3, the parameters are first initialized. Let the number of active data flows in the system (no_flow) be 0, and let (Q_lim) be the physical queue space that can be occupied by the maximum number of packets. When a packet arrives, the scheme first determines whether it belongs to a new or an existing data flow. If it is the former, its source internet protocol (IP), source port, destination IP, destination port, and transport protocol information are recorded, and the number of active data flows in the system (no_flow) is increased by one. At the same time, the upper limit on the number of virtual queue spaces (qlen_upper) that any single data flow is allowed to use in the node's queue is set to the total number of spaces in the given node's queue (Q_lim) divided by the number of active data flows (no_flow) in the system, with the result rounded down to the nearest integer. The threshold for the virtual queue space is half the upper limits of virtual queue space (with the result rounded down to the nearest integer). For example, suppose a system originally has one data flow and an upper limit (qlen_upper) of 50 virtual queue spaces. If a new data flow enters the system, there will be two data flows, and each will be allowed to use an upper limit (qlen_upper) of 25 virtual queue spaces. The threshold for virtual queue spaces is now 12.The next step is to determine whether the number of virtual queue spaces (qlen_i) used by the new data flow is less than or equal to the upper limit (qlen_upper). If (qlen_i) is greater than (qlen_upper), the newly arrived packet is discarded. If (qlen_i) is less than or equal to (qlen_upper), a continued check is performed to determine whether the packet is a video packet or an ordinary data packet. If the packet is not a video packet, it enters the queue and the number of (qlen_i) for the relevant flow is increased by one. However, if the packet is a video packet and (qlen_i) is less than or equal to the threshold for virtual queue spaces, the video packet enters the queue and the number of (qlen_i) for this flow is increased by one. On the contrary, when (qlen_i) is greater than the threshold, a further check is needed based on the type of video packet and the virtual queue space.I-frame type is the most important video packet while B-frame type is the least important. When the virtual queue spaces are close to being full, B-frame type packets are assigned the highest probability of being discarded while the probability of discarding I-frame type packets is the lowest. If drop-tail queue management is adopted for all types of video packets, all incoming video packets are dropped, no matter how important, when (qlen_i) is greater than (qlen_upper). As a result, video quality cannot improve. Therefore, early dropping- and unequal protection-based schemes for different types of video packets should be added to our virtual queue management scheme. The probability of video packets of being discarded is determined by two factors: the importance of the video packet, and (qlen_i). According to the importance of the video packet, different weight factors are assigned. Moreover, the lengths of the virtual queue spaces (qlen_i) are relevant. When (qlen_i) is close to (qlen_upper) in value, the probability that the relevant video packet will be discarded increases. Since the I-frame type is the most important video packet, the weight factor for it being discarded, α, is set as smallest. It is not easy to discard I-frame type packets. Since B-frame video packets are the least important, the weight factor for these being discarded, γ, is set to maximum. Hence, B-frame type packets are the easiest to discard.Finally, we use the probability from a random number generator, tmpx, to determine whether a video packet is discarded. When the value of tmpx (whose value is in the range 0.0–1.0) is less than the probability of discarding a given video packet, prob, the video packet is discarded; otherwise, the video packet enters the virtual queue and waits to be transmitted.If the data flow record to which the packet belongs exists, we locate its corresponding record, and check to see whether the number of active data flows (no_flow) in the system has changed. If it has, (qlen_upper) is recalculated. The upper limit on the number of virtual queue spaces (qlen_upper) that any single data flow is allowed to use in a node's queue is set to the total number of spaces in the node's queue (Q_lim) divided by the number of active data flows (no_flow) in the system, with the resultant rounded down to the nearest integer. The threshold for the virtual queue space is half the upper limits of virtual queue spaces (with the resultant rounded down to the nearest integer). We then determine whether the number of virtual queue spaces (qlen_i) used by the incoming data flow is less than or equal to the upper limit (qlen_upper). If (qlen_i) is greater than (qlen_upper), the given packet is discarded and fails to enter the virtual queue. If (qlen_i) is less than or equal to (qlen_upper), a continued check is performed to determine whether the packet is a video packet or an ordinary data packet. If the packet is not a video packet, the given packet enters the queue and the number, (qlen_i), of this flow is increased by one. Further operations required are similar to the aforementioned.The flowchart in Fig. 4 describes the process in case a data flow packet leaves the queue. The record for the corresponding flow is first located according to the packet's fields (source IP, source port, and so on), and the number of virtual queue spaces used by the data flow (qlen_i) is reduced by one. Following this, the system determines whether (qlen_i) is zero. If it is, the data flow packet is removed from the virtual queue, its record is deleted, and the number of active data flows (no_flow) in the system is reduced by one. If (qlen_i) is not zero, the data flow packet is simply delivered out of the virtual queue.

@&#CONCLUSIONS@&#
