@&#MAIN-TITLE@&#
A fast algorithm for matrix embedding steganography

@&#HIGHLIGHTS@&#
1.A fast matrix embedding algorithm using Hamming code is proposed.2.A fast matrix embedding algorithm using random linear code is proposed.3.The computational complexity is extremely low for low and medium embedding rates.4.The requirement for memory space is low.5.Compared with the existing algorithm, the embedding efficiency maintains the same.

@&#KEYPHRASES@&#
Image steganography,Matrix embedding,Fast algorithm,Hamming code,Random linear code,

@&#ABSTRACT@&#
A fast algorithm for matrix embedding steganography is proposed in this paper. Matrix embedding encodes the cover image and the secret message with an error correction code and modifies the cover image according to the coding result. The modification to the cover image is the coset leader of the error correction code, and it is computationally complex to find the coset leader. This paper proposes a fast algorithm to find the coset leader by using a lookup table algorithm. The proposed algorithm is suitable for matrix embedding steganography using Hamming code and random linear code. In our scheme, the syndrome of the coset is used to search for the coset leader in the standard array of the error correction code. For the Hamming code, we improved the parity check matrix of the code in order to make the syndrome indicate the coset leader by itself. Therefore, it is not necessary to search for the coset leader in a table. For the random linear code, this method is effective for most cosets, and we only memorize the coset leaders that cannot be identified by their syndromes. With this approach, the size of the table can be reduced significantly, and the computational complexity of embedding can be decreased. The proposed fast embedding algorithm has the same embedding efficiency as the conventional matrix embedding. Compared with the existing fast matrix embedding algorithms, the computational complexity of the proposed scheme is decreased significantly for the steganographic systems with low and medium embedding rates.

@&#INTRODUCTION@&#
Digital image steganography is a popular information-hiding technology in which the secret messages are transmitted by being hid in the digital images, which are known as cover images. Using the redundancy of cover images, extensive secret messages can be embedded imperceptibly and transmitted together with the cover images [1]. The presence of the secret messages is imperceptible. Thus, illegal attackers cannot detect the secret messages, but the legal receivers can acquire the secret messages by using an extraction algorithm.Least-significant-bit (LSB) replacement is a popular steganographic method in which the secret message bits are embedded into the LSBs of the cover images. In spatial-image steganography, the lowest bits of the pixelsʼ gray values usually are chosen for embedding the secret messages in LSB replacement. Therefore, LSB replacement either increases (or decreases) the pixel values by one or leaves them unmodified, after which the lowest bits of the stego image represent the secret messages. In addition, there are many other stego methods, such as EzStego, J-Steg, OutGuess, and F5. All of these methods can transmit secret messages imperceptibly in vision and ensure good quality of the stego images [2–4].There are two important issues for a steganography scheme, i.e., payload and security. Payload is the quantity of the embedded message in the cover image. The payload can be quantified as the embedding rate, which is the quantity of the embedded bits vs. the quantity of the pixels used for information hiding in the cover image. Security means that the embedded message should be visually and statistically undetectable. Statistical undetectability is more difficult to achieve than visual undetectability because there are many steganographic analytical methods [5–7]. Steganalysis, which was developed soon after steganography was first proposed, is the antithesis of steganography. Steganography imparts some statistical characteristics to the cover images, and these can be used by steganalysis to determine whether any secret messages are embedded in the cover images or not. Clearly, the larger the embedding rate is, the more detectable the stego image is. A good steganography scheme embeds as much information as possible while modifying the cover images as little as possible. To accomplish this, we must improve the embedding efficiency, i.e., embed more information per modification to the cover image [8,9].Matrix embedding steganography was proposed by Crandall [10] to achieve high embedding efficiency, and this method has been studied extensively [11,12]. In this method, the cover coefficients are perturbed minimally, such that the transmitted bits fall in a coset of the linear code, with the syndrome conveying the hidden bits. Matrix embedding steganography increases embedding efficiency and enhances the security of the steganography with the cost of decreasing the embedding rate. The Hamming codes were initially used for matrix embedding, in whichn−ksecret bits are embedded into n cover pixels by an [n, k] Hamming code. Fridrich proposed two novel matrix embedding steganographic schemes using simplex codes and random linear codes, respectively, and both schemes achieved higher embedding rates [13]. Zhang proposed a “Hamming+1” scheme in whichn−k+1secret bits were embedded into n cover pixels in every embedding group [14].One of the problems associated with matrix embedding is the excessive computational complexity of the embedding process. For a matrix embedding steganographic scheme using an [n, k] block code, the computational complexity isO(n2k)to find the modification to the cover image for every embedding group, whereO(⋅)means the number of bit operations [13]. Therefore, to keep the complexity and memory space low, the code dimension k should be small. In order to simplify the computational complexity, Gao et al. chose to find a vector in the coset that had a relatively small Hamming weight instead of finding a coset leader [15]. This scheme decreased the computational complexity at the cost of reducing the embedding efficiency to a certain degree. Chen et al. proposed to use the Walsh spectrum and the fast Hadamard transform to search for the optimal solution in the embedding process with a reduced computational complexity, and they proposed some methods to increase the embedding efficiency in this scheme [16]. Li et al. proposed a scheme that increases the embedding efficiency by a tree structure [17]. Hou et al. improved Liʼs method as a fast matrix embedding algorithm, which decreases the computational complexity of matrix embedding [18]. But compared with the original matrix embedding proposed in [13], both Liʼs algorithm and Houʼs algorithm decreased the embedding efficiency. Wang et al. proposed a fast matrix embedding scheme by extending the parity check matrix of the block code via some referential columns and achieved higher embedding efficiency and faster embedding speed [19].Recently, the usage of error correction codes for matrix embedding has been extended to convolutional codes. Filler et al. proposed a steganography using trellis-coded quantization [20,21]. In this scheme, the syndrome coding for secret embedding is based on Viterbi algorithm running in the dual domain, which provides an embedding efficiency closing to the upper bound [22].In this paper, we reduce the computational complexity of matrix embedding further and propose a novel fast algorithm for matrix embedding using Hamming code and random linear code. The proposed scheme has the same embedding efficiency as the conventional matrix embedding, but it has lower computational complexity for steganographic systems with low and medium embedding rates, compared with both the conventional matrix embedding and the trellis-coded quantization scheme. Notice that our goal is not to design a new matrix embedding scheme, but to propose a fast algorithm for matrix embedding using Hamming code and random linear code. The small block size of the code used in our scheme and the extremely low computational complexity make our fast algorithm very suitable for the low-power processors. The paper is organized as follows. In Section 2, some preliminaries are given. In Section 3, the characteristics of the conventional matrix embedding steganography are analyzed. Our novel fast embedding algorithm is proposed in Section 4, and the experimental results are presented in Section 5. Our conclusions and recommendations for future work are presented in Section 6.LetF2ndenote the Galois field of order 2 and length n; then,F2nis a space of all n-bit column vectorsx=(x1,x2,…,xn). The Hamming weightw(x)of vector x is defined as the number of ones in x. A binary linear [n, k] codeCof length n and dimension k is a k-dimensional linear sub-space ofF2n, in which the sum of two vectors and a multiplication of a vector by a scalar are defined using the usual binary arithmetics. Let m denote the message of length k, andm∈F2k. The mapping from any message m to the codeword c is called an encoding ofCby means of the generator matrix G, which is(1)c=mG,where the generator matrix G is a k-by-n matrix whose rows are basis vectors of codeC. The orthogonal complement of an [n, k] code is an [n,n−k] code with an(n−k)×ngenerator matrix H with the property thatHc=0for eachc∈C. This [n,n−k] code is called the dual code ofC, and the matrix H is called the parity check matrix of codeC.For any vectorx∈F2n, the vectors=Hxis called the syndrome of x. Note thats∈F2n−k, andx∈Cif and only if the syndrome of x is 0. For each syndrome s, the setE(s)={x∈F2n|Hx=s}is defined as a coset. For an [n, k] linear code, there are2n−kdisjoint cosets, each consisting of2kvectors. Among these vectors, the one that has the smallest Hamming weight is called a coset leader and is denoted aseL(s). For a linear codeC, there is a standard array that denotes all its cosets, as shown in Table 1.In Table 1, the first row of the array consists of all the codewords ofC. To form the second row, we choose a worde1with smallest Hamming weight that is not in the first row. Then we adde1to each word of the first row and get the second row, which is the first coset. In general, the ith row of the standard array is formed by choosing a wordeiwith smallest weight that is not yet in the array and adding it to each word of the first row. This process continues until the array contains all the words inF2n. The vectors in the first column of the standard array are the coset leaders.Digital image steganography modifies the gray value of the selected pixel in the cover image X according to the value of the secret message M, so that the stego image Y conveys M. Suppose that I andMare the sets of all possible values of the cover image and the secret message, respectively. In order to embed the secret message into the cover image, the transmitter needs a bit-assignment function, Emb, to generate the stego image Y. At the receiver side, the recipient gets the embedded informationM′by an extraction function, Ext.(2)Y=Emb(X,M),(3)M′=Ext(Y).Suppose thatlmmessage elements are embedded intolc1cover elements by modifyinglc2cover elements in an embedding process; then, the embedding rate, ER, and the embedding efficiency, EE, are defined as:(4)ER=lmlc1,(5)EE=lmlc2.One of the most popular bit-assignment functions for steganography is the least-significant-bit (LSB) replacement. In this method, the lowest bits of the chosen pixelsʼ values in the cover image are used to indicate the message bits. When embedding, if the LSB of the cover pixel is the same as that of the message bit, the gray value remains unchanged. If they are different, add 1 (or minus 1) to the cover pixel. At the receiver side, the recipient extracts the embedded message by reading the lowest bits of the chosen pixels in the stego image Y. The embedding and extracting processes are denoted as the following:(6)y(i,j)=Emb(x(i,j),m(l))={x(i,j),ifm(l)=x(i,j)mod2,x(i,j)±1,ifm(l)≠x(i,j)mod2,(7)m′(l)=Ext(y(i,j))=y(i,j)mod2,wherex(i,j)andy(i,j)are the gray values of the pixels in position(i,j)in the cover image and the stego image, respectively, andm(l)andm′(l)are the lth bit in the secret message stream and the extracted message stream, respectively. And(xmod2)is the remainder of(x/2).It is apparent that for the LSB replacement, the highest embedding rate ER is 1, when every pixel in the cover image has a secret bit embedded. And the embedding efficiency EE of the LSB replacement is 2. To reduce the influence of the embedded message on the cover image and make the hiding less detectable, matrix embedding steganography was proposed by researchers. In this method,n−kmessage bits are embedded into n cover image pixels by an [n, k] block codeC, of which parity check matrix is H. In the matrix embedding process, first, the transmitter reads the LSBs of n pixels in the cover image (denoted as vector x) andn−kmessage bits (denoted as vector m), which are defined as an embedding group. Then, the coset leader of the cosetE(m−Hx)is found and added to x. By this means, the stego image is achieved. The embedding process is indicated as the following:(8)y=Emb(x,m)=x+eL(m−Hx),whereeL(m−Hx)is the coset leader of which syndrome ism−Hx. This coset leader is the modification to the cover vector. By addingeL(m−Hx)to the cover vector x, the stego vector y is achieved.At the receiver side, sinceHy=H(x+eL(m−Hx))=Hx+m−Hx=m, the extracted messagem′is obtained by(9)m′=Ext(y)=Hy.The average changes, AC, to the cover image for an embedding group are equal to the average weight of all the coset leaders of the block codeC, as shown in the following(10)AC=12n−k∑i=12n−kw(eL,i(s)),whereeL,i(s)is the coset leader of the ith coset of which syndrome iss(i=1,…,n−k).Therefore, the embedding rate, ER, and the embedding efficiency, EE, of the matrix embedding scheme using an [n, k] block code are:(11)ER=n−kn,(12)EE=n−kAC=2n−k(n−k)∑i=12n−kw(eL,i(s)).Embedding rate is also defined as relative payload in some literatures. There is an asymptotic boundary of embedding efficiency [13], which is(13)EE⩽ERH−1(ER),whereH(x)=−xlog2x−(1−x)log2(1−x),0⩽x⩽0.5, is the binary entropy function.In the matrix embedding algorithm using an [n, k] linear block code, one of the biggest challenges is to find the coset leader,eL(m−Hx), in (8). The transmitter must solve a system ofn−klinear equations with n unknowns inF2n, therefore the computational complexity is high. Ref. [13] proposed a fast algorithm to findeL(m−Hx), which has a lower computational complexity, CC, for each embedding bit:(14)CC=O(n2kn−k).From (14) we can see that the computational complexity of the existing method exponentially increases with the number of k. Since the embedding rate, ER, is proportional ton−k, the higher the ER, the lower the computational complexity will be with a given n. But the steganography with low or medium embedding rate, which basically creates stego images with higher quality, is needed in some applications. But for the existing algorithm of matrix embedding, the computational complexity is extremely high when the embedding rate is low or medium, which can be seen from (11) and (14).In this section, we propose a fast embedding algorithm to find the coset leader for matrix embedding steganography using Hamming code. We assumed that the cover image X was gray-value images for which the range of pixel values was[0,255]and that the secret message M was a bit stream. When embedding a secret message using an [n, k] block codeC, we achieved the stego image by (8). Since the valueeL(m−Hx)is the coset leader with syndromem−Hx, we constructed the standard array of the codeCand searched for the coset leader according tom−Hxin the standard array. Since there are2n−kcosets of the [n, k] codeCand every coset has an (n−k)-bit syndrome, finding the coset leader requiresO((n−k)2n−k)computational complexity, at most.Take the [7,4] Hamming code as an example. The parity check matrix H is:(15)H=[100110101010110010111].All the cosets of this Hamming code are shown in Table 2. This table shows the syndromes and the coset leaders of all the 23 cosets of the [7,4] Hamming codeCwith the parity check matrix H.Assume that for an embedding group, the cover vector isx=[0000000], and that the secret message ism=[100]; then,m−Hx=[100]. Taking vector[100]as the syndrome to look up the coset leader in Table 2, we find thateL(m−Hx)=[1000000]. Then the stego vector y is:y=x+eL(m−Hx)=[0000000]+[1000000]=[(1000000)].At the receiver side, the embedded message is extracted by:m′=Ext(y)=Hy=[100].The lookup table method proposed above can be simplified further. The simplification is based on the following two criterions:•The syndromes and their coset leaders are one-to-one correspondent.Changing the positions of any two columns of the parity check matrix H doesnʼt change the characteristics of the Hamming code.Now, we can simplify the embedding algorithm using these two criterions. First, we change the positions of the columns in H to make all columns array in ascending (or descending) order in decimal form. Since the columns of the parity check matrix H of a Hamming code run over all the possible arrays of 0 and 1 (except[000]), we can make the decimal forms of matrix Hʼs column run from 1 to2n−k−1. By this means, the syndromes themselves indicate the coset leaders, and we donʼt have to memorize them in the table.Taking the above [7,4] Hamming code as an example, in our proposed fast embedding algorithm, first, we modify (15) to the following form:(16)Hem=[000111101100111010101].It is apparent that the decimal forms of all the columns in Hem change from 1 to 7 (from left to right). The syndromes and the coset leaders of this new code are shown in Table 3.From Table 3, it can be seen that, if the syndrome is transformed into the decimal form e, the eth bit (from left to right) in its coset leader is 1, and all the others are zeroes. This means that the eth bit in the cover vector x should be changed and that all the others should be unchanged. By this means, we embed the secret messages only according to the syndromes and donʼt have to maintain the table about the cosets of the codeC. For example, assume that the cover vector isx=[0000000]and the secret message ism=[100]; then,m−Hx=[100]. Since[100]is 4 in the decimal form, the 4th bit in x should be changed. Therefore, the stego vector isy=[0001000]. At the receiver side, the extracted vector ism′=Hy=[100]. By this means, the secret message is embedded and extracted correctly, and the computational complexity is low.The embedding process of our fast matrix embedding algorithm using Hamming code is shown as the following:1.In order to embedn−ksecret message bits into n pixels in the cover image, find an [n, k] Hamming code for which the parity check matrix is H.Change the positions of the columns in H to make all the columns arrange in ascending (or descending) order in decimal form.Take the next n pixels in the cover image, get the lowest bits of their gray values, and denote them as vector x. Read the nextn−ksecret message bits and denote them as vector m. Computem−Hx.Transformm−Hxinto a decimal number e.Change the lowest bits of the eth pixelʼs gray value among the n cover pixels, and keep the others unchanged. Then, the stego vector is achieved.The extracting process at the receiver side takes the next n pixels in the stego image, get the lowest bits of the pixelsʼ gray values, and denote them as vector y. Then, the extracted secret vector ism′=Ext(y)=Hy.The embedding rate, ER, and the embedding efficiency, EE, of our fast algorithm are same as the conventional matrix embedding algorithm using Hamming code, since the coset leaders in our fast algorithm is totally the same as those in the conventional algorithm. Therefore, ER and EE are shown as (11) and (12), respectively. Since the weight of every coset leader of the Hamming code is 1, the embedding efficiency, EE, of our fast algorithm can be denoted as the following:(17)EE=n−k12n−k(2n−k−1)=(n−k)⋅2n−k2n−k−1.The fast embedding algorithm proposed above does not depend on a lookup table algorithm or solving equations, so the computational complexity to find the coset leader isO(1), which means a constant complexity regardless of the input size.Matrix embedding steganography using Hamming code has a high embedding efficiency but a low embedding rate. In order to achieve a high embedding rate, many studies have sought to find some other linear block codes for matrix embedding. In Ref. [13], an embedding scheme was proposed that used random linear codes. A random linear code is a kind of block error correction codes that has the parity check matrixH=[In−k,D], whereIn−kis an(n−k)×(n−k)identity matrix, and D is an(n−k)×kmatrix, the elements of which are pseudo-randomly chosen fromF2. Random linear codes achieve the bound asymptotically (13)[23], and they have flexible coding rates. Therefore, we can achieve any embedding rate by constructing a random linear code with proper coding rate and small block size for matrix embedding steganography. A small block size is important for decreasing the computational complexity.But when the parity check matrix H is a pseudo-random matrix, finding the coset leader is a Nondeterministic Polynomial (NP) question. Therefore, Fridrich proposed a simpler method to find the coset leader for embedding process [13]. In this method, for the matrix embedding scheme using an [n, k] random linear code, the average computational complexity for every embedding bit is shown as (14).In this section, we propose a novel fast embedding algorithm for the random linear codes. Although the parity check matrix of the random linear code lacks the perfect structures of Hamming code, we can still use the syndrome to search for the coset leadereL(m−Hx)in the standard array and achieve the stego image by (8). For the random linear code, since there is an identity matrix in its parity check matrix H, some coset leaders can be denoted by the syndromes themselves. Assuming that the syndrome is vector s, its coset leadereLmay be:(18)eL=[s0],wheres=m−Hxand 0 is a1×kvector the elements of which are all zeroes. Therefore, we do not have to memorize all the coset leaders. For some cosets of which the coset leaders can be denoted by (18), we use the syndromes to indicate the coset leaders; and for the others, we memorize the coset leaders and their syndromes in a table. By this means, the size of the table for finding the coset leader is decreased.Assume that the number of the cosets of which the coset leaders cannot be indicated by their syndromes is p, then, there should be p syndromes in the table. Since every syndrome is an (n−k)-bits vector, the computational complexity of searching for the coset leader isp×(n−k). While for the rest2n−k−pcosets, the syndromes indicate their coset leaders by themselves and we donʼt have to search for them in the table. Therefore, the average computational complexity of each embedded bit in our fast algorithm is:(19)CC=O(p(n−k)n−k)=O(p).Taking an [8,2] random linear code as an example, the parity check matrix,H6⁎8, is:H6⁎8=[100000100100000000100011000100110000100000000101].The cosets of this [8,2] random linear code are shown as Table 4. This table lists the syndromes and their coset leaders of all the cosets, and it shows that most coset leaders can be indicated by (18). Only those marked coset leaders cannot be indicated by their syndromes, so we only memorize these cosets in a table. By this means, the size of the table can be decreased significantly. In addition, since the coset leaders found by the simplified table are the same as that found by the standard array, the embedding efficiency of our fast algorithm is the same as that of the conventional matrix embedding.The embedding process of our fast algorithm using random linear code is shown as the following:1.Choose the proper sizen−kof the secret message and the proper size n of the cover vector of an embedding group, according to the embedding rate ER.Construct the parity check matrix H of an [n, k] systematic random linear codeCR.Find the syndromes and the coset leaders of all the cosets. Separate these cosets into two parts. The first part includes those of which the coset leaders can be indicated by (18). The second part includes the rest of the cosets. Memorize the syndromes and the coset leaders of the second part in a table.Take the next n pixels in the cover image, get the lowest bits of their gray values and denote them as vector x. Read the nextn−ksecret message bits and denote them as vector m. Computem−Hx.Ifm−Hxbelongs to the first coset part, the modification to the cover vector iseL(m−Hx)=[s0], wheres=m−Hxand 0 is a1×kvector whose elements are all zeroes, therefore, the stego vector isy=x+eL(m−Hx)=x+[s0]. Ifm−Hxbelongs to the second coset part, findeL(m−Hx)in the table and add it to the cover vector.The extracting algorithm at the receiver side ism′=Ext(y)=Hy. The embedding rate, ER, and the embedding efficiency, EE, of our fast algorithm are the same as those of the conventional algorithm, as shown by (11) and (12), respectively. The computational complexity, CC, of our fast algorithm depends on the number, p, of the cosets that should be memorized in the table. The smaller p is, the lower CC is, shown as (19).An [n, k] Hamming codes is defined asn=2n−k−1. For an [n, k] Hamming code, there are n columns in its parity check matrix H and these columns run over all then−k-length vectors consisting of 0 and 1 (except the all-zero vector). Sincen=2n−k−1for the Hamming code, it is completely possible to use the columns of H to denote all of the decimal numbers varying from 1 to n by permuting the columns. By this means, all of the2n−kcoset leaders, which represent the distortion patterns to the cover vector in matrix embedding algorithm, can be directly denoted by the syndromes,m−Hx. Therefore, the proposed scheme provides exactly the same embedding effect as the conventional matrix embedding algorithm using the Hamming codes.For the proposed fast algorithm using the random linear code, if a coset satisfies (18), then, the coset leader can be directly deduced by its syndrome. Therefore, this coset can be removed from the standard array. If a coset does not satisfy (18), its coset leader and syndrome should be recorded in the table. This algorithm makes sure that the coset leader found by the simplified table is the same as that found by the standard array, therefore, the embedding efficiency maintains constant. The proposed scheme is applicable for the random linear code at the cost of maintaining a shortened standard array.When a large embedding rate is required, the [n, k] random linear code with the condition thatn≫kwill be used for embedding. For the proposed fast algorithm using the random linear code, the computation complexity depends on the amount of the cosets that do not satisfy (18). The more the cosets the random linear code has, the larger the table will be. Since the [n, k] random linear code has2n−kcosets, the large embedding rate will lead to increased computation complexity. Therefore, the proposed fast matrix embedding algorithm using the random linear code is more suitable for low and medium embedding rates, which is more secure from the point of view of the steganalysis.

@&#CONCLUSIONS@&#
A fast algorithm for matrix embedding steganography was proposed in this paper. In this scheme, the syndrome of the error correction code was used to search for the coset leader, which was the modification to the cover image. In addition, in order to simplify the searching process, we improved the parity check matrix of the Hamming code to make the syndrome indicate its coset leader by itself. By this means, we didnʼt have to search for the coset leader in a table when embedding with a Hamming code, and the computational complexity of the embedding process was reduced significantly. For matrix embedding using random linear code, our fast algorithm used the syndrome to indicate its coset leader for most cosets, and it searched for the coset leader by its syndrome for the rest. By this means, the size of the table for embedding was decreased significantly, and the computational complexity was reduced. Our fast algorithm has the same embedding rate and embedding efficiency as the conventional matrix embedding algorithms, while its computational complexity is significantly lower for the low and medium embedding rates. Besides Hamming code and random linear code, some other error correction codes are suitable for the matrix embedding steganography. Our future work may focus on finding the embedding schemes using these codes and the fast embedding algorithms for them.