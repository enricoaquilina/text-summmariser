@&#MAIN-TITLE@&#
Solving the traveling repairman problem on a line with general processing times and deadlines

@&#HIGHLIGHTS@&#
Resolving the complexity status of the Line-TRP with processing times and deadlines.Proof of strong NP-completeness by a reduction from 3-PARTITION.A new practically applicable best-first Branch & Bound procedure is proposed.Development of various lower bounds and dominance rules.Efficiency of the new approach is validated by a computational study.

@&#KEYPHRASES@&#
Line-traveling repairman problem,Optimal schedules,Complexity analysis,Branch,&,Bound,

@&#ABSTRACT@&#
This paper resolves the complexity status of the well-known Traveling Repairman Problem on a line (Line-TRP) with general processing times at the request locations and deadline restrictions. It has long remained an open research question whether an exact solution procedure with pseudo-polynomial running time can be developed for this version of the Traveling Repairman Problem that was known to be at least binaryNP-hard. The presented proof of strongNP-completeness of the problem is provided by a reduction from 3-PARTITION. Since recent literature provides significant new results for further variants of the Line-TRP and the Line-TSP, a brief updated overview of the complexity status of the different variants is given. Another major contribution is that a practically applicable exact best-first search Branch&Bound approach that optimally solves instances of real-world size in reasonable time is proposed. By applying sophisticated dominance rules as well as lower bounds, the number of enumerated partial solutions is kept limited. The efficiency of the new approach and the applied instruments is validated by a computational study.In this paper, the Line-Traveling Repairman Problem (Line-TRP) is considered. In the literature this problem is also known as the Delivery Man Problem or the Minimum Latency Problem (Luo, Qin, and Lim, 2014; Sitters, 2004). In this problem the pure delivery or pickup tour of a single vehicle has to be planned in order to minimize the total customer waiting time. If, however, the objective is to minimize the tour length or tour duration the Line-TRP becomes the Line-Traveling Salesman Problem (Line-TSP). In both problems (Line-TRP and Line-TSP) all customer locations to be visited are positioned along a single path where each location is unambiguously defined by its one-dimensional distance from a predefined starting point. While the general TSP and, therefore, also the TRP are stronglyNP-hard (Garey and Johnson, 1979; Gutin and Punnen, 2007; Lawler, Lenstra, Rinnooy Kan, and Shmoys, 1985), this does not necessarily rule out the existence of strongly polynomial or pseudo polynomial solution approaches for the Line TRP or the Line TSP. Specifically, the complexity status of these problems mainly depends on the existence of time window constraints as well as whether processing times at the customer locations occur.A complete overview of the complexity status of the different Line-TRP- as well as of corresponding Line-TSP-variants at that time can be found in Tsitsiklis (1992) and partly in De Paepe, Lenstra, Sgall, Sitters, and Stougie (2004). Based on the findings of Afrati, Cosmadakis, Papadimitriou, Papageorgiou, and Papakostantinou (1986), Tsitsiklis additionally resolved the complexity status of some other problem variants. However, since 1992 new significant results of the complexity status of Line-TSP- and Line-TRP-variants have been suggested in the literature. An updated overview is provided in Table 1. One major contribution of this paper is that it resolves the complexity status of the Line-TRP-variant with general processing times at the customer locations as well as with hard due date restrictions. Since a violation of these hard due dates is not allowed, we use the term deadline. Originally, Afrati et al. (1986) showed that the simpler variant with deadlines but zero processing times is already binaryNP-hard. This obviously also applies to the considered extended problem variant. Afrati et al. (1986) additionally developed an exact Dynamic Programming procedure with pseudo-polynomial running time for the simpler variant with zero processing times. However, whether such an algorithm for the considered problem exists is unknown (Tsitsiklis, 1992). For this reason, it has long remained an open question whether the problem is stronglyNP-hard.The considered variant of the Line-Traveling Repairman Problem with general processing times at the customer locations and deadlines has various practical applications. It is, for instance, applicable whenever geographical restrictions cause transportation processes to be executed along a predefined transportation path and deliveries have to be made before given deadlines. Such kinds of predefined transportation paths may occur if the delivery process is executed in specific regions, for example along a coastline, a mountain road, or in a valley. Another typical application scenario is inland shipping along a river where cargo has to be delivered to specific ports within given time restrictions. In order to maximize provided service quality, the total weighted waiting time at the ports is minimized (Psaraftis, Solomon, Magnanti, and Kim, 1990; Tsitsiklis, 1992).Furthermore, an application of the Line-TRP is possible if a time-critical production system has to be supplied in real-time with various materials. In order to guarantee efficient and safe transportation that fulfills existing time restrictions, these processes are often executed along predetermined transportation paths using tow trains (cf. Emde and Boysen, 2012; Emde, Fliedner, and Boysen, 2012). The resulting tour planning problem is a Line-TRP with individual station-dependent processing times and deadlines that result from a given production program. Since the available storage space at the assembly line is strictly limited, minimizing the resulting inventory levels at the production stations is pursued by applying the Line-TRP. Moreover, the considered Line-TRPTW variant can also be applied to scheduling problems of time-critical batch processes with specific sequence-dependent setup times. If these setup times are proportional to bridged machine state differences, each machine state is represented by a location and jobs are defined as requests (Bock and Klamroth, 2013; Pinedo, 2008). Furthermore, hard time restrictions are modeled as request deadlines.This paper provides two major contributions for the Line-TRP with general processing times at the request locations and hard due date restrictions (also denoted as deadlines):•The Line-Traveling Repairman Problem with general processing times and deadlines is proven to be stronglyNP-hard.A new practically applicable Branch&Bound algorithm that generates optimal solutions for the considered problem is proposed. By applying various specifically designed lower bounds and dominance rules, this algorithm solves problem instances of real-world size in reasonable time.The outline of the paper is as follows: First, a mathematical definition of the problem is provided in Section 2. Subsequently, the complexity proof that shows that the considered problem variant is stronglyNP-hard is presented in Section 3. In order to solve the problem, a new best-first search Branch&Bound procedure is introduced in Section 4. The practicability of the exact procedure is validated by a computational study in Section 5. A brief summary of the findings, conclusions, and suggestions for future research is provided in Section 6.In this section, the considered Line-Traveling Repairman Problem with general processing or handling times and deadlines is mathematically defined.N – Number of requests that have to be delivered. In what follows, these requests are referenced by indices i, j, or k.SN={1,…,N}denotes the set of requests.xi∈ IN – Position of the delivery location of request i ∈ SNmeasured in distance units from a predefined starting point. For technical reasons, we introduce an initial dummy request 0 with zero processing time and deadline (p0=d0=0) determining the initial vehicle position x0.L=|{xi|i∈SN}|– Number of different delivery locations of requests.ti, j– Traveling time from xito xj. Specifically, it holds that:ti,j={tu·(xj−xi)ifxj≥xitd·(xi−xj)otherwise,with tuand tddefining the time that elapses per distance unit upwards or downwards.di– Hard deadline of request i ∈ SN.pi– Processing time of the request i ∈ SNat its delivery location.A tour schedule is unambiguously defined by a permutationα=(α0,α1,…,αN)of the set SN∪{0}. The entry αidetermines the request that is delivered in tour stepi∈{0,1,…,N}. Moreover,αi−1provides the tour step that delivers request i ∈ SN∪{0}. Clearly, the dummy request 0 is always delivered first, i.e., it holds thatα0=0=α0−1. Moreover, for each request i ∈ SNthere is a request completion timeticthat results from the defined tour schedule.Correctness of completion times:∀i∈SN:tic=∑j=1αi−1tαj−1,αj+pαjAll requests are delivered in time:∀i∈SN:di≥ticThe objective of the model is to minimize the sum of request completion times:MinimizeC=∑i=1NticIn what follows, we prove that the Line-TRP with general processing times and request deadlines is stronglyNP-hard by using a reduction from 3-PARTITION (which is known to be stronglyNP-hard (Garey and Johnson, 1979)). By proving that this problem isNP-hard, the existence of a solution procedure that guarantees an optimal solution in pseudo-polynomial time is ruled out, unless it holds thatP=NP.An instance of 3-PARTITION is defined by an integerB∈Z+and a set A with|A|=3q. Set A contains the integers B/4 < aj< B/2,∀j=1,…,3q. An instance asks whether there exists a perfect partition of the set A into q disjoint subsets{A1,A2,…,Aq}such that|Ai|=3and∑aj∈Aiaj=B,∀i=1,…,q.The following reduction generates a specific tour scheduling problem with two groups of requests that have to be delivered. The first group consists of 3q small requests that represent the elements of 3-PARTITION. These small requests have a uniform processing time of L time units, but do not have a deadline. The second group comprisesq·(3q+2)large requests altogether with a significantly larger uniform processing time of M ≫ L time units. Note that, due to M ≫ L, the urgency of the large requests requires that these large requests be delivered in a fixed sequence that is depicted in Fig. 1. This sequence of requests forces the vehicle to move along the entire path from the first to the last location in each of the q cyclical rounds. In each round(3q+2)large requests are delivered while the tour passes by the delivery locations of the 3q small requests of the first group. If no small request is serviced during these rounds, the large requests that are delivered during the lth round are serviced exactly3·l·L+(l2+l)·Btime units before their deadline. Therefore, in order to reach a total completion time that is below a carefully chosen threshold, this slack time has to be completely used for servicing the 3L small requests during the L tours.Note that the considered instance of the Line-TRP is designed such that scheduling the delivery of a small requestj∈{1,…,3q}before the most closely located large request serviced in roundi∈{1,…,q}results in a short detour of time 2 · i · aj. Note that, due to dominance of the processing time of the large requests, this detour is necessary in order to keep the resulting total completion time below a predetermined threshold. Moreover, the tight deadlines of the large requests allow for the delivery of, at most, 3 · l small requests up to the end of round l. As mentioned above, the generated structure of the delivery locations of the large requests ensures that the durations of the necessary detours strictly increase from round to round. Specifically, the detour for servicing requestj∈{1,…,3q}in roundi∈{1,…,q}requires 2 · i · ajtime units. Furthermore, the deadline of the last visited large request in each roundi∈{1,…,q}is defined in such a way that it can be fulfilled only if the total detour in each preceding roundj=1,…,icoincides with 2 · j · B or if the resulting total completion time is not below the predetermined threshold. Hence, it can be concluded that the problem of finding a feasible tour that possesses a total completion time below the predefined threshold is equivalent to generating a feasible solution of 3-PARTITION. Specifically, the respective sets of three chosen small requests that are delivered in an identical round define a feasible solution of the given instance of 3-PARTITION, and vice versa. The details of this reduction are given in the proof of the following Theorem:Theorem 3.1The Line-TRP with general processing times and request deadlines is stronglyNP-hard.For a given instanceΦ=(a1,a2,a3,…,a3q−1,a3q)of 3-PARTITION, we define the following instance P(Φ) of the Line Traveling Repairman Problem. P(Φ) possesses3q+(3q+2)·qrequests that are separated into two groups. The first group comprises 3q small requests with the indices1,…,3qand a uniform processing timepi=L=1+(q4+256q3+132q2+103q)·B. Note that, due to256q3+132q2+103q=256q·(q+1)·(q+2)−6q2−5q,L is integral for all q ∈ IN.Furthermore, we have a second group ofq·(3q+2)large requests altogether. These large requests possess a considerably larger uniform processing timepi=M=1+(92q3+12q2+152q+1)·L. Again, due to92q3+12q2+152q=92q·(q+1)·(q+2)−32q·(q+1),M is integral for all q ∈ IN. The chosen values of the parameters M, L, and B ensure a strict hierarchy in the objective function. Specifically, for the occurring values, a larger multiplier of parameter M cannot be evened out by reduced multipliers of the parameters B and L. Analogously, a larger multiplier of L cannot be compensated for by smaller multipliers of B. Note that this strict hierarchy results from the fact that the defined values of M and L are computed by deriving an upper bound of the total completion time of an instance that corresponds to a perfect partition. This is carried out in the proof of Lemma 3.2. Conversely, in order to be able to identify those schedules that correspond to perfect partitions solely by their total completion time value (see the proof of Lemma 3.3), this upper bound and the defined values of M and L have to be tight. Note further that, due to the dominances of these parameters, the structure of the schedule is considerably simplified. This leads to the mentioned fixed sequence of the large requests and allows for the conclusion that at most 3 · l small requests are serviced up to the end of round l. Due to their restrictive deadlines, the large requests have to be scheduled into q rounds with3q+2requests each. The ith large request (1≤i≤3q+2) of round l (1 ≤ l ≤ q) obtains the unambiguous index3q+(l−1)·(3q+2)+i.We define the following position values for the requests of the first group that represent the elements of 3-PARTITION. Note that these requests have no deadlines:(1)∀i∈{1,…,3q}:xi=(i+1)·Manddi=∞In each of the q rounds there are3q+2large requests, respectively. The ith large request (1≤i≤3q+2) in the lth round (1 ≤ l ≤ q) that is indexed by3q+(l−1)·(3q+2)+iobtains the position valuex3q+(l−1)·(3q+2)+i. Note that, for technical reasons, we introduce the additional (dummy) parametersa0=a3q+1=0.(2)∀i∈{1,…,3q+2}:∀l∈{1,…,q}:x3q+(l−1)·(3q+2)+i=i·M−l·ai−1Moreover, the ith large request in the lth round possesses the deadline(3)d3q+(l−1)·(3q+2)+i=(9q·(l−1)+4·l+2·i−5)·M−l·ai−1+3·l·L+(l2+l)·BWe ask whether there exists a schedule with a total completion time strictly less thanCmax=(272q4+24q3+52q2−3q+1)·Mand show that this decision problem is equivalent to the considered instance Φ of 3-PARTITION. The structure of each feasible tour of the generated TRP-instance is given in Fig. 1. In order to simplify the technical proof, we separate it into different lemmas.□If Φ has a perfect partition then there is a solution of P(Φ) with total completion time strictly less than Cmax.Let us assume that the given instanceΦ=(a1,a2,a3,…,a3q−1,a3q)of 3-PARTITION is solvable. Then, there are q disjoint setsA1,…,Aq⊂Afulfilling the following restrictions:∀i∈{1,…,q}:|Ai|=3∧∑aj∈Aiaj=B∧⋃i=1qAi={a1,…,a3q}. We generate a corresponding feasible tour schedule S(Φ) of the defined instance P(Φ) that attains a total completion time strictly less than(272q4+24q3+52q2−3q+1)·M. In this schedule the large requests are delivered in the sequence that is given by their indices, i.e., these requests are iteratively delivered in q rounds. Moreover, a small requesti∈{1,…,3q}is delivered in roundl∈{1,…,q}if it holds that ai∈ Al. Then, it is delivered just before the delivery of the large request3q+(l−1)·(3q+2)+i+1.Note that, since the delivery location of the small requesti∈{1,…,3q}is l · aiunits above the delivery location of request3q+(l−1)·(3q+2)+i+1,this visit leads to an additional detour of length 2 · l · ai. Due to the fixed sequence of the large requests, the tour schedule S(Φ) obtains the simple basic structure that is depicted in Fig. 1. It starts in each roundl∈{1,…,q}at the position of the delivery location of the first large requestx3q+(l−1)·(3q+2)+1=M. Subsequently, the vehicle moves upwards from positionx3q+(l−1)·(3q+2)+1to positionx3q+(l−1)·(3q+2)+3q+2. After the completion of roundl∈{1,…,q−1},the vehicle turns the opposite direction and moves back to positionx3q+l·(3q+2)+1in order to start the subsequentl+1th round. Moreover, three short detours are integrated into each round for servicing a small requesti∈{1,…,3q}if it holds that ai∈ Al. Note that, due to the defined position of the subsequently visited large request3q+(l−1)·(3q+2)+i+1,such a detour that services request ai∈ Alin round l has a length of 2 · l · ai.First, we show that the generated schedule S(Φ) is feasible, i.e., it fulfills all deadlines. For this purpose, we consider an arbitrary large request3q+(l−1)·(3q+2)+ithat is the ith serviced large request in the lth round. Due to the defined tour schedule, the precedingl−1rounds deliver(l−1)·(3q+2)large requests and3·(l−1)small requests. The delivery of these large requests takes(l−1)·(2·(3q+1)+3q+2)·M=(l−1)·(9q+4)·Mtime units. Additionally, in order to deliver the small requests at the schedule positions defined above, we obtain a total detour of2·∑ai∈Akk·aiand a total processing time of 3L in roundk=1,…,l−1. In the lth round the delivery of the first i large requests requires(2i−1)·M−l·ai−1time units. Moreover, a preceding delivery of the three small requests of set Alleads to at most3L+2·∑ai∈All·aiadditional time units. Hence, we obtain the following upper bound of the completion time of the large request3q+(l−1)·(3q+2)+i:(l−1)·(9q+4)·M+(2i−1)·M−l·ai−1+3l·L+2·∑k=1lk·∑ai∈Akai=(9q·(l−1)+4·l+2·i−5)·M−l·ai−1+3·l·L+(l2+l)·B=d3q+(l−1)·(3q+2)+i.Second, we derive an upper bound of the total completion time of all large requests by summing up the upper bounds of request completion times that are derived above. This bound amounts to:∑l=1q∑i=13q+2((9q+4)·(l−1)·M+(2i−1)·M−l·ai−1+3l·L+2B·∑h=1lh)=(∑l=1q−1l·∑i=13q+2(9q+4)+∑l=1q∑i=13q+2(2i−1))·M−∑l=1ql·∑i=03q+1ai+(∑l=1ql·(9q+6))·L+2B·∑l=1q∑i=13q+2∑h=1lh=(q(q−1)·(3q+2)·(92q+2)+2q·∑l=13q+2i−(3q2+2q))·M−12(q2+q)·q·B+12q·(q+1)·(9q+6)·L+∑l=1q∑i=13q+2(l2+l)·B=(272q4+212q3+q2)·M+(92q3+152q2+3q)·L+(q4+196q3+72q2+43q)·BMoreover, we have to derive an upper bound of the total contribution of the small requests. During the lth round of the tour schedule (withl∈{1,…,q}) the delivery location of the first large requestx3q+(l−1)·(3q+2)+1is reached at time(l−1)·(9q+4)·M+(l−1)·3·L+2·∑k=1l−1(k·∑ah∈Akah)=(l−1)·(9q+4)·M+(l−1)·3·L+(l2−l)·B. Since three requests are delivered in each round, there is a total contribution of∑l=1q((l−1)·(27q+12)·M+(l−1)·9·L+3·(l2−l)·B). Moreover, as each small request i is delivered in some round l, it is additionally delayed in this particular round by at most2·i·M+3·L+2·l·∑ah∈Alah=2·i·M+3·L+2·l·Btime units. Because three small requests are delivered in each round, we obtain the following upper bound of the total additional delay:∑i=13q(2·i·M+3·L)+3·2B·∑l=1ql=3q·(3q+1)·M+9q·L+3·B·(q2+q)=(9q2+3q)·M+9q·L+3·(q2+q)·B.To sum up, we obtain the following upper bound of the contribution of all small requests:(9q2+3q)·M+9q·L+3·(q2+q)·B+∑l=1q((l−1)·(27q+12)·M+(l−1)·9·L+3·(l2−l)·B)=(9q2+3q)·M+12·(q2−q)·(27q+12)·M+∑l=1ql·9·L+3·(∑l=1q(l2−l)+2·∑l=1ql)·B=(9q2+3q)·M+(272q3−152q2−6q)·M+92(q2+q)·L+3·∑l=1q(l2+l)·B=(272q3+32q2−3q)·M+(92q2+92q)·L+(12(2q3+3q2+q)+32(q2+q))·B=(272q3+32q2−3q)·M+(92q2+92q)·L+(q3+3q2+2q)·BAll in all, we obtain the following upper bound of the objective function value:(272q4+212q3+q2)·M+(92q3+152q2+3q)·L+(q4+196q3+72q2+43q)·B+(272q3+32q2−3q)·M+(92q2+92q)·L+(q3+3q2+2q)·B=(272q4+24q3+52q2−3q)·M+(92q3+12q2+152q)·L+(q4+256q3+132q2+103q)·BDue to the definition of L and M, we conclude that:<(272q4+24q3+52q2−3q)·M+(92q3+12q2+152q+1)·L<(272q4+24q3+52q2−3q+1)·MConsequently, there exists a tour with a total completion time strictly less than(272q4+24q3+52q2−3q+1)·M.□If there is a solution of P(Φ) with a total completion time strictly less than Cmaxthen Φ has a perfect partition.We assume that S(Φ) is a feasible tour with a total completion time strictly less than(272q4+24q3+52q2−3q+1)·M. In what follows, we prove the following four basic characteristics of S(Φ):•Claim 1. All large requests are serviced in sequence of their indices.Claim 2. There are at most 3 · l small requests that are delivered in the first l rounds.Claim 3. There are exactly 3 · l small requests that are delivered in the first l rounds.Claim 4. If a small request i is delivered in the lth tour it is scheduled just before the large request3q+(l−1)·(3q+2)+i+1.Claim 1. All large requests are serviced in sequence of their indices.We assume the opposite. Specifically, there is a large request3q+(l−1)·(3q+2)+i(with 1 ≤ l ≤ q and1≤i≤3q+2) with a minimally chosen index, where, for the first time, it holds that a larger numbered large request is scheduled earlier. Therefore, all smaller numbered requests are serviced before in sequence of their indices. The minimum completion time of the delivery of request3q+(l−1)·(3q+2)+iamounts toM+((9q+4)·(l−1)+2·i−1)·M−l·ai−1=M+(9q·(l−1)+4l+2·i−5)·M−l·ai−1=d3q+(l−1)·(3q+2)+i+M−3·l·L−(l2+l)·B≥d3q+(l−1)·(3q+2)+i+M−q·3·L−(q2+q)·B>d3q+(l−1)·(3q+2)+i. Therefore, this tour is not feasible since it services request3q+(l−1)·(3q+2)+iafter its deadline. Consequently, we conclude that all large requests are serviced in sequence of their indices.    (Claim 1)□Because of Claim 1, we know that the tour S(Φ) comprises q cyclical rounds. Roundl∈{1,…,q}starts at location x0 (position M) and passes the locations of all large requests of round l. Before traveling back to x0, the3q+2nd large request is delivered at position(3q+2)·M.Moreover, due to the considerable distances between the delivery locations and the tight deadlines of the large requests, the delivery of a small requesti∈{1,…,3q}in a roundl∈{1,…,q}is possible only between the delivery of the large requests3q+(l−1)·(3q+2)+iand3q+(l−1)·(3q+2)+i+1or between the delivery of the large requests3q+(l−1)·(3q+2)+i+1and3q+(l−1)·(3q+2)+i+2. Otherwise, due to a detour of at least 2M, the deadline of the subsequently visited large request is exceeded.Claim 2. There are at most 3 · l small requests that are delivered in the first l rounds.Since small requests are not urgent (possess no deadlines), the sequence in which they are delivered is not fixed. However, by delivering the large requests in the given sequence, the lth round completes the delivery of its last request3q+(l−1)·(3q+2)+3q+2not before timeC3q+(l−1)·(3q+2)+3q+2min=(l−1)·(9q+4)·M+(2·(3q+2)−1)·M=(l−1)·(9q+4)·M+(6q+3)·M=(9q·l+4·l−3q−1)·M.The deadline of this large request is defined byd3q+(l−1)·(3q+2)+3q+2=(9q·l+4·l−9q+6q−1)·M−l·a3q+1+3·l·L+B·(l2+l). Since it holds thata3q+1=0,we haved3q+(l−1)·(3q+2)+3q+2=(9q·l+4·l−3q−1)·M+3·l·L+B·(l2+l)and derive a maximum remaining slack time ofd3q+(l−1)·(3q+2)+3q+2−C3q+(l−1)·(3q+2)+3q+2min=3·l·L+(l2+l)·B≤3·l·L+(q2+q)·B<(3l+1)·L. Consequently, the number of small requests that are delivered during the first l rounds is upper bounded by 3 · l.    (Claim 2)□Claim 3. There are exactly 3 · l small requests that are delivered in the first l rounds. This proposition is shown by deriving a lower bound of the total completion time of tour S(Φ) that proves that if there are less than three small requests per round the resulting total completion time is not strictly lower than(272q4+24q3+52q2−3q+1)·M. By processing the large requests in the predetermined sequence, we obtain at least a total completion time of:∑l=1q∑i=13q+2(l−1)·(9q+4)·M+∑l=1q∑i=13q+2(2·i−1)·M−∑l=1ql·∑i=13q+2ai−1=(∑l=1q(l−1)·∑i=13q+2(9q+4)+2q·∑i=13q+2i−(3q2+2q))·M−12·(q2+q)·q·B=(q2−q2·(27q2+30q+8)+9q3+12q2+4q)·M−12·(q3+q2)·B=(272q4+212q3+q2)·M−12·(q3+q2)·BClearly, if there are exactly three requests per round a simple lower bound of the total completion time of the small requests can be derived by summing up the time that is necessary to deliver the previously scheduled large requests. Specifically, for the three small requests that are delivered in round l we have a minimum delay by the preceding rounds of(l−1)·(9q+4)·Mtime units. Moreover, if a small request i is delivered in a tour l it is additionally delayed by at least 2 · i · M time units. This minimum delay is attained if request i is delivered just before the large request3q+(l−1)·(3q+2)+i+1. Furthermore, we have to add a total processing time at the visited delivery locations of small requests. This total processing time amounts, at least, to(3(l−1)+1)·L.Hence, we obtain the following lower bound of the total completion time of the small requests:∑i=13q2·i·M+3·∑l=1q(l−1)·(9q+4)·M+∑l=13q(3(l−1)+1)·L=(272q3+32q2−3q)·M+(272q2−32q)·LBy scheduling exactly three small requests in each round at the defined positions, we obtain the following lower bound lbCT of the total completion time of all requests:lbCT=(272q4+212q3+q2)·M−12·(q3+q2)·B+(272q3+32q2−3q)·M+(272q2−32q)·L=(272q4+24q3+52q2−3q)·M+(272q2−32q)·L−12·(q3+q2)·B>(272q4+24q3+52q2−3q)·M+(272q2−32q−1)·LWe consider the differenceCmax−lbCTof the predetermined threshold(272q4+24q3+52q2−3q+1)·Mand the derived lower bound value of the total completion time of a solution that delivers exactly three requests in each round. Since the difference is already less thanM−(272q2−32q−1)·L,we conclude that the schedule S(Φ) delivers exactly three small requests in each roundl∈{1,…,q}. Otherwise, i.e., if there is a first roundl∈{1,…,q}with strictly less than three delivered small requests, the contribution of the small requests is increased by at least 3 · M. This increase results from postponing the delivery of the last small request of round l after the delivery of the last large request3q+(l−1)·(3q+2)+3q+2of this round. However, a maximum of3q+q(3q+2)−1=3q2+5q−1requests may be delivered at mostL+2·l·max{ai|1≤i≤3q}time units earlier. Therefore, we obtain a modified lower bound value of at least(272q4+24q3+52q2−3q)·M+3M−(3q2+5q−1)·(L+2·l·max{ai|1≤i≤3q})≥(272q4+24q3+52q2−3q+3)·M−(3q2+5q−1)·(L+2·q·B/2)=(272q4+24q3+52q2−3q+3)·M−(3q2+5q−1)·L−(3q3+5q2−q)·B)≥(272q4+24q3+52q2−3q+3)·M−(3q2+5q)·L≥(272q4+24q3+52q2−3q+2)·M>Cmax. As a result, tour S(Φ) delivers exactly three small requests in each roundl∈{1,…,q}.    (Claim 3)□Claim 4. If a small request i is delivered in the lth tour it is scheduled just before the large request3q+(l−1)·(3q+2)+i+1.Analogous to the proof of Claim 3, we conclude that if a small request i is delivered in the lth tour it is scheduled just before the large request3q+(l−1)·(3q+2)+i+1. Otherwise, i.e., if the delivery of request i is scheduled after the delivery of the large request3q+(l−1)·(3q+2)+i+1the derived lower bound lbCT is increased by at least M, whereas all subsequent requests are delivered 2 · l · aitime units earlier due to an avoided detour of length 2 · l · ai. Moreover, the completion time of the large request3q+(l−1)·(3q+2)+i+1is reduced by2·l·ai+L. Consequently, the modified lower bound of the total completion time of the considered schedule would be at least(272q4+24q3+52q2−3q)·M+(272q2−32q)·L−12·(q3+q2)·B+M−(2·l·ai)·(3q2+5q−1)−L≥(272q4+24q3+52q2−3q+1)·M+(272q2−32q−1)·L−12·(q3+q2)·B−(2·q·B/2)·(3q2+5q−1)≥(272q4+24q3+52q2−3q+1)·M+(272q2−32q−1)·L−(72q3+112q2−1)·B≥(272q4+24q3+52q2−3q+1)·M+(272q2−32q−2)·L>(272q4+24q3+52q2−3q+1)·M=Cmax. Therefore, the resulting total completion time of the schedule is not smaller than Cmax, which contradicts the definition of S(Φ). (Claim 4)□In what follows, we denote the indices of the three small requests that are delivered in roundl∈{1,…,q}by r1, l, r2, l, and r3, land introduce the setRl={r1,l,r2,l,r3,l}. Therefore, the completion time of the last delivered large request in roundl∈{1,…,q}amounts toC3q+(l−1)·(3q+2)+3q+2=((l−1)·(2·(3q+1)+3q+2)+2·(3q+2)−1)·M+3·l·L+2·∑h=1lh·∑i=13ari,h=((l−1)·(9q+4)+6q+3)·M+3·l·L+2·∑h=1lh·∑i=13ari,h=(9q·l+4·l−3q−1)·M+3·l·L+2·∑h=1lh·∑i=13ari,h. Compared to the corresponding deadlined3q+(l−1)·(3q+2)+3q+2=(9q·(l−1)+4·l+6q−1)·M−l·a3q+1+3·l·L+(l2+l)·B=(9q·l+4·l−3q−1)·M+3·l·L+(l2+l)·B,we obtain a remaining slack time of(l2+l)·B−2·∑h=1lh·∑i=13ari,htime units.Since the tour schedule S(Φ) fulfills all deadlines, it holds that2·∑h=1lh·∑i=13ari,h≤(l2+l)·B=2·∑h=1lh·B,∀l∈{1,…,q}. Moreover, we know that∑h=1q∑i=13ari,h=q·B. Later rounds possess higher weights, i.e., round l possesses weight l. Hence, the earliest completion time of the last large request3q+(q−1)·(3q+2)+3q+2is attained if it holds that∑i=13ari,l=Bfor each roundl∈{1,…,q}. Then, this completion time amounts toC3q+(q−1)·(3q+2)+3q+2=(9q2+q−1)·M+3q·L+2·∑h=1qh·B=(9q2+q−1)·M+3q·L+(q2+q)·B=d3q+(q−1)·(3q+2)+3q+2. If, otherwise, there exists a first roundl∈{1,…,q}with∑i=13ari,l≠B,since∑h=1q∑i=13ari,h=q·B,we conclude that l < q. Moreover, due to∀h∈{1,…,l−1}:∑i=13ari,h=Band∀h∈{1,…,q}:2·∑k=1hk·∑i=13ari,k≤2·∑k=1hk·B,we obtainB−∑i=13ari,l=Δ>0. Consequently, the large request3q+(l−1)·(3q+2)+3q+2is delivered exactly 2 · l · Δ time units before its deadline. However, due to larger weights in later rounds, the last delivered request3q+(q−1)·(3q+2)+3q+2is delayed by at least2·(l+1)·Δ−2·l·Δ=2·Δ>0time units compared to a tour that fulfills∀h∈{1,…,q}:∑i=13ari,l=B. As shown above, this tour delivers the request3q+(q−1)·(3q+2)+3q+2just with the elapse of its deadlined3q+(l−1)·(3q+2)+3q+2. Consequently, this deadline is exceeded and, therefore, a first roundl∈{1,…,q}with∑i=13ari,l≠Bcannot exist in schedule S(Φ).All in all, we have shown that if a tour schedule S(Φ) exists with an objective function value strictly less than(272q4+24q3+52q2−3q+1)·Mit has the following attributes: First, all large requests are delivered in sequence of their indices as illustrated in Fig. 1. Second, there are always three deliveries of small requests per round. If the ith small request is delivered in round l its delivery is scheduled just before the delivery of the large request with index3·q+(l−1)·(3q+2)+i+1. Third, the delivery of a small request i in round l leads to an additional detour that delays the delivery of subsequently serviced requests by 2 · l · aitime units. Therefore, a schedule S(Φ) with a total completion time below the threshold(272q4+24q3+52q2−3q+1)·Mis feasible only if the three small requests r1, l, r2, l, and r3, lthat are delivered in tour l fulfill∑i=13ari,l=B. Consequently, by settingAi={ar1,i,ar2,i,ar3,i},∀i∈{1,…,q}tour schedule S(Φ) provides a feasible solution for the corresponding instance of 3-PARTITION. (Lemma 3.3)□Therefore, both problems are equivalent. This completes the proof of Theorem 3.1.Observation 3.4The feasibility problem of the Line-TRP with general processing times and deadlines is binaryNP-hard.Since the feasibility problem of the Line-TRP with general processing times and deadlines is equivalent to the feasibility problem of the Line-TSP with general processing times and deadlines, the proposition follows directly from the results presented in Bock and Klamroth (2013).□Note that it is still an open research question whether the feasibility problem of the Line-TRP or Line-TSP with general processing times and deadlines can be decided in pseudo-polynomial time. If this problem is proven to be stronglyNP-hard the complexity status of the Line-TSP variant with general processing times and deadlines would also be resolved. As indicated in Table 1, it remains an open research question as to whether there is a pseudo-polynomial solution approach for this problem.This section introduces a new best-first Branch&Bound procedure. It solves the Line-TRP with deadlines and general processing times to optimality. According to the mathematical definition of the problem in Section 2, (partial) schedulesα that are explored by this procedure are stored as partial sequences of requests that are assigned to their final position.In what follows, a formal definition of a (partial) schedule is provided. We assume that all requests are sorted according to non-decreasing deadlines, i.e., it holds that ∀i < j ∈ SN: di≤ dj. Moreover, if it holds that i < j anddi=djwe have pi≤ pj.Definition 4.1A schedule α is a vector(α0=0,α1,…,αf(α)−1)with∀i∈{1,…,f(α)−1}:αi∈SN. Entries αi∈ SN∪{0} (with 0 ≤ i ≤ N) represent a request to be delivered at locationxαi. The position f(α) ≥ 1 denotes the first vacant position in schedule α for the assignment of requests to be subsequently delivered. The setSs(α)={αk|1≤k≤f(α)−1}⊆SNgives the indices of requests with a fixed schedule position. Moreover, all other (currently unscheduled) requests are in setSu(α)=SN−Ss(α). A schedule α is denoted as a final schedule if and only if it holds thatf(α)−1=N. The completion time of a job αi∈ Ss(α) under schedule α is defined byCαiα=∑l=1i(tαl−1,αl+pαl). Moreover, it holds thatCα0α=C0α=0For all unscheduled requests j ∈ Su(α) of a schedule α we introduce the abbreviation lj(α) that gives a valid upper bound of the maximum position of the request j ∈ Su(α) in a final feasible schedule that coincides with α for the first f(α) positions. For request i ∈ SNthe setSiu(α)={k|k∈Su(α)andk≤i}gives the indices of all unscheduled requests that are more urgent or, if they have an identical deadline, the processing time is smaller than or equal to pi.The Branch&Bound approach transforms the initial scheduleαinit=(α0(=0))withf(αinit)=1into an optimal schedule by systematically enumerating all possible extensions. Specifically, in each branching step every unscheduled request is a possible candidate for addition at position f(α). Restrictions of possible candidates result from specific dominance rules introduced below. The enumeration process of the Branch&Bound approach is conducted in a best-first manner. The feasibility of an extension of schedule α intoα˜by appending requestα˜f(α)at position f(α) is checked by testing whether the earliest service time of each unscheduled request (includingα˜f(α)itself) i ∈ Su(α) that amounts toCα˜f(α)α˜+tα˜f(α),iis not larger than di.A substantially tightened feasibility check (and, based on this check, a first dominance criterion) is provided by the following Lemma.Lemma 4.2First dominance criterion (1stC)Let α be a schedule with a set ofnαu=N−f(α)+1unscheduled requestsSu(α)={σ1,…,σnαu}andσ1<σ2<…<σnαu. Then, α can be transformed into a feasible final schedule only if it holds that:∀αi∈Ss(α):dαi≥Cαiαand∀σi∈Su(α):dσi≥Cαf(α)−1α+∑j=1ipσj+lbαf(α)−1tvl({xσj|1≤j≤i}),with the following lower bound for traveling from the delivery location xhof a serviced request h ∈ Ss(α) to all locations of the set S⊆{xj|j ∈ Su(α)} (delivery locations of unserviced requests):lbhtvl(S)={tu·(max(S)−xh)ifxh<min(S)td·(xh−min(S))ifxh>max(S)min{tu·(max(S)−xh)+td·(max(S)−min(S)),td·(xh−min(S))+tu·(max(S)−min(S))}otherwiseConsequently, if α additionally fulfills the following condition:∃σi∈Su(α):∀σj∈(Su(α)∖Sσiu(α)):Cαf(α)−1α+∑k=1ipσk+pσj+lbαf(α)−1tvl(Sσiu(α)∪{σj})>dσiwithSσiu(α)={σ1,…,σi},we know that, if there exists an optimal final schedule αoptthat coincides with α for the firstf(α)−1positions, it holds that{αf(α)opt,…,αf(α)+i−1opt}=Sσiu(α).Clearly, the first part of the first proposition of the Lemma 4.2 that deals with the scheduled requests αi∈ Ss(α) is trivial. Hence, in order to prove the second part of the first proposition, we assume that there exists a request σi∈ Su(α) that does not fulfill the defined restriction. Therefore, in a final schedule β that is generated out of α and coincides with α for the firstf(α)−1positions there exists a requestσk∈{σ1,…,σi}withCσkβ=max{Cσjβ|1≤j≤i}anddσk≤dσi. Consequently, sinceCαf(α)−1α+∑j=1ipσj+lbαf(α)−1tvl(Sσiu(α))is a valid lower bound of the completion time of the last scheduled job of setSσiu(α)under schedule β, we concludedσk≤dσi<Cαf(α)−1α+∑j=1ipσj+lbαf(α)−1tvl(Sσiu(α))≤max{Cσjβ|1≤j≤i}=Cσkβ. Hence, β is not feasible and the proposition holds.Analogously, we prove the second part of Lemma 4.2. In order to do so, we assume that a partial schedule α fulfills the given restriction, but can be extended to a schedule β that coincides with α for the firstf(α)−1positions. Moreover, we assume that∃l∈{f(α),…,f(α)+i−1}:βl∉Sσiu(α). We consider jobσk∈Sσiu(α)withCσkβ=max{Cjβ|j∈Sσiu(α)}anddσk≤dσi. Since job σkis scheduled in β after visiting βl, it holds thatCσkβ=max{Cjβ|j∈Sσiu(α)}≥Cαf(α)−1α+∑k=1ipσk+pβl+lbαf(α)−1tvl(Sσiu(α)∪{βl})>dσi≥dσkTherefore, the schedule β is not feasible and it followsβl∈Sσiu(α).□In what follows, a second dominance criterion is introduced. It prevents the consideration of schedules where an equal set of requests is repeatedly assigned in a modified sequence without the current solution attaining an improvement.Lemma 4.3Second criterion (2ndC)A scheduleα=(α0(=0),…,αf(α)−1)outperforms a different scheduleβ=(β0(=0),…,βf(β)−1)which is visited later, if the following four characteristics apply:1.f(α)=f(β)>1,Cαf(α)−1α+tαf(α)−1,βf(β)−1≤Cβf(β)−1β,∑i=1f(α)−1Cαiα≤∑i=1f(β)−1Cβiβ,andSu(α)=Su(β).Based on the characteristics 1 and 4, we conclude that, if there is a feasible schedule δ withδ1=β1,…δf(β)−1=βf(β)−1,we can extend the schedule α by iteratively appending the requestsδf(α),…,δNand obtain the scheduleγ=(α0(=0),…,αf(α)−1,δf(α),…,δN). Consequently, due to the second characteristic and the assumed feasibility of schedule δ, we know that the schedule γ is also feasible. Moreover, due to the characteristics 2 and 3, it holds that∑i=1NCγiγ=∑i=1f(α)−1Cαiα+∑i=f(α)NCγiγ≤∑i=1f(β)−1Cβiβ+∑i=f(β)NCδiδ=∑i=1NCδiδ. Therefore, schedule β can be fathomed since all schedules that are subsequently enumerated in the corresponding subtree are dominated by solutions considered in the subtree starting at schedule α.□The following dominance criterion allows us to reduce the number of enumerated assignments at the last position f(α) of a currently considered schedule α. Specifically, two cases that allow for the exclusion of dominated requests are derived.Lemma 4.4Third criterion (3rdC)We consider a scheduleα=(α0(=0),…,αf(α)−1)and two currently unscheduled requests i, j ∈ Su(α), with pi≤ pj. Moreover, it either holds thatxi=xjand di≤ dj(case 1) or the following three characteristics simultaneously apply (case 2):1.xαf(α)−1≤xi<xjorxαf(α)−1≥xi>xj∀h∈Si,ju,r(α)∪{j}:dh+th,i≥di.∀k∈{1,…,|Si,ju,r(α)|}:k·pi≤tk,i,jmin(Si,ju,r(α))+ti,j+tj,i+(pj−pi),The setSi,ju,r(α)consists of all requestsk≠ithat are unscheduled in solution α and are located below xjif request i is also located below request j. If, otherwise, request i is located above request j, these are the unscheduled requestsk≠iwith a location above xj.For all numbersk∈{1,…,|Si,ju,r(α)|}the abbreviationtk,i,jmin(Si,ju,r(α))provides the minimum time necessary for visiting and servicing exactly k additional requests of setSi,ju,r(α)while the tour starts by leaving location xjand terminates with the delivery of request i at position xi.Then, if there exists an optimal final schedule αoptthat coincides with α for the firstf(α)−1positions, it holds that there also exists an optimal final scheduleβopt=(α0,…,αf(α)−1,βf(α)opt,…,βNopt)withβf(α)opt≠j.We assume that case 1 applies and for a feasible scheduleαf=(α0,…,αf(α)−1,αf(α)f,…,αNf),it holds thatαf(α)f=j. There exists a later positionl∈{f(α)+1,…,N}withαlf=i. Since it holds thatxi=xj,an exchange of both requests in the given schedule αfleads to a modified schedule β that possesses the total completion timeCtot(β)=Ctot(αf)−(pj−pi)·(l−f(α)). This results from the fact that all requests that are serviced between the positions f(α) and l are serviced(pj−pi)time units earlier. Since it holds that pi≤ pj, we conclude that Ctot(β) ≤ Ctot(αf). Moreover, the new schedule is feasible although request j is completed significantly later. Specifically, since request i is visited in the feasible schedule αfat timeCiαf≤diand di≤ djapplies, we conclude thatCjβ=Ciαf≤di≤dj. Therefore, schedule β is feasible and at least of the same quality as schedule αf. Hence, the proposition follows for case 1.The second case is up for consideration. Again, we assume that there is a feasible final scheduleαf=(α0,…,αf(α)−1,αf(α)f,…,αNf)withαf(α)f=j. There exists a later positionl∈{f(α)+1,…,N}withαlf=i. Moreover, we identify the latest position kl< l withxαklf≥xj(if xj> xi) or withxαklf≤xj(if xj< xi). Consequently, we conclude that the tour passes through position xjin the next step kl. Therefore, we modify the schedule αfas follows. Instead of servicing request j in step f(α) we service request i. Moreover, we service request j in stepkl+1. Thus, a new schedule β arises withβ=(α0,…,αf(α)−1,βf(α),…,βN)andβf(α)=i,βkl+1=jas well as with∀h∈{kl+2,…,l}:βh=αh−1f. For all other positions the schedules αfand β are identical. The course of the two tours αfand β is sketched in Fig. 2.We first directly compare the completion times of the requests i and j in both schedules αfand β. Specifically, schedule β completes the service of the request i exactlyti,j+pj−pitime units before schedule αfcompletes the delivery of request j. Moreover, schedule β completes the service of request j at least tj, itime units before schedule αfcompletes the service of request i. Therefore, according to the sum of the completion times of the considered requests i and j, we observe an improvement of at leastti,j+tj,i+pj−pi. Schedule β completes the service of both requests in stepkl+1and therefore at least tj, itime units earlier (while omitting the service of request i in step l) than under schedule αf. However, since schedule αfalready passes by the delivery location of request j between the steps klandkl+1,we have no additional detour and, therefore, the requestsβkl+2(=αkl+1f),…,βl(=αl−1f)are serviced exactly pitime units later than in the original schedule αf. All other requests are completed at the same time as under schedule αf. But, due to the choice of step kl, it holds that all delayed requests are in setSi,ju,r(α)or equal to request j.Clearly, if it holds thatl=kl+1then set{βkl+2(=αkl+1f),…,βl(=αl−1f)}is empty and we have to solely check whether request j is timely serviced in schedule β. Since schedule αfis feasible, we obtainCjβ=Ciαf−tj,i≤di−tj,i≤dj. The last inequality results from the second characteristic. Hence, we conclude that schedule β is feasible and outperforms α.In what follows, we assume thatl>kl+1and consider a requestη∈{αkl+1f,…,αl−1f}∪{j}. Since schedule αfis feasible, it holds thatCηβ+tη,i≤Cηβ+tη,αl−1f+tαl−1f,i≤Cαl−1fβ+tαl−1f,i=Ciαf≤di. Due toη∈Si,ju,r(α)∪{j},it holds thatdη+tη,i≥di(characteristic 2) and we conclude thatCηβ≤di−tη,i≤dη. Therefore, request η is timely serviced and schedule β is feasible.We compare the total completion times of the schedules αfand β. Clearly, the increase of the total completion time under schedule β due to a delayed delivery of the requests of set{βkl+2(=αkl+1f),…,βl(=αl−1f)}⊆Si,ju,r(α)amounts topi·(l−kl−1). However, due to the intermediate delivery of these requests, schedule αffurther delays the delivery of request i compared to schedule β. Thus, if ttot denotes this total travel and processing time, we obtainCβtot=Cαftot+pi·(l−kl−1)−ttot−ti,j−tj,i−pj+pi≤Cαftot+pi·(l−kl−1)−tl−kl−1,i,jmin(Si,ju,r(α))−ti,j−tj,i−pj+pi. Because of characteristic 3, we obtain:Cβtot≤Cαftot+pi·(l−kl−1)−tl−kl−1,i,jmin(Si,ju,r(α))−ti,j−tj,i−pj+pi≤Cαftot. Thus, schedule β outperforms the schedule αf. This completes the proof.□Clearly, since the third dominance rule is applied in each node of the enumeration tree, an efficient computation of the function valuestk,i,jmin(Si,ju,r(α))is required. However, the computation of the fastest feasible tour that services exactly k requests of setSi,ju,r(α)and fulfills all deadlines is equivalent to the k-TSP on the line (Blum, Ravi, and Vempala, 1996; Garg, 2005) with processing times and deadlines. This problem is a generalization of the optimization problem considered in Bock and Klamroth (2013) that is at least binaryNP-hard.In what follows, we propose a fast computable simple lower boundtk,i,jlb(Si,ju,r(α))that is based on a simple problem relaxation. This relaxation arises by neglecting the deadlines of the requests. Due to this relaxation, an optimal solution is trivially computable if the locations, through which the tour passes after leaving position xjand before servicing request i, are fixed. In order to find an optimal solution for this relaxation, we consider all possible constellations. Besides the initial interval [min {xj, xi}, max {xj, xi}], we enumerate all requestsh∈Si,ju,r(α)with xh> xi(if xi> xj) or with xh< xi(if xi< xj) as the most distant request to be visited on this tour. As depicted in Fig. 3, the location xhdefines a new setSi,j,xhu,r(α)that comprises all requests whose delivery locations are visited by this tour. The mathematical definition of setSi,j,xhu,r(α)is given by Lemma 4.5. In order to provide a lower bound value, the k requests of setSi,j,xhu,r(α)with minimal delivery time are serviced by this tour.Since all requests l that are serviced on this tour belong to setSi,ju,r(α),their delivery locations xlare larger than xjand not larger than xhif it holds that xi> xj. Otherwise, if it holds that xi< xj, we have xj< xl≤ xh. Therefore, after the service of request j, a fastest tour travels to a locationh∈Si,ju,r(α)with xh≥ xi(if xi> xj) or with xh≤ xi(if xi< xj). The tour ends with the service of request i at location xi. A minimum makespan is obtained by delivering k requests along this tour with minimal processing times. Clearly, if request h does not belong to these k requests the makespan of the currently considered tour is not minimal since the detour to location xhis not necessary.We find an optimal solution of this relaxation by enumerating all possible tour extensions that are defined by feasible choices of requesth∈Si,ju,r(α)with xh≥ xi(if xi> xj) or xh≤ xi(if xi< xj). This process starts with the smallest interval [min {xj, xi}, max {xj, xi}] and ends with the maximum interval[min({xj,xi}∪{xl|l∈Si,ju,r(α)}),max({xj,xi}∪{xl|l∈Si,ju,r(α)})]that comprises the locations of all requests of setSi,ju,r(α). A mathematical definition of this lower bound computation is provided by the following Lemma.Lemma 4.5The following formulas provide a lower boundtk,i,jlb(Si,ju,r(α))fortk,i,jmin(Si,ju,r(α)).∀k∈{1,…,|Si,ju,r(α)|}:tk,i,jlb(Si,ju,r(α))=min{tk,i,j,hmin|h=iorh∈Si,ju,r(α)withxh∉[min{xj,xi},max{xj,xi}]}.Itholdsthatt1,i,j,hmin={pζ1i,j,xh+tj,h+th,iif|Si,j,xhu,r(α)|≥1∞otherwise.Andfork>1:tk,i,j,hmin={∑l=1kpζli,j,xh+tj,h+th,i=tk−1,i,j,hmin+pζki,j,xhif|Si,j,xhu,r(α)|≥k∞otherwise,withSi,j,xhu,r(α)={{k|k∈Si,ju,r(α)andxh≥xk}ifxi≥xj{k|k∈Si,ju,r(α)andxh≤xk}otherwise={ζ1i,j,xh,…,ζ|Si,j,xhu,r(α)|i,j,xh}.ζi,j,xhorders the elements in sequence of non-decreasing processing times, i.e., it holds that∀l1,l2∈{1,…,|Si,j,xhu,r(α)|}:l1<l2⇒pζl1i,j,xh≤pζl2i,j,xhFor two considered requests i and j the needed valuetk,i,jlb(Si,ju,r(α))can be computed in asymptotic timeO(N·L).By neglecting all deadlines, the considered relaxed problem can be optimally solved by a tour with a simple structure. Specifically, it directly travels from the starting location xjto the other end of the visited interval [min {xj, xh}, max {xj, xh}] in order to deliver some request h withxh=xior withxh∈Si,ju,r(α)andxh∉[min{xj,xi},max{xj,xi}]. Subsequently, the tour is completed by traveling to location xi(ifxh≠xi). During this tour it services the k requests with smallest processing times of setSi,ju,r(α)that are positioned in the interval [min {xj, xh}, max {xj, xh}], i.e., the k requests with smallest processing times of setSi,j,xhu,r(α). Since this tour has a minimal makespan, request h is one of the serviced requests. All alternative tours are iteratively enumerated by the recursive formulas given above. This process starts with the smallest interval [min {xj, xi}, max {xj, xi}]. All other alternatives are considered by defining a jobh∈Si,ju,r(α)withxh∉[min{xj,xi},max{xj,xi}]and a corresponding interval [min {xj, xh}, max {xj, xh}]. Since the alternative with minimum makespan is chosen, the relaxed problem is solved to optimality by the recursive formulas given above.Clearly, by maintaining a sorted list of unscheduled requests in sequence of non-decreasing processing times, all valuestk,i,j,hlb(Si,ju,r(α))can be iteratively computed fork=1,…,|Si,ju,r(α)|in total timeO(N). In each iteration, we only have to add the next smallest processing time in the current interval of locations. Since there are at mostO(L)intervals to be considered, we obtain a total asymptotic running time ofO(N·L).□After assigning a new request to position f(α), the application of the third dominance rule causes a total asymptotic running time of at mostO(N2·L)since up toO(N)requests have to be evaluated for i.Three lower bounds are additionally applied in each node of the enumeration process. The first lower bound sums up minimum completion times of all unscheduled jobs j ∈ Su(α). The minimum completion time is derived by assuming that the respective request j is directly serviced after the delivery of the current last requestαf(α)−1. Therefore, the first lower bound of a currently considered schedule α amounts to:lb1(α)=∑j∈Su(α)tαf(α)−1,j+pjA second lower bound results from optimally solving a derived instance of the Linear Assignment Problem (LAP) (see Ahuja, Magnanti, and Orlin, 1993; Burkard, DellÁmico, and Martello, 2012; Harold and Kuhn, 1955). Assignment costs in this instance are defined by the minimum completion time of unscheduled requests that are assigned to the vacant schedule positions. Specifically, a lower bound of the resulting completion timeCj,klbis derived for the scenario of scheduling request j ∈ Su(α) at the vacant positionk+f(α)∈{f(α),…,N}. In order to determineCj,klb,we slightly modify the definition oftl,i,jmin(Si,ju,r(α))(withl=k−1) used in Lemma 4.4 and in Lemma 4.5. For this purpose, the abbreviationtl,jmin(Su(α))is introduced. It gives the makespan of a fastest tour that starts after the completion of the service of requestαf(α)−1at timeCαf(α)−1αand terminates with the delivery of request j. Between these two steps the tour services exactlyl=0,…,|Su(α)|−1additional requests of set Su(α)∖{j}.Again, we neglect the deadlines in order to provide a fast computable lower bound value denoted astk,jlb(Su(α)). Analogous to the derivation of the lower boundtk,i,jlb(Si,ju,r(α))in Lemma 3, we propose an iterative computation of parameterstk,j,a,bmin. As illustrated in Fig. 4,tk,j,a,bmingives the minimum makespan for traveling along the entire interval [xa, xb] that is defined by two requests a, b ∈ Su(α)∖{j} withxa≤min{xαf(α)−1,xj}andxb≥max{xαf(α)−1,xj}plus servicing exactly k requests of set Su(α)∖{j} that are positioned in this interval. Note that a fastest tour whose makespan determines the lower bound valuetk,jlb(Su(α))has such a structure. All requests of set Su(α)∖{j} that possess a delivery location in the interval [xa, xb] constitute the setSj,a,bu(α)={k|k∈Su(α)∖{j}andxb≥xk≥xa}(see Fig. 4). The valuetk,j,a,bminis computed by choosing the k requests with minimal processing times for delivery. In order to simplify the mathematical definition of the lower bound computation that is given by Formula (4), we introduce the mapping ηj, a, bthat sorts the elements of setSj,a,bu(α)in sequence of non-decreasing processing times. It holds thatSj,a,bu(α)={η1j,a,b,…,η|Sj,a,bu(α)|j,a,b}with∀l1,l2∈{1,…,|Sj,a,bu(α)|}:l1<l2⇒pηl1j,a,b≤pηl2j,a,b.By enumerating all intervals [xa, xb] (with suitable requests a, b ∈ Su(α)∖{j} fulfillingxa≤min{xαf(α)−1,xj}andxb≥max{xαf(α)−1,xj}),tk,jlb(Su(α))is computed as the minimumtk,j,a,bmin-value for k ≥ 1. If otherwise, we havek=0,there is no intermediate request to be serviced before the delivery of j andtk,jlb(Su(α))amounts to the pure travel timetαf(α)−1,j. Therefore, the lower bound valuetk,jlb(Su(α))is iteratively computed by the following formulas:(4)∀j∈Su(α):t0,jlb(Su(α))=tαf(α)−1,jand∀k∈{1,…,|Su(α)|−1}:tk,jlb(Su(α))=min{tk,j,a,bmin|a,b∈Su(α)∖{j}withxa≤min{xαf(α)−1,xj}andxb≥max{xαf(α)−1,xj}},witht1,j,a,bmin={pη1j,a,b+min{tαf(α)−1,a+ta,b+tb,j,tαf(α)−1,b+tb,a+ta,j}if|Sj,a,bu(α)|≥1∞otherwiseandtk,j,a,bmin={pηkj,a,b+tk−1,j,a,bminif|Sj,a,bu(α)|≥k∞otherwise.Clearly, all entriestk,jlb(Su(α))can be computed by using the valuestk,j,a,bminfork=0,1,…,|Su(α)|−1. Hence, by applying the recursive Formula (4) that generates each entry in timeO(1),we obtain a total asymptotic running time ofO(N2·L2)for preparing the cost matrixCj,klbwithCj,klb=tk,jlb(Su(α))iftk,jlb(Su(α))≤djandCj,klb=∞,otherwise. Furthermore, the generation of the second lower bound value requires the subsequent application of the Hungarian method for finding a schedule with a minimum sum of lower bound values. This procedure causes an additional asymptotic running time ofO(N3)(see Ahuja et al., 1993; Burkard et al., 2012; Harold and Kuhn, 1955). All in all, we obtain a running time ofO(N2·L2+N3).A third lower bound arises by optimally solving a relaxed variant of the considered Line-TRP instance. This variant ignores processing times of the requests at their delivery locations, i.e., it definespi=0,∀i∈SN. However, deadlines of the requests are reduced by subtracting the respective original processing times. This leads to the well-known variant of the Line-TRP that, although proven to be already binaryNP-hard, can be efficiently solved by a pseudo-polynomial algorithm (see Afrati et al. 1986 as well as Table 1). Consequently, the objective function value of the generated optimal solution provides a lower bound of the considered problem that includes request processing times at the delivery locations.In order to compute the third lower bound in each node, the Dynamic Programming procedure proposed by Afrati et al. (1986) is applied. If this procedure does not result in a feasible solution, the original partial problem is not solvable as well and the respective node is fathomed. After being generated, the schedule that is found by the Dynamic Programming procedure is tested to find out whether it still fulfills all deadlines after integrating the given request processing times. If so and the schedule additionally outperforms the best currently known solution, it is stored as a candidate for an optimal solution. Consequently, the application of the third lower bound allows the generation of upper bounds during the best-first enumeration process.In what follows, the efficiency of the introduced Branch&Bound approach is validated. Specifically, the effectiveness of the proposed dominance rules as well as of the lower bounds is analyzed in detail. For this purpose, this section provides a brief introduction of the utilized test environment, the generated test instances, and the applied versions of the Branch&Bound approach.The different Branch&Bound variants were coded in C++. Each variant is characterized by an individual set of dominance rules as well as of lower bounds that are activated. Based on the respective numbers of lower bounds (L) as well as of dominance rules (D) that are activated, the applied variants of the Branch&Bound procedure are simply denoted as B&B-L1D1, B&B-L13D1, B&B-L13D12, B&B-L13D123a, B&B-L13D123, and B&B-L123D123. Note that, besides the lower bounds 1 and 3 as well as the dominance rules 1 and 2, the variant B&B-L13D123a checks only the first (much simpler) case of the third dominance criterion. All computational tests were conducted on an Intel Core i7-3770 with Ivy-Bridge and 3.4 GHz CPU that is equipped with 32GB working memory.In order to evaluate the performance of the different Branch&Bound versions, various test instances were randomly generated. Depending on the number of requests to be serviced, the number of delivery locations, the tightness of the request deadlines, and the significance of request processing times at the delivery locations, these instances were clustered into different groups. Since we settu=td=1in all test instances, travel durations solely result from randomly drawing the positions of the predetermined number of delivery locations out of the equally distributed integer interval [0, 2000].After the generation of the delivery locations we assign a first request to each location. Subsequently, in case of N > L, all remaining requests are randomly assigned to the L locations. Consequently, the average travel timet¯tvlcan be computed byt¯tvl=∑i∈SN∑j∈SN∖{i}|xi−xj|N·(N−1). Depending on the respective experiment group, the processing times of the requests are randomly drawn out of the equally distributed interval[t¯tvl·tf,min100,t¯tvl·tf,max100],while for the class of moderate processing times, we apply the parameter settingtf,min=3andtf,max=25. If an experiment of the class with significant processing times is generated these parameters are increased totf,min=10andtf,max=60.Based on the generated requests and delivery locations, corresponding deadlines are determined by simulating 100 randomly generated tours. Each of these tours starts at the location of the initial dummy request that is randomly drawn beforehand. In each subsequent iteration the next visited customer is randomly drawn out of at most 10 unserviced requests with a minimal direct completion time. For a partial schedule α this direct completion time of an unserviced request j ∈ Su(α) amounts totαf(α)−1,j+pjand defines the case in which the respective request is serviced immediately. After the generation of the 100 schedules the one with the minimum makespan is chosen in order to derive the deadlines of the different requests. Depending on the completion timetifcof each request i in the fastest generated tour, a request-individual deadline factorfidis randomly chosen out of the equally distributed interval[fmaxd,fmind]. Subsequently, the deadline diof request i is determined by⌊fid·tifc100⌋. In case of tight deadlines, the parametersfmaxdandfmindare set to 120 and 110, respectively, while a moderate scenario is tested by setting these parametersfmaxdandfmindto 140 and 120. Finally, the most relaxed deadline structure is provided in the third scenario characterized byfmaxd=160andfmind=140.Seven settings out of the number of generated requests and locations (these are the tuples(N,L)=(40,40),(50,40),(50,50),(60,30),(60,40),(60,50),(60,60)) are combined with the three deadline and two processing time scenarios. As a result, 42 problem groups, which respectively comprise 10 instances, are generated. In the conducted 420 tests the running time per instance is limited to at most 6 hours (i.e., to 21,600 seconds). After the elapse of these 6 hours the algorithm switches to a heuristic state that prefers considering schedules with a minimum total completion time per assigned requests in order to attain first solutions earlier. Clearly, due to theNP-hardness of the feasibility variant of the considered problem (see Observation 3.4), the heuristic state can neither guarantee finding a feasible solution nor prove that such a solution does not exist. Furthermore, since the Branch&Bound approach (also in the heuristic state) terminates when a first completed solution is taken from the heap of partial schedules, the optimality of the found schedule is no longer proven.In this section, we directly compare the results of the six implemented Branch&Bound procedures for the 420 instances that are clustered into 42 problem groups. Each group is characterized by a tuple (N, L, D, P). The parameters N and L give the predetermined numbers of generated requests and locations, respectively. D ∈ {T, M, R} defines the deadline structure (introduced in Section 5.1) that is either tight (D=T), moderate (D=M), or relaxed (D=R). Finally, the parameter P ∈ {M, S} determines the relative size of the processing times at the request locations. If it holds thatP=Mthese times are of moderate size (see Section 5.1 for details), otherwise (P=S) they are significant. Table 2provides the average results of the applied Branch&Bound versions for all 42 experiment groups. Note that the used abbreviation “N.a.” (not applicable) indicates that a problem group cannot be explored due to memory problems. Since not all instances were solved to optimality after 6 hours in each group, two average time values are given. While the first value gives the average computation time of the respective version over all 10 instances, the second value excludes instances that were not solved to optimality by all versions. Consequently, without being distorted by unsolved instances, the second value illustrates the relative dominance of the best Branch&Bound version more clearly. Note that we denote an instance as (optimally) solved only if the applied procedure has been able to completely explore the solution space of the considered instance. By doing so, the optimality of the generated solution is proven or it is proven that the considered problem is unsolvable.By analyzing the results of Table 2, it becomes obvious that if a given instance possesses considerable complexity, best average results are attained by applying the Branch&Bound version B&B-L123D123. This version uses all bounds and dominance rules that are introduced in Section 4. Specifically, apart from some problem groups with a moderate complexity, B&B-L123D123 significantly outperforms all other procedures for the majority of more complex instances. Therefore, if B&B-L123D123 does not solve an instance to optimality within 21,600 seconds, no tested version was successful. In contrast, B&B-L123D123 was able to optimally solve various complex instances that were not solved to optimality by all other variants. For instance, while B&B-L13D12, B&B-L13D123a, and B&B-L13D123 only solve 4 of 10 experiments of group (60,60,M,S) to optimality, B&B-L123D123 solves five further instances within the given time limit. All in all, B&B-L123D123 proves the optimality of the generated tour in 382 of 420 cases, while the other variants B&B-L13D123, B&B-L13D123a, and B&B-L13D12 solve only 327, 323, and 308 instances to optimality, respectively.Therefore, by applying sophisticated bounds and dominance rules, problem instances of real-world size can be solved to optimality in reasonable time by B&B-L123D123. Furthermore, detailed analyses of the measured results indicate that a considerable amount of computational time is frequently utilized to prove that the best found schedule is optimal. Therefore, it can be conjectured that B&B-L123D123 also provides almost optimal solutions of the 38 remaining instances that are not enumerated completely. This is underscored by the fact that the relative improvement of the average objective function value attained by B&B-L123D123 in direct comparison to the second best variant B&B-L13D123 is comparable with instances where B&B-L123D123 is solely able to prove optimality. Moreover, in comparison to the second best procedure B&B-L13D123, the average running time was significantly reduced for almost all experiment groups with a considerable complexity. These improvements can be ascribed to the fact that the activation of the second lower bound was able to tighten the average lower bound values by approximately 10 percent. While the first lower bound does not provide competitive results (this bound was outperformed by approximately 90 percent on the average), the average difference between the third and the second bound increases with larger problem sizes as well as with larger processing times. The latter effect can be ascribed to the fact that unlike the second bound, the third lower bound does not cover the impact of larger processing times on the optimal tour. Note that the third lower bound only reduces the request deadlines accordingly, but the applied relaxation assumes a zero handling time at the delivery locations. Hence, the average gap between the lower bounds two and three increases to approximately 12 percent for the most complex experiment group (60,60,R,S). In comparison to the two other bounds, the first lower bound does not provide competitive results. Specifically, this bound was outperformed by approximately 90 percent on the average.By significantly tightening the applied lower bound values, B&B-L123D123 generates a sequence of partial solutions on the priority heap that more reliably estimates the quality of the solutions of underlying subtrees. For complex problems, therefore, the number of explored partial solutions is between 5 to almost 17 times larger if B&B-L13D123 is applied instead of B&B-L123D123. In direct comparison to B&B-L13D123, larger running times of B&B-L123D123 for solving less complex instances result from the significant computational effort (O(N2·L2+N3)(see Section 4)) of the second lower bound. In these cases the reduced number of enumerated partial solutions does not yet prevail against the increased computational effort for handling each partial solution.Apart from the indicated relevance of the second lower bound for solving complex instances, the application of the second dominance criterion is of particular importance. By comparing the results of the versions B&B-L13D1 and B&B-L1D1 with the results of the other approaches, it becomes obvious that the deactivation of the second dominance criterion leads to substantial memory problems. This already applies to the experiment groups of lowest complexity. Specifically, a detailed analysis of the results of B&B-L13D1 and B&B-L13D12 for the smallest experiment groups with 40 requests and locations reveals that the average number of explored partial solutions is 178–382 times larger if the rule is deactivated. This clearly shows that the application of the second dominance criterion is a prerequisite for ensuring the practicability of the Branch&Bound approach. It obviously avoids a repeated enumeration of a huge number of partial solutions with an identical set of assigned requests. Due to considerable memory problems, the versions B&B-L13D1 and B&B-L13D12, that do not apply the second dominance criterion, solve only a few instances with more than 40 requests.Compared to the second dominance rule, the impact of the third dominance criterion is substantially smaller. However, although its computation requires the additional effort ofO(N2·L),the positive consequences of this rule are also significant. Note that this applies to both cases of the rule. By comparing the attained results of B&B-L13D123 with the ones of versions B&B-L13D12 and B&B-L13D123a, considerable reductions of the number of enumerated partial solutions can be observed if the third dominance rule is additionally applied and includes both cases. By activating the complex second case of the third dominance criterion, B&B-L13D123 considerably outperforms B&B-L13D123a. Specifically, it attains speedups of more than 20 percent of the average running time for instances that were optimally solvable by at least one approach. In comparison to B&B-L13D12 (that deactivates the dominance criterion completely), this speedup was further increased to almost 30 percent. Due an increased usage of the first case of the rule, B&B-L13D123 attained the most significant improvements compared to B&B-L13D12 for solving instance groups with a larger N/L-ratio (e.g., for the experiment groups withN=60,L=30,40). The simultaneous application of both rules (implemented in B&B-L13D123 and B&B-L123D123) is most effective for these instance groups, since a larger N/L-ratio makes the applicability of the first case more likely.As indicated by the results of Table 2, the average complexity of the generated instances approximately increases with a more relaxed deadline structure and with a larger ratio of average processing time divided by average travel time. This complexity increase can mainly be ascribed to the fact that, in these cases, a considerably smaller number of possible schedules can be fathomed because of deadline violations. Moreover, larger relative request processing times may increase the possibility that the optimal tour comprises a larger number of turnarounds. Therefore, the exploration process has to enumerate a substantially larger number of possible tours that, otherwise, would have been fathomed in early steps. Consequently, largest average computational times are observed for the instances with a relaxed deadline structure and significant processing times (i.e., the last listed experiment groups that are denoted as (60, 30, R, S), (60, 40, R, S), (60, 50, R, S), and (60, 60, R, S)). Since the efficiency of the various proposed lower bounds and dominance rules obviously increases with the complexity of the solved instances, B&B-L123D123 significantly outperforms other versions the most for these experiment groups.In order to further evaluate the competitiveness of the proposed Branch&Bound algorithms, the performance of B&B-L123D123 is additionally compared with CPLEX 12.6. In order to do so, the MIP model of the considered Line-TRP variant was built by using the concert library for C++. The formulation of the MIP-model that is solved by CPLEX 12.6 is based on0.5·(N2−N)binary sequencing variables and N continuous variables defining the completion times of the requests (Manne, 1960; Roshanaei, Azab, and ElMaraghy, 2013). However, preliminary tests indicated that the test instances of the considered 42 problem groups are much too complex to be optimally solved by CPLEX 12.6 in reasonable time. Therefore, as depicted in Table 3, a second set of smaller sized instances was generated and solved by B&B-L123D123 and CPLEX 12.6. This set consists of 12 additional problem groups with 10 instances each. Depending on the respective problem group, each instance possesses 30 requests that are positioned at 20 or 30 locations. Analogous to the first set of 42 problem groups, the due date structure of the requests are either tight, moderate, or relaxed while delivery times are either moderate or significant. The available running time per instance was not limited.It is worth mentioning that CPLEX 12.6 simultaneously executes 8 threads that use the processing power of the 4 cores of the Intel Core i7-3770 efficiently by hyper-threading. Since B&B-L123D123 uses only a single thread, this setting considerably benefits CPLEX.Despite this significant disadvantage, the results in Table 3 show that B&B-L123D123 substantially outperforms CPLEX 12.6 for all tested instances. Due to the application of sophisticated bounds and dominance criteria, the average running time of the Branch&Bound approach is smaller than or equal to 2 seconds for all problem groups. Most of the instances were solved to optimality by B&B-L123D123 in less than 1 second while the longest computation took 14 seconds. In contrast to this, the performance of CPLEX is much worse. Due to excessive memory consumption, CPLEX is even unable to optimally solve the problems of the five groups 8–12. Particularly, the relaxed due date structure of the problem groups 9–12 leads to an increased complexity that was not manageable by CPLEX. Furthermore, for the optimally solved problem groups 1–7, the average running time of CPLEX was between 1,975 and 1,008,059 times larger in comparison to B&B-L123D123. For instance, CPLEX needs between 76 minutes and more than 68 hours to optimally solve the instances of problem group 7, while B&B-L123D123 optimally solved each of these problems in at most 1 second. Therefore, the application of CPLEX 12.6 is strongly limited to smaller sized instances, while B&B-L123D123 can be used to optimally solve instances with up to 60 requests and 60 locations in reasonable time. This additionally underscores the competitiveness of the proposed Branch&Bound approach.

@&#INTRODUCTION@&#


@&#CONCLUSIONS@&#
This paper resolves the complexity status of the well-known Traveling Repairman Problem on a line with general processing times at the request locations and deadlines. This had remained an open research question for a long time. In the paper, the problem variant is found to be stronglyNP-hard. Therefore, there is no exact solution procedure with strongly polynomial or pseudo-polynomial running time possible unless it holds thatNP=P. Apart from this significant result, the paper proposes the first known practically applicable exact solution approach. The best performing Branch&Bound variant B&B-L123D123 is able to solve instances with up to 60 requests and locations to optimality despite relaxed deadline restrictions and considerable processing times. The practicability of the Best-First Branch&Bound approach is attained by the application of various specifically designed lower bounds and dominance rules. Although their application may cause significant computational effort, the resulting reductions of the number of explored partial solutions result in considerable speedups particularly for complex problem instances.While the results of the paper contribute to a better understanding of specific Line-TSP and Line-TRP-variants, there are still various open research questions. As indicated in the overview of Table 3, a very interesting question still open for research is the complexity status of the Line-TRP variant without any time restrictions but with general processing times at request locations. This problem is equivalent to the Tree-TRP where each request location is connected to the single path with an edge half the length of the respective request processing time. Such trees are denoted as caterpillars (Sitters, 2004). Up to now, the question whether this problem can be solved to optimality in strongly or at least pseudo-polynomial time or whether it isNP-hard remains open. Furthermore, future research should be also devoted to the generation of robust tour plans. Note that in real-world applications, travel times may change due to congestions (Bock, 2010; Larsen, Madsen, and Solomon, 2007). Hence, the quality of a generated tour plan does not solely result from its total customer waiting time in an average case scenario, but rather has to additionally integrate robustness issues. Specifically, the plan has to integrate adequate time buffers in order to avoid deadline violations. For this purpose, the considered problem model has to be extended accordingly.