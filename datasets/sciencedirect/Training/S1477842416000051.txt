@&#MAIN-TITLE@&#
Statistical model checking of Timed Rebeca models

@&#HIGHLIGHTS@&#
A toolset was developed for automated translation of Timed Rebeca models to Erlang.McErlang is used for model checking of Timed Rebeca models based on monitors.The existing simulation tool is extended to calculate the confidence interval for simulation results.A new toolset is introduced to provide statistical model checking of Timed Rebeca models.Two case studies are evaluated to show the applicability of proposed approaches.

@&#KEYPHRASES@&#
Statistical model checking,McErlang,Timed Rebeca,Performance analysis,Real-time systems,

@&#ABSTRACT@&#
The actor-based language, Timed Rebeca, was introduced to model distributed and asynchronous systems with timing constraints and message passing communication. A toolset was developed for automated translation of Timed Rebeca models to Erlang. The translated code can be executed using a timed extension of McErlang for model checking and simulation. In this work, we added a new toolset that provides statistical model checking of Timed Rebeca models. Using statistical model checking, we are now able to verify larger models against safety properties compared to McErlang model checking. We examine the typical case studies of elevators and ticket service to show the efficiency of statistical model checking and applicability of our toolset.

@&#INTRODUCTION@&#
In analyzing real-time systems, performance evaluation is a complementary issue to functional verification. Therefore, analysis techniques should consider both correctness and performance to guarantee quality of systems. Different formal timed models have been proposed for modeling and verification of real-time systems. On the other hand, different approaches have been suggested for performance evaluation of real-time systems. Numerical analysis and simulation techniques that are based on statistical methods are two widely used approaches for performance evaluation. In this work, we provide a unified analysis technique and toolset for both verification of correctness and performance evaluation of real-time distributed systems with asynchronous message passing.A well-established paradigm for modeling the functional behavior of distributed systems with asynchronous message passing is the actor model. This model was originally introduced by Hewitt [1] and then elaborated by Agha [2,3] and Talcott [4]. Although actors are attracting more and more attention both in academia and industry, little work has been done on timed actors and even less on analyzing timed actor-based models. To address the specification and verification of real-time systems, a few timed actor-based modeling languages such as RT-synchronizer [5] and Timed Rebeca [6] were proposed.Background: The Reactive Objects Language, Rebeca[7], is an actor based modeling language which can be used in a model-driven methodology, in which the designer builds an abstract model where each component is a reactive object communicating through non-blocking asynchronous messages. Rebeca is an operational interpretation of the actor model with formal semantics and model-checking tools [8,9]. Timed Rebeca [6] is proposed as an extension of the Rebeca language with time constraints and analysis support. The formal semantics of Timed Rebeca was offered using Structural Operational Semantics (SOS) rules [10].In the first implementation of Timed Rebeca, a toolset was developed to translate Timed Rebeca models to Erlang programs [11] automatically, and McErlang [12] was used to simulate the translated Erlang program [6]. At that time, McErlang, a model checking and simulation tool for Erlang, did not support model checking of Erlang program with timing features. In the untimed version of McErlang, simulation takes place by simply executing the Erlang program, and the reason for using McErlang is the monitors provided by this tool. By using monitors one can stop the execution by observing an erroneous state or unexpected behavior in the program. It is also possible to collect the necessary data during the execution. This tool can be used to run multiple simulations for different settings of parameters in a Timed Rebeca model, and then the results of the executions can be employed to select the most appropriate values for the parameters. This version of McErlang is not efficient for larger models since the progress of time is modeled by the system time, a model with an average size takes a long time to be executed.In [13], we extended the previous version of Timed Rebeca to improve its usability, and also to be able to use the timed version of McErlang which has been recently developed [14]. To improve the usability of Timed Rebeca, the language is extended to support a list data structure and the capability of calling custom functions from Erlang. This way the effort for modeling more complicated systems using Timed Rebeca is decreased. Moreover a function named checkpoint is added to the language to be able to provide more data to McErlang and hence get more valuable data in the analysis.Based on the timed version of McErlang, we changed the mapping of timing primitives of Timed Rebeca models to Erlang presented in [6], and we adjusted the implementation of the tool accordingly. As stated in [14], during the development of McErlang with timed semantics there has been a close collaboration between the two teams. So, the timed semantics of McErlang supports the timing features of Timed Rebeca very well. Now, using the checkpoint functions we are able to model check and simulate Timed Rebeca models by McErlang.The approach employed in the timed version of McErlang is inspired by Lamport׳s approach to real-time model checking [15]. The McErlang team used the idea of maximum-time-elapse for progress of time. The timer is increased based on the time of the occurrence of the next event, so, we have a jump to the next value for the timer instead of having a tick function to increase the timer by one. Finding the next event is not difficult in Erlang, as all the real-time computations are encountered within receive statements where timeouts are defined (in an optional after clause). Hence, simulation of Timed Rebeca models is much more efficient compared to the previous work where McErlang basically executed the Erlang programs.Contributions: This paper is an extended version of the work in [13]. In the conference paper [13], we used checkpoint (user-defined) monitors and predefined monitors of McErlang for verification of safety properties. As state space explosion is an inevitable problem in model checking, for large Timed Rebeca models we face state explosion using this approach.Statistical model checking: In this work, we provide statistical model checking of Timed Rebeca models, as an alternative approach to avoid an exhaustive exploration of the state space of the model. So, we are able to verify larger Timed Rebeca models. To this end, a new toolset is developed which is used together with the existing one for verification of Timed Rebeca models. In this approach, we run multiple simulations by McErlang, and then the mean value of correctness of the model is calculated for a given safety property. This tool is different from the simulation tool developed in the previous work. The statistical model checking approach is explained in Section 5.Performance evaluation: In the conference paper, we used the simulation capability of McErlang for performance evaluation of Timed Rebeca models. The statistical methods are applied to the obtained data from different simulation runs in order to compute performance measures of the model, such as the mean response time for a request to be served. In this paper, we extended our approach in [13], and now we also calculate the confidence interval. This way we can indicate the accuracy of simulation results while in [13] the number of simulation runs were chosen by the modeler randomly and the confidence interval was not considered. This method is explained in Section 6.3.To show the efficiency of our approaches in this work, we examine the elevator case study by applying statistical model checking, and computing confidence interval for simulation results. In the statistical model checking, we increase the number of floors to get a very large model, for which the model checking of McErlang is not applicable because of the state space explosion problem. Also, a new case study, ticket service system, is analyzed in Section 7.1. The efficiency and applicability of the statistical model checking approach depends only on the size of our models. The only parameter showing the size of a model is the number of rebecs (actors) and the message passing between them. So, if we increase the number of rebecs (actors) greatly, a simple case study like ticket service can imitate a complicated system.Applications: Since its introduction, Timed Rebeca has been used in different areas. One example is in analyzing different routing algorithms and scheduling policies in NoC (Network on Chip) designs, specifically the GALS (Globally Asynchronous Locally Synchronous) NoC [16,17]. Another example is schedulability analysis of distributed real-time sensor network applications, more specifically a real-time continuous sensing application for structural health monitoring in [18], which is an ongoing project. Another ongoing project is on evaluating different dispatching policies in clouds where we have priorities and deadlines in MapReduce clusters, based on the work in [19]. The extensions provided by the work presented in this paper can help in modeling more complicated designs, and also collect more useful data during simulation runs.Compared to others: Compared to Erlang which is a functional actor-based programming language, Timed Rebeca is an imperative actor-based modeling language. So, by using Timed Rebeca while respecting the actor programming style you can write your code in an imperative style which is more familiar to most of the programmers nowadays. Moreover, by using Timed Rebeca you are using a model-driven development approach. You can start with small models and use model checking and simulation to find possible correctness problems in your core algorithms, and also find how to improve the performance by changing some parameters while the code is still small, understandable, and easily manageable.The authors in [20] present an approach to verify safety properties of Erlang-like, higher-order concurrent programs automatically. Following the Core Erlang [21], λActor is introduced as a prototypical functional language which is augmented with asynchronous message-passing concurrency and dynamic process creation. The authors formalize an abstract model of λActor programs, called Actor Communicating System (ACS). A tool is developed to generate an ACS from an annotated Erlang module, for which safety properties like unreachability of error program locations and mutual exclusion can be defined. This approach starts from an implemented code, while using Timed Rebeca we start from a model. The same discussion holds here as the one comparing Erlang and Timed Rebeca.Two of the mostly used timed modeling languages are UPPAAL [22] and real-time Maude [23]. UPPAAL is an integrated tool environment for modeling, validation and verification of real-time systems modeled as networks of timed automata [24], extended with data types (bounded integers, arrays etc.). The tool is currently the most well-known model checker for real-time systems. The modeling languages used by Timed Rebeca and UPPAAL differ greatly, while Timed Rebeca has a programming-like syntax, UPPAAL uses automata. UPPAAL is more convenient for modeling systems with synchronous agents while Timed Rebeca focuses on distributed and asynchronous agents. Modeling the message queue can cause state explosion in UPPAAL very quickly. The verification tools are different in Timed Rebeca and UPPAAL. Timed properties can be checked in UPPAAL while in this work we focus on checking Timed Rebeca safety properties, which is explained in Section 5.Real-time Maude is a language accompanied with a tool for the formal specification and analysis of real-time and hybrid systems. The specification formalism is based on rewriting logic, and emphasizes generality and ease of specification, and is suitable to specify object-oriented real-time systems. The tool offers a wide range of analysis techniques, including timed rewriting for simulation purposes, and time-bounded linear temporal logic model checking. Timed Rebeca and Real-Time Maude are different in the computational paradigms that they naturally support. Timed Rebeca is based on actor based model of computation while you are free in your modeling style using real-time Maude. Timed Rebeca benefits from its similarity with other commonly used programming languages and is more susceptible to get used by modelers without intimate knowledge of the formal methods.In [25], authors introduce UPPAAL SMC in which systems are represented via networks of automata. In UPPAAL SMC, each component of the system is modeled with an automaton whose clocks can evolve with various rates. To provide efficient analysis of probabilistic properties, statistical model checking is used as a technique for fully stochastic models. The work supports modeling and performance analysis of systems with continuous time behaviors and dynamical features. The modeling languages used in Timed Rebeca and UPPAAL SMC are different, while Timed Rebeca has a Java-like syntax, UPPAAL uses automata. In UPPAAL SMC time is continuous, but in Timed Rebeca time is discrete. In this work, timed performance and functional properties are supported, but in UPPAAL SMC probabilistic performance properties are validated.There are some works on safety critical real-time Java programs [26,27] and WCET analysis of Java Bytecode-based programs [28,29]. A new approach is presented in [26] for schedulability analysis of Safety Critical Hard Real-time Java programs. The approach is based on a translation of programs, written in the Safety Critical Java (SCJ) [30], to timed automata models which are verified by the UPPAAL model checker. In this approach, worst case execution time (WCET) calculation and schedulability analysis are performed to verify that deadline misses never occur. The authors in [28] present a tool for statically determining the WCET of Java Bytecode-based programs. In this approach, the Java program, the JVM, and the hardware are modeled as Networks of Timed Automata (NTA) and given to the UPPAAL model checking tool. While the above works only support schedulability analysis of Java programs, verification of any safety property will be possible in Timed Rebeca if the property can be defined by a checkpoint function. Additionally, performance evaluation of Timed Rebeca models is also provided in this paper. Moreover, the modeling paradigm is different in Timed Rebeca and Real-time Java.Regarding other analysis techniques and tools for Timed Rebeca, a new approach was proposed for schedulability and deadlock freedom analysis of Timed Rebeca models in [31]. The authors proposed the notion of Floating Time Transition System (FTTS) for which the formal definition is presented. The authors proved a bisimulation relation between FTTS and the transition system derived from the SOS rules of Timed Rebeca in [6]. They developed a verification tool based on FTTS and integrated it in the Afra toolset [32]. In this work, the verification of Timed Rebeca models is restricted to deadlock freedom and schedulability analysis, and the performance evaluation of Timed Rebeca models is not supported.Another work on verification of Timed Rebeca models is presented in [33]. In this paper, authors defined an executable formal semantics for Timed Rebeca in Real-Time Maude. This enables a wide range of formal analysis methods for Timed Rebeca models, including simulation, reachability analysis, and both timed and untimed temporal logic model checking. The presented semantics executes all deterministic instantaneous statements in a message server in a single “atomic” step. This approach significantly reduces the number of interleavings and drastically improves the performance of model checking analyses. In addition, in this work, dynamic topology and dynamic creation in Timed Rebeca models is supported. Although the proposed approach covers analysis of an extended version of Timed Rebeca, there is no way for using high-level user defined functions in the models. These functions must be defined in the Maude language which requires expertise in rewriting logic. The direct model checking approach of TCTL properties for Timed Rebeca models in [34] suffers from the same limitations; however, it verifies majority of TCTL formulas inO(n2·|Φ|)for a given formula Φ. This order is the most efficient algorithm for verification of TCTL formulas in discrete time systems which is the same as the order of the verification of CTL formulas.Paper organization: The rest of the paper is organized as follows. Section 2 gives a brief introduction to Timed Rebeca. Considering the Timed Rebeca language presented in [6], Section 3 defines a new mapping for timing primitives of Timed Rebeca to Erlang while adapting to timed extensions of McErlang. It also includes new features added to the Timed Rebeca language to increase its usability. Section 4 explains how safety monitors in McErlang can be used to verify safety properties of Timed Rebeca models. Section 5 explains statistical model checking of larger Timed Rebeca models against safety properties. Section 6 describes the simulation of Timed Rebeca models using McErlang. The result is a dataset including useful information about system behavior to which different analysis methods can be applied. To show the result׳s precision, we calculate the confidence interval for performance measures under study. In Section 7, we apply all methods proposed in the previous sections to the typical examples of elevator and ticket service. Finally, Section 8 concludes the paper.Timed Rebeca is proposed as an extension to Rebeca, for modeling and verification of real-time distributed systems [6]. Rebeca [7,35] is an actor-based language for modeling and verifications of reactive systems with asynchronous communication among actors. Each actor has an unbounded buffer, called the message queue, for its arriving messages. Each actor takes a message, that can be considered as an event from the top of its message queue, and executes its corresponding message server (also called a method).In Timed Rebeca, each actor (also called a rebec) has its own local clock, but there is also a notion of global time based on synchronized distributed clocks of all the rebecs. Instead of a message queue for each rebec, there exists a bag containing all the messages sent for each rebec. Messages that are sent to a rebec are put in its message bag together with their arrival time (called their time tag), and their deadline. Methods are executed atomically, but the passing of time during the execution of methods can be modeled. In addition, communication delay and deadline for execution of messages can be defined in the model. The timing primitives that are added to the Rebeca syntax to support these features are delay, deadline, and after. The descriptions of these constructs are as follows.•Delay: delay(t), where t is a positive natural number, increases the value of the local clock of the respective rebec by the amount t.Deadline: r.m() deadline(t), means that the message m is sent to the rebec r and it is put in the message bag. After t units of time the message is not valid any more and is purged from the bag. Deadlines are used to model message expirations (timeouts).After: r.m() after(t), the message cannot be taken from the bag before t time units is passed. After primitive is used to model network delays in delivering a message to the destination. Note that After primitive can also be used to model periodic events. If we send a message in a loop with After(t), this will cause having the message in the message queue every t units of time. In Timed Rebeca, loops are modeled by sending a message to self.The scheduler decides which message is to be executed next based on the time tags of the messages. The time tag of a message is the value of local clock of the sender rebec when the message was sent, added to the value of the argument of the after if the message is sent with an after. The scheduler takes a message from the message bag, executes the corresponding message server atomically, and then takes another message. Every time the scheduler takes a message for execution, it chooses a message with the least time tag. Before the execution of the corresponding method starts, the local time of the receiver rebec is set to the maximum value between its current time and the time tag of the message [6].An example of a Timed Rebeca model is shown in Listing 1. This is a model of a ticket service system. In the main part, the rebecs are instantiated from the reactive classes. For each rebec, its known rebecs are specified as arguments, e.g. rebecs ts1 and ts2 are the known rebecs of rebec agent (Line 49). The initial values of the state variables can be specified as arguments in the rebec instantiation (empty parentheses in Line 49 can be used for this purpose, otherwise the default values are used). For example,“Agent agent(ts1, ts2):(10, false, 2)” creates an agent and the values of its state variables attemptCount, ticketIssued and token are initialized to 10, false and 2, respectively. A reactive class has an argument of type integer denoting a user-specified upper bound for its queue size (Agent(3) in Line 4). This is necessary to prevent state space explosion in model checking.The model in Listing 1 consists of two reactive classes: Agent and TicketService. The agent a starts by sending a message to the first ticket service ts1 and requesting a ticket (Line 13). The message has a deadline of requestDeadline time units. When the message is received by the ticket service ts1, it issues the ticket after serviceTime1 or serviceTime2 units of time (Lines 42–44). The issuing process is performed by sending a message back to the agent a. After requesting a ticket to ts1, agent a sends a message to itself after checkIssuedPeriod time units (Line 14). This message checks whether the ticket has been issued or not. If the ticket is issued, the model continues to the next customer and request a new ticket after newRequestPeriod time units (Line 26). If the ticket was not issued by ts1, agent a immediately sends a message to the second ticket service ts2 (Line 21). This scenario is repeated recurrently.Listing 1Timed Rebeca model – ticket service system.The McErlang is a model checking and simulation tool for Erlang programs. In [14], authors introduced a timed semantics of Erlang in McErlang with a close collaboration with Timed Rebeca team. The new timed semantics provides the model checking of Erlang programs with timing features. When the first version of Timed Rebeca was proposed in [6], McErlang did not provide the timed semantics for Erlang programs. In this section, we explain a new mapping algorithm for Timed Rebeca models to Erlang programs while conforming to the new timed features of McErlang. Since McErlang is used as the backend model checker and the simulation tool, this mapping is necessary. We also explain new features added to the Timed Rebeca language to make it more convenient to use. New features include checkpoint, calling custom functions, and list data structure which are explained in more details in Section 3.4.Here, we briefly explain timed Erlang semantics introduced in [14] which will be used in the new mapping of Timed Rebeca models to Erlang. Erlang handles time with the use of after as a timeout clause in a receive statement as Listing 2 shows. If a message matches any of the patterns, e.g. Patternj, and the corresponding guard, Guardj, evaluates to true, the message is removed from the mailbox and evaluation continues with expression Exprj.The oldest message in the process mailbox is evaluated to be matched against the patterns according to the above procedure. If no pattern and guard match this message, the same procedure continues with the second oldest message, and so on. If no pattern is matched, the process waits for at least TimeoutValue milliseconds to receive a matching message. This is the minimum amount of time that a timer elapses until the timeout happens. If the timeout occurs, the expression TimeoutExpression is evaluated. A zero deadline means, if no matching message is in the mailbox, the timeout can happen immediately. The atom infinity may be used as a time deadline to show that the timeout never happens.Listing 2Erlang syntax of a receive with timeout.The main changes made to McErlang to implement a timed semantics of Erlang are to record the current time in the state representation of a running program, and to modify the behavior of the receive statement in the model checker so that the current time is considered when timeouts are handled [14].In Listing 2, there is no guarantee for exactly when the timeout happens after a timer has elapsed TimeoutValue milliseconds. In the timed semantics of Erlang, it is possible to specify the urgency of a state with the function mce_erl:urgent(MaximumWait). The parameter MaximumWait specifies the maximum number of milliseconds the process can remain in the current state, if it has transitions enabled. As an example consider the code in Listing 3, a process is spawned and waits between 1000 and 1500ms for a message to arrive before timing out. In this example, we force the timeout to happen before 1500ms if the process does not receive a message.Listing 3An Erlang code with urgency construct implemented in McErlang.In McErlang with timed Erlang semantics, a new API mce_erl_time is introduced to provide the definition and manipulation of timestamps.This new API has the following functions.•now(): returns the current time.nowRef(): stores the current time in a clock reference.was(Ref): returns the time stored in a clock reference.forget(Ref): stops a stored clock reference.Some points should be considered in using this API. The absolute values returned from calls to now() cannot be used by the program. They can only be compared with the previously recorded clocks, i.e., relative comparisons are permitted that shows how much time has elapsed since an event happened.The timed version of McErlang proposed in [14] makes the formal verification of timed programs written in Erlang programming language possible. In timed semantics, timed actions, i.e. actions with a timeout clause, are ordered based on the timeout value while untimed actions, i.e. actions without a timeout clause, are executed infinitely fast.In the Timed Rebeca language, timed behaviors are defined by using timing primitives of after, delay, and deadline. The execution order of messages are specified based on the values of these primitives. In this section, we explain the new mapping of a Timed Rebeca model to an Erlang program according to the timed semantics of Erlang in McErlang. There are two main points to consider regarding the new mapping. Firstly, the mapping algorithm of timing features in Timed Rebeca to Erlang must be changed according to the new timed features of McErlang like timestamps and the urgency construct. Secondly, the new mapping algorithm for Timed Rebeca models should make the correct order of execution of actions possible. In the following paragraphs we explain these two points in more detail.Mapping timing primitives of Timed Rebeca to Erlang: In the previous Timed Rebeca mapping to Erlang, function now() was used to obtain the current time by using the system clock [6]. Timed behaviors like sending messages with deadline, after, and delay statements were implemented in terms of the system clock. In our new mapping, we use the same concepts as described in [6], but with a few and very important differences in the implementation. We use clock references accessible from API mce_erl_time to map timed actions from Timed Rebeca to Erlang. The main difference is that in the new version we use the simulation/model time and not the real system time (like when a real execution of the program is in order).An ordinary message send in Timed Rebeca, i.e. message send without after primitive, is translated to a regular message send in Erlang as shown in Listing 4. Instead of tagging the message with the local time of the sender, as we did in our previous mapping, we utilize a clock reference which is sent as a parameter to the receiver. The clock reference is obtained from calling nowRef() and stored in the variable TT. The clock can be remembered later for relative comparisons by calling was(Ref). Message send also consists of some other information for the receiver such as deadline, message name, and parameters. The default value for deadline is inf (standing for infinity) which denotes no deadline.After receiving a message, its deadline should be checked by the receiver before processing it. The timestamp of the message is the local time of the sender when sending the message and can be remembered using function was(Ref). The local time of the receiver when receiving the message can be obtained by function nowRef(). So, if the message has not expired, this conditiondeadline+was(ref)<nowRef()is satisfied.Listing 4PseudoErlang code for a message send in Timed Rebeca.In Timed Rebeca semantics, a message with the after(Timeunits) statement is put in the message bag of the receiver, and it cannot be taken from the bag before the specified time, i.e. Timeunits milliseconds, has elapsed. In mapping to Erlang, a function is spawned and waits for Timeunits milliseconds before sending the message. The function is an empty receive statement with a timeout clause, and sending the message is placed in the timeout clause as demonstrated in Listing 5.Listing 5PseudoErlang code for a message send with after primitive in Timed Rebeca.In Timed Rebeca, the delay(Timeunits) statement makes the local time of a rebec advance for the specified amount of time (Timeunits milliseconds). In Erlang, the delay is translated to the receive statement including just a timeout value as shown in Listing 6. Since there is no pattern in the receive statement, the timeout clause (after clause) will be executed after the specified time (Timeunits milliseconds) imitating the delay statement in Timed Rebeca. As stated in [14], the function mce_erl:urgent(MaximumWait) can be used to determine the urgency of a state, i.e., how long the process can stay in this state. So, we use the urgent function in the McErlang code to make the delayed process run immediately after the timeout expires.Listing 6PseudoErlang code for a delay statement in Timed Rebeca.Performing timed and untimed actions in the correct sequence: In Timed Rebeca, the execution order of messages is specified with respect to the values of timing primitives delay and after. In the previous paragraph, we explained how timing primitives in Timed Rebeca are translated to Erlang code. We also explained how a message deadline in Timed Rebeca can be handled using timestamps in McErlang. To execute messages in the correct order in Erlang according to the Timed Rebeca semantics, we should take into account more considerations in Erlang:•Actions without timeout clause (equivalent to messages without after in Timed Rebeca) should be executed infinitely fast (immediately).Actions with timeout clause (equivalent to delays or messages with after in Timed Rebeca) should be executed immediately after the timeout expires. The messages are ordered based on their timeout.Using the timed extension in McErlang, we can change the way in which timed (with timeout) and untimed (without timeout) actions are treated using the function mce_erl:urgent (MaximumWait). To execute the untimed actions infinitely fast, the MaximumWait parameter is set to zero. To execute the timed actions immediately after their timeout expires, the MaximumWait parameter is set to the value of timeout.We added some capabilities to Timed Rebeca in order to increase the modeling power of the language. These additions include a list data structure, capability of calling custom functions from the Erlang language, and checkpoints. Table 1shows the syntax of the extensions and their abstract mapping to Erlang.Checkpoint functions can be used in both simulation and model checking. They are considered as markers in the code that indicate important events. Checkpoints are also used to expose the value of variables in a Timed Rebeca model to McErlang.For simulation, a checkpoint is translated to an Erlang function, and for model checking a checkpoint is translated to a probe in Erlang.A checkpoint has two mandatory arguments: a label and at least one term. The label is an arbitrary name which is defined by the modeler and is used to refer to the checkpoint. Note that every piece of data of any type is called a term in Erlang. So, all variables in a Timed Rebeca model are translated to terms. The terms in a checkpoint are variables that are added to the checkpoint function as its arguments. The value of terms can be retrieved during simulation or model checking in McErlang.Another extension in Timed Rebeca language is the ability of calling custom functions in Erlang. A modeler can define a function in Erlang and then call it from the Timed Rebeca model. For example, in Timed Rebeca there is no function for searching a list. So, this function can be defined in Erlang and be called in a Timed Rebeca model. Using this extension, the Timed Rebeca language has the same programming power as the Erlang language.This way, the applications in which implementing buffers or queues is essential, like schedulers, can be modeled using the list data structure in Timed Rebeca language. The elements of a list are of type integer. They can be defined inside message servers as a local variable or as a state variable. In order to facilitate working with the list data structure, the following functions are defined: remove(intValue), size(), first(), last(), insert(intValue). Function remove(intValue) removes the integer value of intValue from the list and function insert(intValue) inserts the value of intValue at the end of the list. Functions first() and last() return the first and the last elements of the list, respectively.McErlang provides two types of model checking facilities for verification of safety properties and Linear Temporal Logic (LTL) formulas, using safety monitors and büchi monitors respectively. In this work safety monitors are used for the corresponding Erlang program of a Timed Rebeca model in order to verify safety properties of the Timed Rebeca model. For a given Erlang program, a safety monitor is defined as a function which is called after creation of each state of the model. If the content of the state is invalid, the safety monitor reports the state as an erroneous state.McErlang allows safety monitors to access both states of the program and the sequence of actions, as labels of transitions among states, but the values of program variables are not allowed to be accessed. However, the safety properties of a Timed Rebeca model are defined based on the values of its variables. This is why we added the checkpoint construct to Timed Rebeca language. A checkpoint in a Timed Rebeca model can include the values of specific variables. As we discussed in Section 3.4, the value of intended variables are passed as arguments to checkpoints. Also, the occurrence of interesting events can be specified using checkpoints. While doing model checking, in the corresponding Erlang program, checkpoints are translated to probes, which are accessible by safety monitors in McErlang.In this subsection, we explain two predefined safety monitors which can be used for Timed Rebeca models, and present a framework for defining safety monitors in McErlang using checkpoints in a Timed Rebeca model.Deadlock monitor: Detecting deadlock in non-terminating systems is essential. The predefined monitor in Listing 7 can be used to investigate the deadlock of Timed Rebeca models. As lines 13–20 of Listing 7 show, deadlock is detected by checking the status of processes. If the status of all the processes is marked as blocked, deadlock is reported.Maximum queue length monitor: Although in theory message queues are unbounded in Timed Rebeca, in model checking and simulation we need a maximum length for each queue to keep the state space bounded. Trying to put messages beyond the queue size of a rebec results in a queue overflow error. The predefined maximum queue-size monitor in McErlang can be used to monitor the size of a rebec׳s queue. As lines 7–10 of Listing 8 show, if a queue of any process exceeds its maximum size, a violation is reported by the monitor. The maximum queue size is specified by parameter MaxQueueSize.Listing 7McErlang – deadlock monitor.McErlang – MaxQueue monitor.Checkpoint monitor: The purpose of defining checkpoints in a Timed Rebeca model is the verification of safety properties using McErlang. Generally, a safety monitor is a function which is called after the creation of each state of the model. The monitor returns satisfied if the state satisfies the specified conditions, otherwise it returns violation. If a safety monitor is defined based on the information provided by checkpoints (which is available for McErlang from the translated Erlang program), the monitor is called checkpoint monitor. This type of monitor should be implemented by a modeler, while the previously mentioned monitors are available in McErlang.Listing 9 shows a template for checkpoint monitors. Any user-defined function can be used in the template. For example, we define the function checkLabelCheckPoint and use it in the monitor (Line 13), in which actions (obtained from the function actions) and a checkpoint label is used as arguments. If a checkpoint with the label CheckpointLabel occurs in a state, the monitor halts with a violation. If the verification terminates without any violation, it is guaranteed that the checkpoint never happens in any paths of the state space.We also developed some other functions to make it easier for a modeler to write the safety specifications in a monitor. The signature of each function and a brief explanation are listed below. The implementation of these functions are accessible from [32].•Checking if a message server is dropped because the deadline is missed. In the following function, the term is equal to the message server name.○checkDropMsgsrv(Actions, CheckpointTerm).Checking if a checkpoint with the specified label occurs.○checkLabelCheckPoint(Actions, CheckPointLabel).Compare the checkpoint term with an integer or boolean. In the following functions, MaxValue/MinValue is the maximum/minimum value for the specified term. In the function checkTermValue, the value of the specified term is checked to be equal to value.○checkTermMaxValue(Actions, CheckPointLabel, CheckpointTerm, MaxValue),checkTermMinValue(Actions, CheckPointLabel, CheckpointTerm, MinValue),checkTermValue(Actions, CheckPointLabel, CheckpointTerm, value).A template (pseudocode) for checkpoint monitors which is used by McErlang.In the previous section we showed how safety monitors can be defined for the corresponding Erlang program of a Timed Rebeca model,using the checkpoints of the Timed Rebeca model. So,the McErlang can be used as a back-end model checker for the verification of safety properties of the Timed Rebeca model. The major limiting factor in applying model checking for verification of real world systems is the huge amount of space and time required to store and explore the state space. Alternatively,statistical model checking can be used and it does not have the problem of state space explosion. Statistical model checking does not guarantee the correctness of systems,however,it provides an approximation of correctness. The main idea behind this approach is analyzing N different independent random executions of a given systemZ1,Z2,…,ZN(i.e. independent samples of random variable Z) to approximate the correctness of the system. IfZ1,Z2,…,ZNare identically distributed with mean μZ, there is a technique that approximates the value of μZbyμ˜Z=(Z1+Z2+⋯+ZN)/N. This way,μ˜zis computed as(ϵ,δ)-approximationof μZ. We sayμ˜Zis an(ϵ,δ)-approximationof μZifPr[|μZ−μ˜Z|<ϵ]≥1−δ. Here, ϵ is the error value and δ is the confidence value of the approximated value ofμ˜Z.In case of statistical model checking, for a given ϵ and δ, we have to provide an upper bound N as the number of simulation traces which are required to compute(ϵ,δ)-approximationof the correctness of the system. Based on the zero-one estimator theorem, if the range of the values of random variable Z is in[0,1]byN>4ln(2/δ)/μZϵ2number of samples, the value of μZis approximated byμ˜Zfor error value ϵ and confidence interval1−δ[36]. But, applying the zero-one estimator theorem encounters a difficulty which is the fact that N depends on1/μZ, the inverse of the value that one intends to approximate. In addition, the factor of1/μZϵ2makes the value of N unnecessarily large. A more practical approach for this problem is proposed by Dagum et el. in [37] for computing N, called the generalized zero-one estimator theorem. Based on this work, Grosu et al. in [38] presented an optimal approximation algorithm to provide N, as shown below.N=Υ2×ϵμ˜ZΥ2=2(1+ϵ)(1+2ϵ)(1+ln3/2ln2/δ)ΥΥ=4ϵ2(e−2)ln(2/δ)In this formula, the value of N depends on the value ofμ˜Zwhich is the raw estimate of μZ. Hereμ˜Z=(1+(1+ϵ)Υ)/N′, whereN′is the number of traces which are needed to be analyzed until at least⌊1+(1+ϵ)Υ⌋of them satisfies the given property. For the raw estimation of μZ, values ofmin{1/2,ϵ}andδ/3are used to compute the value of Υ.Now, we have to specify the subset of formulas which can be model checked by statistical model checking approach of this paper. As shown in [39], formulas with unbounded until operators (and nested until operators) can be model checked using statistical model checking. As a result, the approach of this paper works for formulas with until operators which are both safety and monitor-based LTL properties. So, in a nutshell, Timed Rebeca models can be verified against safety properties, using predefined monitors like Deadlock Monitor and Maximum Queue Length Monitor, and checkpoint monitors.As a final step of developing a statistical model checker, we have to implement the above algorithm to calculate an approximation of the mean value of correctness. As Fig. 1shows, the statistical model checking (SMC) component works with the present tool, which was developed in [13]. The simulation wrapper component is employed to generate needed simulation traces for the SMC component. Fig. 1 demonstrates the analysis tool-set which includes the SMC component and the performance evaluation tool. In the following section, we describe the architecture of the performance evaluation tool.In addition to its model checking facilities, McErlang provides facilities for simulation of Erlang programs. In the simulation mode, the next state of an Erlang program is determined randomly, by choosing one of the available transitions from the current state. Therefore, a randomly chosen path of execution is explored in each simulation run. In each simulation run, we choose the simulation time long enough to reach the steady state of the system. As we model reactive systems, which generally show recurrent behavior, having long simulation runs can guarantee reaching the steady state (if there is any). To have an accurate understanding of the model׳s behavior, data is gathered from different simulation runs, each of them including a different trace. For performance evaluation, statistical methods are applied to the collected data and the results are used to reason about the behavior of the model.Since the resulting information of a performance measurement may be very large, we use average moving method to reduce the dataset for visualization. This well-known method smooths out short-term fluctuations and highlights long-term trends of the data [40].The non-determinism caused by concurrency is resolved by the scheduler of McErlang. McErlang scheduler selects the process that must be executed in the next step based on the uniform distribution. Obviously, resolving non-determinism using uniform distribution affects the performance analysis results. In this work, we follow the community that uses simulation-based and statistical model checking approaches for performance evaluation of concurrent systems.We implement a tool-set to provide performance evaluation of Timed Rebeca models using McErlang. As shown in Fig. 1, the tool-set contains three components as follows.•Translator: for translating Timed Rebeca models to Erlang programs.Trace analyzer: to apply statistical analysis methods to stored information. Different analysis techniques are implemented in this component.Simulation wrapper: it sends required data to other components and stores data of simulation runs. Modeler can define the number of simulations as well as the duration of each simulation run.Fig. 1 shows that simulation wrapper component sends Timed Rebeca models to the translator component to be translated to an Erlang program. The translated Erlang program is sent to McErlang for simulation. The generated data from the simulation is sent to the simulation wrapper component at run-time. The simulation wrapper component categorizes the simulation data of different simulation runs in a way to be used by trace analyzer.We implement two different analysis techniques in the component trace analyzer, called checkpoint analysis and paired-checkpoint analysis, to provide performance evaluation of Timed Rebeca models. In the next section, we explain how information provided by checkpoints can be used in trace analyzer to achieve performance measures of interest.As we discussed in Section 3.4, checkpoints were added to Timed Rebeca language to provide needed information for model checking and simulation. Each checkpoint is translated to a function such that McErlang can access the value of variables and be notified of the occurrence of events. We analyse models based on the information provided by checkpoints.During the simulation, every time a checkpoint is executed the value of terms (variables or any value of available data types), the label, the time of observing the checkpoint and the name of the rebec including the checkpoint are stored for performance evaluation purposes.Listing 10Timed Rebeca model – ticket service system.To illustrate the role of checkpoints in the performance evaluation of Timed Rebeca models, we add some checkpoints to the ticket service model in Listing 1, as shown in Listing 10. For the sake of simplicity, we keep the message servers to which checkpoints are added and delete other message servers. The performance of our model is influenced by the timing variables. Simulation of the Timed Rebeca model reveals the effect of these variables in the average response time.Three different checkpoints are defined in order to collect the required data for performance evaluation of the model. These checkpoints store data about when the request is sent to the ticket service (line 8), when the ticket is received by the agent a, i.e. the ticket is issued (line 15), and whether the ticket is not issued (line 16). We are able to define as many checkpoints as needed depending on the safety properties and the performance measures we are interested in. In these checkpoints we should provide the value of variables which are needed for the intended analysis.In the following subsections, we explain how the performance evaluation of Timed Rebeca models is performed.The paired-checkpoint method is implemented in the trace analyzer tool. In paired-checkpoint analysis, two checkpoints are grouped together. The modeler specifies paired checkpoints with the use of labels when running the tool. The elapsed time between observing two paired checkpoints is important and can show different performance measures. There is a command in our tool that enables the modeler to specify paired checkpoints. For example, the starting checkpoint in line 8 (labelled by requestStart) shows that the request is sent to the ticket service and the ending checkpoint in line 15 (labelled by ticketIssued) represents that the ticket was issued. Consequently, the passed time between the occurrence of these two checkpoints is considered as the response time of the issued ticket.In checkpoint analysis, instead of pairing checkpoints, a certain checkpoint is provided to expose the changes of a particular variable over time. For example, in the ticket service system, we are interested in knowing how many tickets are issued by ticket service ts1 and how many of them are issued by ticket service ts2. This information is available in the simulation results by defining the checkpoint with label ticketIssued in the model. When a ticket is issued at run-time, the time of occurrence and the name of rebec including the checkpoint are stored in the simulation results.While using statistical methods, there is an important question of how precise the results are. In our previous work [13], the number of simulation runs is selected by the user without considering any criteria for the measurement׳s precision. Here, we calculate the confidence interval for simulation results to indicate their accuracy.The confidence interval shows how close our measurement is to the original value if the experiment is repeated. The margin of the error is calculated from the following formula.Zα/2×σnwhere σ is the standard deviation of the intended phenomenon (like response time), n is the sample size, α is the confidence level andZα/2is the confidence coefficient. The most commonly used confidence levels are 90%, 95% and 99%. Suppose the confidence level is 95% (α=0.95), to find the value ofZα/2the z table is checked for the value of0.95/2=0.475[41]. In the z table, the intersection of row 1.9 and the column of 0.06 shows a cell with the value of 0.475 (or the closet value to 0.475), soZ0.475equals 1.96.The confidence interval is obtained from the following formula, wherex¯is the mean value of the intended phenomenon (like response time).x¯±Zα/2×σnIn this section, we present two case studies to illustrate the applicability of the approaches of this work. For each case study, after intuitive description of the model using an event graph [42], the detailed description of the Timed Rebeca model is presented. We use an event graph to give a highly abstracted view of events and their causality relations. Event graphs are widely used for the explanation of event-based models. In this graph, the vertices represent events in a system and the edges represent the causality relation between events (vertices). Additionally, we add a label below each vertex that shows in which reactive class the event occurs. Edges can be conditional (thick edge), mandatory (thin edge) or marking an initial event (jagged edge). Model checking, statistical model checking and performance evaluation are applied for the case studies. In model checking using McErlang, we have limitations on the size of the models to avoid state space explosion. In statistical model checking, we are able to check larger models, and increment the size of the models greatly.Our first case study is the ticket service system, which is shown in Listing 1. As we already described the details of this model in Section 2, here, we only demonstrate the event graph of the Ticket Service model in Fig. 2. As shown in Fig. 2, initially the message server initial in the rebec agent sends a message to itself that triggers the event (the message server) findTicket. Execution of this event causes sending a message to the rebec TicketService which raises the event requestTicket. After a number of trials (which is modeled by causality relation among findTicket, checkTicket, and retry), the event ticketIssued is raised to inform that a ticket is issued.The model in Listing 1 is revised to be usable in monitor-based model checking. A variable is added to the model to restrict the number of ticket requests that are sent to ts1 and the ts2. The maximum number of ticket requests is set to seven. This modification is necessary to avoid state space explosion. We are interested in checking whether a ticket is issued in the system. So, we add a checkpoint with label ticketIssued to the model where a ticket is issued (refer to Listing 10). The checkpoint monitor shown in Listing 11 is used for safety verification. The property is satisfied if a ticket is issued. This property verification is performed by using the predefined function checkLabelCheckPoint, explained in Section 4.2.Listing 11The checkpoint monitor for checking whether a ticket is issued.The results of model checking of the Ticket Service system using McErlang are shown in Table 2. We considered different settings for the model each of which has different values for variables. As shown in the table, there is no tickets issued in the first three settings.We verify the ticket service model shown in Listing 10, with a huge number of ticket requests in the model. We aim at checking the safety property of “at least one ticket is issued”. For each setting in Table 2, we run the statistical model checking (SMC) component with different error values and confidence values. Table 3shows the results for setting 4. The results for settings 5–7 are the same for setting 4. Table 4 shows the verification results for setting 1. Settings 2 and 3 have the same results as setting 1, because no ticket is issued in these settings.For a given safety property, we run as many simulations as needed to getNct=⌊1+(1+ϵ)Υ⌋number of traces that satisfy the safety property (refer to Section 5 for Υ formula). In each simulation run, a random trace is explored to check the safety property. The mean value of correctness of the property is defined asμ˜Z=Nct/N′, whereN′is the total number of simulation runs (explored traces).Considering the error value and the confidence value of the first experiment of Table 3,Nct=289. We run as many simulations as needed to get 289 traces that satisfy the defined property. The total simulation runs (traces) for this experiment is 289 (N′=289), meaning all traces satisfied the property. So, in this experiment the mean value of correctness is one,μ˜Z=1. More accurately, we obtain an(ϵ,δ)-approximation of the mean value of correctness wherePr[|μZ−μ˜Z|<ϵ]≥1−δ, μZis the real mean value of correctness. For the first experiment of Table 3,Pr[|μZ−1|<0.05]≥0.95.As we described before, we run as many simulations as needed until Ncttraces satisfies the property. If the model never satisfies the property, the simulation should continue forever to find Nctsatisfied traces. To avoid this situation, in the implementation of SMC component we stop simulation (generating traces) if the first Ncttraces do not satisfy the property. This case happens for setting 1, so the mean value of correctness equals zero as presented in Table 4.We are also able to verify the model with more actors (rebecs) for which the model checking approach based on McErlang monitors explodes. For example, the number of agents and ticket services is increased to four and nine, respectively. We check the safety property of “at least one ticket is issued” for this model. The mean value of correctness equals one for the following parameters:ϵ=0.05,δ=0.05. We use a different setting which is not listed in Table 2. In this setting, the values of variables (from left to right in Table 2) equal 3, 3, 2, 2, 4, 7. So, large ticket service models can be verified against safety properties using statistical model checking.

@&#CONCLUSIONS@&#
